<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Code Life</title>
    <link>https://www.boris1993.com/</link>
    
    <atom:link href="https://www.boris1993.com/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>Boris has arrived!</description>
    <pubDate>Wed, 04 Jun 2025 15:42:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>自己实现一个 BlockingQueue 并优化</title>
      <link>https://www.boris1993.com/enhancing-my-blocking-queue-implementation.html</link>
      <guid>https://www.boris1993.com/enhancing-my-blocking-queue-implementation.html</guid>
      <pubDate>Wed, 26 Mar 2025 07:10:11 GMT</pubDate>
      
      <description>&lt;p&gt;前阵看见个面试题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请实现一个泛型类 BlockingQueue：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造函数里指定队列容量&lt;/li&gt;
&lt;li&gt; void put (T item) 队列满了会阻塞，直到队列有空间&lt;/li&gt;
&lt;li&gt; T take ()，队列空时会阻塞，直到队列有元素&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;我寻思做做看，结果写出来的答案我自己都看不下去，那干脆看看 Java 里面是咋实现的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>前阵看见个面试题</p><blockquote><p>请实现一个泛型类 BlockingQueue：</p><ol><li>构造函数里指定队列容量</li><li> void put (T item) 队列满了会阻塞，直到队列有空间</li><li> T take ()，队列空时会阻塞，直到队列有元素</li></ol></blockquote><p>我寻思做做看，结果写出来的答案我自己都看不下去，那干脆看看 Java 里面是咋实现的。</p><span id="more"></span><h2 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h2><p>先看看我写的玩意是啥德行吧。实话说这玩意看着都不像能正常工作的样子（虽然实际上它还真能用）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> size)</span> {</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line">        <span class="built_in">this</span>.maxSize = size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="keyword">final</span> T item)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.count &gt;= maxSize) {</span><br><span class="line">            wait();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt; maxSize) {</span><br><span class="line">                notifyAll();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">            items[count] = item;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) {</span><br><span class="line">            wait();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                notifyAll();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> (T) items[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; count; i++) {</span><br><span class="line">            items[i - <span class="number">1</span>] = items[i];</span><br><span class="line">        }</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码主要有俩问题，一个是这些 <code>while</code> 循环看着很不爽；另一个是在取出元素后逐个将元素左移的操作效率非常的低；而且满天飞的 <code>wait()</code> 和 <code>notifyAll()</code> 也会影响代码的可读性。</p><p>那么接下来看看这段代码怎么优化成接近 Java 自己的实现。</p><h2 id="优化阻塞"><a href="#优化阻塞" class="headerlink" title="优化阻塞"></a>优化阻塞</h2><p>BlockingQueue 的一个机制是，在队列空时取元素的操作会被阻塞，而在队列满时放元素的操作会被阻塞。在 Java 的 <code>ArrayBlockingQueue</code> 中，它并没有使用 <code>synchronized</code> 加锁，而是用了 <code>ReentrantLock</code> 对象。此外对于阻塞线程和唤醒线程操作，它也没有用 <code>wait()</code> 和 <code>notifyAll()</code>，而是通过两个 <code>Condition</code> 对象 <code>notEmpty</code> 和 <code>notFull</code> 实现。</p><p>所以改进方案就是，去掉方法定义中的 <code>synchronized</code> 关键字，换成用 <code>ReentrantLock</code> 加锁解锁；去掉 <code>wait()</code> 和 <code>notifyAll()</code>，改成用 <code>notEmpty</code> 和 <code>notFull</code> 管理状态以及负责唤醒，同时可以借助这两个变量的语义增强代码的可读性。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> size)</span> {</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line">        <span class="built_in">this</span>.maxSize = size;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">        <span class="built_in">this</span>.notFull = lock.newCondition();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="keyword">final</span> T item)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 尝试上锁，使其线程安全</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (count &gt;= maxSize) {</span><br><span class="line">                <span class="comment">// 在队列满时使当前线程进入等待状态</span></span><br><span class="line">                <span class="comment">// 直到其signal()方法被调用</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存入元素，更新元素数量</span></span><br><span class="line">            items[count] = item;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知此时队列非空，唤醒在调用take()方法时因队列空而被阻塞的线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 最后无论如何要保证锁被释放</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 尝试上锁，使其线程安全</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 在队列空时使当前线程进入等待状态</span></span><br><span class="line">                <span class="comment">// 直到其signal()方法被调用</span></span><br><span class="line">                notEmpty.await();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出最早被放入的元素</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> (T) items[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 领头的元素出列了，后面的往前挪一个位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; count; i++) {</span><br><span class="line">                items[i - <span class="number">1</span>] = items[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 更新元素数量</span></span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知此时队列非满，唤醒在调用put()方法时因队列满而被阻塞的线程</span></span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 最后无论如何要保证锁被释放</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="优化取出元素后更新队列内容"><a href="#优化取出元素后更新队列内容" class="headerlink" title="优化取出元素后更新队列内容"></a>优化取出元素后更新队列内容</h2><p>如果这是一个非常大的队列，那么用一个 for 循环将所有元素往左移来更新队列内容的方式会消耗巨量的时间，显然它的效率是非常低的。相比于每次取出元素后都重排数组中的元素，Java 中 <code>ArrayBlockingQueue</code> 则是利用循环数组的思路，通过两个指针来指示当前该从什么位置取或该向什么位置存（这不是经典的双指针玩法么，前段时间刷 LeetCode 还做过呢，咋就没想起来），这样每次存取元素后，只需要更新指针指向的位置就行，效率可想而知非常高。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">takeIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">putIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> size)</span> {</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">        <span class="built_in">this</span>.notFull = lock.newCondition();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="keyword">final</span> T item)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (count &gt;= items.length) {</span><br><span class="line">                notFull.await();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            items[putIndex] = item;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存完元素之后，写指针往后挪一位</span></span><br><span class="line">            <span class="comment">// 如果指针挪完之后突破了数组末尾，那么写指针循环到数组头</span></span><br><span class="line">            <span class="comment">// 因为在队列满的时候线程会被阻塞，所以不会出现元素被覆盖的情况</span></span><br><span class="line">            <span class="keyword">if</span> (++putIndex == items.length) {</span><br><span class="line">                putIndex = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) {</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> (T) items[takeIndex];</span><br><span class="line">            items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出当前元素后，读指针往后挪一位</span></span><br><span class="line">            <span class="comment">// 如果指针挪完之后突破了数组末尾，那么读指针循环到数组头</span></span><br><span class="line">            <span class="comment">// 因为在队列空的时候线程会被阻塞，所以不会出现读到无效元素的情况</span></span><br><span class="line">            <span class="keyword">if</span> (++takeIndex == items.length) {</span><br><span class="line">                takeIndex = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            notFull.signal();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Java/">Java</category>
      
      <category domain="https://www.boris1993.com/tags/BlockingQueue/">BlockingQueue</category>
      
      
      <comments>https://www.boris1993.com/enhancing-my-blocking-queue-implementation.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>防止 MicroServer Gen 10 Plus 的风扇突然狂飙</title>
      <link>https://www.boris1993.com/microserver-gen10-plus-prevent-fan-goes-crazy.html</link>
      <guid>https://www.boris1993.com/microserver-gen10-plus-prevent-fan-goes-crazy.html</guid>
      <pubDate>Sat, 22 Mar 2025 22:14:39 GMT</pubDate>
      
      <description>&lt;p&gt;今年元旦我把之前用的 Gen 8 换成了 Gen 10 Plus。后来想着现在性能上去了，可以把 NAS 的功能也合并进来，于是就把给 NAS 用的两块机械硬盘迁进了 Gen 10 Plus 里。但就在这之后，我发现它的风扇时不时就会突然狂转一分多钟，然后再降回平时的转速。而且这个问题不分白天黑夜，甚至有一次大半夜把我吵醒，不胜其烦。终于在上周，我找到了问题的根源，并彻底解决了。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今年元旦我把之前用的 Gen 8 换成了 Gen 10 Plus。后来想着现在性能上去了，可以把 NAS 的功能也合并进来，于是就把给 NAS 用的两块机械硬盘迁进了 Gen 10 Plus 里。但就在这之后，我发现它的风扇时不时就会突然狂转一分多钟，然后再降回平时的转速。而且这个问题不分白天黑夜，甚至有一次大半夜把我吵醒，不胜其烦。终于在上周，我找到了问题的根源，并彻底解决了。</p><span id="more"></span><h2 id="一些无效的尝试"><a href="#一些无效的尝试" class="headerlink" title="一些无效的尝试"></a>一些无效的尝试</h2><blockquote><p>这一节并没有解决方案，如果你不关心我之前的心路历程，那么可以放心跳到下一节。</p></blockquote><p>最起初，我以为是机械硬盘发热导致的，毕竟问题是出在我把机械硬盘装进来之后。为此我还调换了硬盘的安装位置，把机械硬盘从 3、4 号盘位移到了靠上的 1、3 号盘位。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---------------------          ---------------------</span><br><span class="line">| 1 - SSD | 3 - HDD |    =&gt;    | 1 - HDD | 3 - HDD |</span><br><span class="line">| 2 - SSD | 4 - HDD |          | 2 - SSD | 4 - SSD |</span><br><span class="line">---------------------          ---------------------</span><br></pre></td></tr></tbody></table></figure><p>可惜，并没有任何好转。风扇依旧时不时开始跟李有田似的狂飙，唯一区别是风扇能刹住车（为李有田默哀一秒……</p><p>后来我觉得，会不会是硬盘在跑 PT 的时候真的太热了？但是我也在下载的时候摸过硬盘，那个温度撑死只能算温热，怎么想也不会造成整机过热啊？但是本着 “能解决问题就行，哪怕再花点钱” 的想法，我开始找用来替换的 4TB 2.5 寸 SATA 接口固态硬盘。结果…… 并不理想，现在京东自营只找到了三款。更难受的是，根据论坛上的赛博邻居反馈，其中两款是数据火葬场；而剩下的那款，一块盘要卖我两千多块，也就是说两块盘加起来比我买这台 Gen 10 Plus 都贵。所以，换硬盘这个方案也被否了。</p><p>正巧就在这个时候，它又开始狂飙。我想，iLO 里面不是能看见温度吗？那赶紧看看是啥玩意这么热呗？这一看，才找到了问题的根源。</p><h2 id="问题根源及解决方案"><a href="#问题根源及解决方案" class="headerlink" title="问题根源及解决方案"></a>问题根源及解决方案</h2><p>趁着风扇狂飙之际，我进入了 iLO 的温度页面，发现有个传感器 <code>12 - AHCI Max HD</code> 的当前温度是 50°C，而它的警告阈值是 60°C，严重错误阈值是 70°C。也就是说，这时候 BIOS 发现这个东西烫的要挂掉了，所以就要赶紧让风扇转起来散热。等了一会风扇慢下来之后，我发现这个传感器的值变成了 35°C，而且怎么刷新都不变。</p><p>搁网上一顿冲浪之后找到了<span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LmhwZS5jb20vaHBlc2MvcHVibGljL2RvY0Rpc3BsYXk/ZG9jSWQ9YTAwMDgzMTU0ZW5fdXMmZG9jTG9jYWxlPWVuX1VT">惠普的一篇通告<i class="fa fa-external-link-alt"></i></span>，从这里得知这并不是一个物理上的传感器，它检测到的温度是通过惠普的一个叫 <code>Agentless Management Service</code> 的软件组件向主板汇报的。此外还找到<span class="exturl" data-url="aHR0cHM6Ly93d3cuaGl0YWNoaS5jby5qcC9wcm9kdWN0cy9pdC9oYTgwMDB2L3N1cHBvcnQvcHJvZHVjdGluZm8vYXJ0aWNsZS5odG1sP2lkPUFEVi0yMDI0LTAwMTY=">日立的一个类似的通告<i class="fa fa-external-link-alt"></i></span>说硬盘在 AHCI 模式下会导致风扇转速异常升高。</p><p>到 ESXi 里面检查了之后，发现我用的惠普定制系统里面是带着 AMS 组件的。这时候我灵机一动，既然是因为 AMS 汇报了错误的温度才导致这个问题，而要让 AMS 汇报正确的温度，那我就得把硬盘换成 HPE 认证的盘，可想而知这玩意没准会相当贵，而且作为个人用户都不一定买得到。那如果我把 AMS 卸了，让传感器拿不到数据呢？</p><p>说干就干。保险起见我先去了惠普支持网站，下载好了最新版的 AMS 软件包，一旦出了问题我还可以把它再装回去。然后回到 ESXi，开启 SSH。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到AMS的软件包名</span></span><br><span class="line">[root@ESXi:~] esxcli software vib list | grep ams</span><br><span class="line"><span class="comment"># 这个是给Gen 10系列用的</span></span><br><span class="line">amsd 701.11.8.5.22-1OEM.701.0.0.16850804 HPE VMwareAccepted 2023-08-08</span><br><span class="line"><span class="comment"># 这个是给Gen 11系列用的</span></span><br><span class="line">amsdv 701.11.3.0.17-1OEM.701.0.0.16850804 HPE VMwareAccepted 2023-06-12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别给这俩都卸了</span></span><br><span class="line"><span class="comment"># 命令输出我已经忘了，而且这不重要，就不写了</span></span><br><span class="line">[root@ESXi:~] esxcli software vib remove -n amsdv</span><br><span class="line">[root@ESXi:~] esxcli software vib remove -n amsd</span><br></pre></td></tr></tbody></table></figure><p>两条卸载命令都成功之后，逐个关掉虚拟机，然后重启 ESXi 使修改生效。果不其然，重启之后，iLO 系统信息里面显示 <code>Agentless Management Service</code> 不可用，温度页面里 <code>12 - AHCI HD Max</code> 传感器也消失了。经过一星期的测试，风扇也确实没再狂飙过。问题解决！</p><h2 id="一点碎碎念"><a href="#一点碎碎念" class="headerlink" title="一点碎碎念"></a>一点碎碎念</h2><p>尽管这个解决方案远称不上完美，甚至有点 “解决提出问题的人” 的感觉。但这应该是权衡利弊之后的最优解。买 HPE 认证硬盘？拜托我只是拿它存电影而已，虽然要是全丢了也挺心疼，但它们确实不值这个钱。卖掉 Gen 10 Plus 再自己组一套 NAS？那又太折腾了，我实在懒得搞。而且就算夏天天气热起来之后，我毕竟也不是重度 PT 玩家，大部分时间硬盘都是空载的，我相信它不会变得很热，不会因为俩机械硬盘搞炸整台服务器。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/playing/">瞎折腾</category>
      
      
      <category domain="https://www.boris1993.com/tags/Gen-10-Plus/">Gen 10 Plus</category>
      
      
      <comments>https://www.boris1993.com/microserver-gen10-plus-prevent-fan-goes-crazy.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用观察者模式实现动态刷新 Bean 中的配置</title>
      <link>https://www.boris1993.com/dynamically-refresh-config-with-observer-pattern.html</link>
      <guid>https://www.boris1993.com/dynamically-refresh-config-with-observer-pattern.html</guid>
      <pubDate>Fri, 21 Mar 2025 06:14:56 GMT</pubDate>
      
      <description>&lt;p&gt;公司有的项目里面还是采用把 API key 明文写在 &lt;code&gt;application.properties&lt;/code&gt; 或者某个单独的 &lt;code&gt;properties&lt;/code&gt; 文件来管理，这既不安全也不符合公司的规定。所以我通过利用观察者模式和 Spring 的事件机制，将其改为加密存储于配置中心，并且实现了在配置中心更新后，服务中生效的配置也可以立即更新。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>公司有的项目里面还是采用把 API key 明文写在 <code>application.properties</code> 或者某个单独的 <code>properties</code> 文件来管理，这既不安全也不符合公司的规定。所以我通过利用观察者模式和 Spring 的事件机制，将其改为加密存储于配置中心，并且实现了在配置中心更新后，服务中生效的配置也可以立即更新。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>谈论实现之前，我先说一下我有哪些工具可以使用：</p><ul><li>SecretKeyService：一个可以保存对称及非对称加密密钥的服务</li><li> CredentialVault：一个用来存放密钥的服务，密钥一旦存入，就只能再通过 API 的方式得到其原文</li><li> ConfigurationCenter：配置中心，不提供任何加密功能，在配置内容更新后可以通过 Spring 的事件通知到使用了这个配置的服务</li></ul><p>接到这个需求后，我下意识地觉得应该用 CredentialVault 解决问题，但是仔细想想，发现并不能。因为按照公司要求，API key 的密码必须定期轮换，而老的密码在轮换之后就会马上失效。尽管我们有两套 API key 来避免前面的问题，但是更换 API key 密钥对又需要修改配置文件，并经历 code review 及上线部署，依旧需要一定的人工操作。我的设想是，只需要在一个地方设定好要生效的 API key，接下来所有用到这个 API key 的服务都能自动更新。这样看来，似乎带有通知功能的配置中心是唯一解。但是配置中心不提供加密功能，所以还需要 SecretKeyService 提供一个对称加密密钥来把 API key 的密码加密，然后将它放到配置中心。</p><p>记不住这些名字没关系，后面你也看不到它们了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在确定要用的工具之后，就可以开始着手将它们拼装在一起了。因为原本公司的代码需要保密，所以下面的代码更多是展示思路，大概率你不能直接拷出来放到你的项目中用。</p><h3 id="PropertyLoader"><a href="#PropertyLoader" class="headerlink" title="PropertyLoader"></a>PropertyLoader</h3><p>因为直接把配置源从文件换成配置中心有一定的风险，保险起见我们决定逐步迁移配置，在迁移期间需要同时支持配置文件和配置中心。所以，就诞生了 <code>PropertyLoader</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyLoader</span> {</span><br><span class="line">    <span class="comment">// 负责加解密的服务，它会从SecretKeyService取得密钥并对给定字符串完成加解密</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EncryptionDecryptionService encryptionDecryptionService;</span><br><span class="line">    <span class="comment">// 配置中心的客户端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationCenterClient configurationCenterClient;</span><br><span class="line">    <span class="comment">// 配置文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PropertyLoader</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> EncryptionDecryptionService encryptionDecryptionService,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> ConfigurationCenterClient configurationCenterClient,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Properties properties,</span></span><br><span class="line"><span class="params">    )</span> {</span><br><span class="line">        <span class="built_in">this</span>.encryptionDecryptionService = encryptionDecryptionService;</span><br><span class="line">        <span class="built_in">this</span>.configurationCenterClient = configurationCenterClient;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置中心或配置文件取得一个key的值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Property或配置中心条目的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 取到的值，不会为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PropertyNotFoundException 当在配置中心和配置文件中都找不到这个key时抛出，这通常意味着我们把某条配置漏掉了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loadProperty</span><span class="params">(<span class="keyword">final</span> String key)</span> {</span><br><span class="line">        <span class="comment">// 首先尝试从配置中心取值，如果取不到则返回null</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> configurationCenterClient.getValue(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) {</span><br><span class="line">            value = properties.getProperty(key);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyNotFoundException</span>(key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置中心或配置文件取得一个key的值并将其解密</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Property或配置中心条目的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 取到的值，不会为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PropertyNotFoundException 当在配置中心和配置文件中都找不到这个key时抛出，这通常意味着我们把某条配置漏掉了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loadEncryptedProperty</span><span class="params">(<span class="keyword">final</span> String key)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">encryptedValue</span> <span class="operator">=</span> configurationCenterClient.getValue(key);</span><br><span class="line">        <span class="keyword">if</span> (encryptedValue == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 如果从配置中心拿不到值，那就从property文件中拿未加密的原文</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">plainValue</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">            <span class="keyword">if</span> (plainValue == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyNotFoundException</span>(key);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> plainValue;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> encryptionDecryptionService.decrypt(encryptedValue);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查配置文件或配置中心是否有指定的key</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要检查的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当这个key存在时返回true，反之返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasProperty</span><span class="params">(<span class="keyword">final</span> String key)</span> {</span><br><span class="line">        <span class="keyword">return</span> configurationCenterClient.getKeys().contains(key) || properties.containsKey(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实现观察者模式"><a href="#实现观察者模式" class="headerlink" title="实现观察者模式"></a>实现观察者模式</h3><p>上面说到了，我需要在监听到配置中心发出的事件后，更新相关对象中的配置。显然，在每个对象中都实现一个 Spring 事件监听器是很蠢的，我们应该在一处监听 Spring 事件，然后将其以某种方式广播到相关的对象。看起来，<span class="exturl" data-url="aHR0cHM6Ly9yZWZhY3RvcmluZy5ndXJ1L2Rlc2lnbi1wYXR0ZXJucy9vYnNlcnZlcg==">观察者模式<i class="fa fa-external-link-alt"></i></span>是个不错的选择。</p><p>观察者模式包含两个组件：<code>notifier</code> 和 <code>subject</code>。<code>Subject</code> 作为观众，观察着某个事件；<code>notifier</code> 则负责将事件通知给各个 <code>subject</code>。</p><p>OK，理论有这些就够了。接下来我们把它实现。首先是 <code>subject</code>。</p><h4 id="观察者模式-subject"><a href="#观察者模式-subject" class="headerlink" title="观察者模式 - subject"></a>观察者模式 - subject</h4><p>首选我们用一个抽象类定义一个观察者要有的行为，需要成为观察者的类将会继承这个抽象类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ConfigRefreshObserverSubject</span> {</span><br><span class="line">    <span class="comment">// 观察到配置更新后，从PropertyLoader获取新的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertyLoader propertyLoader;</span><br><span class="line">    <span class="comment">// 这个观察者关心的key</span></span><br><span class="line">    <span class="comment">// 因为要计算在这个对象中当前生效的配置的签名，所以要配置这个对象关心哪些key</span></span><br><span class="line">    <span class="comment">// 然后取出这些key对应的value来计算签名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; monitoredKeys;</span><br><span class="line">    <span class="comment">// 当前生效的配置的一个签名</span></span><br><span class="line">    <span class="comment">// 可以将其理解为当前配置的一个哈希，实际上是综合当前生效的配置生成的一个UUID</span></span><br><span class="line">    <span class="comment">// 在收到配置刷新事件后，会将新配置的签名与当前签名比较</span></span><br><span class="line">    <span class="comment">// 仅在签名不一致时刷新对象中的配置</span></span><br><span class="line">    <span class="keyword">private</span> String configSignature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConfigRefreshObserverSubject</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> PropertyLoader propertyLoader,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> List&lt;String&gt; monitoredKeys</span></span><br><span class="line"><span class="params">    )</span> {</span><br><span class="line">        <span class="built_in">this</span>.propertyLoader = propertyLoader;</span><br><span class="line">        <span class="built_in">this</span>.monitoredKeys = monitoredKeys;</span><br><span class="line">        <span class="comment">// 在初始化时计算当前生效配置的签名</span></span><br><span class="line">        <span class="built_in">this</span>.configSignature = calculateConfigurationSignature();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法留给实际成为subject的类去实现具体它要怎么刷新自己的配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">refreshConfigImpl</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法留给notifier调用，实现更新配置及刷新配置签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshConfig</span><span class="params">()</span> {</span><br><span class="line">        refreshConfigImpl();</span><br><span class="line">        configSignature = calculateConfigurationSignature();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PropertyLoader <span class="title function_">getPropertyLoader</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.propertyLoader;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigSignature</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.configSignature;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">calculateConfigurationSignature</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">newConfigurationSignatureSeedBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String key : monitoredKeys) {</span><br><span class="line">            <span class="keyword">if</span> (!propertyLoader.hasProperty(key)) {</span><br><span class="line">                <span class="comment">// 如果找不到某个关心的key，那么说明要么初始配置有问题，要么刷新的配置有问题</span></span><br><span class="line">                <span class="comment">// 这时候尽早抛出异常引发开发人员关注</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Missing property: "</span> + key + <span class="string">" for class: "</span> + <span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            newConfigurationSignatureSeedBuilder.append(propertyLoader.loadProperty(key));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> UUID.nameUUIDFromBytes(newConfigurationSignatureSeedBuilder.toString().getBytes()).toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="观察者模式-notifier"><a href="#观察者模式-notifier" class="headerlink" title="观察者模式 - notifier"></a>观察者模式 - notifier</h4><p>在观察者模式中，<code>notifier</code> 将作为一个单例存在，各个 <code>subject</code> 会注册到这个 <code>notifier</code>，并在接收到事件后被 <code>notifier</code> 逐个通知。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigRefreshObserverNotifier</span> {</span><br><span class="line">    <span class="comment">// 用于存放各个subject的注册表</span></span><br><span class="line">    <span class="comment">// 在某些情况下，同一个subject可能会被重复注册，所以这里我会把subject的类名作为key放在map中</span></span><br><span class="line">    <span class="comment">// 方便在注册时检查是否重复注册</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ConfigRefreshObserverSubject&gt; subjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ConfigRefreshObserverNotifier</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// notifier作为一个单例，我们不希望它被实例化</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">"ConfigRefreshObserverNotifier shouldn't be instantiated"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 待注册的subject对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> ConfigRefreshObserverSubject subject)</span> {</span><br><span class="line">        <span class="keyword">if</span> (!isSubjectRegistered(subject)) {</span><br><span class="line">            subjects.put(subject.getClass().getSimpleName(), subject);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向各个subject发出配置更新的通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ConfigRefreshObserverSubject subject : subjects.values()) {</span><br><span class="line">            <span class="comment">// 计算新配置的签名</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">newConfigSignature</span> <span class="operator">=</span> subject.calculateConfigurationSignature();</span><br><span class="line">            <span class="comment">// 仅当签名不同，即配置有变化时，才通知对应的subject更新</span></span><br><span class="line">            <span class="keyword">if</span> (!newConfigSignature.equals(subject.getConfigSignature())) {</span><br><span class="line">                subject.refreshConfig();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSubjectRegistered</span><span class="params">(<span class="keyword">final</span> ConfigRefreshObserverSubject subject)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">subjectClassName</span> <span class="operator">=</span> subject.getClass().getSimpleName();</span><br><span class="line">        <span class="keyword">return</span> subjects.containsKey(subjectClassName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="观察者模式-实际的观察者类"><a href="#观察者模式-实际的观察者类" class="headerlink" title="观察者模式 - 实际的观察者类"></a>观察者模式 - 实际的观察者类</h4><p>有了 <code>subject</code>，接下来就可以让实际要监控配置更新的类继承 <code>ConfigRefreshObserverSubject</code>，将它变为一个观察者，并实现更新配置的逻辑。这部分其实很简单，就是给对应的字段重新赋值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServiceClient</span> <span class="keyword">extends</span> <span class="title class_">ConfigRefreshObserverSubject</span> {</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SomeServiceClient</span><span class="params">(<span class="keyword">final</span> PropertyLoader propertyLoader)</span> {</span><br><span class="line">        <span class="built_in">super</span>(</span><br><span class="line">            propertyLoader,</span><br><span class="line">            List.of(<span class="string">"some-service-endpoint"</span>, <span class="string">"some-service-username"</span>, <span class="string">"some-service-password"</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        initializeProperties();</span><br><span class="line">        ConfigRefreshObserverNotifier.register(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initializeProperties</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PropertyLoader</span> <span class="variable">propertyLoader</span> <span class="operator">=</span> <span class="built_in">super</span>.getPropertyLoader();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.endpoint = propertyLoader.loadProperty(<span class="string">"some-service-endpoint"</span>);</span><br><span class="line">        <span class="built_in">this</span>.username = propertyLoader.loadProperty(<span class="string">"some-service-username"</span>);</span><br><span class="line">        <span class="built_in">this</span>.password = propertyLoader.loadEncryptedProperty(<span class="string">"some-service-password"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshConfigImpl</span><span class="params">()</span> {</span><br><span class="line">        initializeProperties();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际这个类的业务实现与本文无关，就省略了</span></span><br><span class="line">    <span class="comment">// 说白了无非就是往endpoint发请求，带上username和password来认证</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码应该很容易理解，在配置刷新前，<code>SomeServiceClient</code> 就用当前生效的配置去发请求，在配置刷新后，这个观察者就可以马上得知这个事件并从配置中心取得最新的值替换当前生效的配置。这个过程几乎是瞬间完成的，不会对业务产生影响。</p><h3 id="监听配置刷新事件"><a href="#监听配置刷新事件" class="headerlink" title="监听配置刷新事件"></a>监听配置刷新事件</h3><p>上面洋洋洒洒实现了一堆东西，但最重要的一个还没有实现，那就是配置刷新事件的监听器。因为配置中心会通过 Spring 事件来发布，所以只需要找个地方实现一个 <code>@EventListener</code> 方法就行。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SomeServiceClient <span class="title function_">someServiceClient</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> ResourceLoader resourceLoader,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> EncryptionDecryptionService encryptionDecryptionService </span></span><br><span class="line"><span class="params">    )</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> ResourcesUtils.loadProperties(</span><br><span class="line">            resourceLoader,</span><br><span class="line">            ResourcesUtils.CLASSPATH_META_INF + <span class="string">"/some-service.properties"</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PropertyLoader</span> <span class="variable">propertyLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyLoader</span>(encryptionDecryptionService, properties);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SomeServiceClient</span>(propertyLoader);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleConfigRefreshEvent</span><span class="params">(<span class="keyword">final</span> ConfigRefreshEvent event)</span> {</span><br><span class="line">        <span class="keyword">if</span> (event.getProjects().contains(<span class="string">"my-config-project"</span>)) {</span><br><span class="line">            ConfigRefreshObserverNotifier.notifyObservers();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上，就完成了一个利用配置中心的通知机制实现的配置动态更新功能。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      <category domain="https://www.boris1993.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</category>
      
      
      <comments>https://www.boris1993.com/dynamically-refresh-config-with-observer-pattern.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入了解 Redis 的 Pub/Sub</title>
      <link>https://www.boris1993.com/translation-redis-pubsub-in-depth.html</link>
      <guid>https://www.boris1993.com/translation-redis-pubsub-in-depth.html</guid>
      <pubDate>Sat, 15 Mar 2025 01:18:06 GMT</pubDate>
      
      <description>&lt;p&gt;看到一篇深入讲解 Redis 中 Pub/Sub 的文章&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tZWRpdW0uY29tL0Bqb3Vkd2F3YWQvcmVkaXMtcHViLXN1Yi1pbi1kZXB0aC1kMmM2ZjQzMzQ4MjY=&quot;&gt; Redis Pub/Sub In-Depth&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;，所以打算将它翻译出来，顺便深化自己的理解。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>看到一篇深入讲解 Redis 中 Pub/Sub 的文章<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Bqb3Vkd2F3YWQvcmVkaXMtcHViLXN1Yi1pbi1kZXB0aC1kMmM2ZjQzMzQ4MjY="> Redis Pub/Sub In-Depth<i class="fa fa-external-link-alt"></i></span>，所以打算将它翻译出来，顺便深化自己的理解。</p><span id="more"></span><p>Pub/Sub（即 publish/subscribe 的简称）是一个在分布式系统中给不同组件互相通信的一种消息传递技术。这种消息传递技术与传统的点对点通信（即一个服务直接向另一个服务发送消息）不同，它是一种异步且可伸缩的消息服务，并且它可以将负责发布消息的服务与负责处理消息的服务分隔开。</p><p>在这篇博客中，我们会探索 Pub/Sub 的原理，以及 Redis 是如何实现这个通信模型的。我们会分析 Redis 中错综复杂的实现，将目光聚焦并深入到内存级别的实现的细节上，来让我们完全理解 Pub/Sub 机制，以及通过 Redis 完成的项目实践。</p><h2 id="Pub-Sub入门"><a href="#Pub-Sub入门" class="headerlink" title="Pub/Sub入门"></a>Pub/Sub 入门</h2><p>Pub/Sub 是一个消息模型，它可以让分布式系统中的不同组件互相通信。发布者向一个主题（topic）发送信息，订阅者则从这个主题中接收信息。发送者在这个过程中可以保持匿名，当然如果在消息中包含了发送者的信息，那么订阅者也可以通过它来确定发送者的身份。Pub/Sub 系统保证了消息可以被送达到所有对这个主题感兴趣的订阅者。在恰当的配置下，这将会是一个高度可扩展并且很可靠的消息传递系统，它将可以处理大量的数据。此外，在适当的大小、网络状况，以及订阅者的处理时间的前提下，Pub/Sub 允许服务以 1 毫秒的延迟进行异步通信，因此它非常适合现代快速的分布式应用程序。</p><h2 id="Pub-Sub模型"><a href="#Pub-Sub模型" class="headerlink" title="Pub/Sub模型"></a>Pub/Sub 模型</h2><p>Pub/Sub 的模型很简单，消息中介从发布者收到消息，然后将消息分发到各个订阅者。订阅者在得到消息后，就可以根据实际的场景对消息进行处理。基于发布者和订阅者的数量，这个模型通常可以被归为四类，即一对一、一对多、多对一、多对多。</p><table><thead><tr><th>Pub/Sub 类型</th><th>描述</th></tr></thead><tbody><tr><td>一对一</td><td>包括一个发布者和一个订阅者。消息从发布者直接发送到订阅者。</td></tr><tr><td>一对多</td><td>包括一个发布者和多个订阅者。发布者向主题发送消息，所有订阅这个主题的订阅者都将收到这个消息。</td></tr><tr><td>多对一</td><td>包括多个发布者和一个订阅者。多个发布者都向某个特定的主题发送消息，订阅者会从这个主题收到消息。</td></tr><tr><td>多对多</td><td>包括多个发布者和多个订阅者。各个发布者都向某个主题发送消息，而各个订阅者都将收到这些消息。</td></tr></tbody></table><h2 id="Pub-Sub核心概念"><a href="#Pub-Sub核心概念" class="headerlink" title="Pub/Sub核心概念"></a>Pub/Sub 核心概念</h2><p>在我们深入去了解 Pub/Sub 的细节和实现之前，我们需要先对 Pub/Sub 相关的核心概念有所了解。Pub/Sub 系统包含多个组件，下表描述了其中的一些主要的组件：</p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>发布者</td><td>发布者是一个应用或者服务，它会发出消息。</td></tr><tr><td>订阅者</td><td>订阅者是一个应用或者服务，它会接收消息。</td></tr><tr><td>主题<br>(topic)</td><td> 主题即消息的标题或信息源。发布者可以向一个主题发送消息，这些消息会被广播至订阅者。</td></tr><tr><td>消息</td><td>消息包含将在系统中被接收或传递的消息。</td></tr><tr><td>中介<br>(broker)</td><td> 中介负责指引消息在系统中的流动。它扮演着一个中间人的角色，负责在发布者和订阅者之间建立通信，并在它们之间交换信息。中介可以维护一个关于主题及其订阅者的列表，来帮助中介将从发布者收到的信息发送到正确的订阅者。</td></tr><tr><td>路由<br>(routing)</td><td> 路由指在系统中，信息从发布者流向订阅者，并依靠特定的订阅保障信息被送往正确的订阅者的过程。</td></tr></tbody></table><h2 id="Redis-Pub-Sub"><a href="#Redis-Pub-Sub" class="headerlink" title="Redis Pub/Sub"></a>Redis Pub/Sub</h2><p>现在我们已经了解了关于 Pub/Sub 的一些抽象概念，并且知道了它是如何工作的。接下来我们需要深入到 Redis 针对 Pub/Sub 的实现，来了解消息从发布者发布出来，到结束于订阅者这个过程中，系统是如何通信的。</p><p>Redis 通过在客户端之间实现一个简单而高效的消息系统来实现 Pub/Sub。在 Redis 中，一个客户端可以 “发布” 一条消息到一个命名的通道，其他客户端则可以 “订阅” 这个通道来接收消息。</p><p>当一个客户端向这个通道发布了一条消息，Redis 将会把这个消息发送到所有订阅了这个通道的客户端。这样，应用程序的不同组件之间就可以实时地通信并交换信息。</p><p>Redis Pub/Sub 提供了一个轻量级、高速，并且可扩展的消息传递解决方案，并且可以用于各种场景下，比如实现一个实时通知、在不同微服务之间发送消息，或在一个应用的不同组件之间通信。</p><h3 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h3><p>Redis Pub/Sub 是同步的。<strong>为了保证消息可以成功被传递，订阅者和发布者必须同时连接到 Redis。</strong></p><p>你可以将它想象成一个收音机电台，在调频到这个频道之后，你就可以收听它的内容。然而，在收音机被关掉之后，你就没法再收听了。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-data-flow.png"></p><p>这意味着如果一个订阅者断开了连接，过了一会又连了上来，那么它将无法收到断开期间发出来的消息。也就是说，这限制了 Redis Pub/Sub 只能用在允许数据可能丢失的场景下。</p><h3 id="发射后不管-Fire-Forget"><a href="#发射后不管-Fire-Forget" class="headerlink" title="发射后不管 (Fire &amp; Forget)"></a>发射后不管 (Fire &amp; Forget)</h3><p>“发射后不管” 是一种信息传递模式，在这种模式下，发送方不会期望从接收方明确确认信息已经被收到。发送方只会将消息发出去，然后就继续开始做后面的事，不管消息有没有被接收方收到。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-relationship.png"></p><h3 id="仅向外播散-Fan-out-Only"><a href="#仅向外播散-Fan-out-Only" class="headerlink" title="仅向外播散 (Fan-out Only)"></a>仅向外播散 (Fan-out Only)</h3><p>Redis Pub/Sub 只管向外播散消息，也就是说，当发布者发布了一条消息后，这条消息会被广播到所有当前活动的订阅者。所有订阅者都会收到这条消息的副本，不管它们是不是对这条消息感兴趣。</p><h2 id="掀开Redis-Pub-Sub的引擎盖"><a href="#掀开Redis-Pub-Sub的引擎盖" class="headerlink" title="掀开Redis Pub/Sub的引擎盖"></a>掀开 Redis Pub/Sub 的引擎盖</h2><p>Redis 最著名的功能是键值服务器。当客户端连接到 Redis 服务器后，它将会与服务器建立 TCP 连接，并开始向服务器发送命令。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-server-and-client.png"></p><p>但是 Redis 也是个消息服务器！一个对 <code>topicA</code> 感兴趣的客户端可以向 Redis 服务器建立一个 TCP 连接，发送 <code>SUBSCRIBE topicA</code> 命令，然后等待与 <code>topicA</code> 相关的新闻。“新闻机构” 也可以连接到 Redis 服务器，发送 <code>PUBLISH topicA message-data</code>，然后所有订阅了这个主题的客户端都将收到这条价值连城的消息。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-publish-and-subscribe.png"></p><p>如果放大了看 Redis 里面发生了什么，我们可以想象 Redis 会跟踪每个套接字 (socket) 的订阅集：</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-subscription-set.png"></p><p>咱们继续深入看看 Redis 是怎么做的。</p><p>最初的 Pub/Sub 实现允许客户端发送三个新的命令：<code>PUBLISH</code>，<code>SUBSCRIBE</code>，和 <code>UNSUBSCRIBE</code>。Redis 使用了一个全局变量 <code>pubsub_channels</code> 来跟踪各个订阅，在其中 Redis 维护了一个通道名和订阅它的客户端对象的映射关系。每个客户端对象代表一个 TCP 连接的客户端，并通过其对应的文件描述符来跟踪。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-pubsub-channels.png"></p><p>当一个客户端发送 <code>SUBSCRIBE</code> 命令后，它对应的客户端对象就会被加到对应通道的客户端对象集中。<br>在发布信息时，Redis 会从 <code>pubsub_channel</code> 中找到这个主题对应的订阅者，并针对每个客户端启动一个计划任务来向对应的套接字发送信息。</p><h3 id="处理连接断开"><a href="#处理连接断开" class="headerlink" title="处理连接断开"></a>处理连接断开</h3><p>客户端的连接可能会因为客户端断开连接，或者网线被拔掉而断开。当有连接断开时，Redis 必须将对应的订阅清理掉。假设客户端 A 断开了连接，那么为了将这个客户端从 <code>pubsub_channels</code> 中清除，Redis 需要遍历每个通道 (“topicA” 和”topicB”)，并从它们的客户端对象集中删掉它。</p><p>可想而知，遍历所有的通道的效率是非常低的。按道理，Redis 只需要访问”topicA” 这个通道，因为客户端 A 只订阅了它。为了将这个理论变成实际，Redis 标记了各个客户端及其订阅的通道，并将其与 <code>pubsub_channels</code> 同步。这样，Redis 就只需要访问这个客户端相关的通道，而不需要低效的遍历所有的通道。我们在图中可以将这些标记画成绿色的圆：</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-pubsub-channels-annotated-subscription.png"></p><h3 id="落实理论"><a href="#落实理论" class="headerlink" title="落实理论"></a>落实理论</h3><p>我们已经知道，全局变量 <code>pubsub_channels</code> 的数据结构基本上就是一个 <code>Map&lt;ChannelName, Set&lt;Client&gt;&gt;</code>，而每个客户端的订阅集就是个 <code>Set&lt;ChannelName&gt;</code>。但是这些都只是一个抽象的数据结构，没法说明内存中是如何表现的。所以我们继续放大，看看内存中的样子。</p><p><code>pubsub_channels</code> 这个 Map 实际上是个哈希表，其中通道名会被哈希，然后放到一个 <code>2^n</code> 长的数组中的对应位置。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-pubsub-channels-hash-chain.png"></p><p>包含了 8 个桶的数组 <code>pubsub_channels</code> 是一块独立分配出来的内存空间。要发布消息到一个通道，首先它会将通道名进行哈希，找到它对应的桶，然后遍历这个通道相关联的各个客户端。然而不同的通道名又可能会被哈希到同一个桶中，为了解决这个哈希冲突问题，Redis 使用了一个叫 “哈希链” 的方案，即每个桶都会指向一个保存着通道的链表。比如在上面的例子中，“topicA” 和 “topicB” 都被哈希到了第三个桶中。实际上为了以防万一，Redis 会在启动时为它的哈希函数选择一个随机的种子来尝试避免出现哈希碰撞，这也可以防止被恶意用户蓄意订阅到会被哈希到同一个位置的大量通道而导致性能下降。</p><p>在下图中，绿色的字符串是通道的名字，作为哈希表的键；紫色的是客户端的集合，作为哈希表的值。但 “集合” 在这里也是个抽象的概念，它在 Redis 中是怎样表现的呢？答案是，另一个链表！</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-client-set.png"></p><p>我们可能会觉得字符串 “topicA” 和 “topicB” 是在哈希链里面的，但实际不是。每个字符串都是独立分配的一块内存空间。字符串在 Redis 中被广泛使用着，它们甚至有自己的名字叫 “简单动态字符串（Simple Dynamic Strings）”，其内容分三部分：已占用的空间、剩余的空间，和一个字符数组。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-simple-dynamic-strings.png"></p><p>到现在我们已经快要到内存级别了，但是还有一件事没有提到，那就是每个通道的客户端集。在这里，Redis 并没有选择用链表，而是用了另一个哈希表，其中通道的名字就是哈希表的键。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-clients-set-of-channels.png"></p><p>我暂时还不清楚为什么 Redis 选择用链表保存通道的客户端集，而又选择哈希表来保存客户端的通道集。我怀疑 Redis 选择在通道的客户端集上用链表是因为，链表更适用于发布的场景，因为在发布时会需要遍历它；而选择在客户端的通道集上用哈希表则是因为它更适用于订阅和取消订阅的场景，因为此时要做的是在里面做查找。如果你有更深入的理解，请告诉我。</p><p>需要注意的是，在每个客户端的哈希链上，指向它的值的指针是被忽略的，这片内存没有被用到。当用哈希表来表示一个集合的时候，我们只会用到它的键。相比较于我们从代码复用中得到的收益，这部分浪费不值一提。</p><p>终于，我们快要接近真相了：图中的每个方块都代表 redis-server 进程中分配的一块内存。现在我们来回顾一下 <code>PUBLISH</code> 和 <code>SUBSCRIBE</code> 的算法：</p><ul><li>在 <code>PUBLISH</code> 的时候，首先对通道的名字做一次哈希，接下来遍历哈希链，将要发布的通道名与哈希链中的各个通道名做比较。在找到我们要的那个通道后，从中得到它的客户端列表。然后遍历客户端列表，将消息发至各个客户端。</li><li>在 <code>SUBSCRIBE</code> 的时候，首先像 <code>PUBLISH</code> 一样找到保存着客户端的那个链表，然后将新的客户端附加在链表的尾部。并且将要订阅的通道添加到客户端维护的哈希表中。</li></ul><h3 id="可以实时操作的哈希表"><a href="#可以实时操作的哈希表" class="headerlink" title="可以实时操作的哈希表"></a>可以实时操作的哈希表</h3><p>要注意这些哈希表的大小是不同的，而且都大概与其元素数量成比例。Redis 会根据元素数量调整哈希表的大小。但是，Redis 的设计目标是低延迟，而调整哈希表又是个比较耗时的操作。那么 Redis 是怎么做到在调整哈希表大小时不产生延迟尖峰的？</p><p>答案是：Redis 会逐步的调整哈希表的大小。它在底层维护了新旧两个哈希表。假设 <code>pubsub_channels</code> 这个哈希表正在经历调整。</p><p>每当 Redis 对哈希表进行操作时（查询、插入、删除……），它都会稍微调整一下哈希表的大小。它会跟踪有多少老的桶被移动到了新的桶中，然后在每次操作中，它都会再移动几个过去。这样一来，调整大小的工作量就会被限制，使得 Redis 在调整期间也可以保证响应。</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-hashtable-resizing.png"></p><h3 id="不再订阅昂贵的东西（Expensive-unsubscribed）"><a href="#不再订阅昂贵的东西（Expensive-unsubscribed）" class="headerlink" title="不再订阅昂贵的东西（Expensive unsubscribed）"></a>不再订阅昂贵的东西（Expensive unsubscribed）</h3><p>在 Pub/Sub 中还有一个很重要的操作：<code>UNSUBSCRIBE</code>，它所做的与 <code>SUBSCRIBE</code> 正相反，它会使客户端不再订阅到指定的通道，也不会再收到来自这个通道的消息。那么利用上面说过的数据结构，你会怎么实现 <code>UNSUBSCRIBE</code> 功能呢？Redis 是这样做的：</p><p>在 <code>UNSUBSCRIBE</code> 时，首先找到这个通道对应的客户端链表，然后遍历整个链表直到找到我们要删除的那个客户端。</p><p>也就是说，<code>UNSUBSCRIBE</code> 操作的耗时是 <code>O(n)</code>，其中 <code>n</code> 就是客户端的数量。如果一个通道有大量的客户端订阅，那么 <code>UNSUBSCRIBE</code> 操作就会变得很昂贵。<strong>所以，你要么需要限制你的客户端数量，要么需要限制它们订阅的通道的数量。</strong><span class="exturl" data-url="aHR0cHM6Ly9wdXNoZXIuY29tLw==">Pusher<i class="fa fa-external-link-alt"></i></span>的一个优化就是去掉重复的订阅，数百万的 Pusher 订阅会被折叠为数量更少的 Redis 订阅。</p><p>Redis 可以通过把存放客户端订阅的链表换成哈希表来优化，但也可能不会很理想，会导致发布消息稍稍变慢，因为遍历哈希表比遍历链表慢。Redis 选择针对 <code>PUBLISH</code> 操作去做优化，因为它们比变更订阅更加常见。</p><h3 id="按照表达式匹配订阅（Pattern-subscriptions）"><a href="#按照表达式匹配订阅（Pattern-subscriptions）" class="headerlink" title="按照表达式匹配订阅（Pattern subscriptions）"></a>按照表达式匹配订阅（Pattern subscriptions）</h3><p>最初的 Pub/Sub 提供了 <code>PUBLISH</code>、<code>SUBSCRIBE</code> 和 <code>UNSUBSCRIBE</code> 三个命令。不久之后，Redis 引入了一个名为 “按照表达式匹配订阅” 的新功能及其命令 <code>PSUBSCRIBE</code>，这个可以让客户端订阅所有匹配了某个正则表达式的主题。</p><p>现在，如果一个客户端发送了命令 <code>PSUBSCRIBE food.donuts.*</code>，然后一个发布者发送了命令 <code>PUBLISH food.donuts.glazed 2-for-£2</code>，那么订阅者也会收到消息，因为 <code>food.donuts.glazed</code> 匹配了正则表达式 <code>food.donuts.*</code>。</p><p>按照表达式订阅的实现是与普通的订阅完全不同的。除了全局的 <code>pubsub_channels</code> 哈希表之外，还有一个全局的 <code>pubsub_patterns</code> 列表。这是一个包含了 <code>pubsubPattern</code> 对象的列表，每个对象与一个客户端订阅的一个表达式相关联。类似地，每个客户端对象也有一个包含着它订阅的表达式的链表。下图展示了当客户端 B 订阅了 <code>drink?</code>，同时客户端 A 和客户端 B 订阅了 <code>food.*</code> 之后，redis-server 进程的内存的样子：</p><p><img data-src="https://blog-static.boris1993.com/translation-redis-pubsub-in-depth/redis-pub-sub-pattern-subscriptions.png"></p><p>图示的左侧是一个全局的链表，每个节点都指向一个 <code>pubsubPattern</code>，每个表达式在内存中都是字符串字面量。在图示的右侧，每个客户端都有一个关联着它的订阅的链表。</p><p>当一个客户端发送命令 <code>PUBLISH food.donuts 5-for-£1</code>，Redis 就会遍历 <code>pubsub_patterns</code> 列表，并将字符串 <code>food.donuts</code> 与每个表达式匹配。每遇到一个符合的匹配，Redis 就会发送消息 <code>5-for-£1</code> 到关联的客户端。</p><p>这个实现可能有一个让你惊讶的点：如果多个客户端订阅到同一个表达式时，这些订阅不会被组合在一起。如果有 10000 个客户端都订阅了 <code>food.*</code>，那么你将会得到一个包含了 10000 个表达式的链表，其中每个元素在发布消息的时候都会被匹配。这种设计假定模式订阅集很小，而且各不相同。</p><p>另一个会让你惊讶的点是，表达式都是以其原文存储的，它们并没有被编译。这一点尤其有趣，因为 Redis 的匹配函数 <code>stringmatch</code> 有一些有趣的坏情况。如下展示了 Redis 是如何把字符串 <code>aa</code> 与表达式 <code>*a*a*b</code> 相匹配的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stringmatch("*a*a*b", "aa")</span><br><span class="line">    stringmatch("a*a*b", "aa")</span><br><span class="line">        stringmatch("*a*b", "a")</span><br><span class="line">            stringmatch("a*b", "a")</span><br><span class="line">                stringmatch("*b", "")</span><br><span class="line">                    stringmatch("b", "")</span><br><span class="line">                        false</span><br><span class="line">            stringmatch("a*b", "")</span><br><span class="line">                false</span><br><span class="line">    stringmatch("a*a*b", "a")</span><br><span class="line">        stringmatch("*a*b", "")</span><br><span class="line">            stringmatch("a*b", "")</span><br><span class="line">                false</span><br><span class="line">    stringmatch("a*a*b", "")</span><br><span class="line">        false</span><br></pre></td></tr></tbody></table></figure><p>这种带有许多 <code>glob</code> 的恶意表达式会导致匹配的执行时间爆炸性增长。Redis 的表达式语言虽然可以被编译成确定有限状态自动机（DFA），来让匹配耗时变得线性，但却没这么做。</p><p>所以长话短说，你不应该把 Redis 的按表达式匹配功能开放给不被信任的客户端，因为这可能会引来两种攻击：一种是订阅大量的表达式，另一种就是刻意制造的表达式。在 Pusher，我们会非常小心地处理 Redis 的按表达式订阅功能。</p><h2 id="Pub-Sub的使用场景"><a href="#Pub-Sub的使用场景" class="headerlink" title="Pub/Sub的使用场景"></a>Pub/Sub 的使用场景</h2><p>我们现在知道了 Pub/Sub 的技术细节，以及在 Redis 中是怎么实现的。接下来我们看看有哪些使用场景。</p><p>Redis 提供的异步集成功能提高了系统的整体灵活性和稳定性，使其能够满足各种场景，包括：</p><ul><li>实时消息和聊天</li><li>物联网设备</li><li>新闻发布和警告</li><li>分布式计算和微服务</li><li>事件驱动的架构</li><li>组件间解耦，以及减少依赖</li><li>扇入处理（Fan-in processing）—— 将多个消息组合成一个消息的过程被称为扇入处理。</li><li>刷新分布式缓存</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Redis 是实现 Pub/Sub 最常用的工具之一。它因扩展性、低延迟和易于集成而广为人知。我们也在内存块级别探讨了 Redis 的工作原理。</p><p>Redis Pub/Sub 是一个高效的分发消息的方法，但我们也要知道它在哪些方面做了优化，以及在哪有陷阱。要想彻底了解的话，那就去研究源码吧！一句话，记得只在可信的环境中使用 Redis，并要限制客户端的数量，并且小心处理按照表达式的订阅。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/translations/">翻译</category>
      
      
      <category domain="https://www.boris1993.com/tags/Redis/">Redis</category>
      
      <category domain="https://www.boris1993.com/tags/Pub-Sub/">Pub/Sub</category>
      
      
      <comments>https://www.boris1993.com/translation-redis-pubsub-in-depth.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在同一个类的两个方法内部互相调用中，如何使 AOP 生效</title>
      <link>https://www.boris1993.com/spring-how-to-make-aop-effective-in-internal-calls.html</link>
      <guid>https://www.boris1993.com/spring-how-to-make-aop-effective-in-internal-calls.html</guid>
      <pubDate>Mon, 10 Mar 2025 06:33:53 GMT</pubDate>
      
      <description>&lt;p&gt;熟悉 Spring AOP 的都知道，如果同一个类中的两个方法在内部互相调用，那么此时 AOP 是不会生效的，因为 Spring AOP 是通过代理类来实现的，而类内部的方法调用并不会走到代理对象。那么，有没有办法让内部调用的时候也让 AOP 生效呢？万能的 ChatGPT 告诉我，方法是有的，还有好几种。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>熟悉 Spring AOP 的都知道，如果同一个类中的两个方法在内部互相调用，那么此时 AOP 是不会生效的，因为 Spring AOP 是通过代理类来实现的，而类内部的方法调用并不会走到代理对象。那么，有没有办法让内部调用的时候也让 AOP 生效呢？万能的 ChatGPT 告诉我，方法是有的，还有好几种。</p><span id="more"></span><h2 id="使用-Autowired通过代理调用"><a href="#使用-Autowired通过代理调用" class="headerlink" title="使用@Autowired通过代理调用"></a>使用 <code>@Autowired</code> 通过代理调用</h2><p>这个方法的思路是，利用 <code>@Autowired</code> 注解注入自身的代理对象，然后通过代理对象完成方法调用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloWorld</span><span class="params">()</span> {</span><br><span class="line">        demoService.test();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Test"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个操作我也在本地的一个 Spring Boot 项目中验证确实是可行的，前提是要在 <code>application.properties</code> 里面配置允许循环引用 <code>spring.main.allow-circular-references=true</code>。而且这个操作有一个缺点，就是自身代理对象 <code>demoService</code> 必须通过字段注入的方式完成依赖注入，如果用构造方法注入，启动的时候就会报循环依赖错误导致项目无法成功启动（不用想也知道，在构造方法里面依赖自己肯定不行啊）。</p><p>我个人并不喜欢这个方法，一个原因是因为我不喜欢循环引用，另一个原因是我不喜欢字段注入，毕竟 Spring 早就推荐改成构造方法注入了。所以，我们继续看下一个方法。</p><h2 id="使用AopContext-currentProxy"><a href="#使用AopContext-currentProxy" class="headerlink" title="使用AopContext.currentProxy()"></a>使用 <code>AopContext.currentProxy()</code></h2><p>另一个方法是使用 <code>AopContext#currentProxy()</code> 静态方法获取到当前的代理对象，也就是对象自己，然后再通过这个代理对象进行方法调用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoService</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloWorld</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DemoService</span> <span class="variable">demoService</span> <span class="operator">=</span> (DemoService) AopContext.currentProxy();</span><br><span class="line">        demoService.test();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Test"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是如果就这样运行，你就会得到这样一条错误信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available, and ensure that AopContext.currentProxy() is invoked in the same thread as the AOP invocation context.</span><br></pre></td></tr></tbody></table></figure><p>看来 ChatGPT 没把话说全啊，好在我的 IDEA 里面装了通义灵码，把代码上下文和这个异常抛给它之后，它告诉我要通过注解 <code>@EnableAspectJAutoProxy(exposeProxy = true)</code> 配置 Spring AOP 允许暴露当前代理对象。那么按照它的说法，我给切面配置类加上这个注解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span> <span class="comment">// &lt;-- 就这个，它的默认值是false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAopAdvice</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(DemoAopAdvice.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut("execution(* com.example.demo.DemoService.*(..))")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before("test()")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> {</span><br><span class="line">        LOGGER.info(<span class="string">"Before"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再重启应用，就发现 <code>demoService</code> 里面的内部调用成功触发了 AOP 切面。</p><p>通义灵码还提醒我，在多线程环境中，要确保 <code>AopContext#currentProxy()</code> 必须在与 AOP 调用相同的线程中调用。此外，根据 <code>currentProxy()</code> 的 JavaDoc，调用它的方法也必须经过了 AOP 调用，否则会抛出 <code>IllegalStateException</code> 异常。点进 <code>currentProxy()</code> 方法的实现，发现它内部是用 ThreadLocal 来保存代理对象的，同时在这个类中还有一个 <code>setCurrentProxy(Object)</code> 方法来把当前的代理对象保存到 ThreadLocal 中。下断点调试后发现，<code>setCurrentProxy(Object)</code> 这个方法会先被执行，然后再走到我们实际调用的方法。这正好解释了为什么要注意在相同的线程中调用 <code>AopContext#currentProxy()</code>，并且调用它的方法必须是经过了 AOP 调用的，因为不这样的话 ThreadLocal 中根本就没东西可拿。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Spring/">Spring</category>
      
      <category domain="https://www.boris1993.com/tags/AOP/">AOP</category>
      
      
      <comments>https://www.boris1993.com/spring-how-to-make-aop-effective-in-internal-calls.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在 Java 中为什么不推荐在代码中直接写字符串值</title>
      <link>https://www.boris1993.com/java-why-prefer-string-constants-over-literals.html</link>
      <guid>https://www.boris1993.com/java-why-prefer-string-constants-over-literals.html</guid>
      <pubDate>Thu, 06 Mar 2025 05:26:23 GMT</pubDate>
      
      <description>&lt;p&gt;前两天看到个问题，说在 Java 中，为什么不推荐在代码中直接写字符串值？我一开始能想到的就是代码的可维护性和可读性，但是总觉得这个问题没这么简单，肯定还有 JVM 虚拟机里面的优化。那既然现在大语言模型这么发达，我觉得可以让它给我讲讲。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>前两天看到个问题，说在 Java 中，为什么不推荐在代码中直接写字符串值？我一开始能想到的就是代码的可维护性和可读性，但是总觉得这个问题没这么简单，肯定还有 JVM 虚拟机里面的优化。那既然现在大语言模型这么发达，我觉得可以让它给我讲讲。</p><span id="more"></span><h2 id="ChatGPT的回答"><a href="#ChatGPT的回答" class="headerlink" title="ChatGPT的回答"></a>ChatGPT 的回答</h2><blockquote><p>在 Java 代码中直接写字符串值（即 硬编码字符串）通常是不推荐的，主要从以下两个方面考虑：</p><ol><li>代码可读性和可维护性</li></ol><ul><li>降低可读性：直接在代码中写死字符串值，容易让代码的意图变得不清晰，阅读时难以理解这个字符串的作用。</li><li>难以维护：如果字符串值在多个地方使用，一旦需要修改，就必须逐个查找替换，容易遗漏或出错。</li><li>不利于国际化（i18n）：如果程序需要支持多种语言，硬编码字符串必须手动提取，而如果使用常量或资源文件，则可以更方便地进行国际化处理。</li></ul><ol start="2"><li>JVM 内部优化</li></ol><ul><li><strong>字符串常量池优化</strong>：JVM 会对字符串字面量进行 ** 字符串常量池（String Pool）** 处理，避免重复创建相同的字符串实例。但如果字符串值是动态拼接或 new 关键字创建的，就可能无法享受这种优化。</li><li><strong>减少堆内存占用</strong>：使用 <code>String</code> 变量或 <code>final</code> 常量，JVM 可能会进行<code>常量折叠</code>，减少运行时重复创建的开销，提高效率。</li><li><strong>提高性能</strong>：直接写字符串字面量可能会在某些情况下导致 JVM 额外分配对象，而使用 <code>final</code> 常量或 <code>intern()</code> 方法可以优化内存占用。</li></ul></blockquote><p>果然除了可读性考虑，JVM 也会对字符串常量做一些优化。但，什么是<code>常量折叠</code>？</p><h2 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h2><p>追问 ChatGPT 什么是常量折叠后，它是这么回到我的：</p><blockquote><p>常量折叠（Constant Folding） 是 JVM 编译优化（Just-In-Time Compilation, JIT） 或 Java 编译器（javac）在编译阶段执行的一种优化策略，它会在 编译期 计算出可以确定的常量表达式，并用计算结果替换原始表达式，从而减少运行时的计算开销。</p><ol><li>常量折叠的作用</li></ol><p>常量折叠的核心目标是提前计算出能确定的值，避免运行时重复计算，从而提高性能。例如，以下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> * <span class="number">3</span>;  <span class="comment">// 计算常量表达式</span></span><br><span class="line">       System.out.println(a);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在编译阶段，JVM 会将 <code>2 * 3</code> 计算为 <code>6</code>，然后直接将 <code>6</code> 存入字节码，而不是在运行时执行乘法计算。</p><ol start="2"><li>常量折叠的典型场景</li></ol><p>（前略）</p><p>（2）字符串常量优化<br>如果字符串是常量，编译器会在编译时进行字符串拼接优化，避免运行时的 <code>StringBuilder</code> 操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConstantFolding</span> {</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"Hello, "</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"World!"</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;  <span class="comment">// 直接折叠为 "Hello, World!"</span></span><br><span class="line">       System.out.println(s3);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后的字节码相当于：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"Hello, World!"</span>;</span><br></pre></td></tr></tbody></table></figure><p>（后略）</p><ol start="3"><li>什么时候不会发生常量折叠？<br>（1）变量不是 <code>final</code> - 如果变量不是 <code>final</code>，编译器无法确定其值，因此不会进行常量折叠<br>（2）值在运行时才能确定 - 如果值依赖于外部输入、方法调用、对象实例等，JVM 不能在编译时优化</li></ol></blockquote><p>也就是说，如果在代码里这样写：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLO</span> <span class="operator">=</span> <span class="string">"hello, "</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WORLD</span> <span class="operator">=</span> <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(HELLO + WORLD);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么实际上 JVM 就会给你优化成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLO</span> <span class="operator">=</span> <span class="string">"hello, "</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WORLD</span> <span class="operator">=</span> <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"hello, world"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将这段代码编译后再用 <code>javap</code> 反编译，可以看到这样的结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/boris1993/Developer/java/leetcode/src/Test.class</span><br><span class="line">  Last modified Mar 6, 2025; size 523 bytes</span><br><span class="line">  SHA-256 checksum 3443c8e0a13cd862c0195b772bb4290bde7e1d07b50818d531c2b5d66d665270</span><br><span class="line">  Compiled from "Test.java"</span><br><span class="line">public class Test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 65</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #13                         // Test</span><br><span class="line">  super_class: #2                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 2, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // "&lt;init&gt;":()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Class              #10            // java/lang/System</span><br><span class="line">   #9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span><br><span class="line">  #10 = Utf8               java/lang/System</span><br><span class="line">  #11 = Utf8               out</span><br><span class="line">  #12 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #13 = Class              #14            // Test</span><br><span class="line">  #14 = Utf8               Test</span><br><span class="line">  #15 = String             #16            // hello, world</span><br><span class="line">  #16 = Utf8               hello, world</span><br><span class="line">  #17 = Methodref          #18.#19        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #18 = Class              #20            // java/io/PrintStream</span><br><span class="line">  #19 = NameAndType        #21:#22        // println:(Ljava/lang/String;)V</span><br><span class="line">  #20 = Utf8               java/io/PrintStream</span><br><span class="line">  #21 = Utf8               println</span><br><span class="line">  #22 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               HELLO</span><br><span class="line">  #24 = Utf8               Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               ConstantValue</span><br><span class="line">  #26 = String             #27            // hello,</span><br><span class="line">  #27 = Utf8               hello,</span><br><span class="line">  #28 = Utf8               WORLD</span><br><span class="line">  #29 = String             #30            // world</span><br><span class="line">  #30 = Utf8               world</span><br><span class="line">  #31 = Utf8               Code</span><br><span class="line">  #32 = Utf8               LineNumberTable</span><br><span class="line">  #33 = Utf8               main</span><br><span class="line">  #34 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #35 = Utf8               SourceFile</span><br><span class="line">  #36 = Utf8               Test.java</span><br><span class="line">{</span><br><span class="line">  public Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #15                 // String hello, world</span><br><span class="line">         5: invokevirtual #17                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">}</span><br><span class="line">SourceFile: "Test.java"</span><br></pre></td></tr></tbody></table></figure><p>首先可以看到，在常量池中有这么两行代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#15 = String             #16            // hello, world</span><br><span class="line">#16 = Utf8               hello, world</span><br></pre></td></tr></tbody></table></figure><p>证明代码中 <code>HELLO + WORLD</code> 的值已经被编译器优化成了一个计算好的常量。在 <code>main</code> 方法的字节码中也可以看到</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=1, args_size=1</span><br><span class="line">       0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #15                 // String hello, world</span><br><span class="line">       5: invokevirtual #17                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br></pre></td></tr></tbody></table></figure><p>JVM 直接加载了”hello, world” 这个字符串，而不是调用了 <code>InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</code> 在运行时进行字符串拼接。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，使用字符串常量而不是直接写字符串值，除了让代码更可读更易于维护之外，我感觉最主要的优点就是针对字符串常量的拼接结果也会被放到常量池中，避免了在运行时反复创建新的字符串对象，造成性能浪费。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Java/">Java</category>
      
      
      <comments>https://www.boris1993.com/java-why-prefer-string-constants-over-literals.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在 Dev Container 里写 Hexo 博客</title>
      <link>https://www.boris1993.com/hexo-in-dev-container.html</link>
      <guid>https://www.boris1993.com/hexo-in-dev-container.html</guid>
      <pubDate>Wed, 25 Dec 2024 08:40:19 GMT</pubDate>
      
      <description>&lt;p&gt;我们都知道，Docker 和容器化技术让运维有了质的飞跃，从此我们不必再担心软件运行所需的繁杂环境，只需要拉取镜像并运行就可以一步到位部署好软件的运行环境。但是在开发过程中，我们仍然需要在本机安装各种依赖，一不小心又会把本机的环境搞乱掉，更不提不同版本的语言之间可能存在的冲突。因此，就出现了 Dev Container，顾名思义就是在容器环境中开发，这样我们在开发时也可以享受到统一且隔离的开发环境。&lt;/p&gt;
&lt;p&gt;正好我最近也在开始接触 Dev Container 并使用它给一个开源项目成功提交了代码，正好趁热打铁，把写博客的 Hexo 环境从本机挪到 Dev Container 中。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>我们都知道，Docker 和容器化技术让运维有了质的飞跃，从此我们不必再担心软件运行所需的繁杂环境，只需要拉取镜像并运行就可以一步到位部署好软件的运行环境。但是在开发过程中，我们仍然需要在本机安装各种依赖，一不小心又会把本机的环境搞乱掉，更不提不同版本的语言之间可能存在的冲突。因此，就出现了 Dev Container，顾名思义就是在容器环境中开发，这样我们在开发时也可以享受到统一且隔离的开发环境。</p><p>正好我最近也在开始接触 Dev Container 并使用它给一个开源项目成功提交了代码，正好趁热打铁，把写博客的 Hexo 环境从本机挪到 Dev Container 中。</p><span id="more"></span><h2 id="配置VSCode"><a href="#配置VSCode" class="headerlink" title="配置VSCode"></a>配置 VSCode</h2><p>我的计划是用 VSCode 来在容器中写博客，那么为了让 VSCode 支持 Dev Container，我们需要安装 <code>Dev Containers</code> 这个 VSCode 扩展。哦对，你还得有个 Docker，不论是本机还是在哪个服务器上。我这就用本机的 Docker 演示了。</p><p>装好扩展之后，就可以开始写 Dev Container 的配置了。因为不同项目对应的开发容器必然是不同的，所以 Dev Container 的配置会放到项目目录中。通常来说，Dev Container 相关的文件都会放到项目根目录下的<code>.devcontainer</code> 目录中，所以我们可以在项目目录下创建<code>.devcontainer/devcontainer.json</code>，并填入如下内容：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="comment">// Dev Container的名字</span></span><br><span class="line">    <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"blog"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 基础Docker镜像</span></span><br><span class="line">    <span class="attr">"image"</span><span class="punctuation">:</span> <span class="string">"node:lts-alpine"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 容器创建好之后要执行的命令</span></span><br><span class="line">    <span class="attr">"postCreateCommand"</span><span class="punctuation">:</span> <span class="string">"sh .devcontainer/post_create.sh"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 要转发到主机的端口</span></span><br><span class="line">    <span class="attr">"forwardPorts"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">4000</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>因为基础镜像 <code>node:lts-alpine</code> 中并不包含我们需要的 <code>git</code>、<code>gpg</code>、<code>hexo</code> 等环境，所以我们需要通过 <code>postCreateCommand</code> 指定容器在启动之后执行命令来安装这些依赖。<code>post_create.sh</code> 的内容如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">apk add --no-cache gpg git</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure><p>然后用快捷键 <code>ctrl-shift-p</code>（macOS 就是<code>⌘-shift-p</code>）唤出命令面板，选择 <code>Dev Containers: Rebuild and Reopen in Container</code> 来构建容器并进入容器开发。如果将来 <code>devcontainer.json</code> 或相关的配置发生变化，我们也可以在命令面板中选择 <code>Dev Containers: Rebuild Container</code> 来重建容器。</p><h2 id="编写容器的Dockerfile"><a href="#编写容器的Dockerfile" class="headerlink" title="编写容器的Dockerfile"></a>编写容器的 Dockerfile</h2><p>上面提到的通过 <code>postCreateCommand</code> 来安装依赖的方式，虽然可行，但是不优雅，毕竟每次创建容器都要重新安装一次，就很浪费。所以我们也可以给我们的 Dev Container 写一个 Dockerfile，这样就可以只初始化一次然后一直用下去了。</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:lts-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> devcontainer.metadata = <span class="string">'[{ \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">    "forwardPorts": [4000] \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">}]'</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache gpg git \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; npm install -g hexo-cli</span></span><br></pre></td></tr></tbody></table></figure><p>与部署用的 Dockerfile 不同，我们只需要写配置环境相关的命令就可以，不需要把工作空间拷贝进去，因为 Dev Container 会自动把这个目录 mount 到容器中。此外，在 Dockerfile 中还可以在 <code>devcontainer.metadata</code> 中提前指定好一些配置，以减少 <code>devcontainer.json</code> 的行数。</p><h2 id="配置GPG"><a href="#配置GPG" class="headerlink" title="配置GPG"></a>配置 GPG</h2><p>上面一步完成之后，Dev Container 的配置其实就完成了。但如果你像我一样为 Git 配置了 GPG 签名，同时又是在 macOS 下开发，那么你还需要对 GPG 做一些额外的配置。首先我们需要安装 <code>pinentry-mac</code>，然后编辑 <code>~/.gnupg/gpg-agent.conf</code> 文件，添加一行 <code>pinentry-program /usr/local/bin/pinentry-mac</code>。如果你曾经在 JetBrains IDE 中点过它的 <code>Configure GPG Agent to support own pinentry</code>，那么你就要把它添加的那行 <code>pinentry-program</code> 替换成这一条，否则我们在容器中提交更新的时候，GPG 会因为找不到 <code>/Users/username/.gnupg/pinentry-ide.sh</code> 而报错。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9kZXZjb250YWluZXJzL2NvbnRhaW5lcnM=">Developing inside a Container<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vcmVtb3RlL2FkdmFuY2VkY29udGFpbmVycy9kZXZlbG9wLXJlbW90ZS1ob3N0">Develop on a remote Docker host<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jbGF3cy50b3AvMjAyMi8xMi8wNi8lRTQlQkQlQkYlRTclOTQlQThEZXYtQ29udGFpbmVyJUU1JUJDJTgwJUU1JThGJTkxLw==">使用 Dev Container 开发 - Claws 小花园<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/playing/">瞎折腾</category>
      
      
      <category domain="https://www.boris1993.com/tags/Hexo/">Hexo</category>
      
      <category domain="https://www.boris1993.com/tags/Dev-Container/">Dev Container</category>
      
      
      <comments>https://www.boris1993.com/hexo-in-dev-container.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>记给 Ubuntu 的 LVM 卷扩容</title>
      <link>https://www.boris1993.com/expanding-ubuntu-lvm-partition.html</link>
      <guid>https://www.boris1993.com/expanding-ubuntu-lvm-partition.html</guid>
      <pubDate>Mon, 09 Dec 2024 13:12:39 GMT</pubDate>
      
      <description>&lt;p&gt;刚刚看到我虚拟机里面的 Ubuntu 报硬盘空间不足，看了下发现是在安装那会，自动分区就只用了一半的空间，遂着手扩容。在这里记录下操作过程备忘。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>刚刚看到我虚拟机里面的 Ubuntu 报硬盘空间不足，看了下发现是在安装那会，自动分区就只用了一半的空间，遂着手扩容。在这里记录下操作过程备忘。</p><span id="more"></span><p>看见硬盘空间不足，首先下意识 <code>df -h</code> 了一下，确实满了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs                              392M  3.5M  389M   1% /run</span><br><span class="line">efivarfs                            64K   41K   19K  70% /sys/firmware/efi/efivars</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv   48G   45G  314M 100% /</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs                              5.0M     0  5.0M   0% /run/lock</span><br><span class="line">/dev/sda2                          2.0G  266M  1.6G  15% /boot</span><br><span class="line">/dev/sda1                          1.1G  6.2M  1.1G   1% /boot/efi</span><br><span class="line">tmpfs                              392M   12K  392M   1% /run/user/1000</span><br></pre></td></tr></tbody></table></figure><p>但是 ESXi 里面显示这个虚拟机是有一个 100GB 的虚拟磁盘的，而 <code>df</code> 只显示出将近 50GB，那就是说要么有 50GB 没分，要么出别的问题了。首先排除最简单的情况，看看是不是有一半的硬盘没分进去。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL</span><br><span class="line">NAME                      FSTYPE        SIZE MOUNTPOINT                    LABEL</span><br><span class="line">loop0                                  10.1M /snap/canonical-livepatch/282 </span><br><span class="line">loop1                                  10.7M /snap/canonical-livepatch/286 </span><br><span class="line">loop2                                   104M /snap/core/16928              </span><br><span class="line">loop3                                 104.2M /snap/core/17200              </span><br><span class="line">loop4                                  55.7M /snap/core18/2829             </span><br><span class="line">loop5                                  55.4M /snap/core18/2846             </span><br><span class="line">loop6                                    64M /snap/core20/2379             </span><br><span class="line">loop7                                  63.7M /snap/core20/2434             </span><br><span class="line">loop9                                  73.9M /snap/core22/1663             </span><br><span class="line">loop10                                   71M /snap/prometheus/86           </span><br><span class="line">loop11                                 38.8M /snap/snapd/21759             </span><br><span class="line">loop12                                 44.3M /snap/snapd/23258             </span><br><span class="line">loop13                                 73.9M /snap/core22/1722             </span><br><span class="line">sda                                     100G                               </span><br><span class="line">├─sda1                    vfat            1G /boot/efi                     </span><br><span class="line">├─sda2                    ext4            2G /boot                         </span><br><span class="line">└─sda3                    LVM2_member  96.9G                               </span><br><span class="line">  └─ubuntu--vg-ubuntu--lv ext4         48.5G /                             </span><br><span class="line">sr0                                    1024M                               </span><br></pre></td></tr></tbody></table></figure><p>从上面的命令输出可以看到，<code>sda</code> 这块盘的 100GB 都认出来了，<code>sda3</code> 分区也确实分了 96.9GB，但是 <code>ubuntu--vg-ubuntu--lv</code> 这个卷只分配了 48.5GB，也就是整个 LVM 的一半。</p><p>查阅了教程，了解到可以用 <code>lvdisplay</code> 来检查 LVM 逻辑卷的空间，并可以用 <code>vgdisplay</code> 检查 volume group 的空间。遂分别执行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               ubuntu-vg</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  2</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;96.95 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              24818</span><br><span class="line">  Alloc PE / Size       12409 / 48.47 GiB</span><br><span class="line">  Free  PE / Size       12409 / 48.47 GiB</span><br><span class="line">  VG UUID               zaKkwe-YemQ-dRcV-mrhe-v181-0Ixc-0KVaVL</span><br><span class="line"></span><br><span class="line">$ sudo pvdisplay</span><br><span class="line">  --- Physical volume ---</span><br><span class="line">  PV Name               /dev/sda3</span><br><span class="line">  VG Name               ubuntu-vg</span><br><span class="line">  PV Size               &lt;96.95 GiB / not usable 3.00 MiB</span><br><span class="line">  Allocatable           yes </span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              24818</span><br><span class="line">  Free PE               12409</span><br><span class="line">  Allocated PE          12409</span><br><span class="line">  PV UUID               3FWWGz-CbIQ-BI9e-vMMd-p0Hu-eWUa-rZSeK8</span><br></pre></td></tr></tbody></table></figure><p>其实看不看都一样，已经知道根源是空间没全部分给这个卷。那么接下来就可以用 <code>lvextend</code> 来扩展指定的卷。我直接把所有的空余空间全都分配进去。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv </span><br><span class="line">  Size of logical volume ubuntu-vg/ubuntu-lv changed from 48.47 GiB (12409 extents) to &lt;96.95 GiB (24818 extents).</span><br><span class="line">  Logical volume ubuntu-vg/ubuntu-lv successfully resized.</span><br></pre></td></tr></tbody></table></figure><p>OK，卷扩容成功。但这时候实际的文件系统大小还没变，接下来需要用 <code>resize2fs</code> 扩容文件系统。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv </span><br><span class="line">resize2fs 1.47.0 (5-Feb-2023)</span><br><span class="line">Filesystem at /dev/mapper/ubuntu--vg-ubuntu--lv is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 7, new_desc_blocks = 13</span><br><span class="line">The filesystem on /dev/mapper/ubuntu--vg-ubuntu--lv is now 25413632 (4k) blocks long.</span><br></pre></td></tr></tbody></table></figure><p>完事，这时候再 <code>df -h</code> 就能看到根挂载点有将近 100GB 的空间了，扩容成功。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs                              392M  3.5M  389M   1% /run</span><br><span class="line">efivarfs                            64K   41K   19K  70% /sys/firmware/efi/efivars</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv   96G   45G   47G  50% /</span><br><span class="line">tmpfs                              2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs                              5.0M     0  5.0M   0% /run/lock</span><br><span class="line">/dev/sda2                          2.0G  266M  1.6G  15% /boot</span><br><span class="line">/dev/sda1                          1.1G  6.2M  1.1G   1% /boot/efi</span><br><span class="line">tmpfs                              392M   12K  392M   1% /run/user/1000</span><br></pre></td></tr></tbody></table></figure>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/tips/">小技巧</category>
      
      
      <category domain="https://www.boris1993.com/tags/Ubuntu/">Ubuntu</category>
      
      <category domain="https://www.boris1993.com/tags/LVM/">LVM</category>
      
      
      <comments>https://www.boris1993.com/expanding-ubuntu-lvm-partition.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>找到并处理 Docker 容器中的僵尸进程</title>
      <link>https://www.boris1993.com/finding-the-docker-container-of-a-zombie-process.html</link>
      <guid>https://www.boris1993.com/finding-the-docker-container-of-a-zombie-process.html</guid>
      <pubDate>Thu, 19 Sep 2024 16:14:14 GMT</pubDate>
      
      <description>&lt;p&gt;刚刚登录到我的服务器之后，看到 motd 提示有一个僵尸进程。本来处理僵尸进程很简单，杀掉它的父进程就行了。但是紧接着我发现这个进程是属于一个 Docker 容器的，因为我想要更优雅地处理掉它，就顺藤摸瓜找到了对应的容器并将其重启了。这里就记录下我的排查过程以供参考。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>刚刚登录到我的服务器之后，看到 motd 提示有一个僵尸进程。本来处理僵尸进程很简单，杀掉它的父进程就行了。但是紧接着我发现这个进程是属于一个 Docker 容器的，因为我想要更优雅地处理掉它，就顺藤摸瓜找到了对应的容器并将其重启了。这里就记录下我的排查过程以供参考。</p><span id="more"></span><p>因为僵尸进程在 <code>ps</code> 中的状态是 <code>Z</code>，所以我首先用 <code>ps aux | grep 'Z'</code> 找到这个僵尸进程的 PID。此外因为僵尸进程无法被直接杀死，只能杀掉其父进程来将其连根拔起，所以我还需要用 <code>pstree</code> 命令找到它的父进程 PID。</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps aux | grep <span class="string">'Z'</span></span></span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root      630024  0.0  0.0      0     0 ?        Z    00:55   0:00 [wget] &lt;defunct&gt;</span><br><span class="line">boris19+ 1180864  0.0  0.0   9696  2332 pts/0    S+   23:52   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox Z</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pstree -p -s 630024</span></span><br><span class="line">systemd(1)───containerd-shim(2642178)───node(2642199)───wget(630024)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps aux | grep 2642199</span></span><br><span class="line">boris19+ 1181119  0.0  0.0   9696  2288 pts/0    S+   23:53   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox 2642199</span><br><span class="line">root     2642199  0.0  0.8 21690116 35956 ?      Ssl  Sep07   3:21 node /app/dist/index.js</span><br></pre></td></tr></tbody></table></figure><p>这里可以看到，僵尸 <code>wget</code> 的父进程是 <code>node</code>，它的 PID 是 <code>2642199</code>，而 <code>node</code> 的父进程是 <code>containerd-shim</code>，也就是说这是一个 Docker 容器里的进程。我不确定这时候直接杀掉 <code>node</code> 能不能解决问题。但是老话说，来都来了，那不如继续挖下去。所以我开始尝试去找这个 <code>node</code> 是哪个容器运行的。</p><p>在这我稍微走了点弯路。一开始我是想通过搜索 <code>index.js</code> 关键词来找到容器，所以执行了下 <code>docker ps | grep index.js</code>，但是显然这行不通，不然也不会有这篇文了。在稍微网上冲浪之后，我学到了一个新命令 <code>systemd-cgls</code>，它可以递归展示出 cgroup 的内容。因为 Docker 用到的技术之一就是 cgroup，那么想必这就是突破口。在执行了它之后，它打出来了一大片东西，就像这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Control group /:</span><br><span class="line">-.slice</span><br><span class="line">├─user.slice </span><br><span class="line">│ └─user-1000.slice </span><br><span class="line">│   ├─user@1000.service </span><br><span class="line">│   │ └─init.scope </span><br><span class="line">│   │   ├─1180199 /lib/systemd/systemd --user</span><br><span class="line">│   │   └─1180200 (sd-pam)</span><br><span class="line">│   └─session-35890.scope </span><br><span class="line">│     ├─1180196 sshd: boris1993 [priv]</span><br><span class="line">│     ├─1180374 sshd: boris1993@pts/0</span><br><span class="line">│     ├─1180376 -zsh</span><br><span class="line">│     ├─1182022 systemd-cgls</span><br><span class="line">│     └─1182023 pager</span><br><span class="line">├─init.scope </span><br><span class="line">│ └─1 /sbin/init</span><br><span class="line">└─system.slice </span><br><span class="line">  ├─irqbalance.service </span><br><span class="line">  │ └─941 /usr/sbin/irqbalance --foreground</span><br><span class="line">  ├─docker-27434de50f56b4e096bf5f38bafc76f5c74622c758be1a3f2b9531a3549f4550.scope </span><br><span class="line">  │ └─3204915 /jellyfin/jellyfin</span><br><span class="line">  ├─docker-adf03dfa49427d2d651cd9101c3033adb00396ed45c390dd6bfda0b9b73eeae3.scope </span><br><span class="line">  │ └─3775 /watchtower</span><br><span class="line">  ├─open-vm-tools.service </span><br><span class="line">  │ └─812 /usr/bin/vmtoolsd</span><br><span class="line">  ├─containerd.service </span><br><span class="line">  │ ├─   1017 /usr/bin/containerd</span><br><span class="line">  │ ├─   2197 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 0e752935d348c3a41d66fe539a06268ee29c6975d1d8f0da41bd0c52b5adf337&gt;</span><br><span class="line">  │ ├─   2479 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 6f5e80ca8977314f3d3a9a47a93509438040a6908bde34cc578cdd3e8263c01a&gt;</span><br><span class="line">  │ ├─   2497 /usr/bin/containerd-shim-runc-v2 -namespace moby -id db3750e57842656c285e9641c4391df926721c94722bfb323789967c3a76d23f&gt;</span><br><span class="line">  │ ├─   2886 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 46520cd2506055c50ef361f50381a65b5077ee7b7d2607e26290d70f8b7292ba&gt;</span><br><span class="line">  │ ├─   3449 /usr/bin/containerd-shim-runc-v2 -namespace moby -id d45b7c4e806f1c0e681f317b548f795ff09eab53bc4d1a6bde05aa1fbb5064ee&gt;</span><br><span class="line">  │ ├─   3451 /usr/bin/containerd-shim-runc-v2 -namespace moby -id adf03dfa49427d2d651cd9101c3033adb00396ed45c390dd6bfda0b9b73eeae3&gt;</span><br><span class="line">  │ ├─   3554 /usr/bin/containerd-shim-runc-v2 -namespace moby -id fd2c2b6dfd77b23c0cdd59d50b33bbf70ab8046bf27ffeb595fbeadadf0a4a99&gt;</span><br><span class="line">  │ ├─   3837 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 6195cb19666ad7c58ce26a115ba4f2ea3b32185acb0c33ff80cbade860693fd0&gt;</span><br><span class="line">  │ ├─   3840 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 559a99dc9580a0ddea8501df71bbce3affb90cf3a91152b8274ae508c20e0f32&gt;</span><br><span class="line">  │ ├─   3901 /usr/bin/containerd-shim-runc-v2 -namespace moby -id b11d850487921e336178dd9267b0f281eea279d0135d1d5b853e63f945246baf&gt;</span><br><span class="line">  │ ├─   3964 /usr/bin/containerd-shim-runc-v2 -namespace moby -id f3f9400aeab6331d55166b1c80cd3e27dc2083664a6126cccf279340ab738364&gt;</span><br><span class="line">  │ ├─   5852 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 722497f0a71df4060151468e590b5a69a49332ba379b17c9504077b18bbd1dfc&gt;</span><br></pre></td></tr></tbody></table></figure><p>好在它的输出就像 <code>less</code> 一样，可以上下卷动，也可以用 <code>ed</code> 命令（就像 <code>vi</code> 一样），那么自然而然，我可以用 <code>/2642199</code> 来找到那一行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├─docker-ce8f490423d791ed5f6d1aa2b705d797fc3fd2ddc34816d47c228f6fb9a20c63.scope </span><br><span class="line">│ └─2642199 node /app/dist/index.js</span><br></pre></td></tr></tbody></table></figure><p>好，现在我们知道了容器的 ID 是 <code>ce8f490423d7</code>。虽然现在就可以重启它了，但是我的好奇心不允许我这么做，我想知道是哪个容器。所以</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps | grep ce8f490423d</span><br><span class="line">ce8f490423d7   boris1993/qinglong-bot:latest                                      "docker-entrypoint.s…"   12 days ago     Up 12 days (healthy)   0.0.0.0:3001-&gt;3000/tcp, :::3001-&gt;3000/tcp                                                                                     qinglong-bot</span><br></pre></td></tr></tbody></table></figure><p>啊好吧，竟然是我那个青龙的机器人。这里面我只用了 <code>wget</code> 来做容器的 liveness check，我不理解这么简单的操作怎么就能整出一个僵尸进程来。算了，以后有空再分析吧。重启容器，杀掉僵尸，睡觉。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker restart ce8f490423d</span><br><span class="line">ce8f490423d</span><br></pre></td></tr></tbody></table></figure><p>这时候再用 <code>ps aux | grep 'Z'</code> 就看不到有僵尸进程，也就说明处置成功了。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/tips/">小技巧</category>
      
      
      <category domain="https://www.boris1993.com/tags/Docker/">Docker</category>
      
      <category domain="https://www.boris1993.com/tags/Zombie-Process/">Zombie Process</category>
      
      <category domain="https://www.boris1993.com/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/">僵尸进程</category>
      
      
      <comments>https://www.boris1993.com/finding-the-docker-container-of-a-zombie-process.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在 TypeScript 的 catch 代码块中获取错误信息</title>
      <link>https://www.boris1993.com/translation-get-a-catch-block-error-message-with-typescript.html</link>
      <guid>https://www.boris1993.com/translation-get-a-catch-block-error-message-with-typescript.html</guid>
      <pubDate>Fri, 21 Jun 2024 14:53:25 GMT</pubDate>
      
      <description>&lt;p&gt;最近在试着用 TypeScript 写点东西，在用 &lt;code&gt;catch (error) {}&lt;/code&gt; 代码块处理异常的时候，看到了一个很难理解的错误 &lt;code&gt;TS18046: error is of type unknown&lt;/code&gt;。网上一顿冲浪之后，看到了 Kent C. Dodds 的一篇博客&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9rZW50Y2RvZGRzLmNvbS9ibG9nL2dldC1hLWNhdGNoLWJsb2NrLWVycm9yLW1lc3NhZ2Utd2l0aC10eXBlc2NyaXB0&quot;&gt; Get a catch block error message with TypeScript&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;。我跟着文章的内容成功解决了这个问题，并且解答了我的疑惑，所以想要翻译出来帮助到更多的人。&lt;/p&gt;
&lt;p&gt;以下内容除特别注明外，皆翻译自原文。我亦不对内容做任何的担保，并不对任何可能产生的后果（包括但不限于文件丢失或功能异常）负责。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近在试着用 TypeScript 写点东西，在用 <code>catch (error) {}</code> 代码块处理异常的时候，看到了一个很难理解的错误 <code>TS18046: error is of type unknown</code>。网上一顿冲浪之后，看到了 Kent C. Dodds 的一篇博客<span class="exturl" data-url="aHR0cHM6Ly9rZW50Y2RvZGRzLmNvbS9ibG9nL2dldC1hLWNhdGNoLWJsb2NrLWVycm9yLW1lc3NhZ2Utd2l0aC10eXBlc2NyaXB0"> Get a catch block error message with TypeScript<i class="fa fa-external-link-alt"></i></span>。我跟着文章的内容成功解决了这个问题，并且解答了我的疑惑，所以想要翻译出来帮助到更多的人。</p><p>以下内容除特别注明外，皆翻译自原文。我亦不对内容做任何的担保，并不对任何可能产生的后果（包括但不限于文件丢失或功能异常）负责。</p><span id="more"></span><hr><p>好吧，咱们看看这个代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reportError</span> = (<span class="params">{ message }</span>) =&gt; {</span><br><span class="line">    <span class="comment">// 把错误信息发给我们的日志服务...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'Oh no!'</span>)</span><br><span class="line">} <span class="keyword">catch</span> (error) {</span><br><span class="line">    <span class="comment">// 我们会让代码继续执行，但先把错误报告出去</span></span><br><span class="line">    <span class="title function_">reportError</span>({ <span class="attr">message</span>: error.<span class="property">message</span> })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这么写应该足够好了吧？嘛，毕竟这是 JavaScript。要是换成 TypeScript 的话：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reportError</span> = (<span class="params">{ message }: { message: <span class="built_in">string</span> }</span>) =&gt; {</span><br><span class="line">    <span class="comment">// 把错误信息发给我们的日志服务...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'Oh no!'</span>)</span><br><span class="line">} <span class="keyword">catch</span> (error) {</span><br><span class="line">    <span class="comment">// 我们会让代码继续执行，但先把错误报告出去</span></span><br><span class="line">    <span class="title function_">reportError</span>({ <span class="attr">message</span>: error.<span class="property">message</span> })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这时候 <code>reportError</code> 的 <code>error.message</code> 这部分就要报错了。因为（就在最近）TypeScript 把 <code>error</code> 的类型定义成了 <code>unknown</code>。这倒也是事实，因为它确实没法保证抛出的错误的类型。哦对，这也是你不能用 promise 的泛型 (<code>Promise&lt;ResolvedValue, NopeYouCantProvideARejectedValueType&gt;</code>)，来给 promise reject 的<code>.catch(error =&gt; {})</code> 指定类型的原因。而且，被抛出来的东西可能都不是一个 error，它可以是任何东西：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">'啥玩意？！'</span> <span class="comment">// 译者注：原文为 'What the!?'，请尝试用东北口音理解</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">throw</span> { <span class="attr">wut</span>: <span class="string">'is this'</span> } <span class="comment">// 译者注：wut可以用来表达“傻眼”语境下的what，类似“什么鬼”</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> {})</span><br><span class="line"><span class="keyword">throw</span> <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><p>说真的，你可以想 throw 啥就 throw 啥，啥东西都行。那，要解决上面提到的错误信息好像挺简单对吧，我们在 <code>catch</code> 中声明代码只会抛出 error 不就行了？</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'Oh no!'</span>)</span><br><span class="line">} <span class="keyword">catch</span> (<span class="attr">error</span>: <span class="title class_">Error</span>) {</span><br><span class="line">    <span class="comment">// 我们会让代码继续执行，但先把错误报告出去</span></span><br><span class="line">    <span class="title function_">reportError</span>({ <span class="attr">message</span>: error.<span class="property">message</span> })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>想的美！现在你会得到这么一条 TypeScript 的编译错误：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Catch clause variable type annotation must be 'any' or 'unknown' if specified. ts(1196)</span><br></pre></td></tr></tbody></table></figure><p>报这个错的原因是，尽管看起来在我们的代码里不可能会抛出来其他的东西，但 JavaScript 就这么逗，一个第三方库完全有可能做点什么奇怪的事，比如给 Error 的构造函数来个猴子补丁（译者注：monkey-patching），让它抛出点不一样的东西：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Error</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Flowers'</span></span><br><span class="line">} <span class="keyword">as</span> <span class="built_in">any</span></span><br></pre></td></tr></tbody></table></figure><p>那咱们开发者该怎么办？我们只能尽力，比如这样：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'Oh no!'</span>)</span><br><span class="line">} <span class="keyword">catch</span> (error) {</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">'Unknown Error'</span></span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">Error</span>) message = error.<span class="property">message</span></span><br><span class="line">    <span class="comment">// 我们会让代码继续执行，但先把错误报告出去</span></span><br><span class="line">    <span class="title function_">reportError</span>({ message })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>妥了这不！现在 TypeScript 也不跟我们嚷嚷有问题了，而且万一这个 error 是什么奇怪的东西，我们也用了合适的办法来处理它了。而且这段代码我们还能继续优化成这样：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'Oh no!'</span>)</span><br><span class="line">} <span class="keyword">catch</span> (error) {</span><br><span class="line">    <span class="keyword">let</span> message</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">Error</span>) message = error.<span class="property">message</span></span><br><span class="line">    <span class="keyword">else</span> message = <span class="title class_">String</span>(error)</span><br><span class="line">    <span class="comment">// 我们会让代码继续执行，但先把错误报告出去</span></span><br><span class="line">    <span class="title function_">reportError</span>({ message })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么现在，如果这个 error 不是一个 <code>Error</code> 对象，那么我们就直接把它变成一个字符串并祈祷这个错误信息能有点用。</p><p>然后，我们还能把这段代码抽出来做成一个工具方法来给所有的 catch 块用：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getErrorMessage</span>(<span class="params">error: <span class="built_in">unknown</span></span>) {</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">Error</span>) <span class="keyword">return</span> error.<span class="property">message</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reportError</span> = (<span class="params">{ message }: { message: <span class="built_in">string</span> }</span>) =&gt; {</span><br><span class="line">    <span class="comment">// 把错误信息发给我们的日志服务...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'Oh no!'</span>)</span><br><span class="line">} <span class="keyword">catch</span> (error) {</span><br><span class="line">    <span class="comment">// 我们会让代码继续执行，但先把错误报告出去</span></span><br><span class="line">    <span class="title function_">reportError</span>({ <span class="attr">message</span>: <span class="title function_">getErrorMessage</span>(error) })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个写法在我的项目里面特别好用。希望也能帮助到你！</p><p>更新：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25waXJvdHRl">Nicolas<i class="fa fa-external-link-alt"></i></span>针对 error 对象并不真的是 error 的情况提了一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlbnRjZG9kZHMva2VudGNkb2Rkcy5jb20vaXNzdWVzLzIwNg==">很好的建议<i class="fa fa-external-link-alt"></i></span>。此外<span class="exturl" data-url="aHR0cHM6Ly9kaXNjb3JkLmNvbS91c2Vycy84MDQ3OTU2NTIyNTIxMDY3NjI="> Jesse<i class="fa fa-external-link-alt"></i></span>也提出了<span class="exturl" data-url="aHR0cHM6Ly9kaXNjb3JkLmNvbS9jaGFubmVscy83MTUyMjA3MzA2MDU3MzE5MzEvNzE1MjI3NzM5NzQ5MDg5MjgxLzkwMzY0OTMxMzIyODQ4MDUzMg==">一个建议<i class="fa fa-external-link-alt"></i></span>，在可能的情况下把 error 对象也转换成字符串。把这些结合起来，我们就得到了这样的一份代码：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ErrorWithMessage</span> = {</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isErrorWithMessage</span>(<span class="params">error: <span class="built_in">unknown</span></span>): error is <span class="title class_">ErrorWithMessage</span> {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="keyword">typeof</span> error === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">        error !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="string">'message'</span> <span class="keyword">in</span> error &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> (error <span class="keyword">as</span> <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">unknown</span>&gt;).<span class="property">message</span> === <span class="string">'string'</span></span><br><span class="line">    )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toErrorWithMessage</span>(<span class="params">maybeError: <span class="built_in">unknown</span></span>): <span class="title class_">ErrorWithMessage</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isErrorWithMessage</span>(maybeError)) <span class="keyword">return</span> maybeError</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(maybeError))</span><br><span class="line">    } <span class="keyword">catch</span> {</span><br><span class="line">        <span class="comment">// fallback in case there's an error stringifying the maybeError</span></span><br><span class="line">        <span class="comment">// like with circular references for example.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="title class_">String</span>(maybeError))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getErrorMessage</span>(<span class="params">error: <span class="built_in">unknown</span></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toErrorWithMessage</span>(error).<span class="property">message</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简直太好使了！</p><p><strong>结论</strong></p><p>我觉得关键在于，尽管 TypeScript 有一些奇怪的地方，但也绝对不要因为你觉得这不可能就忽略 TypeScript 抛出的编译错误或警告。大多数情况下，意外是非常有可能发生的，而 TypeScript 很好的强制你去处理这些 “不太可能发生” 的情况…… 然后你也很有可能会发现，这些情况并没有你想的那么少见。</p><hr><p>译者的碎碎念：作为一个 TypeScript 纯新手的我，最后这段代码给我看傻了。Java 里面非常常见的 <code>try {...} catch (Exception e) {...}</code> 在 TypeScript 里面竟然能玩这么花……</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/translations/">翻译</category>
      
      
      <category domain="https://www.boris1993.com/tags/TypeScript/">TypeScript</category>
      
      
      <comments>https://www.boris1993.com/translation-get-a-catch-block-error-message-with-typescript.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>用裸 git 仓库管理点文件的最佳方式</title>
      <link>https://www.boris1993.com/translation-dotfiles-best-way-to-store-in-a-bare-git-repository.html</link>
      <guid>https://www.boris1993.com/translation-dotfiles-best-way-to-store-in-a-bare-git-repository.html</guid>
      <pubDate>Thu, 09 May 2024 13:13:41 GMT</pubDate>
      
      <description>&lt;p&gt;前些天在 Atlassian 的文档中看到一篇关于管理点文件（即&lt;code&gt;.bashrc&lt;/code&gt; 之类以点开头的文件）的文章&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWxzL2RvdGZpbGVz&quot;&gt;《Dotfiles: Best way to store in a bare git repository》&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;，感觉很有参考价值，遂决定翻译出来，希望能帮到更多的人。&lt;/p&gt;
&lt;p&gt;以下内容除特别注明外，皆翻译自原文。我亦不对内容做任何的担保，并不对任何可能产生的后果（包括但不限于文件丢失）负责。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>前些天在 Atlassian 的文档中看到一篇关于管理点文件（即<code>.bashrc</code> 之类以点开头的文件）的文章<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWxzL2RvdGZpbGVz">《Dotfiles: Best way to store in a bare git repository》<i class="fa fa-external-link-alt"></i></span>，感觉很有参考价值，遂决定翻译出来，希望能帮到更多的人。</p><p>以下内容除特别注明外，皆翻译自原文。我亦不对内容做任何的担保，并不对任何可能产生的后果（包括但不限于文件丢失）负责。</p><span id="more"></span><hr><p>免责声明：标题有些夸大其词了，而且针对这个问题也有其他好用的解决方案。但我确实觉得这也是一个优雅的技巧。</p><p>最近我在 Hacker News 中看到一篇<span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTExMDcwNzk3">帖子<i class="fa fa-external-link-alt"></i></span>，是讨论人们怎么管理他们的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG90LWZpbGU=">点文件<i class="fa fa-external-link-alt"></i></span>的。在这篇帖子中，用户 <code>StreakyCobra</code> 分享了一个他的<span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTExMDcxNzU0">很优雅的配置<i class="fa fa-external-link-alt"></i></span>，而且我觉得非常的靠谱。正巧我也在开始用同样的技巧来管理我的系统。这个技巧也只有一个前置条件：你安装了<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQ="> Git<i class="fa fa-external-link-alt"></i></span>。</p><p>按他的说法，这个技巧：</p><blockquote><p>不需要别的工具，不需要创建符号链接，文件都被版本控制系统跟踪，你可以用不同的分支来管理不同的系统，在全新的系统中你也可以轻松复用你的配置。</p></blockquote><p>这个技巧包括两个部分：用一个单独的文件夹（如 <code>$HOME/.cfg</code> 或 <code>$HOME/.myconfig</code>）作为<span class="exturl" data-url="aHR0cDovL3d3dy5zYWludHNqZC5jb20vMjAxMS8wMS93aGF0LWlzLWEtYmFyZS1naXQtcmVwb3NpdG9yeS8=">裸 Git 仓库<i class="fa fa-external-link-alt"></i></span>；和一个专门用来操作这个仓库的命令别名（译者注：<code>alias</code>）。</p><h2 id="从零开始"><a href="#从零开始" class="headerlink" title="从零开始"></a>从零开始</h2><p>如果你还没有用一个 Git 仓库来跟踪你的配置文件，那么你可以从下面这几个简单的命令开始，一步步实现这个技巧。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init --bare <span class="variable">$HOME</span>/.cfg</span><br><span class="line"><span class="built_in">alias</span> config=<span class="string">'/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'</span></span><br><span class="line">config config --<span class="built_in">local</span> status.showUntrackedFiles no</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"alias config='/usr/bin/git --git-dir=<span class="variable">$HOME</span>/.cfg/ --work-tree=<span class="variable">$HOME</span>'"</span> &gt;&gt; <span class="variable">$HOME</span>/.bashrc</span><br></pre></td></tr></tbody></table></figure><ul><li>第一条命令会创建一个用来跟踪文件的裸 Git 仓库 <code>~/.cfg</code>（配置仓库）</li><li>接下来创建一个命令别名 <code>config</code>，在我们要操作配置仓库时就会用这个命令，而不是 <code>git</code> 命令</li><li>设定一个仅对配置仓库生效的设定 —— 不显示未追踪的文件，这样在我们执行 <code>config status</code> 等命令的时候，我们不想跟踪的文件就不会以 <code>untracked</code> 状态被显示出来</li><li>此外我们可以把这个别名的声明添加到<code>.bashrc</code> 里面，方便以后使用</li></ul><p>我把上面这些命令集合成了一个<span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL3NuaXBwZXRzL25pY29sYXBhb2x1Y2NpL2VyZ1g5">代码片段<i class="fa fa-external-link-alt"></i></span>放到了 Bitbucket 上，并给它做了一个短链接，所以你可以用下面的命令一键执行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lks http://bit.do/cfg-init | /bin/bash</span><br></pre></td></tr></tbody></table></figure><p>（译者注：在执行来自网络的代码之前，一定记得先看看内容。闭著眼执行远程命令是一件很危险的事，因为你不知道这个链接的内容是否还正确，比如曾经课本上本来指向《历朝历代咏武侯诗词大全》的网址，在域名过期之后被黄网搞去了……）</p><p>在配置完成后，<code>$HOME</code> 目录下的文件就可以用刚刚创建的 <code>config</code> 别名来进行版本控制了，比如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config status</span><br><span class="line">config add .vimrc</span><br><span class="line">config commit -m <span class="string">"Add .vimrc"</span></span><br><span class="line">config add .bashrc</span><br><span class="line">config commit -m <span class="string">"Add .bashrc"</span></span><br><span class="line">config push</span><br></pre></td></tr></tbody></table></figure><h2 id="把这些点文件安装到新系统（或迁移到本系统）"><a href="#把这些点文件安装到新系统（或迁移到本系统）" class="headerlink" title="把这些点文件安装到新系统（或迁移到本系统）"></a>把这些点文件安装到新系统（或迁移到本系统）</h2><p>如果你已经用 Git 仓库管理你的配置或者点文件，那你可以跟着下面的步骤，来把这个配置迁移到新的系统：</p><ul><li>首先确认你已经配置好了命令别名 </li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> config=<span class="string">'/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在克隆你的配置仓库前，记得让 git 忽略它，以避免各种奇怪的问题 </li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">".cfg"</span> &gt;&gt; .gitignore</span><br></pre></td></tr></tbody></table></figure><ul><li>然后你就可以把你的点文件克隆到一个存在于 “点目录” 的裸仓库中 </li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare &lt;git-repo-url&gt; <span class="variable">$HOME</span>/.cfg</span><br></pre></td></tr></tbody></table></figure><ul><li>在当前 shell 会话中定义好 <code>config</code> 这个别名 </li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> config=<span class="string">'/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>从裸仓库中把配置 checkout 到 <code>$HOME</code></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config checkout</span><br></pre></td></tr></tbody></table></figure><p>这一步可能会报这样的错误</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: The following untracked working tree files would be overwritten by checkout:</span><br><span class="line">    .bashrc</span><br><span class="line">    .gitignore</span><br><span class="line">Please move or remove them before you can switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></tbody></table></figure><p>这是因为你的 <code>$HOME</code> 目录可能已经有这些文件，而 checkout 操作可能会让它们被覆盖。解决方法也很简单：这些文件要是有用，那就备份出来，没用那就删了。你可以用我这个比较粗糙的命令，来一键把有冲突的文件移动到备份目录：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p .config-backup &amp;&amp; \</span><br><span class="line">config checkout 2&gt;&amp;1 | egrep <span class="string">"\s+\."</span> | awk {<span class="string">'print $1'</span>} | \</span><br><span class="line">xargs -I{} <span class="built_in">mv</span> {} .config-backup/{}</span><br></pre></td></tr></tbody></table></figure><p>然后重新执行 <code>config checkout</code></p><ul><li>为配置仓库设定不显示未跟踪的文件 </li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config config --<span class="built_in">local</span> status.showUntrackedFiles no</span><br></pre></td></tr></tbody></table></figure><ul><li>到此就完成了，接下来你就可以和之前一样用 <code>config</code> 命令来管理你的点文件了。</li></ul><p>同样，我也提供了一个一键脚本，把它作为代码片段放在了 Bitbucket 上。你可以用这个命令来执行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lks http://bit.do/cfg-install | /bin/bash</span><br></pre></td></tr></tbody></table></figure><p>为了文章的完整起见，这是我最终得到的脚本（已经在很多个全新启动的 Alpine Linux 容器中做过测试）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare https://bitbucket.org/durdn/cfg.git <span class="variable">$HOME</span>/.cfg</span><br><span class="line"><span class="keyword">function</span> config {</span><br><span class="line">   /usr/bin/git --git-dir=<span class="variable">$HOME</span>/.cfg/ --work-tree=<span class="variable">$HOME</span> <span class="variable">$@</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">mkdir</span> -p .config-backup</span><br><span class="line">config checkout</span><br><span class="line"><span class="keyword">if</span> [ $? = 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Checked out config."</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Backing up pre-existing dot files."</span>;</span><br><span class="line">  config checkout 2&gt;&amp;1 | egrep <span class="string">"\s+\."</span> | awk {<span class="string">'print $1'</span>} | xargs -I{} <span class="built_in">mv</span> {} .config-backup/{}</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line">config checkout</span><br><span class="line">config config status.showUntrackedFiles no</span><br></pre></td></tr></tbody></table></figure><p>（译者注：原文的 <code>if-else</code> 部分似乎缩进有问题，我调整了下格式，未对脚本内容做改动）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我希望你们能觉得这个管理点文件的小技巧能产生帮助。如果你有兴趣的话，可以到<span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2R1cmRuL2NmZy5naXQ=">这里看我的点文件<i class="fa fa-external-link-alt"></i></span>。另外别忘了关注<span class="exturl" data-url="aHR0cHM6Ly93d3cudHdpdHRlci5jb20vZHVyZG4="> @durdn<i class="fa fa-external-link-alt"></i></span>或我那炫酷的小组<span class="exturl" data-url="aHR0cHM6Ly93d3cudHdpdHRlci5jb20vYXRsYXNzaWFuZGV2"> @atlassiandev<i class="fa fa-external-link-alt"></i></span>。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/translations/">翻译</category>
      
      
      <category domain="https://www.boris1993.com/tags/git/">git</category>
      
      <category domain="https://www.boris1993.com/tags/dotfiles/">dotfiles</category>
      
      <category domain="https://www.boris1993.com/tags/%E7%82%B9%E6%96%87%E4%BB%B6/">点文件</category>
      
      
      <comments>https://www.boris1993.com/translation-dotfiles-best-way-to-store-in-a-bare-git-repository.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用 Homebrew Bundle 管理电脑上安装的软件</title>
      <link>https://www.boris1993.com/macos-manage-softwares-with-homebrew-bundle.html</link>
      <guid>https://www.boris1993.com/macos-manage-softwares-with-homebrew-bundle.html</guid>
      <pubDate>Mon, 18 Mar 2024 14:30:37 GMT</pubDate>
      
      <description>&lt;p&gt;今天看到&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly94LmNvbS92aWtpbmdtdXRlL3N0YXR1cy8xNzY5MTc0MzM3NzU0NjczMzI0&quot;&gt;一篇推文&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;说 Homebrew 也支持类似 &lt;code&gt;package.json&lt;/code&gt; 的方式来管理电脑上安装的应用，感觉这玩意挺实用的，像我上回换电脑还是照着 &lt;code&gt;brew list&lt;/code&gt; 的输出再一个个装，有了它的话就可以一键安装了。而且除了 Homebrew 之外，它还可以导出通过 App Store 安装的软件和 VS Code 插件。那么，就小小折腾一下。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天看到<span class="exturl" data-url="aHR0cHM6Ly94LmNvbS92aWtpbmdtdXRlL3N0YXR1cy8xNzY5MTc0MzM3NzU0NjczMzI0">一篇推文<i class="fa fa-external-link-alt"></i></span>说 Homebrew 也支持类似 <code>package.json</code> 的方式来管理电脑上安装的应用，感觉这玩意挺实用的，像我上回换电脑还是照着 <code>brew list</code> 的输出再一个个装，有了它的话就可以一键安装了。而且除了 Homebrew 之外，它还可以导出通过 App Store 安装的软件和 VS Code 插件。那么，就小小折腾一下。</p><span id="more"></span><p>首次运行 <code>brew bundle</code> 的时候它就会自动安装了。如果要导出 App Store 安装的程序的话，那么还需要安装 <code>mas</code> 这个 Formula。</p><p>然后就可以执行 <code>brew bundle dump</code>，它会在当前目录下生成一个 <code>Brewfile</code> 文件，里面就是你电脑上目前装的软件，内容就像这样：</p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 各个Homebrew仓库</span></span><br><span class="line">tap <span class="string">"beeftornado/rmtree"</span></span><br><span class="line">tap <span class="string">"bell-sw/liberica"</span></span><br><span class="line">tap <span class="string">"homebrew/autoupdate"</span></span><br><span class="line">tap <span class="string">"homebrew/bundle"</span></span><br><span class="line">tap <span class="string">"homebrew/cask-fonts"</span></span><br><span class="line">tap <span class="string">"homebrew/cask-versions"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Homebrew安装的Formula</span></span><br><span class="line">brew <span class="string">"cloudflared"</span></span><br><span class="line">brew <span class="string">"curl"</span></span><br><span class="line">brew <span class="string">"git"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Homebrew安装的Cask</span></span><br><span class="line">cask <span class="string">"1password"</span></span><br><span class="line">cask <span class="string">"alfred"</span></span><br><span class="line">cask <span class="string">"altserver"</span></span><br><span class="line">cask <span class="string">"arc"</span></span><br><span class="line">cask <span class="string">"bartender"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过App Store安装的软件</span></span><br><span class="line">mas <span class="string">"DaVinci Resolve"</span>, <span class="symbol">id:</span> <span class="number">571213070</span></span><br><span class="line">mas <span class="string">"Eul"</span>, <span class="symbol">id:</span> <span class="number">1541991958</span></span><br><span class="line">mas <span class="string">"Termius"</span>, <span class="symbol">id:</span> <span class="number">1176074088</span></span><br><span class="line">mas <span class="string">"WireGuard"</span>, <span class="symbol">id:</span> <span class="number">1451685025</span></span><br><span class="line">mas <span class="string">"Xnip"</span>, <span class="symbol">id:</span> <span class="number">1221250572</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VS Code插件</span></span><br><span class="line">vscode <span class="string">"ms-python.debugpy"</span></span><br><span class="line">vscode <span class="string">"ms-python.python"</span></span><br><span class="line">vscode <span class="string">"redhat.vscode-yaml"</span></span><br></pre></td></tr></tbody></table></figure><p>我的这个 Brewfile 算是简单的，它还支持配置安装参数等，具体可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hvbWVicmV3L2hvbWVicmV3LWJ1bmRsZS8/dGFiPXJlYWRtZS1vdi1maWxlI3VzYWdl"> Homebrew Bundle 的实例<i class="fa fa-external-link-alt"></i></span>。</p><p>如果在导出的时候在当前目录已经存在一个 <code>Brewfile</code>，那么它会报错说文件已存在。这时候可以加 <code>--force</code> 参数强制导出，要在 cron 里定时导出的话这个参数会很有用。此外如果你想要每个软件的简介，那么还可以加上 <code>--describe</code> 参数，出来的 <code>Brewfile</code> 就会是这样的：</p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mac App Store command-line interface</span></span><br><span class="line">brew <span class="string">"mas"</span></span><br><span class="line"><span class="comment"># Java-based project management</span></span><br><span class="line">brew <span class="string">"maven"</span></span><br><span class="line"><span class="comment"># Menu bar icon organiser</span></span><br><span class="line">cask <span class="string">"bartender"</span></span><br></pre></td></tr></tbody></table></figure><p>不过 <code>--describe</code> 参数只对 <code>brew</code> 和 <code>cask</code> 条目生效，<code>tap</code>、<code>mas</code> 和 <code>vscode</code> 条目都是没有描述的。</p><p>我试用后发现，似乎 <code>mas</code> 这部分会把你已经卸载的软件也列出来，而第二次再 dump 的时候又另外发现了一个之前没列出来而已经通过 App Store 安装的程序，所以这部分可能需要在导出之后自己再人工校验一下。</p><p>要按照 <code>Brewfile</code> 安装软件的话，只需要 cd 到 <code>Brewfile</code> 所在位置然后执行 <code>brew bundle</code> 就会自动开始安装。</p><p>如果要把不在 <code>Brewfile</code> 中的软件删除，那么可以运行 <code>brew bundle cleanup</code> 命令。</p><p>此外，运行 <code>brew bundle check</code> 可以检查哪些软件在 <code>Brewfile</code> 里列出来了，但是还没安装。但是我用刚刚导出的 <code>Brewfile</code> 检查却报了 <code>brew bundle can't satisfy your Brewfile's dependencies.Satisfy missing dependencies with ``brew bundle install``.</code> 这样的消息，我就有点怀疑这个检查到底准不准……</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/playing/">瞎折腾</category>
      
      
      <category domain="https://www.boris1993.com/tags/macOS/">macOS</category>
      
      <category domain="https://www.boris1993.com/tags/Homebrew/">Homebrew</category>
      
      
      <comments>https://www.boris1993.com/macos-manage-softwares-with-homebrew-bundle.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>理解 Java 中的抽象队列同步器（AQS）</title>
      <link>https://www.boris1993.com/java-understand-aqs.html</link>
      <guid>https://www.boris1993.com/java-understand-aqs.html</guid>
      <pubDate>Wed, 17 Jan 2024 06:46:53 GMT</pubDate>
      
      <description>&lt;p&gt;最近项目里用到了些 Lock，爬了些文了解到它们是基于 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;（即 &lt;code&gt;AQS&lt;/code&gt;）实现的。那么，不如趁热打铁，看看里面是怎么工作的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近项目里用到了些 Lock，爬了些文了解到它们是基于 <code>AbstractQueuedSynchronizer</code>（即 <code>AQS</code>）实现的。那么，不如趁热打铁，看看里面是怎么工作的。</p><span id="more"></span><h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是 AQS</h2><p><code>AbstractQueuedSynchronizer</code>，抽象队列同步器，是很多同步器（如 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>）等都是基于它实现的。</p><p>在 AQS 内部，它维护了一个 FIFO 队列，和一个 <code>volatile</code> 类型的变量 <code>state</code>。FIFO 队列用来实现多线程的排队工作，线程加锁失败时，这个线程就会被封装成一个 <code>Node</code> 节点放到队尾，然后当锁被释放后，队列头部的线程就会被唤醒并让它重新尝试获取锁；<code>state</code> 变量用来记录锁的状态，如 <code>Semaphore</code> 的 <code>permit</code> 就是存在 <code>state</code> 里面的。</p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>上面说到，AQS 使用一个 <code>volatile</code> 的 <code>int</code> 变量 <code>state</code> 来管理锁的状态，<code>state</code> 为 0 时说明锁被释放，反之锁被持有。</p><p>AQS 提供了三个方法来同步锁的状态：<code>getState()</code>，<code>setState(int newState)</code> 和 <code>compareAndSetState(int expect, int update)</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a {<span class="doctag">@code</span> volatile} read.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a {<span class="doctag">@code</span> volatile} write.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> {</span><br><span class="line">    state = newState;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a {<span class="doctag">@code</span> volatile} read</span></span><br><span class="line"><span class="comment"> * and write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> {</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetInt(<span class="built_in">this</span>, STATE, expect, update);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>查看 <code>setState</code> 方法的引用，不难发现像 <code>CountDownLatch</code> 和 <code>Semaphore</code> 这些熟悉的身影。</p><p><img data-src="https://blog-static.boris1993.com/java-understand-aqs/usage-of-set-state.png"></p><h2 id="FIFO队列-线程排队等待锁的地方"><a href="#FIFO队列-线程排队等待锁的地方" class="headerlink" title="FIFO队列 - 线程排队等待锁的地方"></a>FIFO 队列 - 线程排队等待锁的地方</h2><p>在 AQS 内部，未能成功获取锁的线程都会被包装成一个 <code>Node</code> 节点，然后放到 FIFO 队列尾部让它等待。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node status bits, also used as argument and return values</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITING</span>   <span class="operator">=</span> <span class="number">1</span>;          <span class="comment">// must be 1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">0x80000000</span>; <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COND</span>      <span class="operator">=</span> <span class="number">2</span>;          <span class="comment">// in a condition wait</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;       <span class="comment">// initially attached via casTail</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;       <span class="comment">// visibly nonnull when signallable</span></span><br><span class="line">    Thread waiter;            <span class="comment">// visibly nonnull when enqueued</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> status;      <span class="comment">// written by owner, atomic bit ops by others</span></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of the wait queue, lazily initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of the wait queue. After initialization, modified only via casTail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueues the node unless null. (Currently used only for</span></span><br><span class="line"><span class="comment"> * ConditionNodes; other cases are interleaved with acquires.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            node.setPrevRelaxed(t);        <span class="comment">// avoid unnecessary fence</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)                 <span class="comment">// initialize</span></span><br><span class="line">                tryInitializeHead();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">if</span> (t.status &lt; <span class="number">0</span>)          <span class="comment">// wake up to clean link</span></span><br><span class="line">                    LockSupport.unpark(node.waiter);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code> 就是 AQS 的一个实现，从它的源码就能很容易看出来，它内部就是通过 AQS 的 <code>state</code> 来管理 <code>permits</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable {</span><br><span class="line">    <span class="comment">/** All mechanics via AbstractQueuedSynchronizer subclass */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synchronization implementation for semaphore.  Uses AQS state</span></span><br><span class="line"><span class="comment">     * to represent permits. Subclassed into fair and nonfair</span></span><br><span class="line"><span class="comment">     * versions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> {</span><br><span class="line">        Sync(<span class="type">int</span> <span class="keyword">permits</span>) {</span><br><span class="line">            setState(<span class="keyword">permits</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPermits</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">reducePermits</span><span class="params">(<span class="type">int</span> reductions)</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current - reductions;</span><br><span class="line">                <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">drainPermits</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> current;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NonFair version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) {</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        FairSync(<span class="type">int</span> <span class="keyword">permits</span>) {</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a {<span class="doctag">@code</span> Semaphore} with the given number of</span></span><br><span class="line"><span class="comment">     * permits and nonfair fairness setting.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits the initial number of permits available.</span></span><br><span class="line"><span class="comment">     *        This value may be negative, in which case releases</span></span><br><span class="line"><span class="comment">     *        must occur before any acquires will be granted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> {</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a {<span class="doctag">@code</span> Semaphore} with the given number of</span></span><br><span class="line"><span class="comment">     * permits and the given fairness setting.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits the initial number of permits available.</span></span><br><span class="line"><span class="comment">     *        This value may be negative, in which case releases</span></span><br><span class="line"><span class="comment">     *        must occur before any acquires will be granted.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair {<span class="doctag">@code</span> true} if this semaphore will guarantee</span></span><br><span class="line"><span class="comment">     *        first-in first-out granting of permits under contention,</span></span><br><span class="line"><span class="comment">     *        else {<span class="doctag">@code</span> false}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> {</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="与synchronized的区别"><a href="#与synchronized的区别" class="headerlink" title="与synchronized的区别"></a>与 synchronized 的区别</h2><ul><li><code>synchronized</code> 是一个 Java 内置的关键字，<code>AQS</code> 扩展的各种锁则是通过 Java 代码实现的</li><li><code>synchronzed</code> 锁是自动获取和释放的，而 <code>AQS</code> 的锁需要手动获取和释放</li><li>像 <code>ReentrantLock</code> 还可以设置超时等特性，但 <code>synchronized</code> 不行</li></ul>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Java/">Java</category>
      
      <category domain="https://www.boris1993.com/tags/Lock/">Lock</category>
      
      <category domain="https://www.boris1993.com/tags/AQS/">AQS</category>
      
      <category domain="https://www.boris1993.com/tags/%E9%94%81/">锁</category>
      
      
      <comments>https://www.boris1993.com/java-understand-aqs.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Boot 启动过程中的后置处理</title>
      <link>https://www.boris1993.com/spring-boot-application-start-up-post-processing.html</link>
      <guid>https://www.boris1993.com/spring-boot-application-start-up-post-processing.html</guid>
      <pubDate>Sun, 14 Jan 2024 08:02:28 GMT</pubDate>
      
      <description>&lt;p&gt;在前一篇博文 &lt;a href=&quot;/spring-boot-application-starts-up.html&quot;&gt;Spring Boot 启动流程分析&lt;/a&gt;的&lt;code&gt;调用 beanFactory 的后置处理&lt;/code&gt;小节中提到了 beanFactory 的后置处理。这部分是 Spring IoC 的重点，但是因为内容很长，所以在这里单独开一篇博文来分析。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在前一篇博文 <a href="/spring-boot-application-starts-up.html">Spring Boot 启动流程分析</a>的<code>调用 beanFactory 的后置处理</code>小节中提到了 beanFactory 的后置处理。这部分是 Spring IoC 的重点，但是因为内容很长，所以在这里单独开一篇博文来分析。</p><span id="more"></span><h2 id="调用beanFactoryPostProcessors"><a href="#调用beanFactoryPostProcessors" class="headerlink" title="调用beanFactoryPostProcessors"></a>调用 beanFactoryPostProcessors</h2><p>话不多说，继续从 <code>AbstractApplicationContext#refresh</code> 调用 <code>invokeBeanFactoryPostProcessors</code> 方法这里开始。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">    <span class="comment">// 重点</span></span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">    <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WARNING: Although it may appear that the body of this method can be easily</span></span><br><span class="line">    <span class="comment">// refactored to avoid the use of multiple loops and multiple lists, the use</span></span><br><span class="line">    <span class="comment">// of multiple lists and multiple passes over the names of processors is</span></span><br><span class="line">    <span class="comment">// intentional. We must ensure that we honor the contracts for PriorityOrdered</span></span><br><span class="line">    <span class="comment">// and Ordered processors. Specifically, we must NOT cause processors to be</span></span><br><span class="line">    <span class="comment">// instantiated (via getBean() invocations) or registered in the ApplicationContext</span></span><br><span class="line">    <span class="comment">// in the wrong order.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Before submitting a pull request (PR) to change this method, please review the</span></span><br><span class="line">    <span class="comment">// list of all declined PRs involving changes to PostProcessorRegistrationDelegate</span></span><br><span class="line">    <span class="comment">// to ensure that your proposal does not result in a breaking change:</span></span><br><span class="line">    <span class="comment">// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry registry) {</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {</span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor registryProcessor) {</span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) {</span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 这里是重点</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) {</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) {</span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) {</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) {</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) {</span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) {</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) {</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) {</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    }</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) {</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    }</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这一大段代码，实话说看得我云里雾里的，但站在巨人的肩膀上之后，我大概明白 <code>invokeBeanDefinitionRegistryPostProcessors</code> 这个方法调用是里面的重点，那接下来就随着巨人的指引看看这个方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">        Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">postProcessBeanDefRegistry</span> <span class="operator">=</span> applicationStartup.start(<span class="string">"spring.context.beandef-registry.post-process"</span>)</span><br><span class="line">                .tag(<span class="string">"postProcessor"</span>, postProcessor::toString);</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        postProcessBeanDefRegistry.end();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>debug 到 <code>postProcessBeanDefinitionRegistry</code> 这一行，发现 <code>postProcessors</code> 里面只有 <code>ConfigurationClassPostProcessor</code>，那么就进去看看这个类的 <code>postProcessBeanDefinitionRegistry</code> 在干什么。</p><p>下面代码会大量提到 configuration class 这个概念，而所谓 configuration class，就是带有 <code>@Configuration</code> 或者 <code>@Component</code> 注解的类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> {</span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的bean definition的名字</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) {</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 检查这个bean definition是不是一个配置类</span></span><br><span class="line">        <span class="comment">// 1. 取得bean definition的metadata</span></span><br><span class="line">        <span class="comment">// 2. 设定configurationClass这个bean definition attribute的值，full或lite（暂不清楚是干什么用的）</span></span><br><span class="line">        <span class="comment">// 3. 如果指定了这个配置类的生效顺序，那么将其记录到order这个attribute中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) {</span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">    configCandidates.sort((bd1, bd2) -&gt; {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">    <span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry _sbr) {</span><br><span class="line">        sbr = _sbr;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) {</span><br><span class="line">            <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">                    AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">            <span class="keyword">if</span> (generator != <span class="literal">null</span>) {</span><br><span class="line">                <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) {</span><br><span class="line">        <span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">    <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">            <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">            <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">processConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">"spring.context.config-classes.parse"</span>);</span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">                    registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">                    <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line">        processConfig.tag(<span class="string">"classCount"</span>, () -&gt; String.valueOf(configClasses.size())).end();</span><br><span class="line"></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) {</span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = Set.of(candidateNames);</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) {</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) {</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) {</span><br><span class="line">                    <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                            !alreadyParsedClasses.contains(bd.getBeanClassName())) {</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {</span><br><span class="line">        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the PropertySourceDescriptors to contribute them Ahead-of-time if necessary</span></span><br><span class="line">    <span class="built_in">this</span>.propertySourceDescriptors = parser.getPropertySourceDescriptors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory cachingMetadataReaderFactory) {</span><br><span class="line">        <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">        <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">        cachingMetadataReaderFactory.clearCache();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先这里会遍历所有的 bean definition，找到其中的配置类，然后调用 <code>parse</code> 方法解析它们。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> {</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) {</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 如果是从Spring Boot项目进来的，那么这里的bd就是主类封装成的AnnotatedGenericBeanDefinition</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition annotatedBeanDef) {</span><br><span class="line">                parse(annotatedBeanDef.getMetadata(), holder.getBeanName());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition abstractBeanDef &amp;&amp; abstractBeanDef.hasBeanClass()) {</span><br><span class="line">                parse(abstractBeanDef.getBeanClass(), holder.getBeanName());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) {</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载默认的配置，即自动装配的入口</span></span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(metadata, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) {</span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) {</span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">            <span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line">            <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="built_in">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">    <span class="comment">// 递归处理当前的configuration class及其父类</span></span><br><span class="line">    <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">        sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                <span class="string">"I/O failure while processing configuration class ["</span> + sourceClass + <span class="string">"]"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConfigurationClassParser</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(</span></span><br><span class="line"><span class="params">        ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个configuration class带有@Component注解</span></span><br><span class="line">    <span class="comment">// 那么就递归处理其内部类</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) {</span><br><span class="line">        <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">        processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">    <span class="comment">// 针对@PropertySource注解的处理</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,</span><br><span class="line">            PropertySources.class, <span class="literal">true</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.propertySourceRegistry != <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.propertySourceRegistry.processPropertySource(propertySource);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            logger.info(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for locally declared @ComponentScan annotations first.</span></span><br><span class="line">    <span class="comment">// 根据@ComponentScan注解扫描项目中的bean</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class,</span><br><span class="line">            MergedAnnotation::isDirectlyPresent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fall back to searching for @ComponentScan meta-annotations (which indirectly</span></span><br><span class="line">    <span class="comment">// includes locally declared composed annotations).</span></span><br><span class="line">    <span class="comment">// 如果没找到直接使用的@ComponentScan注解，那么就尝试找间接的引用</span></span><br><span class="line">    <span class="comment">// 如 @SpringBootApplication -&gt; @ComponentScan</span></span><br><span class="line">    <span class="keyword">if</span> (componentScans.isEmpty()) {</span><br><span class="line">        componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),</span><br><span class="line">                ComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) {</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            <span class="comment">// 在这里立即开始扫描</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) {</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) {</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 检查扫描到的这个bean是不是一个configuration class</span></span><br><span class="line">                <span class="comment">// 如果是，那么递归查找与它关脸的configuration class，如@Bean定义的bean，或带有@Import注解的@Component类</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) {</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @Import annotations</span></span><br><span class="line">    <span class="comment">// 递归处理@Import注解</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="literal">null</span>) {</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process individual @Bean methods</span></span><br><span class="line">    <span class="comment">// 处理带有@Bean的方法</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) {</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process superclass, if any</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp;</span><br><span class="line">                !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) {</span><br><span class="line">            <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Resource定位"><a href="#Resource定位" class="headerlink" title="Resource定位"></a>Resource 定位</h3><p>这里的重点是 <code>Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</code> 这个方法调用，它负责处理扫描的具体过程，所以点进 <code>parse</code> 方法看它干了什么。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">parse</span><span class="params">(AnnotationAttributes componentScan, String declaringClass)</span> {</span><br><span class="line">    <span class="comment">// 取得扫描器，并设置它的各个属性</span></span><br><span class="line">    <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>.registry,</span><br><span class="line">            componentScan.getBoolean(<span class="string">"useDefaultFilters"</span>), <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; generatorClass = componentScan.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">useInheritedGenerator</span> <span class="operator">=</span> (BeanNameGenerator.class == generatorClass);</span><br><span class="line">    scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="built_in">this</span>.beanNameGenerator :</span><br><span class="line">            BeanUtils.instantiateClass(generatorClass));</span><br><span class="line"></span><br><span class="line">    <span class="type">ScopedProxyMode</span> <span class="variable">scopedProxyMode</span> <span class="operator">=</span> componentScan.getEnum(<span class="string">"scopedProxy"</span>);</span><br><span class="line">    <span class="keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) {</span><br><span class="line">        scanner.setScopedProxyMode(scopedProxyMode);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ScopeMetadataResolver</span>&gt; resolverClass = componentScan.getClass(<span class="string">"scopeResolver"</span>);</span><br><span class="line">        scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    scanner.setResourcePattern(componentScan.getString(<span class="string">"resourcePattern"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes includeFilterAttributes : componentScan.getAnnotationArray(<span class="string">"includeFilters"</span>)) {</span><br><span class="line">        List&lt;TypeFilter&gt; typeFilters = TypeFilterUtils.createTypeFiltersFor(includeFilterAttributes, <span class="built_in">this</span>.environment,</span><br><span class="line">                <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">        <span class="keyword">for</span> (TypeFilter typeFilter : typeFilters) {</span><br><span class="line">            scanner.addIncludeFilter(typeFilter);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes excludeFilterAttributes : componentScan.getAnnotationArray(<span class="string">"excludeFilters"</span>)) {</span><br><span class="line">        List&lt;TypeFilter&gt; typeFilters = TypeFilterUtils.createTypeFiltersFor(excludeFilterAttributes, <span class="built_in">this</span>.environment,</span><br><span class="line">            <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">        <span class="keyword">for</span> (TypeFilter typeFilter : typeFilters) {</span><br><span class="line">            scanner.addExcludeFilter(typeFilter);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> componentScan.getBoolean(<span class="string">"lazyInit"</span>);</span><br><span class="line">    <span class="keyword">if</span> (lazyInit) {</span><br><span class="line">        scanner.getBeanDefinitionDefaults().setLazyInit(<span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 取得basePackages的值，默认情况下为空，因为@SpringBootApplication里面就没给@ComponentScan配置这个值</span></span><br><span class="line">    String[] basePackagesArray = componentScan.getStringArray(<span class="string">"basePackages"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String pkg : basePackagesArray) {</span><br><span class="line">        String[] tokenized = StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">                ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">        Collections.addAll(basePackages, tokenized);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 通过basePackageClasses里面指定的类找到它们所在的包，</span></span><br><span class="line">    <span class="comment">// 并将其加入basePackages</span></span><br><span class="line">    <span class="comment">// 默认情况下这个也是空的</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="string">"basePackageClasses"</span>)) {</span><br><span class="line">        basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 查到最后basePackages还是空的话</span></span><br><span class="line">    <span class="comment">// 那就把带着@ComponentScan这个注解的类所在的包加到basePackages里面</span></span><br><span class="line">    <span class="comment">// 因为启动类带着这个注解，所以启动类所在的包就会被加进去</span></span><br><span class="line">    <span class="keyword">if</span> (basePackages.isEmpty()) {</span><br><span class="line">        basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    scanner.addExcludeFilter(<span class="keyword">new</span> <span class="title class_">AbstractTypeHierarchyTraversingFilter</span>(<span class="literal">false</span>, <span class="literal">false</span>) {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchClassName</span><span class="params">(String className)</span> {</span><br><span class="line">            <span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据basePackages扫描</span></span><br><span class="line">    <span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>走到 <code>scanner.doScan</code> 的时候，就完成了定位这一步。接下来继续走进 <code>ClassPathBeanDefinitionScanner#doScan</code> 看它是怎么载入和注册各个 BeanDefinition 的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> {</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) {</span><br><span class="line">        <span class="comment">// 从指定的包中扫描需要装载的Bean</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) {</span><br><span class="line">            <span class="comment">// 得到这个bean的scope，如singleton、prototype等</span></span><br><span class="line">            <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            <span class="comment">// 并将其设置到BeanDefinition中</span></span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition abstractBeanDefinition) {</span><br><span class="line">                postProcessBeanDefinition(abstractBeanDefinition, beanName);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition annotatedBeanDefinition) {</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations(annotatedBeanDefinition);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 检查与这个bean名字对应的BeanDefinition是否已经被注册过</span></span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) {</span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">                definitionHolder =</span><br><span class="line">                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                <span class="comment">// 将这个bean注册到IoC容器</span></span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="BeanDefinition载入"><a href="#BeanDefinition载入" class="headerlink" title="BeanDefinition载入"></a>BeanDefinition 载入</h3><p>上面代码的 for 循环里首先会执行 <code>findCandidateComponents</code>，这里就是负责载入这个 basePackage 下的所有 BeanDefinition 的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) {</span><br><span class="line">        <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> {</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 根据basePackages生成classpath，</span></span><br><span class="line">        <span class="comment">// 如classpath*:com/example/demo/**/*.class</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">                resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        <span class="comment">// 从这个classpath下面扫描所有匹配的资源，也就是类</span></span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">traceEnabled</span> <span class="operator">=</span> logger.isTraceEnabled();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">        <span class="comment">// 循环处理上面找到的类，将符合条件的类包装成ScannedGenericBeanDefinition并加到candidates中</span></span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> resource.getFilename();</span><br><span class="line">            <span class="keyword">if</span> (filename != <span class="literal">null</span> &amp;&amp; filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {</span><br><span class="line">                <span class="comment">// Ignore CGLIB-generated classes in the classpath</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (traceEnabled) {</span><br><span class="line">                logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                <span class="comment">// 检查这个类是不是既没有命中任何一个exclude filter，并至少命中了一个include filter</span></span><br><span class="line">                <span class="comment">// 其中一个include filter就是根据@Component注解来过滤的</span></span><br><span class="line">                <span class="keyword">if</span> (isCandidateComponent(metadataReader)) {</span><br><span class="line">                    <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                    sbd.setSource(resource);</span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(sbd)) {</span><br><span class="line">                        <span class="comment">// 打日志，略</span></span><br><span class="line">                        candidates.add(sbd);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// 打日志，略</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 打日志，略</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (FileNotFoundException ex) {</span><br><span class="line">                <span class="comment">// 打日志，略</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (ClassFormatException ex) {</span><br><span class="line">                <span class="keyword">if</span> (shouldIgnoreClassFormatException) {</span><br><span class="line">                    <span class="comment">// 打日志，略</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">"Incompatible class format in "</span> + resource +</span><br><span class="line">                            <span class="string">": set system property 'spring.classformat.ignore' to 'true' "</span> +</span><br><span class="line">                            <span class="string">"if you mean to ignore such files during classpath scanning"</span>, ex);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册 BeanDefinition</h3><p>回到 <code>doScan</code> 方法，在得到所有的 BeanDefinition 之后，就会调用 <code>registerBeanDefinition</code> 方法来完成 BeanDefinition 的注册。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> {</span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanDefinitionReaderUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">// 将这个bean注册到DefaultListableBeanFactory的BeanDefinitionMap</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) {</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里就是把传进来的 BeanDefinition 注册到 <code>DefaultListableBeanFactory</code> 的 <code>BeanDefinitionMap</code> 中。这部分在上一篇博文中已经提过，就不重复了。</p><p>在 <code>doScan</code> 方法的 for 循环遍历完所有的 BeanDefinition 之后，所有带有 <code>@Component</code> 注解的 bean 就全部注册好了。接下来会回到 <code>doProcessConfigurationClass</code> 方法，继续处理带有 <code>@Import</code> 注解的类和带有 <code>@Bean</code> 注解的方法。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaGVsbG8tc2hmL3AvMTEwNTE0NzYuaHRtbA==">SpringBoot 启动流程分析（四）：IoC 容器的初始化过程<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Java/">Java</category>
      
      <category domain="https://www.boris1993.com/tags/Spring-Boot/">Spring Boot</category>
      
      
      <comments>https://www.boris1993.com/spring-boot-application-start-up-post-processing.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Boot 启动流程分析</title>
      <link>https://www.boris1993.com/spring-boot-application-starts-up.html</link>
      <guid>https://www.boris1993.com/spring-boot-application-starts-up.html</guid>
      <pubDate>Sat, 06 Jan 2024 14:54:15 GMT</pubDate>
      
      <description>&lt;p&gt;想来用了这么久的 Spring Boot，但一直没仔细了解它是怎么启动的。那既然想起来了，不如趁热打铁，从它的入口开始，深入看看 Spring Boot 在启动时都做了些什么。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>想来用了这么久的 Spring Boot，但一直没仔细了解它是怎么启动的。那既然想起来了，不如趁热打铁，从它的入口开始，深入看看 Spring Boot 在启动时都做了些什么。</p><span id="more"></span><h2 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h2><p>入口这部分就没啥说的，跟个 Hello world 差不多，一个 <code>main</code> 方法执行 <code>SpringApplication#run</code> 来启动整个 Spring Boot 应用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication 注解</h3><p>进到 <code>@SpringBootApplication</code> 注解的源码可以看出，它实际上是 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 的组合。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = { </span></span><br><span class="line"><span class="meta">    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) </span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="SpringBootConfiguration注解"><a href="#SpringBootConfiguration注解" class="headerlink" title="@SpringBootConfiguration注解"></a>@SpringBootConfiguration 注解</h4><p><code>@SpringBootConfiguration</code> 注解实际上只是 <code>@Configuration</code> 注解的套娃，区别只有两点：</p><ol><li><code>@SpringBootConfiguration</code> 是 Spring Boot 提供的注解，而 <code>@Configuration</code> 是 Spring 提供的注解；</li><li><code>@SpringBootConfiguration</code> 注解在整个应用中只能出现一次，<code>@Configuration</code> 注解则可以需要有多少就用多少次。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration {</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration 注解</h4><p><code>@EnableAutoConfiguration</code> 注解通过引入 <code>AutoConfigurationImportSelector</code> 来开启 Spring Boot 的自动配置功能。这部分内容我在另一篇博文 <a href="/java-spring-autoconfiguration.html">Spring Boot 自动配置的原理</a>中有详细的说明，这里就不再重复了。</p><h4 id="ComponentScan注解"><a href="#ComponentScan注解" class="headerlink" title="@ComponentScan注解"></a>@ComponentScan 注解</h4><p><code>@ComponentScan</code> 注解用来配置 Spring 如何扫描组件。我们可以通过设定 <code>basePackageClasses</code> 或 <code>basePackages</code> 属性来指定从哪些包中扫描，而在不指定的情况下，Spring 就会从带有这个注解的类所在的包开始扫描。</p><p>因为这个注解会在启动类中被引入，而启动类又在项目最顶层的包中（应该没有谁闲的会去挪启动类的位置吧），所以 Spring 就会从顶层包开始往下扫描组件。</p><h2 id="SpringApplication类"><a href="#SpringApplication类" class="headerlink" title="SpringApplication类"></a>SpringApplication 类</h2><p>从启动类对 <code>SpringApplication#run</code> 的调用一路追下去，最后会走到 <code>SpringApplication</code> 类的这个代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="SpringApplication的构造方法"><a href="#SpringApplication的构造方法" class="headerlink" title="SpringApplication的构造方法"></a>SpringApplication 的构造方法</h3><p>可以看到这里先实例化了一个 <code>SpringApplication</code> 对象，那么顺着对应的构造方法一路追下去，最后会看到这样一个构造方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> {</span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 判断应用程序的类型</span></span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 实例化bootstrap registry initializer</span></span><br><span class="line">    <span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    <span class="comment">// 实例化所有可用的initializer</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 实例化所有可用的listener</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// 找到主类</span></span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="判断应用程序的类型"><a href="#判断应用程序的类型" class="headerlink" title="判断应用程序的类型"></a>判断应用程序的类型</h4><p>Spring Boot 需要判断应用是哪种类型，来决定要不要启动它内嵌的 web server，以及启动哪种 web server。它会根据这样一个规则来判断当前应用的类型：</p><ul><li>如果能找到 <code>org.springframework.web.reactive.DispatcherHandler</code> 类，同时找不到 <code>org.springframework.web.servlet.DispatcherServlet</code> 和 <code>org.glassfish.jersey.servlet.ServletContainer</code>，那么就判定当前应用是一个 reactive web 应用，并会在将来启动面向 reactive 的 web server；</li><li>如果 <code>org.springframework.web.servlet.DispatcherServlet</code> 和 <code>org.glassfish.jersey.servlet.ServletContainer</code> 都找不到，说明这个应用不是一个 web application，将来也不会启动任何 web server；</li><li>如果以上条件都不符合，那么就判定这个应用是一个 servlet web 应用，将来会启动面向 servlet 的 web server。</li></ul><h4 id="实例化initializer和listener"><a href="#实例化initializer和listener" class="headerlink" title="实例化initializer和listener"></a>实例化 initializer 和 listener</h4><p>点进 <code>getSpringFactoriesInstances</code> 方法的实现并顺着追下去，最终可以看到这样一个代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, ArgumentResolver argumentResolver)</span> {</span><br><span class="line">    <span class="keyword">return</span> SpringFactoriesLoader.forDefaultResourceLocation(getClassLoader()).load(type, argumentResolver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再顺着 <code>forDefaultResourceLocation</code> 方法的实现，最终会走到这里：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SpringFactoriesLoader <span class="title function_">forResourceLocation</span><span class="params">(String resourceLocation, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> {</span><br><span class="line">    Assert.hasText(resourceLocation, <span class="string">"'resourceLocation' must not be empty"</span>);</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">resourceClassLoader</span> <span class="operator">=</span> (classLoader != <span class="literal">null</span> ? classLoader :</span><br><span class="line">            SpringFactoriesLoader.class.getClassLoader());</span><br><span class="line">    Map&lt;String, SpringFactoriesLoader&gt; loaders = cache.computeIfAbsent(</span><br><span class="line">            resourceClassLoader, key -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> loaders.computeIfAbsent(resourceLocation, key -&gt;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SpringFactoriesLoader</span>(classLoader, loadFactoriesResource(resourceClassLoader, resourceLocation)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看起来好像云里雾里的，下断点调试一下看出来了，这里就是扫描所有 <code>META-INF</code> 目录下的 <code>spring.factories</code> 文件，并把里面所有的键值对放到一个 Map 里。最后我们可以得到一个包含了这个 Map 的 <code>SpringFactoriesLoader</code> 对象。</p><p><img data-src="https://blog-static.boris1993.com/how-spring-boot-application-starts-up/load-bootstrap-initializers-1.png"></p><p>接着看 <code>load</code> 方法，顺着追下去会走到这个代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">load</span><span class="params">(Class&lt;T&gt; factoryType, <span class="meta">@Nullable</span> ArgumentResolver argumentResolver,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> FailureHandler failureHandler)</span> {</span><br><span class="line"></span><br><span class="line">    Assert.notNull(factoryType, <span class="string">"'factoryType' must not be null"</span>);</span><br><span class="line">    List&lt;String&gt; implementationNames = loadFactoryNames(factoryType);</span><br><span class="line">    logger.trace(LogMessage.format(<span class="string">"Loaded [%s] names: %s"</span>, factoryType.getName(), implementationNames));</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(implementationNames.size());</span><br><span class="line">    <span class="type">FailureHandler</span> <span class="variable">failureHandlerToUse</span> <span class="operator">=</span> (failureHandler != <span class="literal">null</span>) ? failureHandler : THROWING_FAILURE_HANDLER;</span><br><span class="line">    <span class="keyword">for</span> (String implementationName : implementationNames) {</span><br><span class="line">        <span class="type">T</span> <span class="variable">factory</span> <span class="operator">=</span> instantiateFactory(implementationName, factoryType, argumentResolver, failureHandlerToUse);</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="literal">null</span>) {</span><br><span class="line">            result.add(factory);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    AnnotationAwareOrderComparator.sort(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里就是从上面得到的 Map 中找到 <code>factoryType</code> 传进来的接口对应的实现类，分别调用它们的构造方法将其实例化，然后把得到的对象放在 List 里面返回，并交给外层的 <code>setInitializers</code> 方法来把这个 List 放在 <code>SpringApplication</code> 类的成员变量 <code>initializers</code> 中。</p><p>实例化 listener 也是一样的流程。至于 <code>ApplicationListener</code> 则是 Spring 的事件监听器，利用观察者模式，通过 <code>ApplicationEvent</code> 和 <code>ApplicationListener</code> 接口实现对 Spring 容器全生命周期的监听，同时也可以监听自定义的事件。</p><h4 id="找到主类"><a href="#找到主类" class="headerlink" title="找到主类"></a>找到主类</h4><p>顺着 <code>deduceMainApplicationClass</code> 的实现，会注意到这么两个方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() {</span><br><span class="line">    <span class="keyword">return</span> StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)</span><br><span class="line">        .walk(<span class="built_in">this</span>::findMainClass)</span><br><span class="line">        .orElse(<span class="literal">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Optional&lt;Class&lt;?&gt;&gt; findMainClass(Stream&lt;StackFrame&gt; stack) {</span><br><span class="line">    <span class="keyword">return</span> stack.filter((frame) -&gt; Objects.equals(frame.getMethodName(), <span class="string">"main"</span>))</span><br><span class="line">        .findFirst()</span><br><span class="line">        .map(StackWalker.StackFrame::getDeclaringClass);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看起来挺简单粗暴的，就是遍历栈帧，找执行了 <code>main</code> 方法的那个栈，然后找到这个栈对应的类。</p><h2 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run 方法</h2><p>经过上面一顿操作，这个 <code>SpringApplication</code> 对象就初始化好了，接下来就会调用它的 <code>run</code> 方法开始启动。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> {</span><br><span class="line">    <span class="type">Startup</span> <span class="variable">startup</span> <span class="operator">=</span> Startup.create();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) {</span><br><span class="line">        SpringApplication.shutdownHook.enableShutdownHookAddition();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建 bootstrap context</span></span><br><span class="line">    <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> createBootstrapContext();</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 进入无头模式</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 启动listener</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">    listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">        <span class="comment">// 准备环境</span></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">        <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">        <span class="comment">// 创建application context</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);</span><br><span class="line">        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 刷新application context</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 收尾</span></span><br><span class="line">        startup.started();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), startup);</span><br><span class="line">        }</span><br><span class="line">        listeners.started(context, startup.timeTakenToStarted());</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (context.isRunning()) {</span><br><span class="line">            listeners.ready(context, startup.ready());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="创建bootstrap-context"><a href="#创建bootstrap-context" class="headerlink" title="创建bootstrap context"></a>创建 bootstrap context</h3><p>点进 <code>createBootstrapContext</code> 方法，可以看到这样一个代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DefaultBootstrapContext <span class="title function_">createBootstrapContext</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultBootstrapContext</span>();</span><br><span class="line">    <span class="built_in">this</span>.bootstrapRegistryInitializers.forEach((initializer) -&gt; initializer.initialize(bootstrapContext));</span><br><span class="line">    <span class="keyword">return</span> bootstrapContext;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在构造 <code>SpringApplication</code> 时准备的 <code>this.bootstrapRegistryInitializers</code> 在这用上了。看代码的话就是分别执行每个 initializer 的 <code>initailize</code> 方法。但是我这个应用里面没有 <code>BootstrapRegistryInitializer</code> 的实现类，所以也就没法深入进去看它到底干了什么。</p><p>不过看了眼<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1wcm9qZWN0cy9zcHJpbmctYm9vdC9ibGFtZS84MzcwNDdhYjc5YTIyNmQ0MTZkZjY2ZDY3ZDJmNzY4NmFiNzI5M2NkL3NwcmluZy1ib290LXByb2plY3Qvc3ByaW5nLWJvb3Qvc3JjL21haW4vamF2YS9vcmcvc3ByaW5nZnJhbWV3b3JrL2Jvb3QvU3ByaW5nQXBwbGljYXRpb24uamF2YSNMMzU3"> Git Blame<i class="fa fa-external-link-alt"></i></span>，发现了这么一段话：</p><blockquote><p>Refactor <code>BootstrapRegistry</code> support following initial prototype work with the Spring Cloud team.</p></blockquote><p>看起来是跟 Spring Cloud 相关的，那暂且就不关注了。</p><h3 id="进入无头模式"><a href="#进入无头模式" class="headerlink" title="进入无头模式"></a>进入无头模式</h3><p>在 Oracle 的文档<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmljYWwtcmVzb3VyY2VzL2FydGljbGVzL2phdmFzZS9oZWFkbGVzcy5odG1s"> Using Headless Mode in the Java SE Platform<i class="fa fa-external-link-alt"></i></span>中提到</p><blockquote><p>Headless mode is a system configuration in which the display device, keyboard, or mouse is lacking. Sounds unexpected, but actually you can perform different operations in this mode, even with graphic data.</p><p>Where it is applicable? Let’s say that your application repeatedly generates a certain image, for example, a graphical authorization code that must be changed every time a user logs in to the system. When creating an image, your application needs neither the display nor the keyboard. Let’s assume now that you have a mainframe or dedicated server on your project that has no display device, keyboard, or mouse. The ideal decision is to use this environment’s substantial computing power for the visual as well as the nonvisual features. An image that was generated in the headless mode system then can be passed to the headful system for further rendering.</p></blockquote><p>其实就是，像 web 服务之类不需要显示界面的应用，就可以让它进入无头模式，让它在没有显示器等输入输出设备时也能启动，还可以提高计算效率。</p><h3 id="启动listener"><a href="#启动listener" class="headerlink" title="启动listener"></a>启动 listener</h3><p>点进 <code>getRunListeners</code> 的实现可以看到如下代码块：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title function_">getRunListeners</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ArgumentResolver</span> <span class="variable">argumentResolver</span> <span class="operator">=</span> ArgumentResolver.of(SpringApplication.class, <span class="built_in">this</span>);</span><br><span class="line">    argumentResolver = argumentResolver.and(String[].class, args);</span><br><span class="line">    List&lt;SpringApplicationRunListener&gt; listeners = getSpringFactoriesInstances(SpringApplicationRunListener.class,</span><br><span class="line">            argumentResolver);</span><br><span class="line">    <span class="type">SpringApplicationHook</span> <span class="variable">hook</span> <span class="operator">=</span> applicationHook.get();</span><br><span class="line">    <span class="type">SpringApplicationRunListener</span> <span class="variable">hookListener</span> <span class="operator">=</span> (hook != <span class="literal">null</span>) ? hook.getRunListener(<span class="built_in">this</span>) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hookListener != <span class="literal">null</span>) {</span><br><span class="line">        listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(listeners);</span><br><span class="line">        listeners.add(hookListener);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationRunListeners</span>(logger, listeners, <span class="built_in">this</span>.applicationStartup);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看到 <code>getSpringFactoriesInstances</code> 有没有感觉很熟悉？对，这一步就是尝试从 <code>spring.factories</code> 里尝试找到 <code>SpringApplicationRunListener</code> 的实现类。默认来说这里只能找到 <code>EventPublishingRunListener</code>，它是用来发布各种 <code>SpringBootEvent</code> 的。在 Spring Boot 中，事件是一个很重要的东西，通过事件机制我们可以监听 Spring Boot 容器中正在发生的事件，也可以监听各种自定义的事件。事件机制也为 Bean 之间的消息传递提供支持。</p><p>除了从 <code>spring.factories</code> 尝试获取 listener 之外，Spring Boot 也会尝试从 <code>SpringApplicationHook</code> 中找到 hook 进来的 listener。看了下代码，似乎我们可以在入口的 <code>main</code> 方法里调用 <code>SpringApplication#withHook</code> 来添加我们需要的 hook，但是我的应用里面也没有什么能用的，所以也没法深挖了。</p><p>在得到这些 listener 之后，就会实例化一个 <code>SpringApplicationRunListeners</code> 对象并返回回去，然后在 <code>SpringApplicationRunListeners#starting</code> 方法中调用各个 listener 的 <code>starting</code> 方法。此时，上面得到的 <code>EventPublishingRunListener</code> 就会广播出去一条 <code>ApplicationStartingEvent</code> 事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">starting</span><span class="params">(ConfigurableBootstrapContext bootstrapContext, Class&lt;?&gt; mainApplicationClass)</span> {</span><br><span class="line">    doWithListeners(<span class="string">"spring.boot.application.starting"</span>, (listener) -&gt; listener.starting(bootstrapContext),</span><br><span class="line">            (step) -&gt; {</span><br><span class="line">                <span class="keyword">if</span> (mainApplicationClass != <span class="literal">null</span>) {</span><br><span class="line">                    step.tag(<span class="string">"mainApplicationClass"</span>, mainApplicationClass.getName());</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWithListeners</span><span class="params">(String stepName, Consumer&lt;SpringApplicationRunListener&gt; listenerAction,</span></span><br><span class="line"><span class="params">        Consumer&lt;StartupStep&gt; stepAction)</span> {</span><br><span class="line">    <span class="type">StartupStep</span> <span class="variable">step</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(stepName);</span><br><span class="line">    <span class="built_in">this</span>.listeners.forEach(listenerAction);</span><br><span class="line">    <span class="keyword">if</span> (stepAction != <span class="literal">null</span>) {</span><br><span class="line">        stepAction.accept(step);</span><br><span class="line">    }</span><br><span class="line">    step.end();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>Spring 中的 Environment 负责两件事：</p><ul><li>加载配置好的各种 property 的值</li><li>后续通过各种方法获取 property 的值</li></ul><p>在 Spring Boot 里，property 的值可以通过 YAML 文件或 properties 文件、环境变量，和命令行参数这三种方法配置。此外，Spring Boot 会依照一定的优先级来决定采用哪个 property 值，高优先级的会覆盖低优先级的。常见的几种配置方式会按照如下的优先级排列：</p><ol><li>开发者工具 <code>Devtools</code> 全局配置</li><li>命令行指定的参数（如 <code>--server.port=8080</code>）</li><li>JNDI 参数</li><li> Java 系统参数（通过 <code>-D</code> 指定的参数）</li><li>系统环境变量</li><li>对应不同环境的 <code>application-{profile}.yml</code> 配置文件</li><li><code>application.yml</code> 配置文件</li><li>默认参数</li></ol><p>点进 <code>prepareEvent</code> 方法的实现，可以看到这个代码块（我稍微重新格式化了一下，看起来更舒服一点）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">prepareEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">    SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">    DefaultBootstrapContext bootstrapContext, </span></span><br><span class="line"><span class="params">    ApplicationArguments applicationArguments</span></span><br><span class="line"><span class="params">)</span> {</span><br><span class="line">    <span class="comment">// Create and configure the environment</span></span><br><span class="line">    <span class="comment">// 获得应用的环境（servlet / reactive）</span></span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> getOrCreateEnvironment();</span><br><span class="line">    configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    listeners.environmentPrepared(bootstrapContext, environment);</span><br><span class="line">    DefaultPropertiesPropertySource.moveToEnd(environment);</span><br><span class="line">    Assert.state(!environment.containsProperty(<span class="string">"spring.main.environment-prefix"</span>),</span><br><span class="line">            <span class="string">"Environment prefix cannot be set via properties."</span>);</span><br><span class="line">    bindToSpringApplication(environment);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isCustomEnvironment) {</span><br><span class="line">        <span class="type">EnvironmentConverter</span> <span class="variable">environmentConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnvironmentConverter</span>(getClassLoader());</span><br><span class="line">        environment = environmentConverter.convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">    }</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    <span class="keyword">return</span> environment;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">getOrCreateEnvironment</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.environment;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContextFactory.createEnvironment(<span class="built_in">this</span>.webApplicationType);</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.applicationContextFactory != ApplicationContextFactory.DEFAULT) {</span><br><span class="line">        environment = ApplicationContextFactory.DEFAULT.createEnvironment(<span class="built_in">this</span>.webApplicationType);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (environment != <span class="literal">null</span>) ? environment : <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先在 <code>getOrCreateEnvironment</code> 中，Spring Boot 会根据应用类型 (reactive、servlet 或 none) 来创建对应的环境。比如我这个是一个 servlet 应用，那么 <code>createEnvironment</code> 方法就会返回一个 <code>ApplicationServletEnvironment</code> 对象，并返回回去。</p><p>接下来到 <code>configureEnvironment</code> 里面：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureEnvironment</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.addConversionService) {</span><br><span class="line">        environment.setConversionService(<span class="keyword">new</span> <span class="title class_">ApplicationConversionService</span>());</span><br><span class="line">    }</span><br><span class="line">    configurePropertySources(environment, args);</span><br><span class="line">    configureProfiles(environment, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configurePropertySources</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> {</span><br><span class="line">    <span class="type">MutablePropertySources</span> <span class="variable">sources</span> <span class="operator">=</span> environment.getPropertySources();</span><br><span class="line">    <span class="comment">// 如果有default properties，那就把它们加到MutablePropertySources里面</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="built_in">this</span>.defaultProperties)) {</span><br><span class="line">        DefaultPropertiesPropertySource.addOrMerge(<span class="built_in">this</span>.defaultProperties, sources);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// addCommandLineProperties默认是true</span></span><br><span class="line">    <span class="comment">// args就是启动时传进来的参数，--server.port=8080之类的</span></span><br><span class="line">    <span class="comment">// 如果有指定参数，那就把这些参数包在SimpleCommandLinePropertySource里面，并添加到MutablePropertySources中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.addCommandLineProperties &amp;&amp; args.length &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</span><br><span class="line">        <span class="keyword">if</span> (sources.contains(name)) {</span><br><span class="line">            PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line">            <span class="type">CompositePropertySource</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositePropertySource</span>(name);</span><br><span class="line">            composite.addPropertySource(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(<span class="string">"springApplicationCommandLineArgs"</span>, args));</span><br><span class="line">            composite.addPropertySource(source);</span><br><span class="line">            sources.replace(name, composite);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            sources.addFirst(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(args));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureProfiles</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><del>这个 conversion service 是干啥用的暂时还没搞明白，先留个坑，专注于主线。</del>爬了些文大概看明白了，<code>ConversionService</code> 是用来处理各种类型转换的，比如把字符串转换成 <code>Long</code> 或者日期等。</p><p>这里的话就是把各种参数（比如附加在启动命令里面的命令行参数）给填充到 <code>environment</code> 对象里。<code>MutablePropertySources</code> 就是存放 property 的载体，在前面调用 <code>createEnvironment</code> 的时候，<code>ApplicationServletEnvironment</code> 继承的 <code>AbstractEnvironment</code> 类的构造方法就会创建一个新的 <code>MutablePropertySources</code> 实例。</p><p>接下来 <code>ConfigurationPropertySources#attach</code> 方法里面，environment 的 <code>propertySources</code> 会被封装成一个 <code>ConfigurationPropertySource</code> 并添加到 environment 中。</p><p>环境准备完成后，Spring Boot 会发布一个 <code>ApplicationEnvironmentPreparedEvent</code> 事件。顺着 <code>doWithListeners</code> 方法一路追下去，在 <code>SimpleApplicationEventMulticaster#multicastEvent</code> 方法中，查看 <code>getApplicationListeners(event, type)</code> 的返回结果可以看到，这里会调用多个监听器来处理这个事件。</p><p><img data-src="https://blog-static.boris1993.com/how-spring-boot-application-starts-up/get-application-listeners.png"></p><p>其中 <code>EnvironmentPostProcessorApplicationListener</code> 又会调用多个后处理器实现加载系统环境变量（由 <code>SystemEnvironmentPropertySourceEnvironmentPostProcessor</code> 完成）、在环境中设定启用的 profile 并把配置文件加载到环境（由 <code>ConfigDataEnvironmentPostProcessor</code> 完成）等操作。</p><p>其中 <code>ConfigDataEnvironmentPostProcessor</code> 默认会从 <code>classpath:/</code>、<code>classpath:/config/</code>、<code>file:./</code>、<code>file:./config/</code>、<code>file:./config/*/</code> 这几个地方查找配置文件，如果有需要也可以通过 <code>spring.config.location</code>、<code>spring.config.additional-location</code>、<code>spring.config.import</code> 这三个配置来干预它从哪查找配置文件。</p><p><img data-src="https://blog-static.boris1993.com/how-spring-boot-application-starts-up/default-locations-for-searching-config-files.png"></p><p>在查找到配置文件，并得到当前启用的 profile 后，<code>ConfigDataEnvironment#applyToEnvironment</code> 方法就会将配置文件中的值加载到环境中。</p><p><img data-src="https://blog-static.boris1993.com/how-spring-boot-application-starts-up/loading-config-from-properties-with-profile.png"></p><p>然后 Spring Boot 会把这个 environment 对象与 <code>SpringApplication</code> 绑定起来。但是绑定这部分暂时也没看明白，依旧是专注于主线，以后有时间再说。</p><h3 id="创建application-context"><a href="#创建application-context" class="headerlink" title="创建application context"></a>创建 application context</h3><p>这里会根据应用的类型（reactive 或 servlet）来创建对应的 application context 对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.applicationContextFactory.create(<span class="built_in">this</span>.webApplicationType);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>debug 进去，走到了 <code>DefaultApplicationContextFactory</code> 的这两个方法中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">create</span><span class="params">(WebApplicationType webApplicationType)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> getFromSpringFactories(</span><br><span class="line">            webApplicationType, </span><br><span class="line">            ApplicationContextFactory::create,</span><br><span class="line">            <span class="built_in">this</span>::createDefaultApplicationContext);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"Unable create a default ApplicationContext instance, "</span></span><br><span class="line">                + <span class="string">"you may need a custom ApplicationContextFactory"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; T <span class="title function_">getFromSpringFactories</span><span class="params">(</span></span><br><span class="line"><span class="params">    WebApplicationType webApplicationType,</span></span><br><span class="line"><span class="params">    BiFunction&lt;ApplicationContextFactory, WebApplicationType, T&gt; action, </span></span><br><span class="line"><span class="params">    Supplier&lt;T&gt; defaultResult</span></span><br><span class="line"><span class="params">)</span> {</span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextFactory candidate : SpringFactoriesLoader.loadFactories(ApplicationContextFactory.class,getClass().getClassLoader())) {</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> action.apply(candidate, webApplicationType);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (defaultResult != <span class="literal">null</span>) ? defaultResult.get() : <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个循环里它会分别执行 <code>ReactiveWebServerApplicationContextFactory</code> 和 <code>ServletWebServerApplicationContextFactory</code> 里面的 <code>create</code> 方法，而 <code>create</code> 方法里会判断当前应用的类型，来决定要不要创建对应的 application context。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">create</span><span class="params">(WebApplicationType webApplicationType)</span> {</span><br><span class="line">    <span class="keyword">return</span> (webApplicationType != WebApplicationType.SERVLET) ? <span class="literal">null</span> : createContext();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConfigurableApplicationContext <span class="title function_">createContext</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (!AotDetector.useGeneratedArtifacts()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletWebServerApplicationContext</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建好 application context 实例后，Spring Boot 会开始准备 context 的内容。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(</span></span><br><span class="line"><span class="params">    DefaultBootstrapContext bootstrapContext, </span></span><br><span class="line"><span class="params">    ConfigurableApplicationContext context,</span></span><br><span class="line"><span class="params">    ConfigurableEnvironment environment, </span></span><br><span class="line"><span class="params">    SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">    ApplicationArguments applicationArguments, </span></span><br><span class="line"><span class="params">    Banner printedBanner</span></span><br><span class="line"><span class="params">)</span> {</span><br><span class="line">    <span class="comment">// 绑定环境</span></span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    <span class="comment">// 后置处理</span></span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    addAotGeneratedInitializerIfNecessary(<span class="built_in">this</span>.initializers);</span><br><span class="line">    <span class="comment">// 执行各个initializer的initialize方法</span></span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="comment">// 发布bootstrap context被关闭的事件</span></span><br><span class="line">    bootstrapContext.close(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) {</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 注册启动相关的单例bean</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">    <span class="comment">// 把main方法中的args封装成单例bean注册到容器</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) {</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置是否允许循环引用，是否允许覆盖注册</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> AbstractAutowireCapableBeanFactory autowireCapableBeanFactory) {</span><br><span class="line">        autowireCapableBeanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory listableBeanFactory) {</span><br><span class="line">            listableBeanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 处理延迟初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazyInitialization) {</span><br><span class="line">        context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">LazyInitializationBeanFactoryPostProcessor</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 是否要保持JVM持续运行</span></span><br><span class="line">    <span class="comment">// 为了应对Java 21引入的虚拟线程产生的问题</span></span><br><span class="line">    <span class="comment">// 因为虚拟线程都是守护线程，而在只有守护线程运行时，JVM就会退出</span></span><br><span class="line">    <span class="comment">// 所以这里会启动一个非守护线程来保持JVM能持续运行下去</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.keepAlive) {</span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> <span class="title class_">KeepAlive</span>());</span><br><span class="line">    }</span><br><span class="line">    context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">PropertySourceOrderingBeanFactoryPostProcessor</span>(context));</span><br><span class="line">    <span class="comment">// 不考虑AOT优化时，加载primarySources和sources</span></span><br><span class="line">    <span class="keyword">if</span> (!AotDetector.useGeneratedArtifacts()) {</span><br><span class="line">        <span class="comment">// 载入sources</span></span><br><span class="line">        Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">        Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">        <span class="comment">// 加载启动类并注入到容器</span></span><br><span class="line">        load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">    }</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="注册启动相关的单例bean"><a href="#注册启动相关的单例bean" class="headerlink" title="注册启动相关的单例bean"></a>注册启动相关的单例 bean</h4><p>我对注册启动相关的单例 bean 很感兴趣，于是逐层点进 <code>registerSingleton</code> 的实现，看到了下列代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException {</span><br><span class="line">    <span class="built_in">super</span>.registerSingleton(beanName, singletonObject);</span><br><span class="line">    updateManualSingletonNames(set -&gt; set.add(beanName), set -&gt; !<span class="built_in">this</span>.beanDefinitionMap.containsKey(beanName));</span><br><span class="line">    clearByTypeCache();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultSingletonBeanRegistry</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException {</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">    Assert.notNull(singletonObject, <span class="string">"Singleton object must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">oldObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (oldObject != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"Could not register object ["</span> + singletonObject +</span><br><span class="line">                    <span class="string">"] under bean name '"</span> + beanName + <span class="string">"': there is already object ["</span> + oldObject + <span class="string">"] bound"</span>);</span><br><span class="line">        }</span><br><span class="line">        addSingleton(beanName, singletonObject);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) {</span><br><span class="line">        <span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看下来就是，在注册一个单例 bean 的时候，会传进来 bean 的名字和实际的对象。在 <code>registerSingleton</code> 中首先检查这个名字是不是已经被注册过了，没有被注册过的话就会调用 <code>addSingleton</code> 来注册。而所谓注册，就是：</p><ul><li>在 <code>singletonObjects</code> 这个 Map 里面增加一个条目，key 是 bean 的名字，value 是 bean 对应的对象；</li><li>从 <code>singletonFactories</code> 和 <code>earlySingletonObjects</code> 中删掉以这个 bean 名字为 key 的条目；</li><li>在 <code>registeredSingletons</code> 这个 Set 里面记录这次注册的 bean 的名字。</li></ul><p>上面提到的这三个 Map 实际上就是 Spring 的三级缓存。</p><ul><li><code>singletonObjects</code> 是一级缓存，存储的是完整创建好的单例 bean 对象。在创建一个单例 bean 时，Spring 会先从这里尝试获取这个 bean 的实例，如果找到则直接返回，否则继续创建这个 bean；</li><li><code>earlySingletonObjects</code> 是二级缓存，存储的是尚未完全创建好的 “半成品” 单例 bean 对象。在创建单例 bean 时，如果发现这个 bean 存在循环依赖，那么 Spring 会先创建这个 bean 的 “半成品” 对象并将其存到这里。当循环依赖的 bean 创建完成后，Spring 再将这里存储的代理对象替换为完整的 bean 对象；</li><li><code>singletonFactories</code> 是三级缓存，存储的是单例 bean 的创建工厂。当一个单例 bean 被创建时，Spring 会先将该 bean 的创建工厂存储到这里，然后再执行工厂的 <code>getObject()</code> 方法生成该 bean 的实例对象。在该 bean 被其他 bean 引用时，Spring 会从这里获取该 bean 的创建工厂来创建出这个 bean 的实例，并将这个实例存储到 <code>singletonObjects</code> 中。</li></ul><p>返回到 <code>registerSingleton</code> 之后，继续执行 <code>updateManualSingletonNames</code> 方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateManualSingletonNames</span><span class="params">(Consumer&lt;Set&lt;String&gt;&gt; action, Predicate&lt;Set&lt;String&gt;&gt; condition)</span> {</span><br><span class="line">    <span class="keyword">if</span> (hasBeanCreationStarted()) {</span><br><span class="line">        <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) {</span><br><span class="line">            <span class="keyword">if</span> (condition.test(<span class="built_in">this</span>.manualSingletonNames)) {</span><br><span class="line">                Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.manualSingletonNames);</span><br><span class="line">                action.accept(updatedSingletons);</span><br><span class="line">                <span class="built_in">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Still in startup registration phase</span></span><br><span class="line">        <span class="keyword">if</span> (condition.test(<span class="built_in">this</span>.manualSingletonNames)) {</span><br><span class="line">            action.accept(<span class="built_in">this</span>.manualSingletonNames);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在应用启动的时候，方法会走到 <code>else</code> 这部分，也就是直接向 <code>manualSingletonNames</code> 这个 Set 添加这次注册的 bean 的名字。<code>manualSingletonNames</code> 这个 Set 存放的就是手动注册的各个 bean 的名字。</p><p>然后执行 <code>clearByTypeCache</code> 方法，把这两个 cache 清除。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearByTypeCache</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">this</span>.allBeanNamesByType.clear();</span><br><span class="line">    <span class="built_in">this</span>.singletonBeanNamesByType.clear();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="加载primarySources和sources"><a href="#加载primarySources和sources" class="headerlink" title="加载primarySources和sources"></a>加载 primarySources 和 sources</h4><p><code>getAllSources</code> 会把 <code>primarySources</code> 和 <code>sources</code> 放进一个 Set 里面返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">getAllSources</span><span class="params">()</span> {</span><br><span class="line">    Set&lt;Object&gt; allSources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="built_in">this</span>.primarySources)) {</span><br><span class="line">        <span class="comment">// 把启动类添加到allSources</span></span><br><span class="line">        allSources.addAll(<span class="built_in">this</span>.primarySources);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="built_in">this</span>.sources)) {</span><br><span class="line">        allSources.addAll(<span class="built_in">this</span>.sources);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(allSources);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后走到 <code>load</code> 方法，把 bean 加载到 application context：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> {</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"Loading source "</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">    }</span><br><span class="line">    <span class="type">BeanDefinitionLoader</span> <span class="variable">loader</span> <span class="operator">=</span> createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanNameGenerator != <span class="literal">null</span>) {</span><br><span class="line">        loader.setBeanNameGenerator(<span class="built_in">this</span>.beanNameGenerator);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) {</span><br><span class="line">        loader.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) {</span><br><span class="line">        loader.setEnvironment(<span class="built_in">this</span>.environment);</span><br><span class="line">    }</span><br><span class="line">    loader.load();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BeanDefinitionRegistry <span class="title function_">getBeanDefinitionRegistry</span><span class="params">(ApplicationContext context)</span> {</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> BeanDefinitionRegistry registry) {</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> AbstractApplicationContext abstractApplicationContext) {</span><br><span class="line">        <span class="keyword">return</span> (BeanDefinitionRegistry) abstractApplicationContext.getBeanFactory();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"Could not locate BeanDefinitionRegistry"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BeanDefinitionLoader <span class="title function_">createBeanDefinitionLoader</span><span class="params">(BeanDefinitionRegistry registry, Object[] sources)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionLoader</span>(registry, sources);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanDefinitionLoader</span></span><br><span class="line">BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {</span><br><span class="line">    Assert.notNull(registry, <span class="string">"Registry must not be null"</span>);</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">    <span class="built_in">this</span>.sources = sources;</span><br><span class="line">    <span class="comment">// 初始化注解形式的Bean定义读取器</span></span><br><span class="line">    <span class="built_in">this</span>.annotatedReader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(registry);</span><br><span class="line">    <span class="comment">// 初始化XML形式的Bean定义读取器</span></span><br><span class="line">    <span class="built_in">this</span>.xmlReader = <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(registry);</span><br><span class="line">    <span class="built_in">this</span>.groovyReader = (isGroovyPresent() ? <span class="keyword">new</span> <span class="title class_">GroovyBeanDefinitionReader</span>(registry) : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 初始化classpath扫描器</span></span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(registry);</span><br><span class="line">    <span class="comment">// 给classpath扫描器添加排除过滤器</span></span><br><span class="line">    <span class="built_in">this</span>.scanner.addExcludeFilter(<span class="keyword">new</span> <span class="title class_">ClassExcludeFilter</span>(sources));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先这里会执行 <code>getBeanDefinitionRegistry</code> 方法。因为这个应用的 application context 是一个 <code>AnnotationConfigServletWebServerApplicationContext</code>，而它又层层继承于 <code>BeanDefinitionRegistry</code>，所以这里返回的就是当前的 application context。得到 bean defininition registry 之后，就会用它来初始化一个 <code>BeanDefinitionLoader</code> 对象。<code>BeanDefinitionLoader</code> 的构造方法里面会初始化各种 reader 和 scanner，来支持从不同的资源（XML、Java Config 等）加载 bean definition。</p><p>得到 <code>BeanDefinitionLoader</code> 后，Spring Boot 会把 bean 名字的生成器等自定义部件绑定上去。不过默认情况下它们都是 <code>null</code>。然后，就会执行 <code>BeanDefinitionLoader</code> 的 <code>load</code> 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (Object source : <span class="built_in">this</span>.sources) {</span><br><span class="line">        load(source);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(Object source)</span> {</span><br><span class="line">    Assert.notNull(source, <span class="string">"Source must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt; clazz) {</span><br><span class="line">        load(clazz);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Resource resource) {</span><br><span class="line">        load(resource);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Package pack) {</span><br><span class="line">        load(pack);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence sequence) {</span><br><span class="line">        load(sequence);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Invalid source type "</span> + source.getClass());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(Class&lt;?&gt; source)</span> {</span><br><span class="line">    <span class="keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {</span><br><span class="line">        <span class="comment">// Any GroovyLoaders added in beans{} DSL can contribute beans here</span></span><br><span class="line">        <span class="type">GroovyBeanDefinitionSource</span> <span class="variable">loader</span> <span class="operator">=</span> BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</span><br><span class="line">        ((GroovyBeanDefinitionReader) <span class="built_in">this</span>.groovyReader).beans(loader.getBeans());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (isEligible(source)) {</span><br><span class="line">        <span class="comment">// 将启动类的BeanDefinition注册进beanDefinitionMap</span></span><br><span class="line">        <span class="built_in">this</span>.annotatedReader.register(source);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEligible</span><span class="params">(Class&lt;?&gt; type)</span> {</span><br><span class="line">    <span class="keyword">return</span> !(type.isAnonymousClass() || isGroovyClosure(type) || hasNoConstructors(type));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然这里会遍历 <code>sources</code>，但是实际上 <code>sources</code> 里面只有应用的主启动类，所以最终会走到 <code>load(Class&lt;?&gt; source)</code> 方法中。因为应用中没有 Groovy，所以第一个判断会被跳过，然后经过 <code>isEligible</code> 中的三个判断之后，走进 <code>register</code> 方法，并最终进入 <code>AnnotatedBeanDefinition#doRegisterBean</code> 方法中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotatedBeanDefinitionReader</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> {</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) {</span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> {</span><br><span class="line">    doRegisterBean(beanClass, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">doRegisterBean</span><span class="params">(</span></span><br><span class="line"><span class="params">    Class&lt;T&gt; beanClass, </span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> String name,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, </span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers</span></span><br><span class="line"><span class="params">)</span> {</span><br><span class="line">    <span class="comment">// 将传进来的类封装为AnnotatedGenericBeanDefinition</span></span><br><span class="line">    <span class="type">AnnotatedGenericBeanDefinition</span> <span class="variable">abd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(beanClass);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    abd.setAttribute(ConfigurationClassUtils.CANDIDATE_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">    abd.setInstanceSupplier(supplier);</span><br><span class="line">    <span class="comment">// 获取该类的scope属性</span></span><br><span class="line">    <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    <span class="comment">// 设定这个bean的scope，singleton、prototype等</span></span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">    <span class="comment">// 生成bean的名字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (name != <span class="literal">null</span> ? name : <span class="built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="built_in">this</span>.registry));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类上的注解设定bean的属性，即处理@Lazy、@Primary等</span></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    <span class="keyword">if</span> (qualifiers != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; qualifier : qualifiers) {</span><br><span class="line">            <span class="keyword">if</span> (Primary.class == qualifier) {</span><br><span class="line">                abd.setPrimary(<span class="literal">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) {</span><br><span class="line">                abd.setLazyInit(<span class="literal">true</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                abd.addQualifier(<span class="keyword">new</span> <span class="title class_">AutowireCandidateQualifier</span>(qualifier));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (customizers != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) {</span><br><span class="line">            customizer.customize(abd);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(abd, beanName);</span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">    <span class="comment">// 将这个BeanDefinition注册到IoC容器的BeanDefinitionMap中</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> {</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">lazy</span> <span class="operator">=</span> attributesFor(metadata, Lazy.class);</span><br><span class="line">    <span class="keyword">if</span> (lazy != <span class="literal">null</span>) {</span><br><span class="line">        abd.setLazyInit(lazy.getBoolean(<span class="string">"value"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) {</span><br><span class="line">        lazy = attributesFor(abd.getMetadata(), Lazy.class);</span><br><span class="line">        <span class="keyword">if</span> (lazy != <span class="literal">null</span>) {</span><br><span class="line">            abd.setLazyInit(lazy.getBoolean(<span class="string">"value"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) {</span><br><span class="line">        abd.setPrimary(<span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">dependsOn</span> <span class="operator">=</span> attributesFor(metadata, DependsOn.class);</span><br><span class="line">    <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) {</span><br><span class="line">        abd.setDependsOn(dependsOn.getStringArray(<span class="string">"value"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">role</span> <span class="operator">=</span> attributesFor(metadata, Role.class);</span><br><span class="line">    <span class="keyword">if</span> (role != <span class="literal">null</span>) {</span><br><span class="line">        abd.setRole(role.getNumber(<span class="string">"value"</span>).intValue());</span><br><span class="line">    }</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">description</span> <span class="operator">=</span> attributesFor(metadata, Description.class);</span><br><span class="line">    <span class="keyword">if</span> (description != <span class="literal">null</span>) {</span><br><span class="line">        abd.setDescription(description.getString(<span class="string">"value"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里会处理传进来的类，为它创建一个 <code>BeanDefinition</code> 并设置各种属性，然后调用 <code>BeanDefinitionReaderUtils#registerBeanDefinition</code> 把这个 bean 注册到 application context 中。因为这一步传进来的只有主启动类，所以只会注册一个由主启动类生成的 bean。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">        BeanDefinitionHolder definitionHolder, </span></span><br><span class="line"><span class="params">        BeanDefinitionRegistry registry</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="comment">// 以bean的名字作为key将其注册到BeanDefinitionMap</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    <span class="comment">// 并以这个bean的各个别名再注册一遍</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) {</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenericApplicationContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionStoreException {</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition abd) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            abd.validate();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已有同名的bean被注册过了</span></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!isBeanDefinitionOverridable(beanName)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) {</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="comment">// 如果允许覆盖注册，且当前bean的级别高于已注册的bean（比如已注册的是一个应用自己的bean，但是现在正在注册一个框架提供的bean），</span></span><br><span class="line">            <span class="comment">// 那么就继续</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">                logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">                        existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                        <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                        <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 覆盖beanDefinitionMap中原有的bean</span></span><br><span class="line">        <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (isAlias(beanName)) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">aliasedName</span> <span class="operator">=</span> canonicalName(beanName);</span><br><span class="line">            <span class="keyword">if</span> (!isBeanDefinitionOverridable(aliasedName)) {</span><br><span class="line">                <span class="keyword">if</span> (containsBeanDefinition(aliasedName)) {  <span class="comment">// alias for existing bean definition</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(</span><br><span class="line">                            beanName, beanDefinition, getBeanDefinition(aliasedName));</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {  <span class="comment">// alias pointing to non-existing bean definition</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                            <span class="string">"Cannot register bean definition for bean '"</span> + beanName +</span><br><span class="line">                            <span class="string">"' since there is already an alias for bean '"</span> + aliasedName + <span class="string">"' bound."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                removeAlias(beanName);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) {</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) {</span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) {</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) {</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在启动的时候，实际会走到 <code>registerBeanDefinition</code> 方法的 <code>// Still in startup registration phase</code> 这部分。这里会把传进来的 <code>BeanDefinition</code> 注册到 <code>beanDefinitionMap</code> 中然后返回。</p><h3 id="刷新application-context"><a href="#刷新application-context" class="headerlink" title="刷新application context"></a>刷新 application context</h3><p>在创建 application context 之后，Spring Boot 会刷新它。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) {</span><br><span class="line">        shutdownHook.registerApplicationContext(context);</span><br><span class="line">    }</span><br><span class="line">    refresh(context);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> {</span><br><span class="line">    applicationContext.refresh();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServletWebServerApplicationContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="built_in">super</span>.refresh();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) {</span><br><span class="line">        <span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> <span class="built_in">this</span>.webServer;</span><br><span class="line">        <span class="keyword">if</span> (webServer != <span class="literal">null</span>) {</span><br><span class="line">            webServer.stop();</span><br><span class="line">            webServer.destroy();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException {</span><br><span class="line">    <span class="built_in">this</span>.startupShutdownLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="built_in">this</span>.startupShutdownThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">"spring.context.refresh"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 注入listener等组件，激活application context</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 得到当前application context的bean factory</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// 初始化bean factory，包括设定class loader，注入各种组件等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">// 设置beanFactory的后置处理</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">"spring.context.beans.post-process"</span>);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 调用beanFactory的后置处理</span></span><br><span class="line">            <span class="comment">// 后置处理器的工作时机是在所有BeanDefinition加载完成之后，bean实例化之前</span></span><br><span class="line">            <span class="comment">// 它可以修改BeanDefinition的属性信息</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 注册bean的后处理器</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化上下文中的消息源</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化上下文中的事件机制</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// 初始化其他特殊的bean，如创建web server</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 把listener beans注入到容器</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 把剩余尚未实例化的bean实例化</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">// 发布application context刷新完成的事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex ) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> {</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        <span class="built_in">this</span>.startupShutdownThread = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.startupShutdownLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里首先会一路走到 <code>AbstractApplicationContext#refresh</code> 方法，完成初始化 bean factory，实例化剩余的 bean 等操作。</p><h4 id="得到当前application-context的bean-factory"><a href="#得到当前application-context的bean-factory" class="headerlink" title="得到当前application context的bean factory"></a>得到当前 application context 的 bean factory</h4><p>点进 <code>obtainFreshBeanFactory</code> 方法可以看到这样的实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext</span></span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> {</span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenericApplicationContext</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">refreshed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException {</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title function_">getBeanFactory</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.beanFactory;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 <code>refreshBeanFactory</code> 方法中，Spring 会利用 <code>AtomicBoolean</code> 的 <code>compareAndSet</code> 方法来保证这个方法绝对只会被执行一次。</p><h4 id="调用beanFactory的后置处理"><a href="#调用beanFactory的后置处理" class="headerlink" title="调用beanFactory的后置处理"></a>调用 beanFactory 的后置处理</h4><p><code>invokeBeanFactoryPostProcessors</code> 这里会完成 IoC 容器初始化的三个步骤，分别是</p><ul><li>Resource 定位<br>在前面 Spring Boot 已经得到了启动类的 <code>BeanDefinition</code>，那么在这里它会解析启动类的 <code>BeanDefinition</code>，得到启动类所在的包并将其作为 <code>basePackage</code>，这就完成了定位的过程。<br>此外 Spring Boot 的各种 starter 是通过 SPI 机制实现的自动装配，而自动装配也是在这个方法中完成的。<br>还有就是，这个方法中也会处理 <code>@EnableXXX</code> 注解中通过 <code>@Import</code> 指定的配置类。</li><li>BeanDefinition 载入<br>在上一步得到了 <code>basePackage</code> 后，Spring Boot 会把路径拼接成 <code>classpath*:com/example/demo/**/*.class</code> 这样的形式，然后 <code>PathMatchingResourcePatternResolver</code> 类会把这个路径下所有的 class 都加载进来，然后遍历判断有没有 <code>@Component</code> 注解。因为 <code>@Controller</code>、<code>@Service</code>、<code>@Configuration</code> 之类的实际上只是把 <code>@Component</code> 又包了一层，所以不用单独扫描它们。</li><li>注册 BeanDefinition<br>在这一步，<code>BeanDefinitionRegister</code> 接口的实现类会把解析到的 BeanDefinition 向 IoC 容器注册。</li></ul><p>这部分实在是太长，而本文又已经够长了，所以我会<a href="/spring-boot-application-start-up-post-processing.html">单开一篇来细说</a>。</p><h4 id="把剩余尚未实例化的bean实例化"><a href="#把剩余尚未实例化的bean实例化" class="headerlink" title="把剩余尚未实例化的bean实例化"></a>把剩余尚未实例化的 bean 实例化</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no BeanFactoryPostProcessor</span></span><br><span class="line">    <span class="comment">// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) {</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) {</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    <span class="comment">// 冻结bean definition，不再允许新的修改</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    <span class="comment">// 开始实例化bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">        logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) {</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> SmartFactoryBean&lt;?&gt; smartFactoryBean &amp;&amp; smartFactoryBean.isEagerInit()) {</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton smartSingleton) {</span><br><span class="line">            <span class="type">StartupStep</span> <span class="variable">smartInitialize</span> <span class="operator">=</span> getApplicationStartup().start(<span class="string">"spring.beans.smart-initialize"</span>).tag(<span class="string">"beanName"</span>, beanName);</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            smartInitialize.end();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第一个 for 循环的重点在于 <code>getBean</code> 方法，逐层点进实现，最终会进入 <code>AbstractBeanFactory#doGetBean</code> 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">    String name, </span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, </span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> Object[] args, </span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> typeCheckOnly</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object beanInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">// 先检查这个bean是不是一个已经注册过的singleton，并尝试获取。</span></span><br><span class="line">    <span class="comment">// 如果它已经注册过，但是尚未实例化的话，这个方法会将其实例化并返回。</span></span><br><span class="line">    <span class="comment">// 方法里面是一个复杂的双检锁单例模式。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">                logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 检测bean的正确性，如果获取到的是FactoryBean的话，那么还会调用getObject()方法得到最终的bean实例</span></span><br><span class="line">        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        <span class="comment">// 检查容器中是否存在这个bean的BeanDefinition，如果在当前的工厂中找不到，那就到父级BeanFactory中去找，</span></span><br><span class="line">        <span class="comment">// 如果还找不到那就继续往更上一级去找</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) {</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory abf) {</span><br><span class="line">                <span class="comment">// 递归调用父级的doGetBean查找</span></span><br><span class="line">                <span class="keyword">return</span> abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) {</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">beanCreation</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">"spring.beans.instantiate"</span>).tag(<span class="string">"beanName"</span>, name);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) {</span><br><span class="line">                beanCreation.tag(<span class="string">"beanType"</span>, requiredType::toString);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 根据Bean的名字得到它的BeanDefinition</span></span><br><span class="line">            <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            <span class="comment">// 获取当前bean的所有依赖bean。</span></span><br><span class="line">            <span class="comment">// 这里会递归调用getBean()，直到取到一个没有任何依赖的bean</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) {</span><br><span class="line">                    <span class="comment">// 如果被依赖的bean也依赖它，那就循环依赖了，没法处理，抛异常</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="comment">// 创建并注册这个singleton bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) {</span><br><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                }</span><br><span class="line">                beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"No scope name defined for bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; {</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">finally</span> {</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                    beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">            beanCreation.tag(<span class="string">"exception"</span>, ex.getClass().toString());</span><br><span class="line">            beanCreation.tag(<span class="string">"message"</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">finally</span> {</span><br><span class="line">            beanCreation.end();</span><br><span class="line">            <span class="keyword">if</span> (!isCacheBeanMetadata()) {</span><br><span class="line">                clearMergedBeanDefinition(beanName);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在检查 bean 是否存在时调用的 <code>getSingleton()</code> 是这样实现的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> {</span><br><span class="line">    <span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">    <span class="comment">// 尝试从缓存中取出这个单例的实例</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 如果要获取的bean没有被加载，而且没有正在被创建，那么就主动加载这个bean</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">        <span class="comment">// 尝试去earlySingletonObjects里面去找</span></span><br><span class="line">        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) {</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) {</span><br><span class="line">                <span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">                <span class="comment">// 加锁后再次尝试去singletonObjects和earlySingletonObjects里面找</span></span><br><span class="line">                singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) {</span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) {</span><br><span class="line">                        <span class="comment">// 如果还是找不到，那么就到singletonFactories里面去找对象的实例</span></span><br><span class="line">                        ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) {</span><br><span class="line">                            singletonObject = singletonFactory.getObject();</span><br><span class="line">                            <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                            <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果 <code>Object sharedInstance = getSingleton(beanName)</code> 这一步得到的是 null，那么容器就会调用 <code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code> 方法来创建这个 bean。传给 <code>singletonFactory</code> 的 lambda 表达式中调用了 <code>createBean()</code> 方法，它又调用了 <code>doCreateBean()</code> 方法完成实际的 bean 创建操作。</p><h5 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建 bean</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="comment">// instanceWrapper用来持有创建出来的bean对象</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">        <span class="comment">// 如果是单例的话，那么先把缓存中同名的bean清除</span></span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建bean第一步：创建实例</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) {</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) {</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) {</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">            mbd.markAsPostProcessed();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">// 当这个bean是一个单例，并且允许循环引用，且这个bean正在创建中时，</span></span><br><span class="line">    <span class="comment">// 就提前暴露一个ObjectFactory，来自动解决循环引用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        }</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 创建bean第二步：设置实例的属性。依赖注入就发生在这里。</span></span><br><span class="line">        <span class="comment">// 如果存在依赖其他bean的属性，那么就递归调用，初始化依赖的bean</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 创建bean第三步：调用bean的初始化方法，如 init-method 指定的方法</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException bce &amp;&amp; beanName.equals(bce.getBeanName())) {</span><br><span class="line">            <span class="keyword">throw</span> bce;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) {</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) {</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么 <code>doCreateBean()</code> 方法是怎么创建 bean 的实例的呢？我们继续看 <code>createBeanInstance()</code> 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> {</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    <span class="comment">// 首先确认这个bean所属的类可以被实例化</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName, mbd);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有工厂方法，那么就用工厂方法来初始化bean</span></span><br><span class="line">    <span class="comment">// 比如配置时在XML中指定factory-method属性，或把带有@Bean注解的方法的返回值作为bean</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) {</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) {</span><br><span class="line">                resolved = <span class="literal">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果在重新创建一个bean</span></span><br><span class="line">    <span class="keyword">if</span> (resolved) {</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) {</span><br><span class="line">            <span class="comment">// 需要调用有参数的构造方法完成注入的话，那就通过构造方法完成依赖注入</span></span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 否则调用默认构造方法</span></span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">    <span class="comment">// 寻找可以用来初始化的构造方法</span></span><br><span class="line">    <span class="comment">// 如果有的话，那么再逐个匹配，并调用合适的构造方法完成初始化</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">    <span class="comment">// 否则调用默认构造方法完成实例化</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="设置被注入属性的值"><a href="#设置被注入属性的值" class="headerlink" title="设置被注入属性的值"></a>设置被注入属性的值</h5><p>完成实例化后就会开始填充这个 bean 的属性了，继续看 <code>populateBean()</code> 的实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> {</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bw.getWrappedClass().isRecord()) {</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasPropertyValues()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to a record"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Skip property population phase for records since they are immutable.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">    <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">    <span class="comment">// to support styles of field injection.</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {</span><br><span class="line">            <span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得在BeanDefinition中设定的property值</span></span><br><span class="line">    <span class="comment">// 这些值可以在XML中用 &lt;property&gt; 属性配置</span></span><br><span class="line">    <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {</span><br><span class="line">        <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="comment">// 用by name的方式完成属性注入</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) {</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="comment">// 用by type的方式完成属性注入</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        }</span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="literal">null</span>) {</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {</span><br><span class="line">            <span class="comment">// 完成@Autowire、@Inject等注解的依赖注入</span></span><br><span class="line">            <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) {</span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 注入配置文件中&lt;property&gt;配置的属性</span></span><br><span class="line">        applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中 <code>PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName)</code> 这一行完成了 <code>@Autowire</code> 等注解的注入，那么继续看它的实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> {</span><br><span class="line">    <span class="comment">// 查找@Autowired、@Inject等注解，并解析出依赖注入的元数据</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 完成注入</span></span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) {</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我创建了一个 <code>DemoController</code>，并在其中用属性注入的方式声明需要注入 <code>DemoService</code>（<code>@Autowired private DemoService demoService</code>），然后在 <code>findAutowiringMetadata</code> 这行下个断点调试，就能看到这样的结果：</p><p><img data-src="https://blog-static.boris1993.com/how-spring-boot-application-starts-up/find_autowiring_metadata.png"></p><p>具体的注入是这样实现的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">    <span class="comment">// 得到要注入的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> (Field) <span class="built_in">this</span>.member;</span><br><span class="line">    Object value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cached) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            value = resolveCachedArgument(beanName, <span class="built_in">this</span>.cachedFieldValue);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">            <span class="comment">// Unexpected target bean mismatch for cached argument -&gt; re-resolve</span></span><br><span class="line">            <span class="built_in">this</span>.cached = <span class="literal">false</span>;</span><br><span class="line">            logger.debug(<span class="string">"Failed to resolve cached argument"</span>, ex);</span><br><span class="line">            value = resolveFieldValue(field, bean, beanName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 通过BeanFactory解决依赖关系</span></span><br><span class="line">        value = resolveFieldValue(field, bean, beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 解决依赖关系并得到被注入对象的实例后，通过反射把值设置进去</span></span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) {</span><br><span class="line">        ReflectionUtils.makeAccessible(field);</span><br><span class="line">        field.set(bean, value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="调用bean的初始化方法"><a href="#调用bean的初始化方法" class="headerlink" title="调用bean的初始化方法"></a>调用 bean 的初始化方法</h5><p><code>populateBean()</code> 执行完毕后就会调用 <code>initializeBean()</code> 方法来调用 bean 的初始化方法（XML 或 <code>@Bean</code> 注解配置的 <code>initMethod</code>，或 Bean 实现的 <code>InitializingBean#afterPropertiesSet()</code> 方法）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> {</span><br><span class="line">    <span class="comment">// 调用一系列的aware接口实现</span></span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">        <span class="comment">// 初始化前调用BeanPostProcessor</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用初始化方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">        <span class="comment">// 初始化后调用BeanPostProcessor</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> {</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) {</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware beanNameAware) {</span><br><span class="line">            beanNameAware.setBeanName(beanName);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware beanClassLoaderAware) {</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">bcl</span> <span class="operator">=</span> getBeanClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (bcl != <span class="literal">null</span>) {</span><br><span class="line">                beanClassLoaderAware.setBeanClassLoader(bcl);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware beanFactoryAware) {</span><br><span class="line">            beanFactoryAware.setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="built_in">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="启动部分的收尾工作"><a href="#启动部分的收尾工作" class="headerlink" title="启动部分的收尾工作"></a>启动部分的收尾工作</h3><p>在完成刷新 application context 之后，Spring Boot 会发布 <code>ApplicationStartedEvent</code> 和 <code>ApplicationReadyEvent</code> 事件，调用各个 <code>Runner</code>，然后应用正式启动开始运行</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDM1OTEwNTA1ODEwMTAwMjU1">spring boot 启动流程分析<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83MzY3ZGRkYWIyMGQ=">spring boot 中的 spring factories 机制<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjI5MjcyOTQzMzEyOTYxNTky">应用启动过程 —— 准备应用上下文<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjI5MjY5MjQ2NjgwODkxNDUx">应用启动过程 ——BootstrapContext<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTM5OTAxL2FydGljbGUvZGV0YWlscy8xMzQ5Njc0OTk=">SpringApplication 中文文档<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83NjQ1Mjk3ZjI2ZGE=">Spring Boot 应用 Main 函数入口 Primary Source<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3Ryb25nbW9yZS9wLzE2MjIwODAwLmh0bWw=">Spring 源码分析之 ConversionService<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmluYXJ5bGVpL3AvMTAyNjM1ODEuaHRtbA==">Spring ConversionService 类型转换（一）Converter<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MDg3NTc0NTQ0Mzk4">走心 Springboot 源码解析： 三、prepareEnvironment () 环境配置 解析配置文件信息<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Java/">Java</category>
      
      <category domain="https://www.boris1993.com/tags/Spring-Boot/">Spring Boot</category>
      
      
      <comments>https://www.boris1993.com/spring-boot-application-starts-up.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java 源码阅读 - Timer</title>
      <link>https://www.boris1993.com/java-read-src-timer.html</link>
      <guid>https://www.boris1993.com/java-read-src-timer.html</guid>
      <pubDate>Tue, 19 Dec 2023 13:25:18 GMT</pubDate>
      
      <description>&lt;p&gt;前段时间拿 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 和 &lt;code&gt;Timer&lt;/code&gt; 简单整了个带过期功能的缓存，那用都用了，顺便就看看 &lt;code&gt;Timer&lt;/code&gt; 这玩意是咋实现的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>前段时间拿 <code>ConcurrentHashMap</code> 和 <code>Timer</code> 简单整了个带过期功能的缓存，那用都用了，顺便就看看 <code>Timer</code> 这玩意是咋实现的。</p><span id="more"></span><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>这段代码的背景是，我们想要把已经验证通过的 token 缓存起来，下次遇到同样的 token 就不需要再浪费 CPU 做重复的校验，直接从缓存中返回解析好的 token 对象就行。而因为 token 会过期，所以要每秒检查一次缓存里面是否有 token 过期，并批量从缓存中删除。</p><p>验证和缓存 token 那部份不是本文重点，就不写了。清除过期缓存的 <code>Timer</code> 就是这样实现的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个Timer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">purgeCacheTimer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造方法里面注册一个定时任务</span></span><br><span class="line">purgeCacheTimer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; expiredTokenList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, Object&gt; token : validatedTokenCache.entrySet()) {</span><br><span class="line">            <span class="keyword">if</span> (isTokenExpired(token.getValue())) {</span><br><span class="line">                expiredTokenList.add(token.getKey());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        expiredTokenList.forEach(validatedTokenCache::remove);</span><br><span class="line">    }</span><br><span class="line">}, <span class="number">1000</span>, <span class="number">1000</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="Timer的核心数据结构"><a href="#Timer的核心数据结构" class="headerlink" title="Timer的核心数据结构"></a><code>Timer</code> 的核心数据结构</h2><p>点进 <code>Timer</code> 类就能在开头看到两个属性：<code>queue</code> 和 <code>thread</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The timer task queue.  This data structure is shared with the timer</span></span><br><span class="line"><span class="comment"> * thread.  The timer produces tasks, via its various schedule calls,</span></span><br><span class="line"><span class="comment"> * and the timer thread consumes, executing timer tasks as appropriate,</span></span><br><span class="line"><span class="comment"> * and removing them from the queue when they're obsolete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The timer thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TimerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerThread</span>(queue);</span><br></pre></td></tr></tbody></table></figure><p><code>queue</code> 所属的 <code>TaskQueue</code> 就是这个 <code>Timer</code> 用来存储任务的队列，里面是把一个数组处理成了一个优先队列。<code>thread</code> 所属的 <code>TimerThread</code> 类则是 <code>Timer</code> 的核心，负责任务调度。</p><h2 id="任务是怎么添加进队列的"><a href="#任务是怎么添加进队列的" class="headerlink" title="任务是怎么添加进队列的"></a>任务是怎么添加进队列的</h2><p>先看看给 <code>Timer</code> 添加任务会发生什么。点进 <code>scheduleAtFixedRate</code> 可以看到这么一段代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleAtFixedRate</span><span class="params">(TimerTask task, <span class="type">long</span> delay, <span class="type">long</span> period)</span> {</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Negative delay."</span>);</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Non-positive period."</span>);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, period);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>跟着点进 <code>sched</code> 可以看到这么一段：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sched</span><span class="params">(TimerTask task, <span class="type">long</span> time, <span class="type">long</span> period)</span> {</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal execution time."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constrain value of period sufficiently to prevent numeric</span></span><br><span class="line">    <span class="comment">// overflow while still being effectively infinitely large.</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">        period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(queue) {</span><br><span class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"Timer already cancelled."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(task.lock) {</span><br><span class="line">            <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">"Task already scheduled or cancelled"</span>);</span><br><span class="line">            task.nextExecutionTime = time;</span><br><span class="line">            task.period = period;</span><br><span class="line">            task.state = TimerTask.SCHEDULED;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        queue.add(task);</span><br><span class="line">        <span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">            queue.notify();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看下来其实就做了两件事：向 <code>queue</code> 里面增加一个 <code>TimerTask</code> 对象，然后检查队列里面即将执行的 task，如果是刚添加的这个 task 那就唤醒任务。</p><h2 id="任务是怎么被调度的"><a href="#任务是怎么被调度的" class="headerlink" title="任务是怎么被调度的"></a>任务是怎么被调度的</h2><p>点进 <code>TimerThread</code> 首先可以看到它的 <code>run</code> 方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        mainLoop();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></span><br><span class="line">        <span class="keyword">synchronized</span>(queue) {</span><br><span class="line">            newTasksMayBeScheduled = <span class="literal">false</span>;</span><br><span class="line">            queue.clear();  <span class="comment">// Eliminate obsolete references</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为 <code>TimerThread</code> 继承自 <code>Thread</code> 类，所以 <code>run</code> 方法就是它的入口点。在 <code>Timer</code> 的构造函数中就会执行 <code>thread.start()</code> 操作，所以这个调度线程在 <code>Timer</code> 被创建后就会开始运行。</p><p>继续看看 <code>mainLoop</code> 里面干了些啥。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main timer loop.  (See class comment.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mainLoop</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimerTask task;</span><br><span class="line">            <span class="type">boolean</span> taskFired;</span><br><span class="line">            <span class="keyword">synchronized</span>(queue) {</span><br><span class="line">                <span class="comment">// Wait for queue to become non-empty</span></span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                    queue.wait();</span><br><span class="line">                <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></span><br><span class="line">                <span class="type">long</span> currentTime, executionTime;</span><br><span class="line">                task = queue.getMin();</span><br><span class="line">                <span class="keyword">synchronized</span>(task.lock) {</span><br><span class="line">                    <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) {</span><br><span class="line">                        queue.removeMin();</span><br><span class="line">                        <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">                    }</span><br><span class="line">                    currentTime = System.currentTimeMillis();</span><br><span class="line">                    executionTime = task.nextExecutionTime;</span><br><span class="line">                    <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) {</span><br><span class="line">                        <span class="keyword">if</span> (task.period == <span class="number">0</span>) { <span class="comment">// Non-repeating, remove</span></span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            task.state = TimerTask.EXECUTED;</span><br><span class="line">                        } <span class="keyword">else</span> { <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">                            queue.rescheduleMin(</span><br><span class="line">                                task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                            : executionTime + task.period);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></span><br><span class="line">                    queue.wait(executionTime - currentTime);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></span><br><span class="line">                task.run();</span><br><span class="line">        } <span class="keyword">catch</span>(InterruptedException e) {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先它检查队列是否为空，如果是空的，那么这个调度线程就会进入等待状态（这就是在添加任务之后要调用 <code>notify()</code> 方法的原因）；如果不仅队列是空的，而且队列不再接收新的任务，那么就说明这个 <code>Timer</code> 正在被销毁，所以直接退出循环。</p><p>如果队列非空，那么调度线程就从队列中取出最接近下一个执行时机的任务，然后安排下一次任务执行的时间。同时，在取出最近需要执行的任务后，调度线程会比较当前时间与计划执行时间，如果当前时间还没到，那么调度线程会 <code>wait</code> 到计划执行时间。最后，调用 <code>TimerTask</code> 的 <code>run</code> 方法，开始执行我们指定它做的事。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说白了就是俩东西：</p><ul><li>一个保存任务的队列，里面的任务按照执行时间排队</li><li>一个死循环，反复从队列里面取出最接近下一个执行时机的任务，执行它，并安排下一次的时机</li></ul><p>这玩意优点就是简单粗暴而且轻量级，但因为它是单线程的，如果某个任务执行时间过长，那么后续任务有可能会受影响；而且因为系统调度和任务执行时间的不确定性，它不能提供高精度的定时任务服务；此外，如果其中某个任务抛出了未处理的异常，那么整个 <code>Timer</code> 都会挂掉，也会影响到同一个队列里面的其他任务。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Java/">Java</category>
      
      <category domain="https://www.boris1993.com/tags/Timer/">Timer</category>
      
      
      <comments>https://www.boris1993.com/java-read-src-timer.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java 源码阅读 - 类加载的双亲委派模型</title>
      <link>https://www.boris1993.com/java-read-src-parent-delegation-model.html</link>
      <guid>https://www.boris1993.com/java-read-src-parent-delegation-model.html</guid>
      <pubDate>Wed, 13 Dec 2023 15:29:52 GMT</pubDate>
      
      <description>&lt;p&gt;关于 Java 的类加载机制，尽管我看过几篇文章，知道个&lt;code&gt;双亲委派模型&lt;/code&gt;，但是从来没钻进源码里看它到底是怎么委派的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>关于 Java 的类加载机制，尽管我看过几篇文章，知道个<code>双亲委派模型</code>，但是从来没钻进源码里看它到底是怎么委派的。</p><span id="more"></span><h2 id="什么双亲？怎么委派？"><a href="#什么双亲？怎么委派？" class="headerlink" title="什么双亲？怎么委派？"></a>什么双亲？怎么委派？</h2><p>我刚一开始听到<code>双亲委派</code>，还纳闷咋还双亲？后来才知道，这纯纯就是 <code>Parent Delegation</code> 这个词的误译。<code>Parent</code> 这里指的并不是双亲，而是指父辈。所以看到有人翻译为 “向上委托模型”，我感觉这个翻译更好一点，至于另一个翻译 “啃老模型”…… 倒也没毛病……</p><p>至于怎么委托，相信各位都背的滚瓜烂熟了。那就是，当类加载器收到类加载请求的时候，它首先会把这个请求委托给上一层的类加载器去尝试加载，直到委托到启动类加载器；只有当上一层类加载器无法完成这个加载请求的时候，次一级类加载器才会尝试自己加载。</p><p><img data-src="https://blog-static.boris1993.com/java-read-src-parent-delegation-model/classloader-relationship.png"></p><h2 id="代码上的实现"><a href="#代码上的实现" class="headerlink" title="代码上的实现"></a>代码上的实现</h2><p>截图里面的代码就是 <code>ClassLoader#loadClass</code> 方法的实现，来自 <code>Liberica JDK 8</code>。</p><p><img data-src="https://blog-static.boris1993.com/java-read-src-parent-delegation-model/load-class-method-implementation.png"></p><p>看得出来，逻辑还是很简单易懂的。一进来先加个锁，防止出现并发问题。然后检查这个类是不是已经被加载了。没被加载的话，就一层层向上委托，直到到达启动类加载器。如果上一层类加载器返回了 <code>null</code> 或者抛出了 <code>ClassNotFoundException</code> 异常，就说明它没找到这个类，那么本层类加载器就会尝试加载这个类，如果找不到的话，它就接着把请求交回下一层的类加载器。</p><p>虽然上面的图和代码已经可以解释双亲委派的工作机制，但我还是喜欢调试进去看看代码具体是咋走的。所以我写了这么几行，用来调试类加载器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Main.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader.toString());</span><br><span class="line">        <span class="comment">// 在下面这一行下个断点，走到这一行之后再给 ClassLoader#loadClass 下个断点</span></span><br><span class="line">        classLoader.loadClass(<span class="string">"DaemonThreadDemo"</span>);</span><br><span class="line">        classLoader.loadClass(<span class="string">"java.util.HashMap"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>断点从 <code>classLoader.loadClass("DaemonThreadDemo")</code> 这一行进去并停留在 <code>if (c == null)</code> 之后可以看到，目前类加载的委托请求是交给 <code>AppClassLoader</code>，看得出来，这个就是应用类加载器。</p><p><img data-src="https://blog-static.boris1993.com/java-read-src-parent-delegation-model/debug-classloader-1.png"></p><p>继续往下走到 <code>c = parent.loadClass(name, false)</code> 这一行，然后给 <code>parent</code> 变量添加一个监视，就可以看到接下来 <code>AppClassLoader</code> 要把这个类加载请求委托给 <code>ExtClassLoader</code>，同理可得，这个就是扩展类加载器。</p><p><img data-src="https://blog-static.boris1993.com/java-read-src-parent-delegation-model/debug-classloader-2.png"></p><p>接着往下走，继续调试 <code>ExtClassLoader</code>，这时候可以看到 <code>parent</code> 是 <code>null</code>。没有了 <code>parent</code>，这个类加载器就会将这个类加载请求委托给启动类加载器并尝试加载这个类。</p><p><img data-src="https://blog-static.boris1993.com/java-read-src-parent-delegation-model/debug-classloader-3.png"></p><p>逐层点进去，可以看到如下代码：</p><p><img data-src="https://blog-static.boris1993.com/java-read-src-parent-delegation-model/debug-classloader-4.png"></p><p>emmmm…… 走到了一个 native 方法了呢…… 嘛，里面的代码先不管了，看名字能猜得出来，在这里会调用启动类加载器来尝试加载这个类。</p><p>因为要加载的 <code>DaemonThreadDemo</code> 类并不归启动类加载器管，所以 <code>findBootstrapClassOrNull</code> 返回了 <code>null</code>。<code>ExtClassLoader</code> 得知启动类加载器加载失败，那么它自己就会再尝试加载。然而这个类也不归扩展类加载器管，所以在 <code>ExtClassLoader</code> 里面调用 <code>findClass</code> 方法会抛出 <code>ClassNotFoundException</code> 异常并返回到 <code>AppClassLoader</code>。</p><p>这时候，因为 <code>DaemonThreadDemo</code> 这个类归应用类加载器管，所以这一次调用 <code>findClass</code> 成功的找到了这个类。</p><p><img data-src="https://blog-static.boris1993.com/java-read-src-parent-delegation-model/debug-classloader-5.png"></p><p>所以代码可以成功走到 <code>return c</code> 这一行，来完成一个类的加载。</p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>说到双亲委派模型，必会谈到怎么破坏它。看完上面的代码就明白了，我们可以自己创建一个自定义类加载器，并重写 <code>loadClass</code> 方法，不让它向上委派就行了。</p><h2 id="番外：尝试理解findBootstrapClass"><a href="#番外：尝试理解findBootstrapClass" class="headerlink" title="番外：尝试理解findBootstrapClass"></a>番外：尝试理解 <code>findBootstrapClass</code></h2><p>虽然这部分是 C 和 C++ 的实现，但还是想硬着头皮尝试看一下。到 <code>Bellsoft</code> 的官网下载<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5iZWxsLXN3LmNvbS9qYXZhLzh1MzkyKzkvYmVsbHNvZnQtamRrOHUzOTIrOS1zcmMudGFyLmd6">虚拟机的源码<i class="fa fa-external-link-alt"></i></span>之后，我找到了 <code>FindBootStrapClass</code> 函数的实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这部分代码在 java_md.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The implementation for finding classes from the bootstrap</span></span><br><span class="line"><span class="comment"> * class loader, refer to java.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> FindClassFromBootLoader_t *findBootClass = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">jclass <span class="title function_">FindBootStrapClass</span><span class="params">(JNIEnv *env, <span class="type">const</span> <span class="type">char</span> *classname)</span></span><br><span class="line">{</span><br><span class="line">   HMODULE hJvm;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (findBootClass == <span class="literal">NULL</span>) {</span><br><span class="line">       hJvm = GetModuleHandle(JVM_DLL);</span><br><span class="line">       <span class="keyword">if</span> (hJvm == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       <span class="comment">/* need to use the demangled entry point */</span></span><br><span class="line">       findBootClass = (FindClassFromBootLoader_t *)GetProcAddress(hJvm,</span><br><span class="line">            <span class="string">"JVM_FindClassFromBootLoader"</span>);</span><br><span class="line">       <span class="keyword">if</span> (findBootClass == <span class="literal">NULL</span>) {</span><br><span class="line">          JLI_ReportErrorMessage(DLL_ERROR4, <span class="string">"JVM_FindClassFromBootLoader"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> findBootClass(env, classname);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个 C 语言…… 确实跟我大学学的 C 语言不一样啊…… 爬了些文，大概理解这里是要找 <code>JVM_FindClassFromBootLoader</code> 这个函数的实际地址，然后赋给 <code>findBootClass</code> 指针并执行它的代码。于是我接着挖到了 <code>JVM_FindClassFromBootLoader</code> 函数的实现。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这部分代码在 jvm.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a class loaded by the bootstrap class loader; or null</span></span><br><span class="line"><span class="comment">// if not found.  ClassNotFoundException is not thrown.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Rationale behind JVM_FindClassFromBootLoader</span></span><br><span class="line"><span class="comment">// a&gt; JVM_FindClassFromClassLoader was never exported in the export tables.</span></span><br><span class="line"><span class="comment">// b&gt; because of (a) java.dll has a direct dependecy on the  unexported</span></span><br><span class="line"><span class="comment">//    private symbol "_JVM_FindClassFromClassLoader@20".</span></span><br><span class="line"><span class="comment">// c&gt; the launcher cannot use the private symbol as it dynamically opens</span></span><br><span class="line"><span class="comment">//    the entry point, so if something changes, the launcher will fail</span></span><br><span class="line"><span class="comment">//    unexpectedly at runtime, it is safest for the launcher to dlopen a</span></span><br><span class="line"><span class="comment">//    stable exported interface.</span></span><br><span class="line"><span class="comment">// d&gt; re-exporting JVM_FindClassFromClassLoader as public, will cause its</span></span><br><span class="line"><span class="comment">//    signature to change from _JVM_FindClassFromClassLoader@20 to</span></span><br><span class="line"><span class="comment">//    JVM_FindClassFromClassLoader and will not be backward compatible</span></span><br><span class="line"><span class="comment">//    with older JDKs.</span></span><br><span class="line"><span class="comment">// Thus a public/stable exported entry point is the right solution,</span></span><br><span class="line"><span class="comment">// public here means public in linker semantics, and is exported only</span></span><br><span class="line"><span class="comment">// to the JDK, and is not intended to be a public API.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JVM_ENTRY</span>(jclass, <span class="built_in">JVM_FindClassFromBootLoader</span>(JNIEnv* env,</span><br><span class="line">                                              <span class="type">const</span> <span class="type">char</span>* name))</span><br><span class="line">  <span class="built_in">JVMWrapper2</span>(<span class="string">"JVM_FindClassFromBootLoader %s"</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java libraries should ensure that name is never null...</span></span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">NULL</span> || (<span class="type">int</span>)<span class="built_in">strlen</span>(name) &gt; Symbol::<span class="built_in">max_length</span>()) {</span><br><span class="line">    <span class="comment">// It's impossible to create this class;  the name cannot fit</span></span><br><span class="line">    <span class="comment">// into the constant pool.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  TempNewSymbol h_name = SymbolTable::<span class="built_in">new_symbol</span>(name, CHECK_NULL);</span><br><span class="line">  Klass* k = SystemDictionary::<span class="built_in">resolve_or_null</span>(h_name, CHECK_NULL);</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TraceClassResolution) {</span><br><span class="line">    <span class="built_in">trace_class_resolution</span>(k);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> (jclass) JNIHandles::<span class="built_in">make_local</span>(env, k-&gt;<span class="built_in">java_mirror</span>());</span><br><span class="line">JVM_END</span><br></pre></td></tr></tbody></table></figure><p>好吧，更看不懂了。继续爬了文之后，理解这里大致做了三件事：从常量池中拿到类名的信息；查找类的信息并实例化 <code>Klass</code>；将 <code>Klass</code> 对象转换为 <code>jclass</code> 类型并返回。</p><p>算了，虚拟机源码就看到这吧…… 有兴趣的同志可以看<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veW91Z2V3ZS9wLzE0NDI2OTM2Lmh0bWw="> JVM 系列 (四)：java 方法的查找过程实现<i class="fa fa-external-link-alt"></i></span>这篇博客。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Java/">Java</category>
      
      <category domain="https://www.boris1993.com/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/">双亲委派</category>
      
      <category domain="https://www.boris1993.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</category>
      
      
      <comments>https://www.boris1993.com/java-read-src-parent-delegation-model.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>volatile 修饰符在双检锁单例模式中的作用</title>
      <link>https://www.boris1993.com/java-volatile-in-double-checked-singleton.html</link>
      <guid>https://www.boris1993.com/java-volatile-in-double-checked-singleton.html</guid>
      <pubDate>Sun, 10 Dec 2023 08:08:44 GMT</pubDate>
      
      <description>&lt;p&gt;在实现一个双检锁单例的时候，IDEA 提示我要给 &lt;code&gt;INSTANCE&lt;/code&gt; 实例加上 &lt;code&gt;volatile&lt;/code&gt; 修饰符。当时并不明白为啥，所以选择相信 IDE。但是还是那句话，不能知其然不知其所以然啊，自己写的代码，不能自己心里没底不是。于是乎我一顿网上冲浪，终于整明白了为啥双检单例必须要用 &lt;code&gt;volatile&lt;/code&gt; 修饰符。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在实现一个双检锁单例的时候，IDEA 提示我要给 <code>INSTANCE</code> 实例加上 <code>volatile</code> 修饰符。当时并不明白为啥，所以选择相信 IDE。但是还是那句话，不能知其然不知其所以然啊，自己写的代码，不能自己心里没底不是。于是乎我一顿网上冲浪，终于整明白了为啥双检单例必须要用 <code>volatile</code> 修饰符。</p><span id="more"></span><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>这个单例类没什么好说的，就是一个平平无奇的双检锁单例实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) {</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// Do something here</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而 IDEA 在外层的 <code>if</code> 上标了一个警告，并且建议我给 <code>INSTANCE</code> 变量加上 <code>volatile</code> 修饰符。</p><p><img data-src="https://blog-static.boris1993.com/java-volatile-in-double-checked-singleton/suggestion-in-idea.png"></p><h2 id="如果不加volatile会有什么问题"><a href="#如果不加volatile会有什么问题" class="headerlink" title="如果不加volatile会有什么问题"></a>如果不加 <code>volatile</code> 会有什么问题</h2><p>上面的代码，乍一看非常严谨，在发现 <code>INSTANCE</code> 是 <code>null</code> 的时候，就对其加锁并再检查一次，还是 <code>null</code> 的话就为它创建一个新的实例，最后返回它。但是看了一些文章之后发现，在多线程场景下，有可能出现虽然成功获取到 <code>INSTANCE</code>，但在调用其中的方法时仍然抛出空指针异常的诡异情况。</p><p>比如有这样一个场景，<code>Thread 1</code> 和 <code>Thread 2</code> 同时请求了 <code>Singleton#getInstance()</code> 方法，<code>Thread 1</code> 执行到了第 8 行，开始实例化这个对象；而 <code>Thread 2</code> 执行到了第 5 行，开始检查 <code>INSTANCE</code> 是否为 <code>null</code>。这个时候，有一定几率，虽然 <code>Thread 2</code> 检查到 <code>INSTANCE</code> 并不是 <code>null</code>，但是调用 <code>Singleton#doSomething()</code> 方法的时候却会抛出空指针异常。</p><p><img data-src="https://blog-static.boris1993.com/java-volatile-in-double-checked-singleton/instance-accessed-by-multi-threads.png"></p><p>造成这个问题的原因就是 Java 的指令重排。</p><p>在搞清楚 <code>Thread 2</code> 看到 <code>INSTANCE</code> 虽然不是 <code>null</code>，却在方法调用的时候会抛空指针异常的原因之前，先要搞清楚实例化对象的时候，JVM 到底干了什么。</p><p>JVM 实例化一个对象的过程，大致可以分为这几步：</p><ol><li>JVM 为这个对象分配一片内存</li><li>在这片内存上初始化这个对象</li><li>将这片内存的地址赋值给 <code>INSTANCE</code> 变量</li></ol><p>因为把内存地址赋值给 <code>INSTANCE</code> 是最后一步，所以 <code>Thread 1</code> 在这一步执行之前，<code>Thread 2</code> 对 <code>INSTANCE == null</code> 的判断一定为 <code>true</code>，进而因为拿不到 <code>Singleton</code> 类的锁而被阻塞，直到 <code>Thread 1</code> 完成对 <code>INSTANCE</code> 变量的实例化。</p><p>但是，上面这三步它不是个原子操作，并且 JVM 可能会进行重排序，也就是说上面这三步可能被重排成</p><ol><li>JVM 为这个对象分配一片内存</li><li>将这片内存的地址赋值给 <code>INSTANCE</code> 变量</li><li>在这片内存上初始化这个对象</li></ol><p>你看，这问题就来了，如果在 <code>Thread 1</code> 做完第二步但没做第三步的时候，<code>Thread 2</code> 开始检查 <code>INSTANCE</code> 是不是 <code>null</code> 就会得到 <code>false</code>，然后就走到 <code>return</code>，得到一个不完整的 <code>INSTANCE</code> 对象。这时候，虽然 <code>INSTANCE</code> 不是 <code>null</code>，但同时它也没有完成初始化，所以 <code>Thread 2</code> 在调用 <code>Singleton#doSomething()</code> 方法的时候，就会抛出空指针异常。</p><p>这个问题的解决方案就是 <code>volatile</code> 修饰符，因为它可以禁止指令重排，所以在给 <code>INSTANCE</code> 加上 <code>volatile</code> 之后，JVM 就会老老实实的先初始化好这个对象，再为 <code>INSTANCE</code> 赋值，这样多线程场景下每个线程得到的 <code>INSTANCE</code> 实例都会是一个初始化好了的 <code>Singleton</code> 对象。</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/learning/">学知识</category>
      
      
      <category domain="https://www.boris1993.com/tags/Java/">Java</category>
      
      <category domain="https://www.boris1993.com/tags/volatile/">volatile</category>
      
      <category domain="https://www.boris1993.com/tags/singleton/">singleton</category>
      
      <category domain="https://www.boris1993.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</category>
      
      <category domain="https://www.boris1993.com/tags/%E5%8F%8C%E6%A3%80%E9%94%81/">双检锁</category>
      
      
      <comments>https://www.boris1993.com/java-volatile-in-double-checked-singleton.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>梦幻电子宠物 - 雪儿</title>
      <link>https://www.boris1993.com/virtual-pet-xue-er.html</link>
      <guid>https://www.boris1993.com/virtual-pet-xue-er.html</guid>
      <pubDate>Mon, 27 Nov 2023 15:08:32 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;突然想起来小时候玩过的一个电子宠物游戏《梦幻电子宠物》。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主窗口&lt;/th&gt;
&lt;th&gt;宠物状态&lt;/th&gt;
&lt;th&gt;关于&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;img data-src</description>
        
      
      
      
      <content:encoded><![CDATA[<p>突然想起来小时候玩过的一个电子宠物游戏《梦幻电子宠物》。</p><table><thead><tr><th>主窗口</th><th>宠物状态</th><th>关于</th></tr></thead><tbody><tr><td><img data-src="https://blog-static.boris1993.com/virtual-pet-xue-er/main_window.png"></td><td><img data-src="https://blog-static.boris1993.com/virtual-pet-xue-er/statistics.png"></td><td><img data-src="https://blog-static.boris1993.com/virtual-pet-xue-er/about.png"></td></tr></tbody></table><p>这个小游戏的存档机制很有意思，是在 C 盘根目录下创建一个 ini 文件，记录宠物的出生时间和各项指标，然后它会根据这个时间来计算宠物的状态。也就是说，即使你把游戏关掉，宠物也不会停止成长。所以玩家就必须经常打开游戏照顾这个宠物，不然很有可能下次打开的时候，宠物就已经变成一个墓碑了……</p><p>这个小游戏我上传到蓝奏云了，有兴趣的可以去下载来玩。不过因为 64 位的 Windows 已经不支持 16 位应用，所以你需要一个老版本系统的虚拟机，或者用 <a href="https://github.com/otya128/winevdm"><code>otvdm</code></a>来运行。<br>地址：<span class="exturl" data-url="aHR0cHM6Ly9ib3JpczE5OTMubGFuem91ai5jb20vYjAzcXVldTNj">https://boris1993.lanzouj.com/b03queu3c<i class="fa fa-external-link-alt"></i></span><br>密码：15l3</p><p>P.S.：在找原版的时候，我注意到关于页面里 “碧晓拱籍 设计”，以为这是原作者的名字，于是就拿它一顿找啊，但一无所获。突然灵光一现，这会不会是…… 乱码？鬼使神差把这四个字按照 <code>GBK</code> 编码保存，然后再用 <code>SHIFT-JIS</code> 编码打开，得到一串片假名<code>ｱﾌﾏ�ｹｰｼｮ</code>，定睛一看这不就是 <code>application</code> 的日语<code>アプリケション</code>嘛，虽然里面又掺了个乱码……</p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/memories/">忆往昔</category>
      
      
      <category domain="https://www.boris1993.com/tags/%E7%94%B5%E5%AD%90%E5%AE%A0%E7%89%A9/">电子宠物</category>
      
      <category domain="https://www.boris1993.com/tags/%E6%A2%A6%E5%B9%BB%E7%94%B5%E5%AD%90%E5%AE%A0%E7%89%A9/">梦幻电子宠物</category>
      
      <category domain="https://www.boris1993.com/tags/%E9%9B%AA%E5%84%BF/">雪儿</category>
      
      <category domain="https://www.boris1993.com/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/">小游戏</category>
      
      
      <comments>https://www.boris1993.com/virtual-pet-xue-er.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 Grafana 监控 RouterOS 运行状态</title>
      <link>https://www.boris1993.com/monitoring-routeros-with-grafana.html</link>
      <guid>https://www.boris1993.com/monitoring-routeros-with-grafana.html</guid>
      <pubDate>Sat, 18 Nov 2023 15:19:57 GMT</pubDate>
      
      <description>&lt;p&gt;乱翻收藏夹的时候发现我还有个免费的 Grafana Cloud，遂想着把我这些自建的东西都用它监控起来，反正不用白不用。那么第一个就拿我的 RouterOS 软路由开刀吧。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>乱翻收藏夹的时候发现我还有个免费的 Grafana Cloud，遂想着把我这些自建的东西都用它监控起来，反正不用白不用。那么第一个就拿我的 RouterOS 软路由开刀吧。</p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Mikrotik CHR 7.12</li><li>Grafana Cloud - Cloud Free 订阅</li><li> Prometheus 2.37</li><li>mktxp </li><li>CloudFlare Tunnel，如果你像我一样把 Prometheus 部署在家宽的话</li></ul><h2 id="在RouterOS系统创建组和用户"><a href="#在RouterOS系统创建组和用户" class="headerlink" title="在RouterOS系统创建组和用户"></a>在 RouterOS 系统创建组和用户</h2><p>毕竟还是用第三方工具登陆路由器，还是遵循最小权限原则，给 <code>mktxp</code> 创建一个只包含必要的权限的账号比较好。</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/user<span class="built_in">/group </span><span class="built_in">add</span> <span class="attribute">name</span>=prometheus <span class="attribute">policy</span>=read,api</span><br><span class="line"><span class="built_in">/user </span><span class="built_in">add</span> <span class="attribute">name</span>=prometheus <span class="attribute">group</span>=prometheus <span class="attribute">password</span>=changeme <span class="attribute">disabled</span>=<span class="literal">no</span></span><br></pre></td></tr></tbody></table></figure><h2 id="配置mktxp"><a href="#配置mktxp" class="headerlink" title="配置mktxp"></a>配置 mktxp</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FrcHcvbWt0eHA=">mktxp<i class="fa fa-external-link-alt"></i></span>是一个面向 Mikrotik RouterOS 的 Prometheus exporter。选择这个而不是 <code>nshttpd/mikrotik-exporter</code> 主要出于以下两个原因：</p><ul><li><code>nshttpd/mikrotik-exporter</code> 已经停止更新，最后一次 commit 停留于 2022 年 6 月 17 日</li><li>它每一次获取数据都会登入和登出，而这会导致 RouterOS 的日志里面充斥 <code>prometheus</code> 用户的登入和登出记录，就像这样：<br><img data-src="https://blog-static.boris1993.com/monitoring-routeros-with-grafana/mikrotik-exporter-log-spamming.png"></li></ul><p>我使用 Docker 部署 <code>mktxp</code>，它需要两个配置文件：<code>mktxp.conf</code> 和<code>_mktxp.conf</code>。</p><p><code>_mktxp.conf</code> 负责 <code>mktxp</code> 的运行配置，比如端口号、数据获取的间隔时间等。内容如下：</p><figure class="highlight toml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[MKTXP]</span></span><br><span class="line">    <span class="attr">port</span> = <span class="number">49090</span></span><br><span class="line">    <span class="attr">socket_timeout</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">initial_delay_on_failure</span> = <span class="number">120</span></span><br><span class="line">    <span class="attr">max_delay_on_failure</span> = <span class="number">900</span></span><br><span class="line">    <span class="attr">delay_inc_div</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">bandwidth</span> = <span class="literal">True</span>                <span class="comment"># Turns metrics bandwidth metrics collection on / off</span></span><br><span class="line">    <span class="attr">bandwidth_test_interval</span> = <span class="number">420</span>   <span class="comment"># Interval for colllecting bandwidth metrics</span></span><br><span class="line">    <span class="attr">minimal_collect_interval</span> = <span class="number">5</span>    <span class="comment"># Minimal metric collection interval</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">verbose_mode</span> = <span class="literal">False</span>            <span class="comment"># Set it on for troubleshooting</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">fetch_routers_in_parallel</span> = <span class="literal">False</span>   <span class="comment"># Set to True if you want to fetch multiple routers parallel</span></span><br><span class="line">    <span class="attr">max_worker_threads</span> = <span class="number">5</span>              <span class="comment"># Max number of worker threads that can fetch routers. Meaningless if fetch_routers_in_parallel is set to False</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">max_scrape_duration</span> = <span class="number">10</span>            <span class="comment"># Max duration of individual routers' metrics collection</span></span><br><span class="line">    <span class="attr">total_max_scrape_duration</span> = <span class="number">30</span>      <span class="comment"># Max overall duration of all metrics collection</span></span><br></pre></td></tr></tbody></table></figure><p><code>mktxp.conf</code> 用于配置要监控的 RouterOS 实例，内容如下：</p><figure class="highlight toml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Router为路由器的代号，可以改成自己喜欢的值</span></span><br><span class="line"><span class="comment"># 将来在Grafana就是用这个来区分各个RouterOS设备</span></span><br><span class="line"><span class="section">[Router]</span></span><br><span class="line">    <span class="comment"># 是否启用对这个RouterOS设备的监控</span></span><br><span class="line">    <span class="attr">enabled</span> = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路由器的地址</span></span><br><span class="line">    <span class="attr">hostname</span> = <span class="number">192.168</span>.<span class="number">1.1</span></span><br><span class="line">    <span class="comment"># RouterOS API服务的端口</span></span><br><span class="line">    <span class="attr">port</span> = <span class="number">8728</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填写上面创建的 prometheus 用户的账号和密码</span></span><br><span class="line">    <span class="attr">username</span> = prometheus</span><br><span class="line">    <span class="attr">password</span> = changeme</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SSL部分关闭就行</span></span><br><span class="line">    <span class="attr">use_ssl</span> = <span class="literal">False</span>                 <span class="comment"># enables connection via API-SSL servis</span></span><br><span class="line">    <span class="attr">no_ssl_certificate</span> = <span class="literal">False</span>      <span class="comment"># enables API_SSL connect without router SSL certificate</span></span><br><span class="line">    <span class="attr">ssl_certificate_verify</span> = <span class="literal">False</span>  <span class="comment"># turns SSL certificate verification on / off</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下为各个监控的开关，按需设定即可</span></span><br><span class="line">    <span class="attr">installed_packages</span> = <span class="literal">True</span>       <span class="comment"># Installed packages</span></span><br><span class="line">    <span class="attr">dhcp</span> = <span class="literal">True</span>                     <span class="comment"># DHCP general metrics</span></span><br><span class="line">    <span class="attr">dhcp_lease</span> = <span class="literal">True</span>               <span class="comment"># DHCP lease metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">connections</span> = <span class="literal">True</span>              <span class="comment"># IP connections metrics</span></span><br><span class="line">    <span class="attr">connection_stats</span> = <span class="literal">False</span>        <span class="comment"># Open IP connections metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">pool</span> = <span class="literal">True</span>                     <span class="comment"># Pool metrics</span></span><br><span class="line">    <span class="attr">interface</span> = <span class="literal">True</span>                <span class="comment"># Interfaces traffic metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">firewall</span> = <span class="literal">True</span>                 <span class="comment"># IPv4 Firewall rules traffic metrics</span></span><br><span class="line">    <span class="attr">ipv6_firewall</span> = <span class="literal">False</span>           <span class="comment"># IPv6 Firewall rules traffic metrics</span></span><br><span class="line">    <span class="attr">ipv6_neighbor</span> = <span class="literal">False</span>           <span class="comment"># Reachable IPv6 Neighbors</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">poe</span> = <span class="literal">False</span>                     <span class="comment"># POE metrics</span></span><br><span class="line">    <span class="attr">monitor</span> = <span class="literal">True</span>                  <span class="comment"># Interface monitor metrics</span></span><br><span class="line">    <span class="attr">netwatch</span> = <span class="literal">True</span>                 <span class="comment"># Netwatch metrics</span></span><br><span class="line">    <span class="attr">public_ip</span> = <span class="literal">True</span>                <span class="comment"># Public IP metrics</span></span><br><span class="line">    <span class="attr">route</span> = <span class="literal">True</span>                    <span class="comment"># Routes metrics</span></span><br><span class="line">    <span class="attr">wireless</span> = <span class="literal">False</span>                <span class="comment"># WLAN general metrics</span></span><br><span class="line">    <span class="attr">wireless_clients</span> = <span class="literal">False</span>        <span class="comment"># WLAN clients metrics</span></span><br><span class="line">    <span class="attr">capsman</span> = <span class="literal">False</span>                 <span class="comment"># CAPsMAN general metrics</span></span><br><span class="line">    <span class="attr">capsman_clients</span> = <span class="literal">False</span>         <span class="comment"># CAPsMAN clients metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">user</span> = <span class="literal">True</span>                     <span class="comment"># Active Users metrics</span></span><br><span class="line">    <span class="attr">queue</span> = <span class="literal">True</span>                    <span class="comment"># Queues metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">remote_dhcp_entry</span> = None        <span class="comment"># An MKTXP entry for remote DHCP info resolution (capsman/wireless)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">use_comments_over_names</span> = <span class="literal">True</span>  <span class="comment"># when available, forces using comments over the interfaces names</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">check_for_updates</span> = <span class="literal">False</span>       <span class="comment"># check for available ROS updates</span></span><br></pre></td></tr></tbody></table></figure><p>然后用如下 <code>docker-compose.yml</code> 启动 <code>mktxp</code> 即可：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mktxp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ghcr.io/akpw/mktxp:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mktxp</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">49090</span><span class="string">:49090</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;存放以上两个conf的目录&gt;:/home/mktxp/mktxp/</span></span><br></pre></td></tr></tbody></table></figure><p><code>mktxp</code> 在启动成功的情况下是没有日志输出的，访问 <code>49090</code> 端口（即<code>_mktxp.conf</code> 中配置的端口），如果能看到一大片 Prometheus 的 metrics，那就说明启动成功了。</p><h2 id="配置Prometheus"><a href="#配置Prometheus" class="headerlink" title="配置Prometheus"></a>配置 Prometheus</h2><p>在 <code>prometheus.yml</code> 中添加如下配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'mikrotik_exporter'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">'mktxp的主机地址:49090'</span>]</span><br><span class="line">        <span class="comment"># 标签按需，不想要可以去掉</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">instance:</span> <span class="string">'CHR'</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="string">'Production'</span></span><br></pre></td></tr></tbody></table></figure><p>重启 Prometheus，然后到 Prometheus 的 <code>Status -&gt; Targets</code> 中，检查 <code>mikrotik_exporter</code> 这个 target 是否存在，以及 <code>State</code> 是不是 <code>UP</code>。</p><h2 id="配置Grafana"><a href="#配置Grafana" class="headerlink" title="配置Grafana"></a>配置 Grafana</h2><p>如果你的 Prometheus 是部署在家宽环境，那在配置 Grafana 之前需要先做个内网穿透，让 Prometheus 的 <code>9090/tcp</code> 端口能被外网访问到。内网穿透的方案有很多，比如我就用的 CloudFlare Tunnel。因为本文不是讲内网穿透，所以就不展开讲配置了。</p><p>到 Grafana 的 <code>Home -&gt; Connections -&gt; Data sources</code> 中，添加一个新的 Prometheus 数据源，其中 <code>Prometheus server URL</code> 填你的 Prometheus 服务的地址，别的不用管，<code>Save &amp; test</code> 成功就没问题。<br>此外，还可以到 Grafana 的 <code>Explore</code> 页面查询一个 <code>mktxp</code> 的 metrics，来检查 Grafana 是否能成功获取到数据。</p><p><img data-src="https://blog-static.boris1993.com/monitoring-routeros-with-grafana/grafana-explore-mktxp-metrics.png"></p><p>确认 Grafana 能成功获取到数据后，就可以导入 <code>mktxp</code> 的<span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS9ncmFmYW5hL2Rhc2hib2FyZHMvMTM2NzktbWlrcm90aWstbWt0eHAtZXhwb3J0ZXIv"> Grafana Dashboard<i class="fa fa-external-link-alt"></i></span>了。到 Grafana 的 Dashboards 页面，点击 <code>New</code> 按钮后选择 <code>Import</code>，填写这个 dashboard 的 ID<code>13679</code>，点 <code>Load</code>，在下一个页面给这个 dashboard 绑定我们的 Prometheus，然后点 <code>Import</code>，就可以用了。</p><p><img data-src="https://blog-static.boris1993.com/monitoring-routeros-with-grafana/grafana-dashboard.png"></p>]]></content:encoded>
      
      
      <category domain="https://www.boris1993.com/categories/playing/">瞎折腾</category>
      
      
      <category domain="https://www.boris1993.com/tags/RouterOS/">RouterOS</category>
      
      <category domain="https://www.boris1993.com/tags/Prometheus/">Prometheus</category>
      
      <category domain="https://www.boris1993.com/tags/Grafana/">Grafana</category>
      
      
      <comments>https://www.boris1993.com/monitoring-routeros-with-grafana.html#disqus_thread</comments>
      
    </item>
    
    <follow_challenge>
        <feedId>59132913829684225</feedId>
        <userId>81365198606215168</userId>
    </follow_challenge>
  </channel>
</rss>