<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Code Life</title>
    <link>https://www.boris1993.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>码农pilot的个人博客</description>
    <pubDate>Thu, 12 Sep 2019 07:29:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>让MyBatis把查询结果以Map形式返回</title>
      <link>https://www.boris1993.com/projects/mybatis/mybatis-return-query-results-in-a-map.html</link>
      <guid>https://www.boris1993.com/projects/mybatis/mybatis-return-query-results-in-a-map.html</guid>
      <pubDate>Thu, 12 Sep 2019 07:27:27 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>https://www.boris1993.com/projects/mybatis/mybatis-return-query-results-in-a-map.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JDBC错误Illegal mix of collations解决方法</title>
      <link>https://www.boris1993.com/projects/java/jdbc/illegal-mix-of-collations.html</link>
      <guid>https://www.boris1993.com/projects/java/jdbc/illegal-mix-of-collations.html</guid>
      <pubDate>Thu, 22 Aug 2019 09:43:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近项目开发时遇到了一个错误，内容是&lt;br&gt;&lt;code&gt;Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation &amp;#39;=&amp;#39;&lt;/code&gt;&lt;br&gt;经查是关联查询时两个表的排序规则(collation)不同导致的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近项目开发时遇到了一个错误，内容是<br><code>Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation &#39;=&#39;</code><br>经查是关联查询时两个表的排序规则(collation)不同导致的。</p><a id="more"></a><p>解决方法也很简单，有两种方法：</p><p>一种是在查询的SQL中指定另一张表的collation，这是一种权宜之计，治标不治本。代码是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设左表的排序规则是 utf8_general_ci,</span></span><br><span class="line"><span class="comment">-- 而右表的排序规则是 utf8_unicode_ci</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="string">`a`</span>.<span class="string">`column1`</span>,</span><br><span class="line">    <span class="string">`b`</span>.<span class="string">`column2`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`table_1`</span> <span class="keyword">AS</span> <span class="string">`a`</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`table_2`</span> <span class="keyword">AS</span> <span class="string">`b`</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="string">`a`</span>.<span class="string">`id`</span> = <span class="string">`b`</span>.<span class="string">`id`</span></span><br><span class="line">    <span class="keyword">COLLATE</span> <span class="string">`utf8_general_ci`</span></span><br></pre></td></tr></table></figure><p>另一种方法是修改表和列的排序规则，将其统一。这个方法从根本上解决了这个问题。操作方法可以参考<a href="/database/mysql/mysql-convert-tables-and-columns-collation.html">在 MySQL 中修改表和列的排序规则</a>。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/jdbc/illegal-mix-of-collations.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在MySQL中修改表和列的排序规则</title>
      <link>https://www.boris1993.com/database/mysql/mysql-convert-tables-and-columns-collation.html</link>
      <guid>https://www.boris1993.com/database/mysql/mysql-convert-tables-and-columns-collation.html</guid>
      <pubDate>Thu, 22 Aug 2019 03:33:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;使用如下SQL语句即可更新一张表的字符集(character set)和排序规则(collation)：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
        
      
      </description>
      
      <content:encoded><![CDATA[<p>使用如下SQL语句即可更新一张表的字符集(character set)和排序规则(collation)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此处假设使用utf8字符集，以及使用utf8_unicode_ci排序规则</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_unicode_ci;</span><br></pre></td></tr></table></figure><p>然后可以使用如下SQL查询表和列的字符集和排序规则是否修改成功：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询表的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`TABLE_SCHEMA`</span>, <span class="string">`TABLE_NAME`</span>, <span class="string">`TABLE_COLLATION`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`TABLES`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`TABLE_NAME`</span> = <span class="string">'table_name'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询表中每个列的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`TABLE_SCHEMA`</span>, <span class="string">`TABLE_NAME`</span>, <span class="string">`COLUMN_NAME`</span>, <span class="string">`COLLATION_NAME`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`COLUMNS`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`TABLE_NAME`</span> = <span class="string">'table_name'</span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/database/mysql/mysql-convert-tables-and-columns-collation.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>突然情绪爆发，暴哭了一场</title>
      <link>https://www.boris1993.com/others/i-just-cried.html</link>
      <guid>https://www.boris1993.com/others/i-just-cried.html</guid>
      <pubDate>Sun, 18 Aug 2019 02:55:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;刚才久违的暴哭了一场。&lt;/p&gt;
&lt;p&gt;嘛，其实也没暴走多久，满打满算，也就暴走了一个刘强东那么久。&lt;/p&gt;
&lt;p&gt;无奈，最近一段时间里，发生了太多闹心的事。&lt;/p&gt;
&lt;p&gt;有多闹心呢？你想想，能让一个网瘾少年连游戏都不想玩了，你就想这是有多闹心吧。&lt;/p&gt;
&lt;p&gt;已经不记得上次哭是什么时候了，甚至，已经忘了该怎么哭了。&lt;/p&gt;
&lt;p&gt;我说我连该怎么引导自己哭出来，都是查的知乎，你信吗。&lt;/p&gt;
&lt;p&gt;当然也不是没来由的就哭了，主要还是最近心力交瘁，最后因为一件屁事情绪爆发了。&lt;/p&gt;
&lt;p&gt;您要是想看个来龙去脉呢，那就继续往下，看我这个祥林嫂的絮叨吧。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>刚才久违的暴哭了一场。</p><p>嘛，其实也没暴走多久，满打满算，也就暴走了一个刘强东那么久。</p><p>无奈，最近一段时间里，发生了太多闹心的事。</p><p>有多闹心呢？你想想，能让一个网瘾少年连游戏都不想玩了，你就想这是有多闹心吧。</p><p>已经不记得上次哭是什么时候了，甚至，已经忘了该怎么哭了。</p><p>我说我连该怎么引导自己哭出来，都是查的知乎，你信吗。</p><p>当然也不是没来由的就哭了，主要还是最近心力交瘁，最后因为一件屁事情绪爆发了。</p><p>您要是想看个来龙去脉呢，那就继续往下，看我这个祥林嫂的絮叨吧。</p><a id="more"></a><p>起初呢，是年中那会，经过哥们啊、领导们啊、当然还有我自己的努力，争取到了一个外派的机会</p><p>嗯，这里插句嘴，其实现在我心里都抱着一点歉意的，因为当时领导也是有在挽留的，怎奈当时王八吃秤砣，铁了心的要出去看看这个大世界，最后就还是出来了。</p><p>那既然外派出来了，那当然是想要好好的干啊。一方面呢，当时本来就是奔着这边有没玩过的技术，我是来学习的；另一方面呢，我毕竟是外派出来的，也挂着咱老东家的脸呢，出来混，丢啥不能丢老东家的脸呐。</p><p>头先派我俩活，一个我忘了是啥了，另一个是给现有的一个系统设计并新增一个功能。</p><p>这两次呢，也没跟我规定啥时候交货。我寻思着，按照这个难度，我设计啊编码啊给你做的精细点，一星期也差不多吧。</p><p>结果周五验收的时候，负责人表示，我觉得你时间有点太长了。</p><p>第一个活，负责人表示我快了一天就搞定，最慢也就三天，按你这效率我不如不要你了。</p><p>第二个呢，负责人表示，这个应该四天就能解决的。</p><p>这就不太对了吧。开始的时候也没有定一个deadline，可最后又说你不应该花这么多时间，这是什么操作啊？</p><p>第二个活呢，我当时上交设计文档的时候，负责人表示没有什么要修改的，那么我就按照我自己的设计稿去做了。可到了交货的时候，却砍了一个功能。</p><p>为啥我要把这个被砍了的功能拎出来说呢？因为那天上午，我就是在写这个功能。如果一开始就砍了不要，那我真的确确实实就只花了四天就完成了。</p><p>当时想，算了算了，屁大点事，懒得反驳了，没劲。大不了我后面再证明我自己嘛。</p><p>但是我错了。</p><p>在上面发生的事情之后不久，我们开始从头设计和开发一个新的系统。而今天这次暴走，也是从这时候开始埋下了雷。</p><p>在这个新项目开始不久，某一天，老东家那边的领导跟我讲，这边对我的效率好像不太满意，有一点不想再要我的意思。</p><p>我一听，这不行啊。真就这么给我踹回去了，我无所谓，可是这多少会影响那哥们，和老东家的面子啊。</p><p>你看啊，咱哥们，又是拼缝，又是联系，里外里没少折腾，最后就整进来这么个怂蛋，这要是后面咱哥们再想介绍谁过来，那他领导不也得犯嘀咕，他可别再给我整个怂蛋来啊。</p><p>再看咱老东家，也是费劲巴拉的没少折腾了，结果这废物没干几天就让踹回去了，脸上也不好看啊。</p><p>那咋整呢？废话，更玩命的干呗。豁出去命挣个脸皮呗。</p><p>可事实整明，我还是 too young too naive 了。脸皮没那么好挣，但是精神却可以消耗的很快。</p><p>从谈话之后，我就开始5*8的满负载工作。去卫生间，要快。喝水，要快。任何事，都不能影响我的进度。</p><p>然后，有一天，就在临下班的时候，突然一阵头晕，我发现我的右眼的上半部分，看不见了。</p><p>具体是什么症状呢？就像是一张损坏的图片。下半部分还是画面本来的样子。而上半部分，只剩下一片灰色。</p><p>所幸，不是永久的。它只持续了不到一分钟。</p><p>但是，我很害怕。我怕下次，就变成了一只眼睛半只瞎。我怕下次，就变成了两只眼睛一只瞎。</p><p>当天挂了眼科急诊，第二天又挂了眼科门诊。好在经过各种检查，眼睛没有任何问题，诊断是一时性的供血不足。而且时间很短，没有对眼睛造成什么永久性的损伤。</p><p>但是大夫后面说了一句话，让我不淡定了。</p><p>“这种一过性的症状，通常不是眼睛的病变，而有可能是脑部的问题。”</p><p>啥？老子年纪轻轻的，脑子就坏了？老子不答应！</p><p>可我不答应没用啊，还是得拿诊断结果说话。再联系到那段时间总有右脑隐隐的偏头疼，所以也害怕是有肿瘤或者血栓在里面。</p><p>于是就先后做了脑CT和MRI。</p><p>又是各种请假。而且都这种情况了，我个废物还在考虑会不会拖团队的后腿。</p><p>最后结果出来，也算是意料之中，检查都是正常。</p><p>脑子里没有什么不该有的东西。血管也很通畅。死不掉，也瘫不了。悬下的心，算是放下了。</p><p>既然没事了，那就继续干活吧。</p><p>可是好景不长，没过一两天，右耳开始感觉耳鸣。</p><p>一开始没管它，结果越是不管，声音越是大。正巧那两天虫子开始叫起来。我一时分不清是真的耳鸣，还是虫子太响。</p><p>既然有疑惑，那就得去查。越拖着，疑心越重，没病都能拖出癔症。</p><p>其实我是个很胆小的人。我害怕的，不是虫子骑脸，不是被疯子攮了。我怕的是，突然生大病，让远在半个中国以北的爹妈操碎心。</p><p>看耳朵的时候，大夫倒是干脆，直接就说，耳屎太多了。开了瓶药，滴两天，把耳屎泡软了之后，找大夫给我取出来，就解决了。</p><p>但是这事吧，它就不能平平稳稳的过去。</p><p>取耳屎的前一天晚上，滴完了药之后，耳朵眼里开始觉得肿胀，而且，右耳几乎听不见了。</p><p>我干哦！最后一天晚上都不让我好好过吗？而且急诊又没有耳鼻喉科！玩我呢吧！</p><p>没办法求助万能的网络，结果是，耳屎彻底泡发了，涨起来堵住了耳道，造成传导性耳聋。</p><p>哦。耳屎堵了啊。好吧睡觉。明天给孙子掏出来。</p><p>第二天，也就是昨天，一大早心事重重的就醒了。赶了早班车，挂最早的号，去掏耳屎。</p><p>中间发生了一个插曲。大夫掏耳屎用的是一个吸气的管子，来把耳屎吸出来。而这个管子，让我弄堵住了。是的耳屎太多把管子堵了。</p><p>大夫都一脸很受不了的表情，说这玩意都给堵了。</p><p>吸完右耳吸左耳。你以为吸完了就完了？右耳里面，还有块钉子户你敢信？</p><p>我还得滴两天药水，再过来掏一次。</p><p>然后一整天去体检、去退还光猫，这些杂事就按下不表。</p><p>晚上回去之后，也不知道是心太累，还是天太热，只觉得心烦意乱。哥几个联机打游戏，我都没法专心的去玩，不知道思绪在哪，一团乱麻。</p><p>想着，也到了吃饭的时候了吧，于是就去做饭。做饭的时候，也是心神不宁。</p><p>菜出来了，吃了一口，咸，没法吃。</p><p>这时候，突然情绪就爆发了。</p><p>为什么？为什么就这么多破事？为什么工作也干不好，身体也养不好，就连菜都炒不好？</p><p>当时就觉得想哭。但是，又哭不出来。</p><p>就像前两天，上海一位住户，住着数百万的房子，却在台风天坏了马桶，蹲地痛哭。区别只是，我没哭出来。</p><p>忍着恶心，扔掉饭菜，出门觅食。虽然当时一点胃口都没有，但还是强迫自己吃了一碗小馄饨。</p><p>因为，任由自己的坏心情折腾自己，只会让自己离抑郁更近一步。老子，不答应。老子，要乐呵的活着。</p><p>然后就是一觉醒来，到了今天5点。时间是睡饱了，可是精神还是没有恢复。</p><p>早饭是逼着自己吃的。想出去走走，结果隔一分钟换一个目的地。</p><p>而且，还是半憋着想哭。</p><p>这不是个事，这样下去，解决不了。这样下去，老子要崩。</p><p>果断掉头回住处。上网搜，“想哭哭不出来”。嗯，网络就是好，各路大神给支招。</p><p>挑了个简单的，只需要三步。</p><p>刚做完一步半，感觉就上来了。眼泪啊，kua的一下，就出来了。</p><p>来的快，去的也快。感觉已经哭爽了，再也哭不出来之后，整理思绪，写下了这些絮絮叨叨的东西。</p><p>果然啊，心情不好的时候，哭一场，就什么都过去了。</p><p>谢谢您耐着性子，跟着这个胆小的家伙，回顾了一下这段波折的人生。</p><p>我写这么多呢，就是为了发泄一下。您呢，就当看了一篇文笔拙劣的小说吧。</p><p>$EOF.</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/others/i-just-cried.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用Docker配置Redis哨兵</title>
      <link>https://www.boris1993.com/database/Redis/redis-sentinel-in-docker.html</link>
      <guid>https://www.boris1993.com/database/Redis/redis-sentinel-in-docker.html</guid>
      <pubDate>Wed, 05 Jun 2019 02:08:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;接上文&lt;a href=&quot;/database/Redis/redis-replication-in-docker.html&quot;&gt;使用Docker配置Redis主从复制&lt;/a&gt;完成之后，这篇文章主要介绍如何使用Docker在本机搭建Redis的哨兵，内容包括涉及的目录结构、&lt;code&gt;docker-compose.yml&lt;/code&gt;的编写。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>接上文<a href="/database/Redis/redis-replication-in-docker.html">使用Docker配置Redis主从复制</a>完成之后，这篇文章主要介绍如何使用Docker在本机搭建Redis的哨兵，内容包括涉及的目录结构、<code>docker-compose.yml</code>的编写。</p><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>本文将采用如下的目录结构，其中<code>data</code>目录将用于存放各个容器的数据，<code>server</code>目录存放<code>docker-compose.yml</code>以及针对<code>master</code>和<code>slave</code>节点的配置文件，<code>sentinel</code>目录存放哨兵的配置文件和<code>docker-compose.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-master</span><br><span class="line">│   │   └── dump.rdb</span><br><span class="line">│   ├── redis-slave-1</span><br><span class="line">│   │   └── dump.rdb</span><br><span class="line">│   └── redis-slave-2</span><br><span class="line">│       └── dump.rdb</span><br><span class="line">├── sentinel</span><br><span class="line">│   ├── docker-compose.yml</span><br><span class="line">│   └── redis-sentinel.conf</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    └── redis-slave.conf</span><br></pre></td></tr></table></figure><h2 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h2><p>编辑<code>redis-sentinel.conf</code>，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 接受来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 哨兵的端口号</span><br><span class="line"># 因为各个哨兵节点会运行在单独的Docker容器中</span><br><span class="line"># 所以无需担心端口重复使用</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 配置哨兵的监控参数</span><br><span class="line"># 格式：sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># master-name是为这个被监控的master起的名字</span><br><span class="line"># ip是被监控的master的IP或主机名。因为Docker容器之间可以使用容器名访问，所以这里写master节点的容器名</span><br><span class="line"># redis-port是被监控节点所监听的端口号</span><br><span class="line"># quorom设定了当几个哨兵判定这个节点失效后，才认为这个节点真的失效了</span><br><span class="line">sentinel monitor local-master redis-server-master 6379 2</span><br><span class="line"></span><br><span class="line"># 连接主节点的密码</span><br><span class="line"># 格式：sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass local-master redis</span><br></pre></td></tr></table></figure><h2 id="配置及启动容器"><a href="#配置及启动容器" class="headerlink" title="配置及启动容器"></a>配置及启动容器</h2><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写<code>docker-compose.yml</code></h3><p>这里继续使用<code>docker-compose</code>管理容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 哨兵的数量应是奇数，以便于哨兵通过投票来作出决策</span></span><br><span class="line"><span class="attr">  redis-sentinel-1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-sentinel-1</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">      <span class="comment"># 向外暴露26379端口</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">26379</span><span class="string">:26379</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      default:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.5</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">      <span class="comment"># 将哨兵配置文件和存放数据的文件夹挂载到容器内</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-sentinel-1:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="comment"># 设定容器的内核参数，以消除Redis启动过程中的一个warning</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line">    <span class="comment"># 根据指定的配置文件来启动Redis哨兵</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-sentinel",</span> <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  redis-sentinel-2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-sentinel-2</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">26380</span><span class="string">:26379</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      default:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.6</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-sentinel-2:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-sentinel",</span> <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  redis-sentinel-3:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-sentinel-3</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">26381</span><span class="string">:26379</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      default:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.7</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-sentinel-3:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-sentinel",</span> <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  default:</span></span><br><span class="line"><span class="attr">    external:</span></span><br><span class="line">      <span class="comment"># 因为哨兵容器需要与服务端容器运行在同一网络内</span></span><br><span class="line">      <span class="comment"># 所以这里指定了一个外部的网络</span></span><br><span class="line">      <span class="comment"># 网络名参考《使用Docker配置Redis主从复制》中的注释</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">server_redis-cluster</span></span><br></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>这里同样使用<code>docker-compose up -d</code>启动容器，然后使用<code>redis-cli</code>连接到哨兵节点，连接成功后，可以使用<code>info sentinel</code>检查哨兵的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379&gt; info sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=local-master,status=ok,address=10.1.0.2:6379,slaves=2,sentinels=1</span><br></pre></td></tr></table></figure><p>其中，<code>sentinel_masters:1</code>说明这个哨兵在监控一个master，最后一行中写明了<code>master0</code>这个节点别名为<code>local-master</code>，状态为<code>OK</code>，地址是<code>10.1.0.2:6379</code>，有2个从节点。</p><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>哨兵光是启动了还是不够的，还需要测试一下当被监控节点下线之后，哨兵是否能作出反应。</p><p>首先，停掉<code>master</code>，<code>slave-1</code>，<code>slave-2</code>，然后观察哨兵的日志，在经过一段时间之后，哨兵宣布有节点下线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:13.487 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:13.487 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:13.502 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:13.502 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:13.581 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:13.582 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:14.429 # +sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:14.439 # +sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:14.470 # +sdown master local-master 10.1.0.2 6379</span><br></pre></td></tr></table></figure><p>然后再启动<code>master</code>，<code>slave-1</code>，<code>slave-2</code>，并观察哨兵的日志，在节点上线之后，哨兵宣布了节点重启，并解除了节点的下线状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.040 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.082 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.132 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.132 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.133 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.133 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.140 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.141 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.231 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.960 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.963 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:46.043 # -sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:46.046 # -sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:46.054 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:46.144 # -sdown master local-master 10.1.0.2 6379</span><br></pre></td></tr></table></figure><h2 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h2><ul><li><a href="/database/Redis/redis-replication-in-docker.html">使用Docker配置Redis主从复制</a></li><li><a href="/database/Redis/redis-sentinel-in-docker.html">使用Docker配置Redis哨兵</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/database/Redis/redis-sentinel-in-docker.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用Docker配置Redis主从复制</title>
      <link>https://www.boris1993.com/database/Redis/redis-replication-in-docker.html</link>
      <guid>https://www.boris1993.com/database/Redis/redis-replication-in-docker.html</guid>
      <pubDate>Thu, 23 May 2019 07:22:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;这篇文章主要介绍如何使用Docker在本机搭建一个带有主从复制功能的Redis环境，内容包括涉及的目录结构、&lt;code&gt;docker-compose.yml&lt;/code&gt;的编写，以及结果的验证。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这篇文章主要介绍如何使用Docker在本机搭建一个带有主从复制功能的Redis环境，内容包括涉及的目录结构、<code>docker-compose.yml</code>的编写，以及结果的验证。</p><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>本文将采用如下的目录结构，其中<code>data</code>目录将用于存放各个容器的数据，<code>server</code>目录存放<code>docker-compose.yml</code>以及针对<code>master</code>和<code>slave</code>节点的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    ├── redis-slave1.conf</span><br><span class="line">    └── redis-slave2.conf</span><br></pre></td></tr></table></figure><h2 id="配置Redis节点"><a href="#配置Redis节点" class="headerlink" title="配置Redis节点"></a>配置Redis节点</h2><h3 id="配置master节点"><a href="#配置master节点" class="headerlink" title="配置master节点"></a>配置<code>master</code>节点</h3><p>编辑<code>redis-master.conf</code>，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 监听来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br></pre></td></tr></table></figure><h3 id="配置slave节点"><a href="#配置slave节点" class="headerlink" title="配置slave节点"></a>配置<code>slave</code>节点</h3><p>创建<code>redis-slave1.conf</code>，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 监听来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br><span class="line"></span><br><span class="line"># 配置master节点信息</span><br><span class="line"># 格式：</span><br><span class="line">#slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"># 此处masterip所指定的redis-server-master是运行master节点的容器名</span><br><span class="line"># Docker容器间可以使用容器名代替实际的IP地址来通信</span><br><span class="line">slaveof redis-server-master 6379</span><br><span class="line"></span><br><span class="line"># 设定连接主节点所使用的密码</span><br><span class="line">masterauth &quot;redis&quot;</span><br></pre></td></tr></table></figure><p>创建<code>redis-slave2.conf</code>，修改监听端口号为<code>6381</code>，其余配置与<code>redis-slave1.conf</code>相同。</p><h2 id="配置及启动容器"><a href="#配置及启动容器" class="headerlink" title="配置及启动容器"></a>配置及启动容器</h2><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写<code>docker-compose.yml</code></h3><p>本例中使用<code>docker-compose</code>编排相关容器。要说为什么不用<code>Kubernetes</code>，那是因为对于一个示例来说这玩意太重了。<del>说的一套一套的还不是因为不会用</del></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 主节点的容器</span></span><br><span class="line"><span class="attr">  redis-server-master:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-server-master</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      redis-cluster:</span></span><br><span class="line">        <span class="comment"># 为容器指定一个静态IP</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">      <span class="comment"># 映射配置文件和数据目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-master.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-master:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="comment"># 必要的内核参数</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="comment"># 从节点1的容器</span></span><br><span class="line"><span class="attr">  redis-server-slave-1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-server-slave-1</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis-server-master</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">6380</span><span class="string">:6380</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      redis-cluster:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-slave1.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-slave-1:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="comment"># 从节点2的容器</span></span><br><span class="line"><span class="attr">  redis-server-slave-2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-server-slave-2</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis-server-master</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">6381</span><span class="string">:6381</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      redis-cluster:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-slave2.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-slave-2:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  redis-cluster:</span></span><br><span class="line">    <span class="comment"># IP Address Management</span></span><br><span class="line"><span class="attr">    ipam:</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line">        <span class="comment"># 为容器分配一个独立的子网，用来方便为容器指定静态IP</span></span><br><span class="line">        <span class="comment"># 使用独立的子网可以避免IP地址冲突的问题</span></span><br><span class="line"><span class="attr">        - subnet:</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>在<code>docker-compose.yml</code>所在位置执行<code>docker-compose up</code>即可启动上述三个容器，<code>docker-compose</code>会将容器日志打印到终端，在日志中可以看到三个<code>Redis</code>服务器在启动过程中的动作，以及从节点加入主节点的信息。</p><p>启动成功后，可以在本机使用<code>redis-cli</code>连接至主节点。连接成功后，可以使用<code>info replication</code>命令检查主从复制的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=10.1.0.3,port=6380,state=online,offset=476,lag=1</span><br><span class="line">slave1:ip=10.1.0.4,port=6381,state=online,offset=476,lag=0</span><br><span class="line">master_replid:f29d9059a286deb4bbe5360f9c673a2484370205</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:476</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:476</span><br></pre></td></tr></table></figure><p>其中第6行的<code>role:master</code>指示该节点为主节点，第7行的<code>connected_slaves:2</code>说明当前有2个从节点，第8、9行则是两个从节点的信息，包括它们的地址、端口号，和状态。</p><p>如果此时查看该项目的目录结构，则可以发现在<code>data</code>目录中增加了三个Redis服务器的数据目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-master</span><br><span class="line">│   │   └── dump.rdb</span><br><span class="line">│   ├── redis-slave-1</span><br><span class="line">│   │   └── dump.rdb</span><br><span class="line">│   └── redis-slave-2</span><br><span class="line">│       └── dump.rdb</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    └── redis-slave.conf</span><br></pre></td></tr></table></figure><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>光是启动成功还不够，还需要测试一下从节点是否能同步主节点的数据。</p><p>首先连接到主节点，新增一个set：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure><p>好的，在主节点里面成功添加了一条数据。那么接下来连接到<code>slave-1</code>，看一下数据有没有同步过去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">127.0.0.1:6380&gt; set foo baz</span><br><span class="line">(error) READONLY You can&apos;t write against a read only replica.</span><br></pre></td></tr></table></figure><p>看来<code>slave-1</code>成功的从主节点同步了数据，并且这个节点也按照设定，是一个只读的节点。那么<code>slave-2</code>呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">127.0.0.1:6381&gt; set foo baz</span><br><span class="line">(error) READONLY You can&apos;t write against a read only replica.</span><br></pre></td></tr></table></figure><p>OK，<code>slave-2</code>也成功的同步了数据，并且正在作为一个只读节点运行着。</p><h2 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h2><ul><li><a href="/database/Redis/redis-replication-in-docker.html">使用Docker配置Redis主从复制</a></li><li><a href="/database/Redis/redis-sentinel-in-docker.html">使用Docker配置Redis哨兵</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/database/Redis/redis-replication-in-docker.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM的栈帧</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-jvm-stack-frame.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-jvm-stack-frame.html</guid>
      <pubDate>Tue, 02 Apr 2019 02:08:33 GMT</pubDate>
      <description>
      
        &lt;p&gt;栈帧是支持JVM进行方法调用和执行的数据结构，它是&lt;a href=&quot;/projects/java/fundamentals/java-jvm-runtime-data-areas.html&quot;&gt;JVM 运行时的数据区域&lt;/a&gt;的栈元素，其中包含了方法的局部变量表、操作数栈、动态链接方法，和返回地址等信息。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>栈帧是支持JVM进行方法调用和执行的数据结构，它是<a href="/projects/java/fundamentals/java-jvm-runtime-data-areas.html">JVM 运行时的数据区域</a>的栈元素，其中包含了方法的局部变量表、操作数栈、动态链接方法，和返回地址等信息。</p><a id="more"></a><p>局部变量表和操作数栈的空间，在编译期就已经可以确定下来，并会随着方法表的code属性一并提供给JVM，所以每个栈帧的空间不会受运行时数据的影响，而仅取决于JVM的实现。</p><p>每当一个方法被调用都会生成一个栈帧，并在方法执行完毕后被销毁，并且对于每个活动的线程，只有栈顶的栈帧是活动的，这个栈帧被称为“活动栈帧”，与其相关联的方法被称为“活动方法”，以及与其相关联的类被称为“活动类”。</p><h1 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h1><p>每个栈帧中都会有一个被称为“局部变量表”的数组，其中保存着方法的局部变量。局部变量表的大小在编译期就已经确定下来，并保存在class文件的code区。各个变量可通过数组下标的方式被定位到，对于需要占用两个元素的数据类型，比如<code>long</code>和<code>double</code>，其对应的下标使用较小的那个值。</p><p>在方法执行时，JVM使用局部变量表完成参数值到参数列表的传递过程的。如果调用的是类方法，那么参数会从局部变量表第0位开始向后排列。如果调用的是实例方法(非static方法)，则局部变量表第0位默认用于传递方法所属对象的实例的引用，在方法中使用<code>this</code>关键字可以访问到这个隐含的参数，其余的参数则从第1位开始向后排列；在参数表分配完毕后，方法体内部定义的变量会按照其顺序和作用域分配剩余的位置。</p><h1 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h1><p>每个栈帧中都有一个被称为“操作数栈”的栈。操作数栈的最大深度也是在编译期就可以确定下来，并保存在class文件的code区。</p><p>在栈帧创建初期，其中的操作数栈是空的。JVM提供了一系列的指令，用于将值压入操作数栈，同时也有指令来从操作数栈中取出值并进行计算，并将计算结果压入操作数栈。比如<code>iadd</code>指令会从操作数栈中取出最顶部的两个<code>int</code>数值，将其相加，然后将结果压入操作数栈。</p><p>压入操作数栈的元素的类型必须与指令的要求严格匹配，比如使用<code>iadd</code>指令将一个<code>float</code>和一个<code>double</code>相加是不允许的，这一点不仅在编译期会被严格确定，在类校验阶段也会进行检查。</p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>每个栈帧都包含一个指向运行时常量池的引用，用来支持方法调用过程中的动态链接。</p><p>字节码中的方法调用指令会以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用时转化成直接引用，这种称为静态解析；另一部分将在每一次运行期间转化为直接引用，这种称为动态链接。</p><h1 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h1><p>当一个方法开始执行后，只有两种方式可以退出这个方法：执行方法返回的指令，和遇到未处理的异常。</p><p>执行方法返回的指令称为“正常方法调用出口(Normal Method Invocation Completion)”，在这种情况下，如果方法有返回值，那么返回值将会被传递到上方的调用者。此时，当前栈帧将被用来恢复调用者的状态，包括调用者的本地变量表和操作数栈，并会修改pc寄存器的值来跳过方法调用指令。</p><p>当方法执行期间遇到了异常，并没有找到对应的异常处理器时，导致的方法返回称为“异常方法调用出口(Abrupt Method Invocation Completion)”，在这种情况下将不会有值被传回上方调用者。</p><h1 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h1><p>虚拟机规范允许具体的JVM实现增加一些规范中没有的信息到栈帧中，比如调试信息等，这些信息的内容将取决于JVM的具体实现。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-jvm-stack-frame.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java的垃圾回收算法</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-gc-algorithms.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-gc-algorithms.html</guid>
      <pubDate>Thu, 28 Mar 2019 06:29:41 GMT</pubDate>
      <description>
      
        &lt;p&gt;在&lt;a href=&quot;/projects/java/fundamentals/java-jvm-runtime-data-areas.html&quot;&gt;JVM运行时的数据区域&lt;/a&gt;中了解到了JVM的内存模型，那么既然使用了内存，就要考虑如何回收内存。与C语言不同，Java不需要开发人员人工回收内存，而是交给Java的垃圾回收机制来完成。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在<a href="/projects/java/fundamentals/java-jvm-runtime-data-areas.html">JVM运行时的数据区域</a>中了解到了JVM的内存模型，那么既然使用了内存，就要考虑如何回收内存。与C语言不同，Java不需要开发人员人工回收内存，而是交给Java的垃圾回收机制来完成。</p><a id="more"></a><h1 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h1><p>在Java中，GC的对象是堆和方法区。栈中的栈帧随着方法的调用和退出，会自行完成压栈和出栈操作，每个栈帧所需的内存空间也是在类结构确定下来时就已知的，所以不怎么需要考虑内存的回收问题。但是堆和方法区则不一样，这部分的空间是动态分配和回收的，同时也只有在运行时才可得知要生成哪些对象以及需要多少空间。</p><p>判断对象是否可以被回收通常有两种算法：<code>引用计数法</code>和<code>可达性分析法</code>。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法会给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就会加一；反之，每当一个引用失效时，计数器就会减一。任何时候，如果引用计数为0，则说明这个对象可以被回收。</p><p><img src="/images/java-gc-algorithms/reference-counter.png" alt="Reference counter"></p><p>但是，这个算法有一个问题，那就是无法处理循环引用，即这样：</p><p><img src="/images/java-gc-algorithms/circular-reference.png" alt="Circular reference"></p><p>此时，<code>对象1</code>，<code>对象2</code>，<code>对象3</code>都是不可达状态，理论上这三个对象都应该被回收，但是因为它们三个形成循环引用，引用计数器不为零，导致GC不会回收它们的空间。所以实际上，JVM并没有采用这种判断方法。</p><h2 id="可达性分析法-根搜索算法"><a href="#可达性分析法-根搜索算法" class="headerlink" title="可达性分析法(根搜索算法)"></a>可达性分析法(根搜索算法)</h2><p>可达性分析法的原理是，从根对象(GC Root)开始向下搜索，搜索走过的路径称为“引用链”，对象与引用链可以形成一个图，当任一个对象没有到根对象的引用链，即在这个图中该对象是不可达的，那么就判定这个对象是可以被回收的。</p><p>Java语言使用如下几种GC Root对象：</p><blockquote><ol><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol></blockquote><p>还是用上面这个循环引用作为示例：</p><p><img src="/images/java-gc-algorithms/circular-reference.png" alt="Circular reference"></p><p>此时虽然<code>对象1</code>、<code>对象2</code>、<code>对象3</code>互相之间存在引用，但是从根对象开始无法找到到达它们的路径，即它们三个都是<code>不可达</code>的，也就是可以被回收的。</p><h1 id="如何进行回收"><a href="#如何进行回收" class="headerlink" title="如何进行回收"></a>如何进行回收</h1><p>在根搜索算法的基础上，现代虚拟机中实现了三种算法：<code>标记-清除算法</code>，<code>复制算法</code>，<code>标记-整理算法</code>。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除算法把垃圾回收过程分成标记和清除两个阶段。在标记阶段，通过根节点标记所有可达的对象，也就是说，未被标记的对象都是不可达的对象。然后在清除阶段回收所有未被标记的对象。详细来说的话，就是当堆中的有效内存空间被耗尽时，就会停止整个程序(stop the world)，然后逐步开始标记和清除工作。</p><p>标记的过程，实际上是遍历所有的GC Roots，并标记所有可达的对象。而清除的过程，则是遍历堆中所有的对象，并清除没有被标记的对象。</p><p>在回收过程中一定要停止程序运行的原因，是为了避免在标记完成而尚未开始清除时，有新的可达的对象被创建出来。一旦出现这种情况，因为新创建的对象没有被标记，所以在清除阶段这个对象又会被清除。如果停止了程序的运行，那么在清除过程中，对象的状态不会发生变化，也就不会发生前面说的这种问题。</p><p>这个算法尽管可以有效的回收内存，但是也有两个比较大的缺点：</p><ol><li>遍历所有对象的效率比较低，导致程序停止运行的时间比较长</li><li>这种方法清理出的内存空间是不连续的，会造成空闲空间碎片化，并会影响数组分配空间。同时为了得知哪些空间是可用的，JVM还需要额外维护内存闲置空间的信息。</li></ol><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法的思想，是将原有的内存空间分成两部分，每次只使用其中一部分。在垃圾回收时，会从正在使用的部分中，将标记的对象复制到另一块内存中，然后清除正在使用的内存块，并交换两块内存的角色，来完成空间的回收。</p><p>该算法比标记-清除算法的效率高，但是该算法不适合活动对象较多的场合，比如老年代空间。此外，该算法会造成一定程度的内存空间浪费，因为总是有一片内存空间是被闲置的。为了节省空间，考虑到新生代空间中的对象存活时间大多不会很长，所以虚拟机可以选择不将内存对半分，而是将内存分割成一块比较大的Eden空间和两块比较小的Survivor空间(<code>From Survivor</code>和<code>To Survivor</code>)，每次同时使用Eden和其中一个Survivor。比如HotSpot虚拟机默认为Eden分配80%的空间，为两个Survivor各分配10%的空间。</p><p>Eden区，如其名字“伊甸园”一般，对象在被创建时，首先会放在这个区域；Survivor区，也如其名字“幸存者区”一样，存放的是每次垃圾回收后被保留下来的对象。</p><p>在每次垃圾回收时，Eden区中不能被回收的对象，和From Survivor区中不能被回收的对象，都将被复制到To Survivor区中，然后回收Eden区和From Survivor区的空间，并且幸存下来的对象的age属性会加一，最后From Survivor和To Survivor两者的角色对调。如果发生Survivor空间不足以存放所有活动对象时，则会使用老年代来进行分配担保，大的对象会跳过Survivor区直接进入老年代。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>因为复制算法在活动对象较多时，会发生很多的复制操作，导致算法效率比较低，而老年代的特点就是活动的对象比较多。“标记-整理”算法就是为了应对这一情况而诞生的。</p><p>标记-整理算法把垃圾回收过程分成标记和整理两个阶段。标记阶段的做法与“标记-清除”算法一样，遍历所有的GC Roots并标记出活动的对象；而在整理阶段，所有的活动对象都会向内存空间的一端移动(比如全部从内存空间的其实位置开始排列)，然后将边界以外的内存直接清理。</p><p>该算法的另一个优点是，因为该算法不会分割内存空间，而且每次回收后对象占用的空间肯定小于回收前所占用的空间，所以不再需要额外的空间进行分配担保。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>分代收集算法实际上就是根据不同内存空间的特性，一般是将堆分为新生代和老年代，并根据其各自的特点，在新生代使用复制算法回收，在老年代使用标记-整理算法回收。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-gc-algorithms.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM运行时的数据区域</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-jvm-runtime-data-areas.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-jvm-runtime-data-areas.html</guid>
      <pubDate>Wed, 27 Mar 2019 02:19:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;JVM在运行时，会按照程序执行的需要来创建一系列的运行时数据区域。有的区域只会随JVM起停而被创建和销毁，有的区域则会独立分配给各个线程，并随线程的起停而创建和销毁。这些运行时区域，按照功能和性质不同，会分成如下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程专有&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#pc-register&quot;&gt;pc(program counter)寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-stacks&quot;&gt;JVM栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-native-method-stack&quot;&gt;本地方法栈&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程间共享&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-heap&quot;&gt;堆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-method-area&quot;&gt;方法区&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-constant-pool&quot;&gt;运行时常量池&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>JVM在运行时，会按照程序执行的需要来创建一系列的运行时数据区域。有的区域只会随JVM起停而被创建和销毁，有的区域则会独立分配给各个线程，并随线程的起停而创建和销毁。这些运行时区域，按照功能和性质不同，会分成如下几部分：</p><ul><li>线程专有<ul><li><a href="#pc-register">pc(program counter)寄存器</a></li><li><a href="#jvm-stacks">JVM栈</a></li><li><a href="#jvm-native-method-stack">本地方法栈</a></li></ul></li><li>线程间共享<ul><li><a href="#jvm-heap">堆</a></li><li><a href="#jvm-method-area">方法区</a><ul><li><a href="#jvm-constant-pool">运行时常量池</a></li></ul></li></ul></li></ul><a id="more"></a><h1 id="pc-program-counter-寄存器"><a href="#pc-program-counter-寄存器" class="headerlink" title="pc(program counter)寄存器"></a><a name="pc-register"></a>pc(program counter)寄存器</h1><p>JVM允许同时运行多个线程，每个线程都有它自己的PC寄存器。在任意时刻，每个JVM线程都在执行一个方法中的某条语句，而这个正在被执行的方法，就叫做这个线程的“当前方法”。</p><p>如果当前方法不是一个本地(native)方法，那么PC寄存器的内容是当前正在执行的指令的地址；如果当前方法是本地方法，那么PC寄存器的值则是空(undefined)的。</p><h1 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a><a name="jvm-stacks"></a>JVM栈</h1><p>每个JVM都会在其启动时创建自己私有的JVM栈，栈之中存储的是<a href="/projects/java/fundamentals/java-jvm-stack-frame.html">栈帧</a>，用于存储局部变量和方法调用信息。</p><p>规范中允许栈的深度可以是固定的，也可以根据要求动态的扩展和收缩。如果是固定深度的栈，那么每个栈的深度会在其创建时按照需要独立指定。</p><p>当请求创建的栈大于所允许的深度，那么JVM会抛出<code>StackOverflowError</code>异常；当程序试图扩大一个可以动态伸缩的栈，或者试图为新的线程创建一个栈，但是可用内存不足以完成这个操作时，那么JVM会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><a name="jvm-native-method-stack"></a>本地方法栈</h1><p>本地方法栈与JVM栈类似，保存了本地方法的调用信息。</p><p>本地方法栈的空间可以是固定的，也可以是动态伸缩的。</p><p>当程序申请了大于所允许的本地方法栈空间，那么JVM会抛出<code>StackOverflowError</code>异常；如果程序申请扩展一个可以动态伸缩的本地方法栈，或者试图创建一个栈，但是可用内存不足以满足要求时，JVM会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a><a name="jvm-heap"></a>堆</h1><p>在JVM启动时，会创建一个共享于所有线程的堆空间，其中存放着所有的对象，和被分配好空间的数组。用于存放对象的空间由一个自动化的存储空间管理机制，即垃圾回收机制(garbage collector)，来进行管理。堆空间可以是固定大小的，也可以是按需伸缩的。</p><p>如果程序试图申请扩大堆空间，但是存储管理机制无法满足需求时，JVM会抛出<code>OutOfMemory</code>异常。</p><p>在堆中，JVM又根据作用不同，将内存空间分为如下几部分：</p><h2 id="新生代-New-generation"><a href="#新生代-New-generation" class="headerlink" title="新生代(New generation)"></a>新生代(New generation)</h2><p>新生代保留的是生命周期短，并且很快就会被回收掉的对象。其中的空间又随着“复制算法”这一垃圾回收算法而被分为<code>Eden Space</code>和<code>Survivor Space</code>。具体可以参考<a href="/projects/java/fundamentals/java-gc-algorithms.html">Java的垃圾回收算法</a>这篇博文。</p><h2 id="老年代-Tenured-generation"><a href="#老年代-Tenured-generation" class="headerlink" title="老年代(Tenured generation)"></a>老年代(Tenured generation)</h2><p>在多次垃圾回收后仍然存活的对象，将会被放到老年代空间中。因此可以认为，老年代中的对象的生命周期都是比较长的。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><a name="jvm-method-area"></a>方法区</h1><p>方法区(method area)是一个共享于所有JVM线程的空间，创建于JVM启动时，其中存放着各个类的结构，如运行时常量池、属性、方法，以及方法和<a href="/projects/java/fundamentals/java-jvm-special-methods.html">特殊方法(special methods)</a>的代码。</p><p>方法区的大小可以是固定的，也可以是按需伸缩的，但是根据虚拟机实现的不同，垃圾回收机制可能不会回收或压缩方法区的空间。</p><p>如果方法区的可用内存无法满足一次申请空间的请求，那么JVM会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><a name="jvm-constant-pool"></a>运行时常量池</h1><p>运行时常量池对应class文件中的<a href="/projects/java/fundamentals/java-jvm-constant-pool.html"><code>constant_pool</code>表</a>。</p><p>运行时常量池中包含了数值常量和属性的引用。每个运行时常量池的空间都会在类或接口被创建时生成，并且从方法区中分配空间。在创建运行时方法区时，如果申请的空间大于方法区可提供的空间，那么JVM会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>《The Java Virtual Machine Specification (Java SE 8 Edition)》 - 2.5 Run-Time Data Areas</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-jvm-runtime-data-areas.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java源码阅读 - ArrayList</title>
      <link>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-arraylist.html</link>
      <guid>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-arraylist.html</guid>
      <pubDate>Fri, 22 Mar 2019 08:07:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。&lt;/p&gt;
&lt;p&gt;这次就来阅读一下&lt;code&gt;ArrayList&lt;/code&gt;的源码。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p><p>这次就来阅读一下<code>ArrayList</code>的源码。</p><a id="more"></a><h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>上面代码声明了一个叫<code>ArrayList</code>的泛型类，继承了<code>AbstractList</code>，并实现了<code>List</code>，<code>RandomAccess</code>，<code>Cloneable</code>，<code>Serializable</code>接口。</p><p><code>AbstractList</code>抽象类提供了一个“骨架”级别的<code>List</code>接口的实现，用来减少实现一个支持随机存储的<code>List</code>的工作量。</p><p><code>RandomAccess</code>中没有声明任何方法，是一个标记接口(marker interface)，表明了这个类支持快速(通常是<code>O(1)</code>时间复杂度)的随机存取。在遍历一个集合前，可以用<code>instanceof</code>判断这个集合是否实现了<code>RandomAccess</code>，来选择合适的遍历方法。</p><p><code>Cloneable</code>也是一个标记接口，表明了这个类允许使用<code>Object.clone()</code>命令进行属性到属性的复制。</p><p><code>Serializable</code>也是一个标记接口，表明在这个类上启用Java的序列化功能。</p><h1 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><code>elementData</code>数组用来实际存放数据，<code>ArrayList</code>的空间(capacity)对应这个数组的长度(size)。<code>ArrayList</code>实现了自己的序列化(<code>ArrayList#writeObject()</code>)和反序列化(<code>ArrayList#readObject()</code>)方法，所以加上<code>transient</code>关键字来使<code>elementData</code>不参与Java自带的序列化和反序列化过程。</p><p><code>size</code>成员变量记录当前<code>ArrayList</code>中元素的数量。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p><code>ArrayList</code>有三个构造方法</p><ul><li>使用默认大小的<code>ArrayList()</code></li><li>指定最初大小的<code>ArrayList(int initialCapacity)</code></li><li>根据一个给定集合来初始化的<code>ArrayList(Collection&lt;? extends E&gt; c)</code></li></ul><h2 id="使用默认大小"><a href="#使用默认大小" class="headerlink" title="使用默认大小"></a>使用默认大小</h2><p>类中首先指定了默认的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>但是，在它下面，还有这么一个东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>在最初被构造时，<code>elementData</code>会先指向<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，而不是直接创建一个容量为10的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处在于可以更合理的利用空间。试想一下，如果某个场景中需要创建5个<code>ArrayList</code>备用，如果直接就分配好空间的话，那么就会消耗掉至少50个元素所需要的空间。所以Java选择先将<code>elementData</code>指向一个空数组，在向<code>ArrayList</code>中添加数据时，再去创建合适大小的数组。</p><h2 id="指定最初大小"><a href="#指定最初大小" class="headerlink" title="指定最初大小"></a>指定最初大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当指定的大小是一个正整数时，Java会创建好对应大小的数组，并将<code>elementData</code>指向这个数组；如果指定的大小为零，那么Java也会将<code>elementData</code>指向一个共享的空数组<code>EMPTY_ELEMENTDATA</code>，注意这个空数组与上文提到的不是同一个；如果指定的大小为负数，则抛出一个异常。</p><p>那么为什么要专门把<code>EMPTY_ELEMENTDATA</code>和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>区分出来呢？<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>的JavaDoc是这么说的：</p><blockquote><p>We distinguish this from <code>EMPTY_ELEMENTDATA</code> to know how much to inflate when first element is added.<br>我们将它与<code>EMPTY_ELEMENTDATA</code>区分开来，是方便在添加第一个元素时计算要扩张多少空间。</p></blockquote><h2 id="根据给定的集合初始化"><a href="#根据给定的集合初始化" class="headerlink" title="根据给定的集合初始化"></a>根据给定的集合初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先试图调用给定集合的<code>Collection#toArray()</code>方法，将集合转换成一个<code>Object[]</code>数组。</p><p>当数组中有元素时，检查<code>elementData</code>的数据类型是否为<code>Object[]</code>类型，如果不是则使用<code>Arrays.copyOf()</code>方法重新复制元素到一个<code>Object[]</code>对象中；而当数组中没有元素时，则重新使<code>elementData</code>指向<code>EMPTY_ELEMENTDATA</code>。</p><h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>当添加元素时，首先会调用<code>ensureCapacityInternal()</code>方法，来保证空间足够。保证有足够空间后，就会向<code>elementData[size]</code>处放置被添加的元素，并且使<code>size</code>加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p><code>ensureCapacityInternal()</code>方法用于确保在添加元素时有足够的空间。如果空间不足，则会调用<code>grow()</code>方法扩容。</p><p><code>grow()</code>方法会将<code>elementData</code>扩张为当前的1.5倍空间，并使用<code>Arrays.copyOf()</code>方法将元素放入新的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算扩容目标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 检查目标容量是否大于当前已有容量</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 增加容量，以确保至少可以容纳minCapacity所指定个数的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity 目标最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newCapacity = olcCapacity + (oldCapacity / 2)</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><p><code>ArrayList</code>提供了两种方式来删除一个元素：根据元素位置(index)删除，和匹配元素删除。</p><h2 id="根据位置删除"><a href="#根据位置删除" class="headerlink" title="根据位置删除"></a>根据位置删除</h2><p>根据位置删除时，首先会检查给定的位置是否越界。如果没有越界，就会先取出被删除的元素，用来向调用方返回。</p><p>删除元素的方法是将<code>index+1</code>后面的元素重新放在<code>index</code>起始的位置上。可以看出，删除操作的消耗是比较高的。</p><p>在重新排列元素后，数组中最后一个元素将与倒数第二个元素重复。所以还需要将最后一个元素置为null，并将size减一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要移动的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(</span><br><span class="line">            <span class="comment">// 源</span></span><br><span class="line">            elementData,</span><br><span class="line">            <span class="comment">// 源位置</span></span><br><span class="line">            index+<span class="number">1</span>,</span><br><span class="line">            <span class="comment">// 目标</span></span><br><span class="line">            elementData,</span><br><span class="line">            <span class="comment">// 目标位置</span></span><br><span class="line">            index,</span><br><span class="line">            <span class="comment">// 要复制的个数</span></span><br><span class="line">            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配元素删除"><a href="#匹配元素删除" class="headerlink" title="匹配元素删除"></a>匹配元素删除</h2><p>如果向<code>remove()</code>方法提供了一个对象，那么<code>ArrayList</code>会遍历<code>elementData</code>，并会删除第一个与给定对象匹配的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缩减容量"><a href="#缩减容量" class="headerlink" title="缩减容量"></a>缩减容量</h1><p><code>ArrayList#trimToSize()</code>方法可以将<code>ArrayList</code>的容量缩减至当前元素个数。这个操作需要通过<code>Arrays.copyOf()</code>方法进行，所以成本也是比较高的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the</span></span><br><span class="line"><span class="comment"> * list's current size.  An application can use this operation to minimize</span></span><br><span class="line"><span class="comment"> * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Fail-fast"><a href="#Fail-fast" class="headerlink" title="Fail fast"></a>Fail fast</h1><p>在会改变<code>elementData</code>大小的方法中，经常会看到类似<code>modCount++</code>这样的操作。那么这个操作的目的是什么呢？</p><p>首先来看看<code>modCount</code>成员变量的JavaDoc是怎么说的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the size of the</span></span><br><span class="line"><span class="comment"> * list, or otherwise perturb it in such a fashion that iterations in</span></span><br><span class="line"><span class="comment"> * progress may yield incorrect results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This field is used by the iterator and list iterator implementation</span></span><br><span class="line"><span class="comment"> * returned by the &#123;<span class="doctag">@code</span> iterator&#125; and &#123;<span class="doctag">@code</span> listIterator&#125; methods.</span></span><br><span class="line"><span class="comment"> * If the value of this field changes unexpectedly, the iterator (or list</span></span><br><span class="line"><span class="comment"> * iterator) will throw a &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; in</span></span><br><span class="line"><span class="comment"> * response to the &#123;<span class="doctag">@code</span> next&#125;, &#123;<span class="doctag">@code</span> remove&#125;, &#123;<span class="doctag">@code</span> previous&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> set&#125; or &#123;<span class="doctag">@code</span> add&#125; operations.  This provides</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in</span></span><br><span class="line"><span class="comment"> * the face of concurrent modification during iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass</span></span><br><span class="line"><span class="comment"> * wishes to provide fail-fast iterators (and list iterators), then it</span></span><br><span class="line"><span class="comment"> * merely has to increment this field in its &#123;<span class="doctag">@code</span> add(int, E)&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> remove(int)&#125; methods (and any other methods that it overrides</span></span><br><span class="line"><span class="comment"> * that result in structural modifications to the list).  A single call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> add(int, E)&#125; or &#123;<span class="doctag">@code</span> remove(int)&#125; must add no more than</span></span><br><span class="line"><span class="comment"> * one to this field, or the iterators (and list iterators) will throw</span></span><br><span class="line"><span class="comment"> * bogus &#123;<span class="doctag">@code</span> ConcurrentModificationExceptions&#125;.  If an implementation</span></span><br><span class="line"><span class="comment"> * does not wish to provide fail-fast iterators, this field may be</span></span><br><span class="line"><span class="comment"> * ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>也就是说，<code>modCount</code>记录了一个<code>List</code>的结构被修改的次数，并且提到了如果在迭代过程中修改了<code>List</code>的结构，那么可能会导致得到错误的结果。</p><p>在迭代或者序列化的过程中，程序会检查<code>modCount</code>的值是否被修改过，如果被修改，就会抛出<code>ConcurrentModificationException</code>异常。比如<code>ArrayList.Itr#next()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><p>如上文所说，<code>ArrayList</code>实现了自己的序列化与反序列化方法，所以<code>elementData</code>使用<code>transient</code>修饰。</p><p>在序列化时，程序并不是直接序列化<code>elementData</code>这个数组，而是只取出数组中有效的元素(包括null元素)，并逐个序列化每个元素的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment"> * is, serialize it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反序列化时，首先会使<code>elementData</code>指向<code>EMPTY_ELEMENTDATA</code>，只在有元素会被反序列化时，才会为<code>elementData</code>扩容并逐个反序列化对应的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-arraylist.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java自定义注解</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-customized-annotations.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-customized-annotations.html</guid>
      <pubDate>Fri, 15 Mar 2019 01:49:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;注解是Java 5引入的一个新特性，它提供了一个用来将信息和元数据与程序元素相关联的能力，其作用如同一个修饰符，本身并不包含任何程序逻辑。&lt;/p&gt;
&lt;p&gt;本文将介绍如何创建和使用自定义的注解。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>注解是Java 5引入的一个新特性，它提供了一个用来将信息和元数据与程序元素相关联的能力，其作用如同一个修饰符，本身并不包含任何程序逻辑。</p><p>本文将介绍如何创建和使用自定义的注解。</p><a id="more"></a><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>Java自带了四个作用于注解上的注解，即元注解，分别是：</p><ul><li><code>@Documented</code>，用于注明该注解是否包含于JavaDoc中</li><li><code>@Retention</code>，用于注明这个注解将保留到什么时候</li><li><code>@Target</code>，用于注明这个注解将作用于哪些元素上</li><li><code>@Inherit</code>，用于注明该注解是否会被子类继承</li></ul><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><code>@Retention</code></h2><p><code>@Retention</code>元注解定义了这个注解的生命周期，即这个注解将保留到什么时候。注解的生命周期有这三种：</p><ul><li><code>RetentionPolicy.SOURCE</code>：仅在源码中保留，在编译期就会被丢弃。比如<code>@Override</code>和<code>@SuppressWarnings</code>就属于这类注解</li><li><code>RetentionPolicy.CLASS</code>：注解将会被写入到字节码中，但是在运行时会被丢弃。这个是默认的生命周期。</li><li><code>RetentionPolicy.RUNTIME</code>：该注解将保留至运行时。这意味着在运行时可以通过反射机制读取到注解的信息。</li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h2><p><code>@Target</code>元注解指定了该注解将可用于哪些元素上。可用的参数有如下几种：</p><ul><li><code>ElementType.ANNOTATION_TYPE</code>，用于描述注解。<code>@Target(ElementType.ANNOTATION_TYPE)</code>标注的注解将成为一个元注解。</li><li><code>ElementType.CONSTRUCTOR</code>，用于描述构造方法</li><li><code>ElementType.FIELD</code>，用于描述成员变量、对象、属性（包括enum实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>，用于描述局部变量</li><li><code>ElementType.METHOD</code>，用于描述方法</li><li><code>ElementType.PACKAGE</code>，用于描述包</li><li><code>ElementType.PARAMETER</code>，用于描述参数</li><li><code>ElementType.TYPE</code>，用于描述类、接口（包括注解）、enum生命声明</li></ul><p>Java 8中又新增了两个参数：</p><ul><li><code>ElementType.TYPE_PARAMETER</code>，可以用在Type的声明前</li><li><code>ElementType.TYPE_USE</code>，可以用在使用Type的地方</li></ul><h1 id="编写自定义注解及相关方法"><a href="#编写自定义注解及相关方法" class="headerlink" title="编写自定义注解及相关方法"></a>编写自定义注解及相关方法</h1><p>自定义注解的类型为<code>@interface</code>，注解中可以包含方法，方法名将作为注解的属性。</p><p>注解中的方法不可以有参数，也不可以抛出异常，同时方法只能返回原始类型、<code>String</code>、<code>Class</code>、<code>enums</code>、注解类型，以及上述类型的数组。方法的默认值不可以是<code>null</code>。</p><p>下面将通过一个示例演示如何编写和使用自定义注解相关的方法。</p><p>示例将分别创建两个名为<code>@JsonSerializable</code>和<code>@JsonElement</code>的注解，以及一个名为<code>JsonUtils</code>的工具类。</p><p><code>@JsonSerializable</code>标记一个类可以被序列化成JSON，<code>@JsonElement</code>标记一个成员变量将会被包含在这个JSON中；<code>JsonUtils</code>工具类包含将对象序列化为JSON的方法。</p><h2 id="JsonSerializable"><a href="#JsonSerializable" class="headerlink" title="@JsonSerializable"></a><code>@JsonSerializable</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记一个类可以被序列化成JSON</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解要在运行时通过反射获取，所以retention为runtime</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解作用于一个类，所以target为type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonSerializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JsonElement"><a href="#JsonElement" class="headerlink" title="@JsonElement"></a><code>@JsonElement</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记一个成员变量将会被包含在这个JSON中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解要在运行时通过反射获取，所以retention为runtime</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解作用于成员变量，所以target为field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonElement &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定该成员变量在JSON中的key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JsonUtils"><a href="#JsonUtils" class="headerlink" title="JsonUtils"></a><code>JsonUtils</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象序列化为JSON</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 要序列化的对象，需要有&#123;<span class="doctag">@link</span> JsonSerializable&#125;注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 序列化后的JSON字符串，如果不可序列化则是null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serializeToJson</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查对象是否可以被序列化</span></span><br><span class="line">        <span class="keyword">if</span> (!isSerializable(object)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得对象所属的类</span></span><br><span class="line">        Class clazz = object.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得类中的所有方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得所有方法的方法名，后面用于搜索</span></span><br><span class="line">        List&lt;String&gt; methodNames = Arrays.stream(methods).map(Method::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得类中所有成员变量，包括public、protected、private、和默认访问权限的</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个空的HashMap，用于存放要序列化的属性的名字和值</span></span><br><span class="line">        Map&lt;String, String&gt; elements = <span class="keyword">new</span> HashMap&lt;&gt;(fields.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有成员变量</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 如果有JsonElement注解</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(JsonElement.class)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取得变量名</span></span><br><span class="line">                String fieldName = field.getName();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拼接其对应getter方法名</span></span><br><span class="line">                <span class="comment">// 不直接使用setAccessible()方法是因为我不喜欢这么干，这会破坏封装性</span></span><br><span class="line">                String getterName = <span class="string">"get"</span> + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查这个变量是否有getter方法</span></span><br><span class="line">                <span class="keyword">if</span> (methodNames.contains(getterName)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果有getter方法，则根据方法名取得对应的方法实例</span></span><br><span class="line">                    Method method = clazz.getMethod(getterName);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取得JsonElement注解中设定的key值</span></span><br><span class="line">                    String keyName = field.getAnnotation(JsonElement.class).key();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果key的值为空字符串，则使用属性名作为JSON中的key名</span></span><br><span class="line">                    <span class="comment">// 否则取指定的key名</span></span><br><span class="line">                    <span class="comment">// 并调用变量对应的getter方法取得变量的值</span></span><br><span class="line">                    <span class="comment">// 最后放入HashMap中</span></span><br><span class="line">                    elements.put(<span class="string">""</span>.equals(keyName) ? field.getName() : keyName, String.valueOf(method.invoke(object)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历HashMap，构造JSON内容</span></span><br><span class="line">        String jsonBody = elements.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                <span class="comment">// 取得每个元素的key名和值，拼接成 \t"key":"value" 的形式</span></span><br><span class="line">                .map(entry -&gt; <span class="string">"\t\""</span> + entry.getKey() + <span class="string">"\":\""</span> + entry.getValue() + <span class="string">"\""</span>)</span><br><span class="line">                <span class="comment">// 每行元素间插入分隔符，逗号分隔每行数据，\n实现换行</span></span><br><span class="line">                .collect(Collectors.joining(<span class="string">",\n"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后拼接JSON首尾的大括号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\n"</span> + jsonBody + <span class="string">"\n&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查对象是否可被序列化成JSON</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 将被序列化的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否可被序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSerializable</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// null不可被序列化</span></span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class clazz = object.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有JsonSerializable注解，即可被序列化</span></span><br><span class="line">        <span class="keyword">return</span> clazz.isAnnotationPresent(JsonSerializable.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用自定义注解"><a href="#使用自定义注解" class="headerlink" title="使用自定义注解"></a>使用自定义注解</h1><p>首先创建一个<code>BookModel</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 书籍信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JsonSerializable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement</span>(key = <span class="string">"bookname"</span>) <span class="comment">// 在JSON中将bookName重命名为bookname</span></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement</span></span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookModel&#123;"</span> +</span><br><span class="line">                <span class="string">"bookName='"</span> + bookName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", category='"</span> + category + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getter，setter和构造方法略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在main方法里构造对象，并将其序列化成JSON：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BookModel book = <span class="keyword">new</span> BookModel(<span class="string">"Head First Java"</span>, <span class="string">"Java"</span>, <span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(JsonUtils.serializeToJson(book));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化后的结果将是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bookname"</span>:<span class="string">"Head First Java"</span>,</span><br><span class="line">    <span class="attr">"category"</span>:<span class="string">"Java"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="string">"55"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-customized-annotations.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>循序渐进写一个Servlet(5) - Filter</title>
      <link>https://www.boris1993.com/projects/java/Servlet/java-servlet-5-filter.html</link>
      <guid>https://www.boris1993.com/projects/java/Servlet/java-servlet-5-filter.html</guid>
      <pubDate>Wed, 13 Mar 2019 07:47:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。&lt;/p&gt;
&lt;p&gt;这篇博文将演示如何创建和使用filter。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。</p><p>这篇博文将演示如何创建和使用filter。</p><a id="more"></a><h1 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是<code>Filter</code></h1><p>当客户端向servlet容器发送请求时，请求通常会直接发送到servlet进行处理，就像下图这样：</p><p><img src="/images/java-servlet-5-filter/request-flow-without-filter.png" alt="Request flow without Filter"></p><p>但是，如果希望在请求被servlet处理之前和之后，再进行一些附加的处理，就可以使用<code>Filter</code>完成。</p><p><img src="/images/java-servlet-5-filter/request-flow-with-filter.png" alt="Request flow with Filter"></p><p>一个常见的使用场景是，在filter中定义如何检查请求是否合法，比如请求头中是否携带了有效的认证和鉴权信息；或者可以在filter中针对请求和响应记录日志。</p><h1 id="怎么使用Filter"><a href="#怎么使用Filter" class="headerlink" title="怎么使用Filter"></a>怎么使用<code>Filter</code></h1><p><code>javax.servlet.Filter</code>接口定义了一个filter的生命周期，要创建一个filter，就要实现<code>Filter</code>接口。</p><p><code>Filter</code>接口包含下列方法声明：</p><ol><li><code>init()</code>，用于定义在初始化这个filter时要执行的操作，该方法在filter的生命周期内只会执行一次；</li><li><code>doFilter()</code>，用于定义这个filter要进行的操作，每当有请求被发送到与该filter绑定的资源时，该方法都会被执行一次；</li><li><code>destroy()</code>，用于定义在停止这个filter时要执行的操作，只会在一个filter被销毁时执行。</li></ol><h2 id="创建一个实现Filter接口的类"><a href="#创建一个实现Filter接口的类" class="headerlink" title="创建一个实现Filter接口的类"></a>创建一个实现<code>Filter</code>接口的类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter1</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义这个filter的行为"><a href="#定义这个filter的行为" class="headerlink" title="定义这个filter的行为"></a>定义这个filter的行为</h2><p>在<code>doFilter()</code>方法内定义这个filter的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在处理请求前打印信息</span></span><br><span class="line">    System.out.println(<span class="string">"Request passing through Filter 1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交由FilterChain将请求交给下一个filter或交给servlet处理</span></span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// servlet发送响应后打印信息</span></span><br><span class="line">    System.out.println(<span class="string">"Response passing througe Filter 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在容器中注册filter"><a href="#在容器中注册filter" class="headerlink" title="在容器中注册filter"></a>在容器中注册filter</h2><p>与servlet一样，filter也需要在容器中注册之后才能发挥作用。注册filter也有两种方式：通过<code>web.xml</code>，或者通过<code>@WebFilter</code>注解。</p><p>这里有一点需要注意，虽然filter之间没有依赖关系，但是如果要保证filter的执行顺序，那么必须使用<code>web.xml</code>来注册。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5vcmFjbGUuY29tL290bmRvY3MvamNwL3NlcnZsZXQtMy4wLWZyLWV2YWwtb3RoLUpTcGVjLw==" title="https://download.oracle.com/otndocs/jcp/servlet-3.0-fr-eval-oth-JSpec/">Servlet 3.0 规范<i class="fa fa-external-link"></i></span>的<code>8.2.3</code>节中有如下说明：</p><blockquote><p>If the order in which the listeners, servlets, filters are invoked is important to an application then a deployment descriptor must be used.</p></blockquote><p>因为使用注解注册的filter，其调用顺序没有在规范中指定。</p><blockquote><p>As described above, when using annotations to define the listeners, servlets and filters, the order in which they are invoked is unspecified.</p></blockquote><p>如果一定要使用注解并保证filter的执行顺序，那么可以参考<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY1NjE4MTYvMzgzMzg1OA==" title="https://stackoverflow.com/a/6561816/3833858">Stack Overflow中这篇回答<i class="fa fa-external-link"></i></span>。</p><p>为了演示filter的执行顺序，这里再增加一个名为<code>Filter2</code>的filter，内容与<code>Filter1</code>类似。</p><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><code>web.xml</code></h3><p>在<code>web.xml</code>中增加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.boris.tomcatlistener.filter.Filter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demoServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.boris.tomcatlistener.filter.Filter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demoServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>filter</code>标签描述了一个filter的基本信息，其中filter名称(<code>filter-name</code>)和filter所在类(<code>filter-class</code>)为必填项。</p><p><code>filter-mapping</code>标签描述了一个filter将与哪个URL或者与哪个servlet绑定，<code>filter-name</code>指定使用哪个filter处理请求，<code>url-pattern</code>指定发往哪个URL的请求会触发这个filter，<code>servlet-name</code>指定发往哪个servlet的请求会触发这个filter。<code>url-pattern</code>和<code>servlet-name</code>可以同时存在，也可以同时存在多个。</p><p><code>filter-mapping</code>标签的先后顺序，将决定filter链中各个filter被调用的先后顺序。如上文中先配置了<code>filter1</code>后配置了<code>filter2</code>，那么在请求到达时，会先执行<code>filter1</code>然后再执行<code>filter2</code>。</p><p>配置完毕后部署并运行该项目，向<code>http://localhost:8080/servletdemo/DemoServlet</code>发送一个请求，在控制台可以看到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request passing through Filter 1</span><br><span class="line">Request passing through Filter 2</span><br><span class="line">Response passing througe Filter 2</span><br><span class="line">Response passing througe Filter 1</span><br></pre></td></tr></table></figure><h3 id="WebFilter注解"><a href="#WebFilter注解" class="headerlink" title="@WebFilter注解"></a><code>@WebFilter</code>注解</h3><p><code>@WebFilter</code>是<code>Servlet 3.0</code>中新增的特性，在<code>Tomcat 7</code>及以前版本中将无法工作。</p><p>以<code>Filter1</code>为例，为其添加如下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(</span><br><span class="line">    filterName = <span class="string">"filter1"</span>,</span><br><span class="line">    urlPatterns = <span class="string">"/demoServlet"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>filter-name</code>属性指定了这个filter的名称。</p><p>有三个属性可以指定filter的触发条件：</p><ol><li><code>value</code></li><li><code>urlPatterns</code></li><li><code>servletNames</code></li></ol><p>以上三个属性都可以接受一个字符串，或者用大括号包括起来的多个字符串。</p><p>在注解只有一个参数，并且该参数是指定要匹配的URL时，建议使用<code>value</code>属性，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value为默认的属性</span></span><br><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/demoServlet"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式指定value属性</span></span><br><span class="line"><span class="meta">@WebFilter</span>(value = <span class="string">"/demoServlet"</span>)</span><br></pre></td></tr></table></figure><p>否则，建议使用<code>urlPatterns</code>属性和<code>servletNames</code>属性。不允许<code>value</code>和<code>urlPatterns</code>同时出现。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5vcmFjbGUuY29tL290bmRvY3MvamNwL3NlcnZsZXQtMy4wLWZyLWV2YWwtb3RoLUpTcGVjLw==" title="https://download.oracle.com/otndocs/jcp/servlet-3.0-fr-eval-oth-JSpec/">Servlet 3.0 规范<i class="fa fa-external-link"></i></span>的<code>8.1.2 @WebFilter</code>节中说明原文如下：</p><blockquote><p>It is recommended to use value when the only attribute on the annotation is the url pattern and to use the urlPatterns attribute when the other attributes are also used. It is illegal to have both value and urlPatterns attribute used together on the same annotation.</p></blockquote><p>配置完毕后部署并运行该项目，向<code>http://localhost:8080/servletdemo/DemoServlet</code>发送一个请求，在控制台可以看到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request passing through Filter 1</span><br><span class="line">Response passing througe Filter 1</span><br></pre></td></tr></table></figure><h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul><li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个Servlet(1) - 介绍相关的接口和类</a></li><li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个Servlet(2) - 第一个servlet</a></li><li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个Servlet(3) - 分别处理GET和POST</a></li><li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个Servlet(4) - 会话追踪</a></li><li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个Servlet(5) - Filter</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/Servlet/java-servlet-5-filter.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>循序渐进写一个Servlet(4) - 会话追踪</title>
      <link>https://www.boris1993.com/projects/java/Servlet/java-servlet-4-session-tracking.html</link>
      <guid>https://www.boris1993.com/projects/java/Servlet/java-servlet-4-session-tracking.html</guid>
      <pubDate>Tue, 12 Mar 2019 03:26:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。&lt;/p&gt;
&lt;p&gt;这篇博文将演示如何使用&lt;code&gt;cookie&lt;/code&gt;和&lt;code&gt;session&lt;/code&gt;进行会话追踪。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。</p><p>这篇博文将演示如何使用<code>cookie</code>和<code>session</code>进行会话追踪。</p><a id="more"></a><p>HTTP协议是一个无状态的协议，也就是说，在服务器眼中，每一个HTTP请求都是一个全新的请求，每个请求之间没有关联。所以我们需要一个可以管理请求中携带的用户信息的方法。而会话追踪就是一个可以管理用户信息的方法。</p><p>会话追踪可以通过下列几个方式实现：</p><ol><li>Cookie</li><li>表单隐藏域</li><li>URL改写</li><li>HttpSession</li></ol><p>本文将主要演示<code>Cookie</code>和<code>HttpSession</code>的用法。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h1><h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><p><code>Cookie</code>是一串可以持久化于各个请求之间的信息片段。每个cookie都有一个名字，并有一个值，同时可以包含备注、路径、域名、过期时间、版本等附加信息。</p><p>Cookie有两种：</p><ol><li>非持久cookie，这种cookie只在会话中存留，并且不具有过期时间属性，一旦用户关闭浏览器(或者标签页)，也就是使这个会话失效，这个cookie就会丢失。</li><li>持久化cookie，这种cookie可以被用于多个会话中，而且只会在到达过期时间，或者用户主动使该cookie失效后，才会被删除。</li></ol><p>可以使用<code>HttpServletResponse#addCookie(Cookie)</code>方法在HTTP响应中携带cookie。</p><h2 id="保存cookie"><a href="#保存cookie" class="headerlink" title="保存cookie"></a>保存cookie</h2><p>首先修改前文中的<code>doPost()</code>方法，将请求中的参数取出来，并存入cookie。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有参数，得到一个Map</span></span><br><span class="line">    Map parameterMap = request.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历parameterMap</span></span><br><span class="line">        parameterMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将参数以 key = value 形式输出</span></span><br><span class="line">            writer.print(k + <span class="string">" = "</span> + ((String[]) v)[<span class="number">0</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数的key作为cookie的name，参数的value作为cookie的value</span></span><br><span class="line">            response.addCookie(<span class="keyword">new</span> Cookie(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发送一个<code>POST</code>请求，在返回中可以看到请求中的参数已经被放到cookie中，并返回到了客户端。</p><p><img src="/images/java-servlet-4-session-tracking/post-request-with-cookie.png" alt="POST request with cookie"></p><h2 id="使用cookie"><a href="#使用cookie" class="headerlink" title="使用cookie"></a>使用cookie</h2><p>一旦cookie被保存到了客户端，那么在下次访问这个cookie所对应的地址时，客户端就会自动将相关的cookie带入请求一并发送到服务端。所以客户端不需要对cookie主动做任何操作。</p><p>修改前文中的<code>doGet()</code>方法，使其可以取出cookie的值，并输出到页面上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类简化null判断</span></span><br><span class="line">    Optional&lt;String&gt; optionalQueryString = Optional.ofNullable(request.getQueryString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出每个参数</span></span><br><span class="line">    String[] queryStrings = optionalQueryString.isPresent() ? optionalQueryString.get().split(<span class="string">"&amp;"</span>) : <span class="keyword">new</span> String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Parameters: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (String query : queryStrings) &#123;</span><br><span class="line">            <span class="comment">// 取出参数的key和value</span></span><br><span class="line">            String[] q = query.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            writer.print(q[<span class="number">0</span>] + <span class="string">" = "</span> + q[<span class="number">1</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Cookies:&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从request中取出cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历各个cookie</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="comment">// 输出其name和value</span></span><br><span class="line">            writer.print(cookie.getName() + <span class="string">" = "</span> + cookie.getValue());</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发送一个<code>GET</code>请求，在返回中可以看到cookie中的内容已经被输出到页面上。</p><p><img src="/images/java-servlet-4-session-tracking/get-request-with-cookie.png" alt="GET request with cookie"></p><h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h2><p>将cookie的存活时间设为0，并返回到客户端，即可从客户端中删除这个cookie。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        <span class="comment">// JSESSIONID存放的是当前session的ID</span></span><br><span class="line">        <span class="comment">// 如果删掉这个cookie，那么当前的session也会被丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"JSESSIONID"</span>.equalsIgnoreCase(cookie.getName())) &#123;</span><br><span class="line">            <span class="comment">// 设定存活时间为0秒</span></span><br><span class="line">            cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将修改过的cookie放入响应中返回到客户端</span></span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = resp.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 因为response需要输出到客户端，才可以使新的cookie被送到客户端</span></span><br><span class="line">        <span class="comment">// 但是又懒得输出那么多东西了</span></span><br><span class="line">        <span class="comment">// 所以就输出了一个空字符串</span></span><br><span class="line">        <span class="comment">// 实际上输出内容不影响对cookie的操作</span></span><br><span class="line">        writer.print(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a><code>HttpSession</code></h1><h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h2><p>Session记录着一次会话相关的信息。</p><p>当一个请求到达服务器后，服务器会检查请求中是否包含session ID信息，比如在Tomcat中就是检查有无<code>JSESSIONID</code>这个cookie，或者URL中有无<code>JSESSIONID</code>这个查询字符串。如果找到了对应的session，则服务器会将这个session检索出来使用；请求中没有包含session ID，或者对应的session已经被销毁，则服务器会创建一个新的session并返回其ID。</p><p>Session ID通常以cookie的形式返回到客户端，如果客户端禁用了cookie，那么服务端则会使用URL重写技术将session ID写到URL中。</p><p>Session中可以键值对的形式保存附加数据，称为attributes。</p><p>与cookie不同，session保存于服务器端，而且它能保存的数据也不仅限于字符串。</p><h2 id="保存attribute"><a href="#保存attribute" class="headerlink" title="保存attribute"></a>保存attribute</h2><p>修改<code>doPost()</code>方法，编写修改session的代码。修改完成后发送一个带有参数的<code>POST</code>请求，以向session中写入一些数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有参数，得到一个Map</span></span><br><span class="line">    Map parameterMap = request.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    <span class="comment">// 如果没有，则会新建一个session并返回其ID</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历parameterMap</span></span><br><span class="line">        parameterMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将参数以 key = value 形式输出</span></span><br><span class="line">            writer.print(k + <span class="string">" = "</span> + ((String[]) v)[<span class="number">0</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数的key作为cookie的name，参数的value作为cookie的value</span></span><br><span class="line">            Cookie cookie = <span class="keyword">new</span> Cookie(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]);</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将各个参数放到session的attributes中</span></span><br><span class="line">            session.setAttribute(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取出attribute"><a href="#取出attribute" class="headerlink" title="取出attribute"></a>取出attribute</h2><p>修改<code>doGet()</code>方法，使其可以从session中取出attributes并显示在页面上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类简化null判断</span></span><br><span class="line">    Optional&lt;String&gt; optionalQueryString = Optional.ofNullable(request.getQueryString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有attribute的name</span></span><br><span class="line">    Enumeration&lt;String&gt; attributeNames = session.getAttributeNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出每个参数</span></span><br><span class="line">    String[] queryStrings = optionalQueryString.isPresent() ? optionalQueryString.get().split(<span class="string">"&amp;"</span>) : <span class="keyword">new</span> String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Parameters: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (String query : queryStrings) &#123;</span><br><span class="line">            <span class="comment">// 取出参数的key和value</span></span><br><span class="line">            String[] q = query.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            writer.print(q[<span class="number">0</span>] + <span class="string">" = "</span> + q[<span class="number">1</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Cookies:&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从request中取出cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历各个cookie</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="comment">// 输出其name和value</span></span><br><span class="line">            writer.print(cookie.getName() + <span class="string">" = "</span> + cookie.getValue());</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Attributes: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历attribute的各个name</span></span><br><span class="line">        <span class="keyword">while</span>(attributeNames.hasMoreElements()) &#123;</span><br><span class="line">            String key = attributeNames.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出attribute的值</span></span><br><span class="line">            String value = String.valueOf(session.getAttribute(key));</span><br><span class="line"></span><br><span class="line">            writer.print(key + <span class="string">" = "</span> + value);</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发送一个<code>GET</code>请求，在返回中就可以看到刚才保存在session中的数据：</p><p><img src="/images/java-servlet-4-session-tracking/get-request-with-session-attribute.png" alt="GET request with session attribute"></p><h2 id="删除attribute"><a href="#删除attribute" class="headerlink" title="删除attribute"></a>删除attribute</h2><p>此外<code>HttpSession</code>类提供了<code>removeAttribute()</code>方法用于删除一个attribute。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">    Enumeration&lt;String&gt; attributeNames = session.getAttributeNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        <span class="comment">// JSESSIONID存放的是当前session的ID</span></span><br><span class="line">        <span class="comment">// 如果删掉这个cookie，那么当前的session也会被丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"JSESSIONID"</span>.equalsIgnoreCase(cookie.getName())) &#123;</span><br><span class="line">            <span class="comment">// 设定存活时间为0秒</span></span><br><span class="line">            cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将修改过的cookie放入响应中返回到客户端</span></span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历attribute names</span></span><br><span class="line">        <span class="keyword">while</span>(attributeNames.hasMoreElements()) &#123;</span><br><span class="line">            String key = attributeNames.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将其从session中移除</span></span><br><span class="line">            session.removeAttribute(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = resp.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 因为response需要输出到客户端，才可以使新的cookie被送到客户端</span></span><br><span class="line">        <span class="comment">// 但是又懒得输出那么多东西了</span></span><br><span class="line">        <span class="comment">// 所以就输出了一个空字符串</span></span><br><span class="line">        <span class="comment">// 实际上输出内容不影响对cookie的操作</span></span><br><span class="line">        writer.print(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul><li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个Servlet(1) - 介绍相关的接口和类</a></li><li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个Servlet(2) - 第一个servlet</a></li><li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个Servlet(3) - 分别处理GET和POST</a></li><li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个Servlet(4) - 会话追踪</a></li><li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个Servlet(5) - Filter</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/Servlet/java-servlet-4-session-tracking.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>生产者与消费者问题在Java中的实现</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-producer-consumer-problem.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-producer-consumer-problem.html</guid>
      <pubDate>Mon, 11 Mar 2019 06:33:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;生产者与消费者问题(Producer-consumer problem)，也叫有限缓冲问题(Bounded-buffer problem)，是一个经典的多线程同步问题案例。&lt;/p&gt;
&lt;p&gt;该问题中有两个线程共享一个固定大小的缓冲区，一个线程作为生产者，负责向缓冲区中放入数据；另一个线程作为消费者，负责从缓冲区中取出数据。该问题的重点在于，要保证当缓冲区满时，生产者不能继续向其中放入数据，而当缓冲区空时，消费者也不能从缓冲区中取出数据。&lt;/p&gt;
&lt;p&gt;那么要保证以上两点，需要在缓冲区空时休眠消费者线程，并当缓冲区有数据之后唤醒消费者线程；以及当缓冲区满时休眠生产者线程，在缓冲区有空闲空间后唤醒生产者线程，或者直接在缓冲区满时放弃未存入缓冲区的数据。&lt;/p&gt;
&lt;p&gt;这个问题的难点在于可能会产生死锁。当陷入死锁时，生产者和消费者都会处于休眠状态，并等待对方唤醒自己。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>生产者与消费者问题(Producer-consumer problem)，也叫有限缓冲问题(Bounded-buffer problem)，是一个经典的多线程同步问题案例。</p><p>该问题中有两个线程共享一个固定大小的缓冲区，一个线程作为生产者，负责向缓冲区中放入数据；另一个线程作为消费者，负责从缓冲区中取出数据。该问题的重点在于，要保证当缓冲区满时，生产者不能继续向其中放入数据，而当缓冲区空时，消费者也不能从缓冲区中取出数据。</p><p>那么要保证以上两点，需要在缓冲区空时休眠消费者线程，并当缓冲区有数据之后唤醒消费者线程；以及当缓冲区满时休眠生产者线程，在缓冲区有空闲空间后唤醒生产者线程，或者直接在缓冲区满时放弃未存入缓冲区的数据。</p><p>这个问题的难点在于可能会产生死锁。当陷入死锁时，生产者和消费者都会处于休眠状态，并等待对方唤醒自己。</p><a id="more"></a><h1 id="使用同步锁实现"><a href="#使用同步锁实现" class="headerlink" title="使用同步锁实现"></a>使用同步锁实现</h1><h2 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h2><p>产品类代表将要被生产和消费的产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者-消费者问题 -- 产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product&#123;"</span> +</span><br><span class="line">                <span class="string">"productId="</span> + productId +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProductId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductId</span><span class="params">(<span class="keyword">int</span> productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仓库类"><a href="#仓库类" class="headerlink" title="仓库类"></a>仓库类</h2><p>仓库类用来构造一个存放产品的数组，并带有存取数组的方法(pop/push)，本质上是一个栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者-消费者问题 -- 仓库类(缓冲区)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Warehouse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product[] products;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Warehouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        products = <span class="keyword">new</span> Product[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Warehouse</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        products = <span class="keyword">new</span> Product[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产产品</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果仓库已满</span></span><br><span class="line">        <span class="keyword">if</span> (top == products.length) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Warehouse full."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将生产者线程置于等待态</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Warehouse full but failed to wait. Reason:"</span>);</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        products[top++] = product;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在仓库已有产品</span></span><br><span class="line">        <span class="comment">// 可以唤醒消费者线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费产品</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 取出的产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Product <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果仓库空</span></span><br><span class="line">        <span class="keyword">while</span> (products[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Warehouse empty"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒生产者线程</span></span><br><span class="line">            notifyAll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将消费者线程置于等待态</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Warehouse empty but failed to wait. Reason:"</span>);</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        product = products[--top];</span><br><span class="line">        products[top] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仓库非满，可以唤醒生产者线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String producerName;</span><br><span class="line">    <span class="keyword">private</span> Warehouse warehouse;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String producerName, Warehouse warehouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.producerName = producerName;</span><br><span class="line">        <span class="keyword">this</span>.warehouse = warehouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        produce();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产产品并存入仓库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Product product = <span class="keyword">new</span> Product(i++);</span><br><span class="line">            warehouse.push(product);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"[PRODUCED] Product "</span> + product.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred in producer thread. Reason: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String consumerName;</span><br><span class="line">    <span class="keyword">private</span> Warehouse warehouse;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String consumerName, Warehouse warehouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consumerName = consumerName;</span><br><span class="line">        <span class="keyword">this</span>.warehouse = warehouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Product product = warehouse.pop();</span><br><span class="line">            System.out.println(<span class="string">"[CONSUMED] Product "</span> + product.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred in consumer thread. Reason: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Warehouse warehouse = <span class="keyword">new</span> Warehouse();</span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(<span class="string">"producer"</span>, warehouse);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(<span class="string">"consumer"</span>, warehouse);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        executorService.execute(consumer);</span><br><span class="line">        executorService.execute(producer);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread pool is down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Warehouse empty</span><br><span class="line">[PRODUCED] Product 0</span><br><span class="line">[CONSUMED] Product 0</span><br><span class="line">[PRODUCED] Product 1</span><br><span class="line">[CONSUMED] Product 1</span><br><span class="line">[PRODUCED] Product 2</span><br><span class="line">[PRODUCED] Product 3</span><br><span class="line">[PRODUCED] Product 4</span><br><span class="line">[PRODUCED] Product 5</span><br><span class="line">[CONSUMED] Product 5</span><br><span class="line">[PRODUCED] Product 6</span><br><span class="line">[CONSUMED] Product 6</span><br><span class="line">[CONSUMED] Product 4</span><br><span class="line">[CONSUMED] Product 3</span><br><span class="line">[CONSUMED] Product 2</span><br><span class="line">[PRODUCED] Product 7</span><br><span class="line">[CONSUMED] Product 7</span><br><span class="line">[PRODUCED] Product 8</span><br><span class="line">[CONSUMED] Product 8</span><br><span class="line">Warehouse empty</span><br><span class="line">[PRODUCED] Product 9</span><br><span class="line">[CONSUMED] Product 9</span><br><span class="line">Warehouse empty</span><br></pre></td></tr></table></figure><h1 id="使用阻塞队列实现"><a href="#使用阻塞队列实现" class="headerlink" title="使用阻塞队列实现"></a>使用阻塞队列实现</h1><p>相比较于队列，阻塞队列(Blocking queue)可以在队列空时阻塞取值操作，并在队列满时阻塞存入操作。</p><p>实际上根据调用不同的方法，可以实现在队列空/满时抛出异常、返回特殊值、阻塞操作、带超时的阻塞操作，具体请参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzcvZG9jcy9hcGkvamF2YS91dGlsL2NvbmN1cnJlbnQvQmxvY2tpbmdRdWV1ZS5odG1s" title="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue文档<i class="fa fa-external-link"></i></span></p><h2 id="产品类和仓库类"><a href="#产品类和仓库类" class="headerlink" title="产品类和仓库类"></a>产品类和仓库类</h2><p>产品类实现同上，仓库使用阻塞队列(<code>ArrayBlockingQueue</code>)实现。</p><h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String producerName;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Product&gt; warehouse;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String producerName, BlockingQueue&lt;Product&gt; warehouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.producerName = producerName;</span><br><span class="line">        <span class="keyword">this</span>.warehouse = warehouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        produce();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产产品并存入仓库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Product product = <span class="keyword">new</span> Product(i++);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                warehouse.put(product);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred when putting product in producer. Reason: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"[PRODUCED] Product "</span> + product.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred in producer thread. Reason: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String consumerName;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Product&gt; warehouse;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String consumerName, BlockingQueue&lt;Product&gt; warehouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consumerName = consumerName;</span><br><span class="line">        <span class="keyword">this</span>.warehouse = warehouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Product product = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                product = warehouse.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred when taking product in consumer. Reason: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"[CONSUMED] Product "</span> + product.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred in consumer thread. Reason: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCED] Product 0</span><br><span class="line">[CONSUMED] Product 0</span><br><span class="line">[PRODUCED] Product 1</span><br><span class="line">[CONSUMED] Product 1</span><br><span class="line">[PRODUCED] Product 2</span><br><span class="line">[CONSUMED] Product 2</span><br><span class="line">[PRODUCED] Product 3</span><br><span class="line">[CONSUMED] Product 3</span><br><span class="line">[PRODUCED] Product 4</span><br><span class="line">[CONSUMED] Product 4</span><br><span class="line">[PRODUCED] Product 5</span><br><span class="line">[PRODUCED] Product 6</span><br><span class="line">[CONSUMED] Product 5</span><br><span class="line">[PRODUCED] Product 7</span><br><span class="line">[PRODUCED] Product 8</span><br><span class="line">[CONSUMED] Product 6</span><br><span class="line">[PRODUCED] Product 9</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-producer-consumer-problem.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>循序渐进写一个Servlet(3) - 分别处理GET和POST</title>
      <link>https://www.boris1993.com/projects/java/Servlet/java-servlet-3-handle-get-and-post.html</link>
      <guid>https://www.boris1993.com/projects/java/Servlet/java-servlet-3-handle-get-and-post.html</guid>
      <pubDate>Fri, 08 Mar 2019 03:13:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。&lt;/p&gt;
&lt;p&gt;这篇博文将演示如何分别处理&lt;code&gt;GET&lt;/code&gt;和&lt;code&gt;POST&lt;/code&gt;请求，以及处理请求中的参数。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。</p><p>这篇博文将演示如何分别处理<code>GET</code>和<code>POST</code>请求，以及处理请求中的参数。</p><a id="more"></a><h1 id="编写doGet-和doPost-方法"><a href="#编写doGet-和doPost-方法" class="headerlink" title="编写doGet()和doPost()方法"></a>编写<code>doGet()</code>和<code>doPost()</code>方法</h1><p>首先把要实现的功能写好，后面才好调用不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区分HTTP方法"><a href="#区分HTTP方法" class="headerlink" title="区分HTTP方法"></a>区分HTTP方法</h1><p>因为servlet是调用<code>service()</code>方法来处理请求的，所以对请求做区分也需要在<code>service()</code>方法中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    HttpServletRequest httpServletRequest = (HttpServletRequest) req;</span><br><span class="line">    HttpServletResponse httpServletResponse = (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"GET"</span>.equalsIgnoreCase(httpServletRequest.getMethod())) &#123;</span><br><span class="line">        doGet(httpServletRequest, httpServletResponse);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"POST"</span>.equalsIgnoreCase(httpServletRequest.getMethod())) &#123;</span><br><span class="line">        doPost(httpServletRequest, httpServletResponse);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果请求既不是GET也不是POST</span></span><br><span class="line">        <span class="comment">// 那么就返回HTTP 501 NOT IMPLEMENTED状态码</span></span><br><span class="line">        <span class="comment">// 毕竟不能把请求直接扔了，总是要有个返回的</span></span><br><span class="line">        httpServletResponse.sendError(<span class="number">501</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行起来看看效果"><a href="#运行起来看看效果" class="headerlink" title="运行起来看看效果"></a>运行起来看看效果</h1><p>首先发个<code>GET</code>请求</p><p><img src="/images/java-servlet-3-handle-get-and-post/handling-get-request.png" alt="Handling GET request"></p><p>再发个<code>POST</code>请求</p><p><img src="/images/java-servlet-3-handle-get-and-post/handling-post-request.png" alt="Handling POST request"></p><h1 id="为什么不用HttpServlet类呢"><a href="#为什么不用HttpServlet类呢" class="headerlink" title="为什么不用HttpServlet类呢"></a>为什么不用<code>HttpServlet</code>类呢</h1><p>没错，上面做的，就是自己实现了一个简陋的<code>HttpServlet</code>类，因为是循序渐进嘛，没头没脑的直接砸上来一个，算什么循序渐进。</p><p>那么现在就让<code>DemoServlet</code>继承<code>HttpServlet</code>。同时，因为<code>HttpServlet</code>已经在<code>service()</code>方法中实现了判断请求类型，所以<code>DemoServlet</code>中不要覆盖<code>service()</code>方法，只覆盖<code>doGet()</code>和<code>doPost()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">            <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">            writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">            <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">            writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="处理请求中的参数"><a href="#处理请求中的参数" class="headerlink" title="处理请求中的参数"></a>处理请求中的参数</h1><p>HTTP请求是可以带参数的，有了参数，那就得处理。</p><h2 id="处理GET请求的参数"><a href="#处理GET请求的参数" class="headerlink" title="处理GET请求的参数"></a>处理<code>GET</code>请求的参数</h2><p><code>GET</code>请求里带的参数，名字叫<code>查询字符串(query string)</code>，是一组或多组<code>key=value</code>格式的键值对。</p><p>Query string写在URL后面，以一个问号起头，用<code>&amp;</code>分隔各个键值对，即类似<code>http://localhost:8080/appname/servlet?arg1=value1&amp;arg2=value2&amp;...&amp;argN=valueN</code>。</p><p>在代码里使用<code>HttpServletRequest#getQueryString()</code>方法，就可以获取到问号后面的query string，分别用<code>&amp;</code>和<code>=</code>分割字符串，就可以取到每个参数的key和value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    String queryString = request.getQueryString();</span></span><br><span class="line"><span class="comment">    String[] queryStrings;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (queryString != null) &#123;</span></span><br><span class="line"><span class="comment">        queryStrings = queryString.split("&amp;");</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        queryStrings = new String[]&#123;&#125;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类简化null判断</span></span><br><span class="line">    Optional&lt;String&gt; optionalQueryString = Optional.ofNullable(request.getQueryString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有query string则取出每个参数</span></span><br><span class="line">    <span class="comment">// 如果没有则返回一个空的String数组</span></span><br><span class="line">    String[] queryStrings = optionalQueryString.isPresent() ? optionalQueryString.get().split(<span class="string">"&amp;"</span>) : <span class="keyword">new</span> String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (String query : queryStrings) &#123;</span><br><span class="line">            <span class="comment">// 取出参数的key和value</span></span><br><span class="line">            String[] q = query.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            writer.print(q[<span class="number">0</span>] + <span class="string">" = "</span> + q[<span class="number">1</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，结果是这样子的：</p><p><img src="/images/java-servlet-3-handle-get-and-post/handling-query-string.png" alt="Handling query string"></p><h2 id="处理POST请求的参数"><a href="#处理POST请求的参数" class="headerlink" title="处理POST请求的参数"></a>处理<code>POST</code>请求的参数</h2><p><code>POST</code>请求的参数就叫参数(parameter)，位于请求体(body)里，格式由<code>Content-Type</code>请求头决定。详细介绍可以参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9NZXRob2RzL1BPU1Q=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST">这篇MDN文档<i class="fa fa-external-link"></i></span>。</p><p><code>HttpServletRequest#getParameterMap()</code>方法可以取出请求中的所有参数，并放到一个Map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有参数，得到一个Map</span></span><br><span class="line">    Map parameterMap = request.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历parameterMap</span></span><br><span class="line">        parameterMap.forEach((k, v) -&gt; writer.print(k + <span class="string">" = "</span> + ((String[]) v)[<span class="number">0</span>] + <span class="string">"&lt;br&gt;"</span>));</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文中将使用<code>application/x-www-form-urlencoded</code>格式做示例。</p><p><img src="/images/java-servlet-3-handle-get-and-post/handling-parameter.png" alt="Handling parameter"></p><h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul><li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个Servlet(1) - 介绍相关的接口和类</a></li><li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个Servlet(2) - 第一个servlet</a></li><li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个Servlet(3) - 分别处理GET和POST</a></li><li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个Servlet(4) - 会话追踪</a></li><li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个Servlet(5) - Filter</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/Servlet/java-servlet-3-handle-get-and-post.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>循序渐进写一个Servlet(1) - 介绍相关的接口和类</title>
      <link>https://www.boris1993.com/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html</link>
      <guid>https://www.boris1993.com/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html</guid>
      <pubDate>Wed, 06 Mar 2019 02:04:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。&lt;/p&gt;
&lt;p&gt;这篇博文将介绍一些后面会用到的接口和类。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。</p><p>这篇博文将介绍一些后面会用到的接口和类。</p><a id="more"></a><h1 id="常用的类和接口"><a href="#常用的类和接口" class="headerlink" title="常用的类和接口"></a>常用的类和接口</h1><h2 id="javax-servlet-Servlet"><a href="#javax-servlet-Servlet" class="headerlink" title="javax.servlet.Servlet"></a><code>javax.servlet.Servlet</code></h2><p><code>javax.servlet.Servlet</code>是一个接口，它定义了一个servlet必须要实现的方法，包括如何初始化一个servlet，如何让这个servlet处理请求，以及如何将这个servlet从容器中移除，即“生命周期方法”。它们被调用的顺序，即servlet的生命周期，是这样的：</p><ol><li>容器生成这个servlet的对象，然后调用其<code>init()</code>方法完成初始化步骤</li><li>当收到请求之后，会调用其<code>service()</code>方法来处理请求</li><li>当这个servlet停止服务时，<code>destroy()</code>方法会被调用并准备销毁</li></ol><p>Servlet的启动时间由<code>web.xml</code>中<code>load-on-startup</code>属性决定，当值为负数或未设定该属性时，容器可以自由决定何时初始化该servlet；当值为零或正整数时，容器需要在启动时就初始化该servlet，此时该属性的值代表初始化的优先级，值越小优先级越高，对于有相同优先级的servlet，容器可以自行决定加载顺序。</p><p>当应用被重新部署，或者在容器停机时，servlet会被销毁，同时servet无法被手动销毁。</p><p>除了生命周期方法外，<code>Servlet</code>接口还有两个方法：</p><ol><li><code>getServletConfig()</code>可以让servlet取到启动相关的信息</li><li><code>getServletInfo()</code>用来获取servlet相关的信息，如作者、版本号、版权信息等</li></ol><h2 id="javax-servlet-GenericServlet"><a href="#javax-servlet-GenericServlet" class="headerlink" title="javax.servlet.GenericServlet"></a><code>javax.servlet.GenericServlet</code></h2><p><code>GenericServlet</code>类是一个抽象类，定义了一个协议无关的，通用的servlet实现。</p><p>它预置了<code>ServletConfig</code>接口的实现，并且简易实现了<code>Servlet</code>接口中的<code>init()</code>方法和<code>destroy()</code>方法，开发人员只需要覆盖<code>service()</code>方法。</p><h2 id="javax-servlet-http-HttpServlet"><a href="#javax-servlet-http-HttpServlet" class="headerlink" title="javax.servlet.http.HttpServlet"></a><code>javax.servlet.http.HttpServlet</code></h2><p><code>HttpServlet</code>类提供了一个用于处理HTTP请求的servlet基类。一个<code>HttpServlet</code>的子类至少需要覆盖一个方法，而且通常是覆盖如下几个方法：</p><ol><li><code>doGet()</code>，以实现对<code>HTTP GET</code>请求的处理</li><li><code>doPost()</code>，以实现对<code>HTTP POST</code>请求的处理</li><li><code>doPut()</code>，以实现对<code>HTTP PUT</code>请求的处理</li><li><code>doDelete()</code>，以实现对<code>HTTP DELETE</code>请求的处理</li><li><code>init()</code>和<code>destroy()</code>，以管理servlet生命周期内所需的资源</li><li><code>getServletInfo()</code>，可以用来自定义servlet返回哪些关于自身的信息</li></ol><p>此外，不建议直接覆盖<code>service()</code>方法，因为<code>HttpServlet#service()</code>方法中已经实现了根据HTTP请求类型调用对应的<code>doXXX()</code>方法。</p><p>如果某个HTTP方法对应的<code>doXXX()</code>方法没有被覆盖，则视为该servlet不支持这个HTTP方法。如在没有覆盖<code>doGet()</code>时收到<code>HTTP GET</code>请求，则会返回<code>HTTP 405 METHOD NOT ALLOWED (对应HTTP 1.1)</code>错误码，或<code>HTTP 400 BAD REQUEST (对应其他HTTP版本)</code>错误码。</p><p>需要注意的是，<code>HttpServlet</code>类并没有实现<code>HTTP CONNECT</code>和<code>HTTP PATCH</code>方法。当请求这两个方法，或其他非<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9NZXRob2Rz" title="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">标准<i class="fa fa-external-link"></i></span>方法时，将会返回<code>HTTP 501 NOT IMPLEMENTED</code>错误码。</p><h1 id="常用的常量"><a href="#常用的常量" class="headerlink" title="常用的常量"></a>常用的常量</h1><ul><li>HTTP方法相关的常量位于<code>HttpServlet</code>类中，是String类型，命名规则为<code>METHOD_方法</code>，如<code>METHOD_GET</code></li><li>HTTP状态码相关的常量位于<code>HttpServletResponse</code>类中，是int类型，命名规则为<code>SC_状态码名</code>，如<code>SC_OK</code>、<code>SC_NOT_FOUND</code></li></ul><h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul><li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个Servlet(1) - 介绍相关的接口和类</a></li><li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个Servlet(2) - 第一个servlet</a></li><li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个Servlet(3) - 分别处理GET和POST</a></li><li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个Servlet(4) - 会话追踪</a></li><li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个Servlet(5) - Filter</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>循序渐进写一个Servlet(2) - 第一个servlet</title>
      <link>https://www.boris1993.com/projects/java/Servlet/java-servlet-2-first-servlet.html</link>
      <guid>https://www.boris1993.com/projects/java/Servlet/java-servlet-2-first-servlet.html</guid>
      <pubDate>Wed, 06 Mar 2019 02:04:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。&lt;/p&gt;
&lt;p&gt;这篇博文将演示如何创建一个servlet。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。</p><p>这篇博文将演示如何创建一个servlet。</p><a id="more"></a><h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><p>首先，使用Maven的<code>maven-archetype-webapp</code>创建一个Java Webapp项目。这样就可以得到一个Java Webapp项目的基本骨架。将项目命名为<code>servletdemo</code>。</p><h1 id="创建Servlet对象"><a href="#创建Servlet对象" class="headerlink" title="创建Servlet对象"></a>创建Servlet对象</h1><p>新建一个名为DemoServlet的类。</p><p>因为<code>GenericServlet</code>已经实现了一个servlet的生命周期方法，而且这里也不需要对生命周期方法做定制化，所以直接继承一个<code>GenericServlet</code>就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现这个servlet的功能"><a href="#实现这个servlet的功能" class="headerlink" title="实现这个servlet的功能"></a>实现这个servlet的功能</h1><p><code>service()</code>方法定义了这个servlet的具体实现，这里先让它返回一个HTML。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    res.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    res.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java 8 新特性 - try with resources</span></span><br><span class="line">    <span class="comment">// 该特性优点在于，try代码块执行完毕后，会自动close相关资源</span></span><br><span class="line">    <span class="comment">// 要求资源所属的类必须实现了 AutoCloseable 或 Closeable 接口</span></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = res.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注册到容器"><a href="#注册到容器" class="headerlink" title="注册到容器"></a>注册到容器</h1><p>光有servlet还不够，下面还需要让容器知道有这个servlet，以及知道要把哪些请求发往这个servlet。这里可以通过修改<code>web.xml</code>的方式，也可以通过注解的方式完成注册。</p><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><code>web.xml</code></h2><p><code>web.xml</code>位于<code>src/main/webapp/WEB_INF/web.xml</code>。</p><p>向其中添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet属性定义了一个servlet的名字和对应的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.boris.tomcatlistener.servlet.DemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- servlet-mapping属性定义了匹配某个URL的请求应该发往哪个servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 目标servlet的servlet-name --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 匹配的URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demoServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>WebServlet(String value)</code>注解表明了这个类是一个servlet，其中<code>value</code>的值等同于<code>web.xml</code>中<code>url-patterm</code>参数。</p><p>在项目部署时，容器会处理<code>WebServlet</code>注解，并将这个servlet与指定的URL pattern绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/demoServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">        res.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">        res.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 8 新特性 - try with resources</span></span><br><span class="line">        <span class="comment">// 该特性优点在于，try代码块执行完毕后，会自动close相关资源</span></span><br><span class="line">        <span class="comment">// 要求资源所属的类必须实现了 AutoCloseable 或 Closeable 接口</span></span><br><span class="line">        <span class="keyword">try</span> (PrintWriter writer = res.getWriter()) &#123;</span><br><span class="line">            <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">            writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行起来吧，servlet哟！"><a href="#运行起来吧，servlet哟！" class="headerlink" title="运行起来吧，servlet哟！"></a>运行起来吧，servlet哟！</h1><p>在上面步骤中，创建一个servlet的所有步骤就完成了，尽管这个servlet的功能及其有限，它甚至不能区分发来的HTTP请求。</p><p>那么，就将这个servlet部署到容器中，让它开始工作吧。启动成功后，使用浏览器，或者HTTP请求构造工具，向<code>http://localhost:8080/servletdemo/DemoServlet</code>（假设Tomcat在监听8080端口）发一条请求。</p><p>如果一切正常的话，就可以看到服务器返回了上面<code>service()</code>方法中指定的内容。</p><h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul><li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个Servlet(1) - 介绍相关的接口和类</a></li><li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个Servlet(2) - 第一个servlet</a></li><li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个Servlet(3) - 分别处理GET和POST</a></li><li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个Servlet(4) - 会话追踪</a></li><li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个Servlet(5) - Filter</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/Servlet/java-servlet-2-first-servlet.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java线程池</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-thread-pool.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-thread-pool.html</guid>
      <pubDate>Mon, 04 Mar 2019 02:43:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;就像数据库连接可以使用连接池管理一样，Java中的线程也可以使用线程池来管理。本文介绍在Java中如何使用线程池，以及有哪些线程池。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>就像数据库连接可以使用连接池管理一样，Java中的线程也可以使用线程池来管理。本文介绍在Java中如何使用线程池，以及有哪些线程池。</p><a id="more"></a><h1 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h1><p>每个线程的创建和销毁，都会消耗一定的系统资源，尤其在高并发的系统中，频繁创建和销毁线程会造成大量的资源浪费。</p><p>那么，为了避免频繁的创建和销毁线程，就可以在系统启动时，预先创建好一定数量的线程，并将其交由线程调度器管理，这就是线程池。</p><h1 id="怎么使用线程池"><a href="#怎么使用线程池" class="headerlink" title="怎么使用线程池"></a>怎么使用线程池</h1><p>依旧是用一个示例来演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount-- + <span class="string">" tickets"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" stopped."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread pool created"</span>);</span><br><span class="line"></span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Assigning jobs to thread pool"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向线程池提交任务</span></span><br><span class="line">        executorService.execute(myRunnable);</span><br><span class="line">        executorService.execute(myRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在所有线程都完成工作后，线程池会继续等待新的工作任务</span></span><br><span class="line">        <span class="comment">// 所以如果需要程序在完成后退出，需要显式关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread pool is down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Thread pool created</span><br><span class="line">Assigning jobs to thread pool</span><br><span class="line">pool-1-thread-2 started.</span><br><span class="line">pool-1-thread-1 started.</span><br><span class="line">pool-1-thread-1 has 20 tickets</span><br><span class="line">pool-1-thread-2 has 19 tickets</span><br><span class="line">pool-1-thread-1 has 18 tickets</span><br><span class="line">pool-1-thread-2 has 17 tickets</span><br><span class="line">pool-1-thread-1 has 16 tickets</span><br><span class="line">pool-1-thread-2 has 15 tickets</span><br><span class="line">pool-1-thread-1 has 14 tickets</span><br><span class="line">pool-1-thread-2 has 13 tickets</span><br><span class="line">pool-1-thread-2 has 12 tickets</span><br><span class="line">pool-1-thread-1 has 11 tickets</span><br><span class="line">pool-1-thread-1 has 10 tickets</span><br><span class="line">pool-1-thread-2 has 9 tickets</span><br><span class="line">pool-1-thread-1 has 8 tickets</span><br><span class="line">pool-1-thread-2 has 7 tickets</span><br><span class="line">pool-1-thread-2 has 6 tickets</span><br><span class="line">pool-1-thread-1 has 5 tickets</span><br><span class="line">pool-1-thread-2 has 4 tickets</span><br><span class="line">pool-1-thread-1 has 3 tickets</span><br><span class="line">pool-1-thread-2 has 2 tickets</span><br><span class="line">pool-1-thread-1 has 1 tickets</span><br><span class="line">pool-1-thread-1 stopped.</span><br><span class="line">pool-1-thread-2 stopped.</span><br><span class="line">Thread pool is down</span><br></pre></td></tr></table></figure><h1 id="几种线程池的简介"><a href="#几种线程池的简介" class="headerlink" title="几种线程池的简介"></a>几种线程池的简介</h1><h2 id="固定线程池-Fixed-thread-pool"><a href="#固定线程池-Fixed-thread-pool" class="headerlink" title="固定线程池(Fixed thread pool)"></a>固定线程池(Fixed thread pool)</h2><p>使用<code>Executors.newFixedThreadPool(int nThreads)</code>创建。</p><p>该线程池维护着固定数量的线程(nThreads个)，在任何时间只允许最多nThreads个线程执行任务，多出来的任务将会在队列中等待，直到有空闲的线程出现。如果其中一个线程在执行过程中因为错误而异常退出，则线程池会立刻创建一个新的线程并执行后续的任务。</p><p>该线程池在显式关闭(<code>ExecutorService#shutdown</code>)前将一直存在。</p><h2 id="工作窃取线程池-Work-stealing-pool"><a href="#工作窃取线程池-Work-stealing-pool" class="headerlink" title="工作窃取线程池(Work stealing pool)"></a>工作窃取线程池(Work stealing pool)</h2><p>使用<code>Executors.newWorkStealingPool(int parallelism)</code>或<code>Executors.newWorkStealingPool()</code>创建。</p><p>该线程池无法保证各个被提交的任务将会以何种顺序执行。</p><h3 id="newWorkStealingPool-int-parallelism"><a href="#newWorkStealingPool-int-parallelism" class="headerlink" title="newWorkStealingPool(int parallelism)"></a><code>newWorkStealingPool(int parallelism)</code></h3><p>该方法将根据给定的“并行量(parallelism)”，来创建一个包含足够数量线程的线程池，并会<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQxMzQzNTAxLzM4MzM4NTg=" title="https://stackoverflow.com/a/41343501/3833858">使用多个队列来减少线程与队列的争抢<i class="fa fa-external-link"></i></span>。</p><p>“并行量”的值对应于最多允许参与执行任务的线程数量。但实际存在的线程数可能会动态的增减。</p><h3 id="Executors-newWorkStealingPool"><a href="#Executors-newWorkStealingPool" class="headerlink" title="Executors.newWorkStealingPool()"></a><code>Executors.newWorkStealingPool()</code></h3><p>将所有的“可用的处理器”的数目作为“并行量”来创建线程池。</p><p>可用的处理器数量使用<code>Runtime.getRuntime().availableProcessors()</code>获取，<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExODc4MDI4LzM4MzM4NTg=" title="https://stackoverflow.com/a/11878028/3833858">其值等同于CPU中逻辑处理器的数量<i class="fa fa-external-link"></i></span>。</p><h2 id="有缓存的线程池-Cached-thread-pool"><a href="#有缓存的线程池-Cached-thread-pool" class="headerlink" title="有缓存的线程池(Cached thread pool)"></a>有缓存的线程池(Cached thread pool)</h2><p>使用<code>Executors.newCachedThreadPool()</code>创建。</p><p>当接收到新的任务后，线程池会根据有无可用线程，来决定使用线程池中的空闲线程，或者在线程池中创建新的线程。</p><p>如果线程池中有线程空置超过60秒，则该线程就会被终止并从线程池中移除。</p><h2 id="可计划的线程池-Scheduled-thread-pool"><a href="#可计划的线程池-Scheduled-thread-pool" class="headerlink" title="可计划的线程池(Scheduled thread pool)"></a>可计划的线程池(Scheduled thread pool)</h2><p>使用<code>Executors.newScheduledThreadPool(int corePoolSize)</code>创建。<code>corePoolSize</code>为线程池中保持的线程数。</p><p>该线程池可以指定一个延迟，或指定一个周期，并按照这个计划执行任务。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9saWJyYXJ5L2otanRwMDczMC9pbmRleC5odG1s" title="https://www.ibm.com/developerworks/library/j-jtp0730/index.html">Thread pools and work queues<i class="fa fa-external-link"></i></span></p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-thread-pool.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程概念</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-concepts.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-concepts.html</guid>
      <pubDate>Sun, 03 Mar 2019 07:02:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文记录一些Java多线程相关的概念性的知识。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本文记录一些Java多线程相关的概念性的知识。</p><a id="more"></a><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p><img src="/images/java-multi-threading-concepts/java-thread-states.png" alt="Java thread states"></p><h2 id="新建-New"><a href="#新建-New" class="headerlink" title="新建(New)"></a>新建(New)</h2><p>线程已被创建，但是尚未启动</p><h2 id="可运行-Runnable"><a href="#可运行-Runnable" class="headerlink" title="可运行(Runnable)"></a>可运行(Runnable)</h2><p>此线程在JVM中正在运行</p><h2 id="阻塞-Blocked"><a href="#阻塞-Blocked" class="headerlink" title="阻塞(Blocked)"></a>阻塞(Blocked)</h2><p>此线程正在等待获取一个监视锁(monitor lock)，需要其他线程显式唤醒</p><h2 id="等待-Waiting"><a href="#等待-Waiting" class="headerlink" title="等待(Waiting)"></a>等待(Waiting)</h2><p>此线程正在无限期等待另一个线程完成某些工作</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td><code>Object#wait()</code></td><td><code>Object#notify()</code>或<code>Object#notifyAll()</code></td></tr><tr><td><code>Thread#join()</code></td><td>被调用的线程执行完毕</td></tr></tbody></table><h2 id="限期等待-Timed-waiting"><a href="#限期等待-Timed-waiting" class="headerlink" title="限期等待(Timed waiting)"></a>限期等待(Timed waiting)</h2><p>此线程正在有限期等待另一个线程完成某些工作</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td><code>Thread.sleep()</code></td><td>设定的休眠时间结束</td></tr><tr><td><code>Object#wait(long timeout)</code></td><td>时间结束 / <code>Object#notify()</code> / <code>Object#notifyAll()</code></td></tr><tr><td><code>Thread#join(long millis)</code></td><td>时间结束 / 被调用的线程执行完毕</td></tr></tbody></table><h2 id="终止-Terminated"><a href="#终止-Terminated" class="headerlink" title="终止(Terminated)"></a>终止(Terminated)</h2><p>线程结束</p><h1 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h1><p>见<a href="/projects/java/fundamentals/java-multi-threading-how-to.html">Java 如何创建和运行多线程</a></p><h1 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><code>synchronized</code></h2><h3 id="同步一个代码块"><a href="#同步一个代码块" class="headerlink" title="同步一个代码块"></a>同步一个代码块</h3><p>只作用于同一个对象，如多个<code>Thread</code>使用同一个<code>Runnable</code>时。一个线程若要使用此方法，则必须获得obj对象的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步一个方法"><a href="#同步一个方法" class="headerlink" title="同步一个方法"></a>同步一个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只作用于同一个对象。</span></span><br><span class="line"><span class="comment">// 一个线程若要使用此方法，则必须获得该方法所在对象的锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">synchronized</span> <span class="title">something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用于整个类</span></span><br><span class="line"><span class="comment">// 一个线程若要使用此方法，则必须获得该方法所在类的锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="title">aStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步一个类"><a href="#同步一个类" class="headerlink" title="同步一个类"></a>同步一个类</h3><p>作用于整个类，即使两个线程使用同一个类的不同对象，也会进行同步。一个线程若要使用此方法，则必须获得该类的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizationExample.class) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h2><p><code>ReentrantLock</code>是<code>java.util.concurrent</code>包中的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockDemo lockDemo = <span class="keyword">new</span> LockDemo();</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        executorService.execute(lockDemo);</span><br><span class="line">        executorService.execute(lockDemo);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h1><h2 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread#join()"></a><code>Thread#join()</code></h2><p>在A线程中调用B线程的<code>join()</code>方法，会将当前线程挂起，直到目标线程结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger ticketCount = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ticketCount.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount.getAndDecrement() + <span class="string">" tickets"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" stopped."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待 t1 执行完毕</span></span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 started.</span><br><span class="line">Thread-0 has 5 tickets</span><br><span class="line">Thread-0 has 4 tickets</span><br><span class="line">Thread-0 has 3 tickets</span><br><span class="line">Thread-0 has 2 tickets</span><br><span class="line">Thread-0 has 1 tickets</span><br><span class="line">Thread-0 stopped.</span><br><span class="line">Thread-1 started.</span><br><span class="line">Thread-2 started.</span><br><span class="line">Thread-1 has 5 tickets</span><br><span class="line">Thread-2 has 5 tickets</span><br><span class="line">Thread-2 has 4 tickets</span><br><span class="line">Thread-1 has 4 tickets</span><br><span class="line">Thread-2 has 3 tickets</span><br><span class="line">Thread-1 has 3 tickets</span><br><span class="line">Thread-2 has 2 tickets</span><br><span class="line">Thread-1 has 2 tickets</span><br><span class="line">Thread-1 has 1 tickets</span><br><span class="line">Thread-2 has 1 tickets</span><br><span class="line">Thread-1 stopped.</span><br><span class="line">Thread-2 stopped.</span><br></pre></td></tr></table></figure><h2 id="wait-，notify-，和notifyAll"><a href="#wait-，notify-，和notifyAll" class="headerlink" title="wait()，notify()，和notifyAll()"></a><code>wait()</code>，<code>notify()</code>，和<code>notifyAll()</code></h2><p><code>wait()</code>将当前线程变为等待状态，<code>notify()</code>和<code>notifyAll()</code>将等待状态的线程唤醒。<code>wait()</code>方法必须在有锁(即<code>synchronized</code>)的代码块中执行。</p><p>当有多个线程处于等待状态时，<code>notify()</code>会任意选择一个线程来唤醒，选择的方式由JVM的实现来决定；而<code>notifyAll()</code>则会唤醒所有等待中的线程。</p><p>因为线程唤醒后，程序将会从<code>wait()</code>的下一条语句中开始执行，所以<code>wait()</code>方法应当总在<code>while</code>循环中调用，通过循环条件控制线程是否继续等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        WaitNotifyDemo waitNotifyDemo = <span class="keyword">new</span> WaitNotifyDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用after()后，遇到wait()进入等待状态</span></span><br><span class="line">        executorService.execute(waitNotifyDemo::after);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用before()后，遇到`notifyAll()`，唤醒所有线程</span></span><br><span class="line">        executorService.execute(waitNotifyDemo::before);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-multi-threading-concepts.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>为webapp设定单独的context.xml</title>
      <link>https://www.boris1993.com/tools/tomcat/customize-context-xml-for-individual-webapp.html</link>
      <guid>https://www.boris1993.com/tools/tomcat/customize-context-xml-for-individual-webapp.html</guid>
      <pubDate>Fri, 01 Mar 2019 05:41:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;要给某个webapp设定单独的&lt;code&gt;context.xml&lt;/code&gt;，只需要在&lt;code&gt;${WEBAPP_ROOT}/webapp&lt;/code&gt;目录下新建一个&lt;code&gt;META-INF&lt;/code&gt;目录，并将&lt;code&gt;context.xml&lt;/code&gt;放进
        
      
      </description>
      
      <content:encoded><![CDATA[<p>要给某个webapp设定单独的<code>context.xml</code>，只需要在<code>${WEBAPP_ROOT}/webapp</code>目录下新建一个<code>META-INF</code>目录，并将<code>context.xml</code>放进去，就可以了。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/tomcat/customize-context-xml-for-individual-webapp.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
