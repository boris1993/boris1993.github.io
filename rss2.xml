<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Code Life</title>
    <link>https://www.boris1993.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>码农pilot的个人博客</description>
    <pubDate>Fri, 26 Nov 2021 19:46:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java 8 的一个 SNI 的 bug</title>
      <link>https://www.boris1993.com/others/java-8-sni-bug.html</link>
      <guid>https://www.boris1993.com/others/java-8-sni-bug.html</guid>
      <pubDate>Wed, 24 Nov 2021 09:17:22 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;联动&lt;a href=&quot;/tools/nginx/resolving-ngin
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>联动<a href="/tools/nginx/resolving-nginx-sni-issue.html">上一篇博文</a>，在解决了 OpenResty 上那个 SNI 的问题之后，我们发现有一个 Java 应用也有类似的问题。而最后发现，这是因为我们当前版本的 Java 中有一个 bug……</p><p>简单来说，就是在 <code>Java 1.8u141</code> 之前，<code>HttpsURLConnection#setDefaultHostnameVerifier()</code> 方法会破坏 SNI，而正好我们的代码里有这么一行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -&gt; <span class="keyword">true</span>);</span><br></pre></td></tr></tbody></table></figure><p>翻了下框架的代码，发现如果我不设定这个值，框架也调用这个方法来指定它默认的 hostname verifier；而如果我传个 null，那么它会抛个异常给我。所以，代码层面没有很方便的解决方案。</p><p>无奈，最后决定，先临时换了个没开启 SNI 的域名，暂时解决掉问题，然后升级 Java 到 <code>1.8u181</code>，一劳永逸。</p><hr><p>终于，我也有机会理直气壮地喊出 “这是 Java 的 bug” 了！（笑</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzA4MTc5MzQvZXh0ZW5kZWQtc2VydmVyLW5hbWUtc25pLWV4dGVuc2lvbi1ub3Qtc2VudC13aXRoLWpkazEtOC0wLWJ1dC1zZW5kLXdpdGgtamRrMS03">Extended server_name (SNI Extension) not sent with jdk1.8.0 but send with jdk1.7.0<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsuamF2YS5uZXQvYnJvd3NlL0pESy04MDcyNDY0">Custom HostnameVerifier disables SNI support on client in Java 8<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/others/java-8-sni-bug.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>记一次修复生产环境中 nginx 出现的 SNI 相关的问题</title>
      <link>https://www.boris1993.com/tools/nginx/resolving-nginx-sni-issue.html</link>
      <guid>https://www.boris1993.com/tools/nginx/resolving-nginx-sni-issue.html</guid>
      <pubDate>Sun, 21 Nov 2021 15:41:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;前段时间，我司出现了一次生产事故，调查后发现是当时的 OpenResty 配置不兼容 SNI 导致的。在这里我也记录一下整件事的排查过程，以及解决方法，供遇到类似问题的同志们参考。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前段时间，我司出现了一次生产事故，调查后发现是当时的 OpenResty 配置不兼容 SNI 导致的。在这里我也记录一下整件事的排查过程，以及解决方法，供遇到类似问题的同志们参考。</p><span id="more"></span><h1 id="事故症状"><a href="#事故症状" class="headerlink" title="事故症状"></a>事故症状</h1><p>某天开始，我司的 OpenResty 日志中大量出现 SSL 握手失败的错误，并影响了正常的业务。查看 OpenResty 日志，看到有大量这样子的报错：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021/10/19 20:51:30 [warn] 16776#16776: *1110324 upstream server temporarily disabled while SSL handshaking to upstream, client: [MASKED], server: localhost, request: "GET /endpoint/to/the/api?query=param HTTP/1.1", upstream: "https://MASKED:443/endpoint/to/the/api?query=param", host: "MASKED"</span><br><span class="line"></span><br><span class="line">2021/10/19 20:51:30 [error] 16776#16776: *1110324 SSL_do_handshake() failed (SSL: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error:SSL alert number 80) while SSL handshaking to upstream, client: MASKED, server: localhost, request: "GET /endpoint/to/the/api?query=param HTTP/1.1", upstream: "https://MASKED:443/endpoint/to/the/api?query=param", host: "MASKED"</span><br></pre></td></tr></tbody></table></figure><h1 id="调查中的弯路"><a href="#调查中的弯路" class="headerlink" title="调查中的弯路"></a>调查中的弯路</h1><p>知道了是 SSL 握手失败导致的问题，那么当然接下来就开始调查为什么会握手失败。是解析配置出错？还是证书出现问题？</p><p>按照一直的经验，我决定先用 <code>nslookup</code> 检查一下 DNS 解析。因为保密和时间问题，我就不把 <code>nslookup</code> 的输出放在这里了。简而言之，再出现问题之前，我司的域名都是通过 <code>CNAME</code> 记录解析到 Akamai 的 Edge 节点上的，但现在，却直接用 <code>A</code> 记录解析到了一个 IP 上，这让我感觉很奇怪。同时，我为了确认，又用 <code>openssl</code> 命令连接了一下解析出来的 IP，看它会返回什么证书信息，可出乎意料，啥也没有。</p><p>我感觉不对劲，于是联系了 NetOps 组。这时候，NetOps 点出了这篇博文的主题，SNI。</p><p>他说，给 <code>openssl</code> 命令加一个 <code>-servername</code> 参数，把目标服务器的域名放上去。我一试，好使了，Akamai 返回了正确的证书信息。</p><p>那么问题来了，解析没问题，那就是我有问题了。但问题出在哪呢？</p><h1 id="SNI是什么"><a href="#SNI是什么" class="headerlink" title="SNI是什么"></a>SNI 是什么</h1><p>在继续之前，我想先简单介绍一下，什么是 SNI。</p><p>根据维基百科 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[服务器名称指示](https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E7%A7%B0%E6%8C%87%E7%A4%BA)">[1]</span></a></sup> 中的说法：</p><blockquote><p>基于名称的虚拟主机允许多个 DNS 主机名由同一 IP 地址上的单个服务器（通常为 Web 服务器）托管。为了实现这一点，服务器使用客户端提供的主机名作为协议的一部分（对于 HTTP，名称显示在主机头中）。但是，当使用 HTTPS 时，TLS 握手发生在服务器看到任何 HTTP 头之前。因此，服务器不可能使用 HTTP 主机头中的信息来决定呈现哪个证书，并且因此只有由同一证书覆盖的名称才能由同一 IP 地址提供。<br>……<br>实际上，这意味着对于安全浏览来说，HTTPS 服务器只能是每个 IP 地址服务一个域名（或一组域名）。为每个站点分配单独的 IP 地址会增加托管成本，因为对 IP 地址的请求必须为区域互联网注册机构提供证据而且现在 IPv4 地址已用尽。<br>……<br>客户端在 SNI 扩展中发送要连接的主机名称，作为 TLS 协商的一部分。这使服务器能够提前选择正确的主机名称，并向浏览器提供相应 TLS 证书。从而，具有单个 IP 地址的服务器可以在获取公共证书不现实的情况下提供一组域名的 TLS 连接。</p></blockquote><p>也就是说，在握手的时候，我需要预先提供我要访问的网站的域名，这样服务器才会把正确的证书返回给我。而上面说的 <code>openssl</code> 命令中的 <code>-servername</code> 参数就是做了这件事。</p><h1 id="无心插柳，柳暗花明"><a href="#无心插柳，柳暗花明" class="headerlink" title="无心插柳，柳暗花明"></a>无心插柳，柳暗花明</h1><p>就在我拿着各种关键词 Google 的时候，一篇文章 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[SSL: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error:SSL alert number 80](https://www.dailytask.co/task/ssl-error14094438ssl-routinesssl3readbytestlsv1-alert-internal-errorssl-alert-number-80-ahmed-zidan)">[2]</span></a></sup> 引起了我的注意。</p><p>文章里描述的问题也是在 OpenResty 中出现了 SSL 握手失败，同样作者也在 <code>proxy_pass</code> 中用了 <code>upstream</code>。作者做了一个测试，如果在 <code>proxy_pass</code> 中直接写上游的域名，就没有问题，但是一旦用 <code>upstream</code>，就会出现握手失败。那么问题一定出现在 <code>upstream</code> 导致的某种行为变化。</p><p>然后作者发现，在用域名的时候，OpenResty 的变量 <code>$proxy_host</code> 存放的就是域名，可在用 <code>upstream</code> 的时候，这里面就变成了那个 <code>upstream</code> 的名字。</p><p>看到这，我知道了，这应该就是我这个问题的解决方案。</p><h1 id="动手解决问题"><a href="#动手解决问题" class="headerlink" title="动手解决问题"></a>动手解决问题</h1><p>首先我先展示一下修复前的 OpenResty 的一部分配置：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /path/to/endpoint {</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/proxy.common;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host api.$DOMAIN_FOR_GCP.com;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://gcp-https/path/to/the/endpoint/on/server;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见，如果按照这个配置，那么我发给 Akamai 的域名就是 <code>gcp-https</code>，而不是正确的 <code>api.mycompany.com</code>。</p><p>所以，根据那篇文章，以及参照 OpenResty 的手册 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[proxy_ssl_name - Module ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_name)">[3]</span></a></sup>，我在配置中增加了一条 <code>proxy_ssl_name</code> 指令，并将其配置为实际的后端服务的域名。</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /path/to/endpoint {</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/proxy.common;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host api.$DOMAIN_FOR_GCP.com;</span><br><span class="line">    <span class="comment"># THIS ONE</span></span><br><span class="line">    <span class="attribute">proxy_ssl_name</span> api.$DOMAIN_FOR_GCP.com;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://gcp-https/path/to/the/endpoint/on/server;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可部署新配置之后，问题并未解决，SSL 握手失败的问题依旧存在。</p><p>然后我注意到，那篇文章中还出现了一个指令 <code>proxy_ssl_server_name on;</code>。莫非，我们的 OpenResty 里面干脆没启用 SNI 支持？</p><p>在终端里 dump 了一下当前的配置，果然没有显式指定 <code>proxy_ssl_server_name</code> 的值，而默认情况下这个是被关闭的 <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[proxy_ssl_server_name - Module ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ssl_server_name)">[4]</span></a></sup>。那好办，我在 OpenResty 的全局配置中把它打开就好了。</p><p>然后再次部署测试，发现再没有 SSL 握手失败的问题，测试环境中业务也恢复了正常。火速打包上线生产环境，事故解决。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlDJThEJUU1JThBJUExJUU1JTk5JUE4JUU1JTkwJThEJUU3JUE3JUIwJUU2JThDJTg3JUU3JUE0JUJB"> 服务器名称指示<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGFpbHl0YXNrLmNvL3Rhc2svc3NsLWVycm9yMTQwOTQ0Mzhzc2wtcm91dGluZXNzc2wzcmVhZGJ5dGVzdGxzdjEtYWxlcnQtaW50ZXJuYWwtZXJyb3Jzc2wtYWxlcnQtbnVtYmVyLTgwLWFobWVkLXppZGFu">SSL: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error:SSL alert number 80<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfcHJveHlfbW9kdWxlLmh0bWwjcHJveHlfc3NsX25hbWU=">proxy_ssl_name - Module ngx_http_proxy_module<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfcHJveHlfbW9kdWxlLmh0bWwjcHJveHlfc3NsX3NlcnZlcl9uYW1l">proxy_ssl_server_name - Module ngx_http_proxy_module<i class="fa fa-external-link-alt"></i></span><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/nginx/resolving-nginx-sni-issue.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在群晖的 Docker 环境中运行甜糖星愿服务</title>
      <link>https://www.boris1993.com/others/run-tiantang-on-synology-docker.html</link>
      <guid>https://www.boris1993.com/others/run-tiantang-on-synology-docker.html</guid>
      <pubDate>Mon, 04 Jan 2021 14:14:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;前段时间在网上看到了一个叫 “甜糖星愿计划” 的东西，声称可以通过贡献闲置带宽来获得积分。正好我有个 NAS，正好我的宽带一天从白天闲到黑夜，不如利用起来，少少挣一些零花钱。&lt;/p&gt;
&lt;p&gt;需要注意的一点是，本文提到的镜像仅在我的&lt;code&gt;群晖DS218+&lt;/code&gt; 上测试过，虽然镜像中未使用任何群晖限定的依赖，理论上适用于任何 x86 架构的平台，但并不保证运行效果。而且本文目标平台是 x86，如果你拥有 ARM 平台的机器，那根本不需要废这个劲，你可以直接运行甜糖星愿的可执行程序。&lt;/p&gt;
&lt;p&gt;本文提到的操作全部基于 Docker，故在按照本文操作前，请先确保你已经拥有足够的知识来使用 &lt;code&gt;Docker&lt;/code&gt; 和 &lt;code&gt;docker-compose&lt;/code&gt;。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前段时间在网上看到了一个叫 “甜糖星愿计划” 的东西，声称可以通过贡献闲置带宽来获得积分。正好我有个 NAS，正好我的宽带一天从白天闲到黑夜，不如利用起来，少少挣一些零花钱。</p><p>需要注意的一点是，本文提到的镜像仅在我的<code>群晖DS218+</code> 上测试过，虽然镜像中未使用任何群晖限定的依赖，理论上适用于任何 x86 架构的平台，但并不保证运行效果。而且本文目标平台是 x86，如果你拥有 ARM 平台的机器，那根本不需要废这个劲，你可以直接运行甜糖星愿的可执行程序。</p><p>本文提到的操作全部基于 Docker，故在按照本文操作前，请先确保你已经拥有足够的知识来使用 <code>Docker</code> 和 <code>docker-compose</code>。</p><span id="more"></span><h2 id="我的网络环境"><a href="#我的网络环境" class="headerlink" title="我的网络环境"></a>我的网络环境</h2><p>因为这个镜像相关的一些配置是以我的网络结构为基础的，所以我觉得有必要简单说一下我的网络结构是什么样的。</p><p>简单来说，我的网络就是这样子的。虽然网络里还有别的设备，但是因为与本文无关，我就略掉了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[公网] -- [光猫] -- [群晖]</span><br></pre></td></tr></tbody></table></figure><p>其中光猫负责拨号，所以它也是最外层的一个路由器，光猫的 IP 地址是 <code>192.168.1.1</code>，它下面有一个 <code>192.168.1.0/24</code> 的子网，群晖与光猫直连，有一个 <code>192.168.1.0/24</code> 子网下的 IP 地址。在群晖的 Docker 中，会有一个 <code>macvlan</code> 驱动的网络，与物理网卡共享同一个子网。甜糖星愿的容器将会接入到这个 <code>macvlan</code> 网络，在接入时我会手动为其分配一个 IP 地址。</p><h2 id="安装Docker及配置网络"><a href="#安装Docker及配置网络" class="headerlink" title="安装Docker及配置网络"></a>安装 Docker 及配置网络</h2><p>因为本文是通过 Docker 来实现的，所以第一步当然是安装 Docker。群晖嘛就从套件商店安装，其他平台就用自己平台的方法安装，总之装上 Docker 就行。安装好 Docker 之后，进入<code>控制面板 -- 网络 -- 网络界面</code>，选择连接公网的接口，如<code>局域网1</code>，点击<code>管理 -- Open vSwitch设置</code>，勾选<code>启用 Open vSwitch</code>。</p><p>然后我们需要在 Docker 里面创建一个 <code>macvlan</code> 驱动的网络，命令如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network create \</span><br><span class="line">    -d macvlan \</span><br><span class="line">    --subnet=192.168.1.0/24 \</span><br><span class="line">    --gateway=192.168.1.1 \</span><br><span class="line">    -o parent=ovs_eth0 \</span><br><span class="line">    macvlan</span><br></pre></td></tr></tbody></table></figure><p>上面命令中 <code>subnet</code> 的值替换成群晖所在网络的子网，<code>gateway</code> 指向该子网的网关，<code>parent</code> 指向要绑定的物理网卡，最后面的 <code>macvlan</code> 是网络名，可以按需修改。</p><h2 id="准备二进制翻译器"><a href="#准备二进制翻译器" class="headerlink" title="准备二进制翻译器"></a>准备二进制翻译器</h2><p>接下来，我们要借助 QEMU 的力量，放一个幻术。毕竟，甜糖星愿只给了 ARM 平台的可执行程序，直接在 x86 平台跑肯定是跑不起来的，所以我们要向内核注册一个翻译器，这样 Docker 在执行其他平台的机器码时就可以通过这个翻译器将其翻译成 x86 指令来执行了。是的，我知道这玩意效率不高，我已经体验过了。</p><p>首先，克隆这个镜像的源码仓库 <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[tiantang-x86-docker - Docker Hub](https://hub.docker.com/repository/docker/boris1993/tiantang-x86-docker)">[2]</span></a></sup>，找到 <code>resources/qemu-aarch64-static</code>，或者你直接<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL211bHRpYXJjaC9xZW11LXVzZXItc3RhdGljL3JlbGVhc2VzL2Rvd25sb2FkL3Y1LjIuMC0yL3FlbXUtYWFyY2g2NC1zdGF0aWM=">从 GitHub 下载 qemu-aarch64-static<i class="fa fa-external-link-alt"></i></span>也行，把这个文件放到 <code>$PATH</code> 指定的目录，赋予执行权限。</p><p>然后施法吟唱，很简单，就一句话：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --rm --privileged multiarch/qemu-user-static:register</span><br></pre></td></tr></tbody></table></figure><p>但是，这个幻术在群晖重启之后就会消失，幻术没了，甜糖星愿就起不来。所以我们还得配一个开机后的自启动任务，让群晖帮我们自动吟唱。操作也很简单，首先将本仓库的 <code>set_qemu_user_static.sh</code> 放到一个合适的位置，比如我放到了 <code>/var/services/homes/boris1993/scripts</code>，然后前往<code>控制面板 -- 任务计划</code>，然后按照如下说明新增一个任务计划：</p><ul><li>任务名称：可自选</li><li>用户账号：root</li><li> 事件：开机</li><li>任务设置页面的运行命令：<br><code>/var/services/homes/boris1993/scripts/set_qemu_user_static.sh</code></li></ul><p>如果要看这个脚本的日志的话，在<code>运行命令</code>里面把脚本输出重定向到一个文件就可以了。</p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>进入本仓库所在目录，或者下载<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2JvcmlzMTk5My90aWFudGFuZy14ODYtZG9ja2VyL21hc3Rlci9kb2NrZXItY29tcG9zZS55bWw="> docker-compose.yml<i class="fa fa-external-link-alt"></i></span>到一个合适的目录下，然后稍微编辑一下，以符合你的网络状况。主要要检查的就是 <code>networks.macvlan.ipv4_address</code> 的值，要确保它处在上面创建的那个 <code>macvlan</code> 网络的子网中。</p><p>确认无误后，执行 <code>sudo docker-compose up -d</code>，Docker 就会自动拉取镜像，并启动一个名为 <code>tiantang</code> 的容器。</p><p>容器内的甜糖星愿在首次启动时会自动退出，这是因为它在自我更新（我就不说这个操作一开始给了我多大的困扰了）。不要怕，容器里面有一个每分钟执行一次的定时任务，在没有发现甜糖星愿的进程时会自动将它启动。</p><p>除此之外，我会在容器启动两分钟后，检测甜糖星愿监听了哪些端口，然后通过脚本自动设置路由器上的 UPnP 规则，这样你就不需要将甜糖星愿容器的 IP 放到 DMZ 里，也不需要手动配置端口转发了。当然这个操作的前提是，你的路由器支持 UPnP，并且你启用了 UPnP，如果没有的话，那你只能手动操作了。或者，如果你不想让脚本自动配置 UPnP，或者客观条件下不允许你这么做，那么你可以把 <code>docker-compose.yml</code> 中 <code>SKIP_UPNP_AUTOCONFIG</code> 这一环境变量置为 <code>true</code>，这样脚本就不会执行了。</p><p>在甜糖星愿稳定运行，且端口转发规则也配置成功后，就可以通过手机客户端绑定这个节点了。但是这里有个问题，就是手机与甜糖星愿必须处在同一个子网里才能自动发现，如果因为各种原因没能自动发现，那么你可以在 <code>tiantang</code> 这个容器中打开一个 <code>bash</code> 终端，执行 <code>ttnode_168 -p /data</code>，在输出中会打印出这个节点的 UID，将其复制到任意二维码生成工具中生成一个二维码，然后用手机端扫描这个二维码，即可完成绑定。</p><p>在这之后，就没什么我们能做的了。我们就慢慢等着甜糖星愿给你分配任务吧。我是等了大概有两三天才开始跑流量的。如果在配置好 UPnP 后，手机端仍提示 “未配置网络”，那有可能是在配置 UPnP 的脚本启动时，甜糖星愿尚未打开所有端口，导致 UPnP 规则不完整。你可以前往路由器的 UPnP 页面，将页面显示结果与 <code>netstat -nlp | grep qemu</code> 命令的输出做对比，如果不一致的话，重新手动运行 <code>set-port-forwarding.sh</code> 脚本即可。</p><h2 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h2><p>如果你不止满足于把它跑起来，还想要了解这个镜像背后的运作方式，那么你可以前往这个镜像的 GitHub 仓库 <sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[tiantang-x86-docker - GitHub](https://github.com/boris1993/tiantang-x86-docker)">[3]</span></a></sup> 阅读该镜像相关的源码。在源码中我也写了注释，可以方便你理解我的想法。</p><h2 id="我的邀请码"><a href="#我的邀请码" class="headerlink" title="我的邀请码"></a>我的邀请码</h2><p>如果我的镜像帮到了你，或者我的这篇文章帮到了你，那么如果你愿意的话，你可以在手机客户端的<code>填写邀请码</code>处，填上我的邀请码<strong><code>804744</code></strong>，这样你可以获得 15 张加成卡，当然我也会得到一些加成。反正互利互惠，我的加成不会从你的身上扣掉，何乐而不为呢？</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cDovL20udGlhbnRhbmcubW9nZW5jbG91ZC5jb20v"> 甜糖星愿官方网站<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yZXBvc2l0b3J5L2RvY2tlci9ib3JpczE5OTMvdGlhbnRhbmcteDg2LWRvY2tlcg==">tiantang-x86-docker - Docker Hub<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My90aWFudGFuZy14ODYtZG9ja2Vy">tiantang-x86-docker - GitHub<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/others/run-tiantang-on-synology-docker.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 Google Cloud Logging 的日志输出中增加类名、方法名和行数</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/gcp-logging-show-class-and-method-name.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/gcp-logging-show-class-and-method-name.html</guid>
      <pubDate>Sun, 30 Aug 2020 06:09:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;由于我司目前的项目都运行在 Google Cloud Platform (以下简称 GCP) 上，那么自然而然的，我们选择了使用 GCP 的 Logging 来查看日志。在使用过程中，我们发现了一个问题，那就是我们无法直观的看到日志是从什么地方打印出来的，经常需要通过日志内容，在代码里面通过全文搜索来定位。这样就产生了一个需求：可不可以把这条日志所在的类、方法，和行数一起打印在日志中？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>由于我司目前的项目都运行在 Google Cloud Platform (以下简称 GCP) 上，那么自然而然的，我们选择了使用 GCP 的 Logging 来查看日志。在使用过程中，我们发现了一个问题，那就是我们无法直观的看到日志是从什么地方打印出来的，经常需要通过日志内容，在代码里面通过全文搜索来定位。这样就产生了一个需求：可不可以把这条日志所在的类、方法，和行数一起打印在日志中？</p><span id="more"></span><h2 id="日志是怎么生成的"><a href="#日志是怎么生成的" class="headerlink" title="日志是怎么生成的"></a>日志是怎么生成的</h2><p>既然要实现自动化地修改日志的内容，那么我们首先得要知道，日志的内容是怎么产生的。根据我们的 <code>logback-spring.xml</code> 中的配置，我们可以定位到，日志是从 <code>StackdriverJsonLayout</code> 这个类中生成出来的。</p><p>打开这个文件，阅读源码，发现有一个名为 <code>toJsonMap</code> 的方法很像我们这次的目标，为了大家省事，我从 GitHub 上把这段源码拿到了这里。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a logging event into a Map.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the logging event</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map which should get rendered as JSON</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">toJsonMap</span><span class="params">(ILoggingEvent event)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeMDC) {</span><br><span class="line">        event.getMDCPropertyMap().forEach((key, value) -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (!FILTERED_MDC_FIELDS.contains(key)) {</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeTimestamp) {</span><br><span class="line">        map.put(StackdriverTraceConstants.TIMESTAMP_SECONDS_ATTRIBUTE,</span><br><span class="line">                TimeUnit.MILLISECONDS.toSeconds(event.getTimeStamp()));</span><br><span class="line">        map.put(StackdriverTraceConstants.TIMESTAMP_NANOS_ATTRIBUTE,</span><br><span class="line">                TimeUnit.MILLISECONDS.toNanos(event.getTimeStamp() % <span class="number">1_000</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    add(StackdriverTraceConstants.SEVERITY_ATTRIBUTE, <span class="keyword">this</span>.includeLevel,</span><br><span class="line">            String.valueOf(event.getLevel()), map);</span><br><span class="line">    add(JsonLayout.THREAD_ATTR_NAME, <span class="keyword">this</span>.includeThreadName, event.getThreadName(), map);</span><br><span class="line">    add(JsonLayout.LOGGER_ATTR_NAME, <span class="keyword">this</span>.includeLoggerName, event.getLoggerName(), map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意看这个if块，我们的日志语句就是在这里被处理的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeFormattedMessage) {</span><br><span class="line">        String message = event.getFormattedMessage();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.includeExceptionInMessage) {</span><br><span class="line">            IThrowableProxy throwableProxy = event.getThrowableProxy();</span><br><span class="line">            <span class="keyword">if</span> (throwableProxy != <span class="keyword">null</span>) {</span><br><span class="line">                String stackTrace = getThrowableProxyConverter().convert(event);</span><br><span class="line">                <span class="keyword">if</span> (stackTrace != <span class="keyword">null</span> &amp;&amp; !stackTrace.equals(<span class="string">""</span>)) {</span><br><span class="line">                    message += <span class="string">"\n"</span> + stackTrace;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, message);</span><br><span class="line">    }</span><br><span class="line">    add(JsonLayout.MESSAGE_ATTR_NAME, <span class="keyword">this</span>.includeMessage, event.getMessage(), map);</span><br><span class="line">    add(JsonLayout.CONTEXT_ATTR_NAME, <span class="keyword">this</span>.includeContextName, event.getLoggerContextVO().getName(), map);</span><br><span class="line">    addThrowableInfo(JsonLayout.EXCEPTION_ATTR_NAME, <span class="keyword">this</span>.includeException, event, map);</span><br><span class="line">    addTraceId(event, map);</span><br><span class="line">    add(StackdriverTraceConstants.SPAN_ID_ATTRIBUTE, <span class="keyword">this</span>.includeSpanId,</span><br><span class="line">            event.getMDCPropertyMap().get(StackdriverTraceConstants.MDC_FIELD_SPAN_ID), map);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.serviceContext != <span class="keyword">null</span>) {</span><br><span class="line">        map.put(StackdriverTraceConstants.SERVICE_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.serviceContext);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customJson != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.customJson.isEmpty()) {</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : <span class="keyword">this</span>.customJson.entrySet()) {</span><br><span class="line">            map.putIfAbsent(entry.getKey(), entry.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addCustomDataToJsonMap(map, event);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看起来篇幅好像很大，但是仔细一看，不难明白，它就是生成了一个 <code>Map</code>，而这个 <code>Map</code> 里面放的，就是最后我们在 GCP Logging 里面将要看到的日志。好了，目标找到了，那就准备动手吧。</p><h2 id="修改日志内容"><a href="#修改日志内容" class="headerlink" title="修改日志内容"></a>修改日志内容</h2><p>要修改的方法找到了，但是我们仍不知道应该怎么取得类名、方法和行号。经过又一顿网上冲浪，加上在源码里面一刨一刨的翻，和一点小小的灵感，最后得知这些信息全部可以通过 <code>ILoggingEvent#getCallerData()</code> 方法取得。请原谅因为时间过去的有点久，我已经找不到当时给我指路的文章，所以也就不能放在下面的参考中了。</p><p>那么我们就开始着手实现这个需求吧。首先在项目里面新建一个类，因为我们的目的是重写 <code>toJsonMap</code> 这个方法，所以要让它继承 <code>StackdriverJsonLayout</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcpLoggingLayout</span> <span class="keyword">extends</span> <span class="title">StackdriverJsonLayout</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">toJsonMap</span><span class="params">(ILoggingEvent event)</span> </span>{</span><br><span class="line">        <span class="comment">// 先调用原本的方法，把日志的信息全部生成好</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>.toJsonMap(event);</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] callerData = event.getCallerData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有callerData，那后面也没法操作了</span></span><br><span class="line">        <span class="keyword">if</span> (callerData == <span class="keyword">null</span> || callerData.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素就是这个日志所在位置的信息</span></span><br><span class="line">        StackTraceElement stackTraceElement = callerData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我只需要类名，不需要前面的包名</span></span><br><span class="line">        <span class="comment">// 而 getClassName() 会返回类的全限定名</span></span><br><span class="line">        <span class="comment">// 所以我把它拆了，取最后一个元素，也就是类名</span></span><br><span class="line">        String[] classNameParts = stackTraceElement.getClassName().split(<span class="string">"\\."</span>);</span><br><span class="line">        String callerClass = classNameParts[classNameParts.size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        String methodName = stackTraceElement.getMethodName();</span><br><span class="line">        String lineNumber = stackTraceElement.getLineNumber().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个是原本的日志信息</span></span><br><span class="line">        String originalMessage = map.get(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把类名、方法名、行数附加在原本的信息前面</span></span><br><span class="line">        String enhancedMessage = <span class="string">"class="</span> + callerClass + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"method="</span> + methodName + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"line="</span> + lineNumber + <span class="string">" "</span></span><br><span class="line">                                + originalMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把改好的日志放回去</span></span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, enhancedMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们的日志里就带上了类名、方法名，和行号了。但是到了这里并没有结束，因为上面的代码有一个问题：框架打出来的日志也带上了这些信息。虽然不影响使用，但是它不好看，我不想要。所以我决定继续优化一下。</p><h2 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h2><p>稍加思索，我提出了两个新的需求：</p><ul><li>要根据包名过滤，只给指定的包里面的类加上这些信息。这样，我就可以排除掉所有无关的包。</li><li>还要根据类名过滤，遇到被指定的类，我就不加上这些信息。因为对于启动类 (就是放 <code>main</code> 方法那个)，和一些用于健康检查的类，它们打出的日志也没必要加上这些信息。</li></ul><p>但是很明显，原厂的功能并不足以实现这两个需求。我为了这两个需求，新增了两个参数：<code>appPackage</code> 用来指定应用的包名，<code>excludedClassNames</code> 用来指定要被排除的类。</p><p>增加了参数，那必然也要修改代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcpLoggingLayout</span> <span class="keyword">extends</span> <span class="title">StackdriverJsonLayout</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String appPackage;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; excludedClassNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppPackage</span><span class="params">(String appPackage)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.appPackage = appPackage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppPackage</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.appPackage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要注意</span></span><br><span class="line">    <span class="comment">// 我为了 logback-spring.xml 写起来方便，所以在XML中这个属性是一个逗号分隔的字符串</span></span><br><span class="line">    <span class="comment">// 但是在代码里面，我为了用 contains 方法，所以用了一个List来存放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExcludedClassNames</span><span class="params">(String excludedClassNames)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.excludedClassNames =</span><br><span class="line">            Arrays.stream(excludedClassNames.split(<span class="string">","</span>))</span><br><span class="line">                .map(String::trim)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter就没啥讲究了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getExcludedClassNames</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.excludedClassNames;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">toJsonMap</span><span class="params">(ILoggingEvent event)</span> </span>{</span><br><span class="line">        <span class="comment">// 先调用原本的方法，把日志的信息全部生成好</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>。toJsonMap(event);</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] callerData = event.getCallerData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有callerData，那后面也没法操作了</span></span><br><span class="line">        <span class="keyword">if</span> (callerData == <span class="keyword">null</span> || callerData.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素就是这个日志所在位置的信息</span></span><br><span class="line">        StackTraceElement stackTraceElement = callerData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了通过包名匹配，所以先拿出来全限定名</span></span><br><span class="line">        String callerClassFullName = stackTraceElement.getClassName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是应用所在的包打出来的日志，那么不处理</span></span><br><span class="line">        <span class="keyword">if</span> (!callerClassFullName.contains(appPackage)) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        String[] classNameParts = stackTraceElement.getClassName().split(<span class="string">"\\."</span>);</span><br><span class="line">        String callerClass = classNameParts[classNameParts.size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类是被排除的，那就不处理</span></span><br><span class="line">        <span class="keyword">if</span> (excludedClassNames.contains(callerClass)) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        String methodName = stackTraceElement.getMethodName();</span><br><span class="line">        String lineNumber = String.valueOf(stackTraceElement.getLineNumber());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个是原本的日志信息</span></span><br><span class="line">        String originalMessage = map.get(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把类名、方法名、行数附加在原本的信息前面</span></span><br><span class="line">        String enhancedMessage = <span class="string">"class="</span> + callerClass + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"method="</span> + methodName + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"line="</span> + lineNumber + <span class="string">" "</span></span><br><span class="line">                                + originalMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把改好的日志放回去</span></span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, enhancedMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>除了修改代码，日志配置文件 <code>logback-spring.xml</code> 也要针对我们新增的两个属性作出修改。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/cloud/gcp/autoconfigure/logging/logback-appender.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/cloud/gcp/logging/logback-json-appender.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/defaults.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- CONSOLE输出部分略 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE_JSON"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.encoder.LayoutWrappingEncoder"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指向我们上面写的GcpLoggingLayout --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"com.boris1993.myapplication.config.GcpLoggingLayout"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 应用的包名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appPackage</span>&gt;</span>com.boris1993.myapplication<span class="tag">&lt;/<span class="name">appPackage</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要排除的类名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逗号后面的空格可有可无，为了好看我选择加上，反正最后会被trim掉 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludedClassNames</span>&gt;</span>APP, HealthCheck<span class="tag">&lt;/<span class="name">excludedClassNames</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他GCP Logging配置略 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- springProfile配置略 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后就可以部署到 GCP 上面看效果了，或者在本机使用对应的 profile 启动，然后检查控制台里面打印出来的 JSON。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5zcHJpbmcuaW8vc3ByaW5nLWNsb3VkLWdjcC9tdWx0aS9tdWx0aV9fc3RhY2tkcml2ZXJfbG9nZ2luZy5odG1s">Stackdriver Logging<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1jbG91ZC9zcHJpbmctY2xvdWQtZ2NwL2Jsb2IvMTRhNzQ3YTVkOGZkMzYyYWI3NzNlNDNhY2FmYWU1ZWNhZWJiZDcyZC9zcHJpbmctY2xvdWQtZ2NwLWxvZ2dpbmcvc3JjL21haW4vamF2YS9vcmcvc3ByaW5nZnJhbWV3b3JrL2Nsb3VkL2djcC9sb2dnaW5nL1N0YWNrZHJpdmVySnNvbkxheW91dC5qYXZhI0w0NQ==">StackdriverJsonLayout.java - GitHub<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/gcp-logging-show-class-and-method-name.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 Spring 中通过配置类注入配置文件的值</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/spring-injecting-property-value-with-configuration-bean.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/spring-injecting-property-value-with-configuration-bean.html</guid>
      <pubDate>Sun, 03 May 2020 10:44:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;我们在开发过程中，为了保证项目的灵活性，经常会选择将一些值放在配置文件中，并在代码中将它注入并使用。将值注入代码最常见的一种方法，则是使用 &lt;code&gt;@Value()&lt;/code&gt; 注解搭配 SpEL 直接注入我们需要的属性。但是鲁迅先生有云：从来如此，便对吗？这里，我想介绍一个我个人认为更好的实践：通过配置类来注入属性的值。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们在开发过程中，为了保证项目的灵活性，经常会选择将一些值放在配置文件中，并在代码中将它注入并使用。将值注入代码最常见的一种方法，则是使用 <code>@Value()</code> 注解搭配 SpEL 直接注入我们需要的属性。但是鲁迅先生有云：从来如此，便对吗？这里，我想介绍一个我个人认为更好的实践：通过配置类来注入属性的值。</p><span id="more"></span><h2 id="旧的做法有什么问题"><a href="#旧的做法有什么问题" class="headerlink" title="旧的做法有什么问题"></a>旧的做法有什么问题</h2><p>假设我们现在有这样一个 <code>application.yml</code>，其中 <code>credentials</code> 部分是我自定义的一个属性：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="attr">credentials:</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">A_VERY_SECRET_TOKEN</span></span><br></pre></td></tr></tbody></table></figure><p>然后，我们会在用到它的地方，直接通过 <code>@Value</code> 注解把它注入进来，就像这样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value("${credientials.token}")</span></span><br><span class="line">  <span class="keyword">private</span> String token;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>好像没什么问题对吧，直接用表达式把值拿进来，然后该怎么用就怎么用。但是我不知道你们有没有注意过，这种做法其实既不利于后期重构，也不利于为代码生成好的文档。</p><p>比如说，这个值在多个类中都有被引用，但某一天，我们觉得这个名字不够直观，我们想改成 <code>contactServiceAppToken</code>，那么我们就只能先改掉属性的名字，然后在代码里面全文替换，把 <code>credentials.token</code> 批量替换成 <code>credentials.contactServiceAppToken</code>。我不知道你们是怎么想的，我每次做这种文本批量替换都很慌，生怕一个没看见而改掉了不应该改的东西。</p><p>而对于生成文档，我们都知道，在 Java 代码上面我们可以使用 JavaDoc 来编写文档，阐明这个类的作用等等。而对于 YAML 文件，则没有类似的东西，我们只能在属性上面写普通的注释。可是，大篇幅的注释又有可能会影响 YAML 文件的可读性，更不用说有谁会在看代码的时候专程去看 YAML 文件？</p><p>所以，我会建议团队使用配置类，也就是本文下面要讲的这个东西，来管理和注入这些自定义的属性。</p><h2 id="来个示例"><a href="#来个示例" class="headerlink" title="来个示例"></a>来个示例</h2><p>首先，我们需要创建一个配置类，来给这些属性找一个家。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个注解是重点，说明我们要把配置文件的 credentials 部分映射到这里</span></span><br><span class="line"><span class="meta">@ConfigurationProperties("credentials")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>{</span><br><span class="line">  <span class="comment">// 属性名与变量名保持一致即可，Spring会自动处理两者的绑定关系</span></span><br><span class="line">  <span class="comment">// 同时，Spring会自动完成不同命名方式的转换，比如 kebab-case 变成 camelCase</span></span><br><span class="line">  <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，在要使用这些属性的地方，把这个配置类注入，然后直接 get 属性的值，就可以了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Credentials credentials;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SomeService</span><span class="params">(Credentials credentials)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> String token = credentials.getToken();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与直接取值的方法比较起来，使用配置类有这么几个优点：</p><ul><li>如果在重构的时候要改变属性名，那么我们只需要修改配置文件里面的属性名，和配置类里面的属性名。当然要记得使用 IDE 里面的重构功能改名，这样 IDE 会自动分析这个属性的引用，并自动改正过来。</li><li>使用配置类还可以方便我们生成文档。如果直接在配置文件里面写文档，一方面是不一定易读，另一方面，也不是所有人都会想到在配置文件里面还有文档。而使用配置类的话，我们只需要在类上面加上 JavaDoc 就好了。</li><li>而且，我们还不需要担心打错字，导致 <code>@Value</code> 注入失败而使得应用起不来。虽然这不是什么大问题，改正就行了，但毕竟还是麻烦。</li></ul><h2 id="多层属性怎么办"><a href="#多层属性怎么办" class="headerlink" title="多层属性怎么办"></a>多层属性怎么办</h2><p>上面只是演示了只有一级子属性的情况，如果下面包含了多层属性，那配置类应该怎么写呢？</p><p>假设现在配置文件变成了这样：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">credentials:</span></span><br><span class="line">  <span class="attr">token:</span></span><br><span class="line">    <span class="attr">contact:</span> <span class="string">TOKEN_FOR_CONTACT_API</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">TOKEN_FOR_USER_API</span></span><br><span class="line">  <span class="attr">oauth:</span></span><br><span class="line">    <span class="attr">client-id:</span> <span class="string">CLIENT_ID</span></span><br><span class="line">    <span class="attr">client-secret:</span> <span class="string">CLIENT_SECRET</span></span><br><span class="line"></span><br><span class="line"><span class="attr">endpoint:</span></span><br><span class="line">  <span class="attr">contact:</span></span><br><span class="line">    <span class="attr">v1:</span> <span class="string">URL_FOR_CONTACT_API_VERSION_1</span></span><br><span class="line">    <span class="attr">v2:</span> <span class="string">URL_FOR_CONTACT_API_VERSION_2</span></span><br></pre></td></tr></tbody></table></figure><p>对于 <code>credentials</code> 部分，因为里面子属性的名字大致是确定的，我们用一个内部类就可以搞定（其实写在单独的类里面也可以，只是我不喜欢那么做）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties("credentials")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> Token token;</span><br><span class="line">  <span class="keyword">private</span> Oauth oauth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String contact;</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Oauth</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>取值的时候呢，逐层取到就好了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Credentials credentials;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SomeService</span><span class="params">(Credentials credentials)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> String contactApiToken = credentials.getToken().getContact();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是对于 <code>endpoint</code> 部分，因为里面的值是某个 API 各个版本的 URL，考虑到 API 还有可能会有新版本，每加一个版本都要再改配置类有点麻烦，所以我们可以直接用一个 Map 来存放。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties("endpoint")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, String&gt; contact;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在取值的时候，就还是一样的套路，注入这个配置类，然后从 Map 中取值就行了。Map 的 key 就是属性名，比如 <code>v1</code>，值就是属性的值。当然这样做的话，就要处理一下取到 null 的情况。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Endpoint endpoint;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SomeService</span><span class="params">(Endpoint endpoint)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.endpoint = endpoint;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> String contactV1Url = endpoint.getContact().get(<span class="string">"v1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contactV1Url == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="comment">// handle it here</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="给配置文件加上自动提示"><a href="#给配置文件加上自动提示" class="headerlink" title="给配置文件加上自动提示"></a>给配置文件加上自动提示</h2><p>其实，<code>Configuration properties</code> 配置类除了可以方便我们管理属性之外，他还可以搭配 <code>spring-boot-configuration-processor</code> 来实现配置文件的自动提示，当然这也需要 IDE 的支持。</p><p>在 <code>pom.xml</code> 中加入如下依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后在编写完配置类之后，执行一下 build 操作，或者 <code>mvn compile</code>，来让它帮我们生成一个 <code>additional-spring-configuration-metadata.json</code> 文件。有了这个文件之后，IDE 就会参照它在配置文件里面给我们提供自动提示。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/spring-injecting-property-value-with-configuration-bean.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 NexT 主题中接入 Google AdSense</title>
      <link>https://www.boris1993.com/others/hexo-next-enable-google-adsense.html</link>
      <guid>https://www.boris1993.com/others/hexo-next-enable-google-adsense.html</guid>
      <pubDate>Sun, 05 Apr 2020 06:58:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;这个博客从建站到现在，也差不多有两三年时间了，一直以来也都是一种 “用爱发电” 的状况，看到其他博主都开始通过接入广告联盟来挣零花钱，说不心动那是不可能的。所以就研究了一下怎么在这个博客里面接入 Google AdSense。&lt;/p&gt;
&lt;p&gt;在使用本文介绍的方法前，请检查您的 NexT 主题版本是否为 &lt;code&gt;v6.0.2&lt;/code&gt; 或后续版本，因为本文涉及的功能是在 &lt;code&gt;v6.0.2&lt;/code&gt; 引入的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这个博客从建站到现在，也差不多有两三年时间了，一直以来也都是一种 “用爱发电” 的状况，看到其他博主都开始通过接入广告联盟来挣零花钱，说不心动那是不可能的。所以就研究了一下怎么在这个博客里面接入 Google AdSense。</p><p>在使用本文介绍的方法前，请检查您的 NexT 主题版本是否为 <code>v6.0.2</code> 或后续版本，因为本文涉及的功能是在 <code>v6.0.2</code> 引入的。</p><span id="more"></span><p>虽然网上已经有很多类似的博文了，我为什么还要再写一篇呢？主要是因为，很多文章在添加认证代码的时候，都是直接修改 <code>themes/next/layout/_partials/head.swig</code> 或者 <code>themes/next/layout/_custom/google_adsense.ejs</code> 等位置，说白了就是在 NexT 主题所在的目录动手了，而我并不喜欢这种侵入性强的操作。经过一点简单的搜索，我发现是可以通过数据文件来实现非侵入性的修改的，所以就想讲一下我的做法。<del>当然借此机会还能水一篇博文何乐而不为 / 滑稽</del></p><p>那么言归正传，一起来看一下我是怎么配置的吧。</p><h2 id="注册Google-AdSense"><a href="#注册Google-AdSense" class="headerlink" title="注册Google AdSense"></a>注册 Google AdSense</h2><p>要接入 AdSense，那当然要有一个 AdSense 的账户。进入<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNuL2Fkc2Vuc2Uvc3RhcnQv"> Google AdSense<i class="fa fa-external-link-alt"></i></span>主页，点击 “开始使用”，跟随页面提示填好各项信息，这部分操作很简单，就不多废话了。</p><p>但是这里可能有一个坑，就是我只能接入一个裸域名，不知道是我的问题还是 AdSense 就是这么要求的。我的博客地址是 <code>https://www.boris1993.com</code>，但是在页面上输入网站地址之后，AdSense 会把 <code>www</code> 这个二级域名去掉，变成裸域名 <code>https://boris1993.com</code>，所以我只好把裸域名也关联到了我的博客站上。你们在配置的时候，记得注意一下这个地方。如果你知道具体的原因，或者解决方案，那么也请不吝赐教，在留言区告诉我。</p><h2 id="添加AdSense代码"><a href="#添加AdSense代码" class="headerlink" title="添加AdSense代码"></a>添加 AdSense 代码</h2><p>在注册完成后，AdSense 会给你一串代码，并要求你把这串代码放在 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中。注意这里就是我跟他们不一样的地方了。</p><p>同时再次提醒确认你的 NexT 主题的版本是不是 <code>v6.0.2</code> 或后续版本。如果不是的话，你要么考虑升级，要么可以点❌关闭了。</p><p>首先，我们需要在主题配置文件中指定自定义 layout 文件的位置。当然，这步也是在数据文件中操作的。什么？你还没有用数据文件这个功能？那你赶紧学习并且用起来吧，省的每次更新主题还要担心丢配置。</p><p>在 <code>source/_data/next.yml</code> 中增加如下配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置的原文可以在themes/next/_config.yml的24行找到(针对v7.5.0)</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment"># 因为我们只需要自定义head部分，所以就只配置head这一个属性，其他都保持默认</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br></pre></td></tr></tbody></table></figure><p>指定好 <code>head.swig</code> 的位置之后，我们继续在 <code>source/_data</code> 中创建 <code>head.swig</code> 文件，并把 AdSense 给我们的那串代码放在 <code>head.swig</code> 里面，就像这样：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-ad-client</span>=<span class="string">"██████████"</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后可以重新启动一下本地的 Hexo 环境，检查 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中有没有出现刚才添加的代码。检查没有问题之后，就可以部署到生产环境使上面的修改生效了。为了保险起见，在生产环境上也要检查一下 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中有没有出现刚才添加的代码。确认没有问题之后，就可以回到 AdSense 页面中点击验证按钮了。</p><p>注意，如果 AdSense 告诉你检查不通过，你一定不要频繁点击再次检查，一定要先确定检查不通过的原因，并在排除问题之后再重新检查，因为每天检查次数是有限制的，如果超过限制，就只能等 24 小时之后再检查了<del>（别问我是怎么知道的</del>。</p><p>然后 AdSense 会开始审核阶段，这期间我们静静等待审核结果的邮件就好了。</p><p><del>因为在写这篇博文的时候，我也在等 AdSense 审核，所以这篇文章暂且先告一段落，等有了结果我再更新后面的内容。</del></p><p>等了这么久，终于收到 Google 的邮件说我通过了审核，可以开始投放广告了。那么，我们也可以开始继续完成后面的工作了。</p><h2 id="配置广告模块"><a href="#配置广告模块" class="headerlink" title="配置广告模块"></a>配置广告模块</h2><p>进入 AdSense 管理后台之后，进入侧边栏的<code>广告 -&gt; 概览</code>。在这里我们可以配置广告会在什么位置展示了。</p><p>因为我并不希望让我的网站满地都是广告，而影响正常内容的展示，而是，只在首页左侧边栏最下面，和在每篇博文结束的位置，各放置一个广告。所以我就需要到<code>按广告单元</code>这个页面手动配置两个广告模块。在这个截图里我们可以看到已经有了两个广告模块，那是因为我已经配置好了。</p><p><img data-src="https://sat02pap001files.storage.live.com/y4mqBrBdZk7AdZYmaLHEzTxqM1wdb3mfqyT0Fi9x4pEXO08dzL5jTPjpVpBmi2amqE9kYQVwbp9IEUbXy136-A1JwKa2pVgwb94ZU7MJWVnMwy71Lbk6REbabo65Ukzurut6hCxFzjO3lFG_2Y2Pk3ft0j5BKajtst2AOYE17dUjVSBA1Yj9JeS-j9LfFU7DJik?width=2880&amp;height=1580&amp;cropmode=none" alt="Configuring ad modules"></p><h3 id="添加广告模块"><a href="#添加广告模块" class="headerlink" title="添加广告模块"></a>添加广告模块</h3><p>点击<code>展示广告</code>按钮来新建一个类型为<code>展示</code>的广告。在顶部文本框填入广告模块的名字，比如 <code>side ad</code>，然后在右边栏选择广告的尺寸，是自适应的，还是固定长宽的。如果是自适应尺寸，那么还需要选择广告的大致形状。配置完毕后，点击<code>保存</code>按钮，一个广告模块就配置好了。</p><p><img data-src="https://sat02pap001files.storage.live.com/y4mIMEzrsVH9T9rPveow-ndYO6w1vSkIQUERwk5K5YfGZpvXofPCiZvstTes-o58NhQG4KgbQQCjVbUj1QFflUAsEWl-jFclarZ7EUIpb-eeV9kMvYaimA-ag3whEtue05E26huoUYs5icMfBHBRHz6S1cqXvRjgCYM5WvQSDaKDCkT6Mo_gLTX0Q8ZURXwen5_?width=2880&amp;height=1580&amp;cropmode=none" alt="Sidebar ad module"></p><p>按照同样的操作，继续添加一个名为 <code>bottom ad</code> 的展示广告。这样，我们就添加好了两个广告模块。</p><h3 id="配置博客页面"><a href="#配置博客页面" class="headerlink" title="配置博客页面"></a>配置博客页面</h3><p>广告模块是创建好了，但是我们还需要配置广告展示的位置。这里我依旧使用数据文件功能，来实现非侵入性的修改。</p><p>首先，在 <code>source/_data/</code> 目录新建两个文件，分别命名为 <code>sidebar.swig</code> 和 <code>post-body-end.swig</code>，分别用来存放侧边栏广告和文章底部广告的代码。</p><p>还记得刚才添加完广告模块之后弹出的那一片代码吗？把它们原样默写到这两个文件里就好啦。开玩笑的，谁记得住那一大堆东西啊。回到<code>按广告单元</code>这个页面，在刚才添加的广告单元那里，有一个形似 <code>&lt;&gt;</code> 的按钮，点击它，就可以看到这个广告单元的配置代码了。</p><p>把 <code>side ad</code> 的代码复制到 <code>sidebar.swig</code> 中，来把这个侧边栏广告真正的放到侧边栏上。比如我的广告代码是这样的：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- side ad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span> <span class="attr">class</span>=<span class="string">"adsbygoogle"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">style</span>=<span class="string">"display:block"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-client</span>=<span class="string">"████████████████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-slot</span>=<span class="string">"██████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-format</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-full-width-responsive</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="comment">// 因为直接执行AdSense的代码会出现 No slot size for availableWidth=0 的错误</span></span></span><br><span class="line"><span class="javascript">     <span class="comment">// 并且这个广告位会无法正常展示</span></span></span><br><span class="line"><span class="javascript">     <span class="comment">// 所以加一个 event listener，在页面加载完毕之后再执行</span></span></span><br><span class="line"><span class="javascript">     <span class="comment">// 参考：https://stackoverflow.com/a/37822404/3833858</span></span></span><br><span class="line"><span class="javascript">     <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">          (adsbygoogle = <span class="built_in">window</span>.adsbygoogle || []).push({});</span></span><br><span class="line"><span class="javascript">     });</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后把 <code>bottom ad</code> 的代码复制到 <code>post-body-end.swig</code>，来把这个广告放到文章底部。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bottom ad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span> <span class="attr">class</span>=<span class="string">"adsbygoogle"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">style</span>=<span class="string">"display:block"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-client</span>=<span class="string">"████████████████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-slot</span>=<span class="string">"██████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-format</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-full-width-responsive</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     (adsbygoogle = <span class="built_in">window</span>.adsbygoogle || []).push({});</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>接下来继续修改 <code>source/_data/next.yml</code> 中 <code>custom_file_path</code> 的配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br><span class="line">  <span class="comment"># 加入下面两行</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="string">source/_data/sidebar.swig</span> <span class="comment"># 侧边栏广告</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.swig</span> <span class="comment"># 博文末尾广告</span></span><br></pre></td></tr></tbody></table></figure><p>这样，广告就放置好了。接下来，把博客发布上去，就可以开始打广告了。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/others/hexo-next-enable-google-adsense.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>解决 Maven 的 unable to find valid certification path to requested target 错误</title>
      <link>https://www.boris1993.com/tools/maven/maven-unable-to-find-valid-certification-path-to-requested-target.html</link>
      <guid>https://www.boris1993.com/tools/maven/maven-unable-to-find-valid-certification-path-to-requested-target.html</guid>
      <pubDate>Mon, 30 Mar 2020 03:13:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天我在从公司的 Maven 私库上下载依赖时，Maven 报出了 &lt;code&gt;unable to find valid certification path to requested target&lt;/code&gt; 的问题，经查询是因为没有将私库使用的自签名证书导入到 Java 的 keystore。这里写一下我的两个解决方案，方便发生了同样问题的人参考。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天我在从公司的 Maven 私库上下载依赖时，Maven 报出了 <code>unable to find valid certification path to requested target</code> 的问题，经查询是因为没有将私库使用的自签名证书导入到 Java 的 keystore。这里写一下我的两个解决方案，方便发生了同样问题的人参考。</p><span id="more"></span><h2 id="让Maven忽略证书错误"><a href="#让Maven忽略证书错误" class="headerlink" title="让Maven忽略证书错误"></a>让 Maven 忽略证书错误</h2><p>因为在默认情况下，自签名证书是不受信任的，那么我们只要让 Maven 忽略证书错误，就可以解决这个问题了。</p><p>我们可以在<code>.bashrc</code> 或<code>.zshrc</code>（或者其他位置，看你用哪个 shell 了）里面加入如下语句：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_OPTS=<span class="string">'-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Djsse.enableSNIExtension=false'</span></span><br></pre></td></tr></tbody></table></figure><p>或者，也可以在 <code>~/.mavenrc</code> 中配置这个参数：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MAVEN_OPTS</span>=<span class="string">"-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Djsse.enableSNIExtension=false"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="导入证书到keystore"><a href="#导入证书到keystore" class="headerlink" title="导入证书到keystore"></a>导入证书到 keystore</h2><p>首先使用这个命令得到网站上面的证书：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意将mavenrepository.mycompany.com替换成实际的地址</span></span><br><span class="line">openssl s_client -showcerts -connect mavenrepository.mycompany.com:443</span><br></pre></td></tr></tbody></table></figure><p>在输出中可以看到类似这样的证书信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s:/C=US/ST=North Carolina/L=Raleigh/O=Red Hat, Inc./OU=Red Hat Network/CN=Entitlement Master CA/emailAddress=ca-support@redhat.com</span><br><span class="line"></span><br><span class="line">i:/C=US/ST=North Carolina/L=Raleigh/O=Red Hat, Inc./OU=Red Hat Network/CN=Entitlement Master CA/emailAddress=ca-support@redhat.com</span><br></pre></td></tr></tbody></table></figure><p>我们要在这里面寻找 <code>issuer(i:)</code> 和 <code>subject(s:)</code> 相同的证书，这个就是我们要导出的根证书。找到之后，保存证书的哈希（即以 <code>—–BEGIN CERTIFICATE—–</code>开始，以 <code>—–END CERTIFICATE—–</code>结束的这部分内容）到一个文件中，比如 <code>root.crt</code>。</p><p>接下来，我们需要使用 <code>keytool</code> 把这个证书导入到 Java 的 keystore 中，命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo keytool \</span><br><span class="line">    -importcert \</span><br><span class="line">    <span class="comment"># keystore文件位置需要修改成实际的位置</span></span><br><span class="line">    -keystore /usr/<span class="built_in">local</span>/java/jdk1.8.0_60/jre/lib/security/cacerts \</span><br><span class="line">    <span class="comment"># keystore密码需要修改成实际的密码，默认密码是changeit</span></span><br><span class="line">    -storepass changeit \</span><br><span class="line">    <span class="comment"># 要导入的证书，就是刚才保存的那个，注意使用实际的位置</span></span><br><span class="line">    -file ~/Downloads/root.crt \</span><br><span class="line">    <span class="comment"># 给证书起个名字</span></span><br><span class="line">    -<span class="built_in">alias</span> <span class="string">"mavenrepository-mycompany"</span></span><br></pre></td></tr></tbody></table></figure><p>执行后 keytool 会询问是否信任这个证书，输入 <code>yes</code> 来信任。</p><p>导入完成后，Maven 就可以从这个私库下载依赖了。如果你使用 IDEA 的话，那么可能需要重新启动一下 IDEA 才会使新的 keystore 生效。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9qZnJvZy5jb20va25vd2xlZGdlLWJhc2UvaG93LXRvLXJlc29sdmUtdW5hYmxlLXRvLWZpbmQtdmFsaWQtY2VydGlmaWNhdGlvbi1wYXRoLXRvLXJlcXVlc3RlZC10YXJnZXQtZXJyb3Iv">How to resolve “unable to find valid certification path to requested target” error? - JFrog<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjEyNTI4MDAvaG93LXRvLXRlbGwtbWF2ZW4tdG8tZGlzcmVnYXJkLXNzbC1lcnJvcnMtYW5kLXRydXN0aW5nLWFsbC1jZXJ0cw==">How to tell Maven to disregard SSL errors (and trusting all certs)?<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/maven/maven-unable-to-find-valid-certification-path-to-requested-target.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>学习 Concourse CI - 使用变量</title>
      <link>https://www.boris1993.com/tools/concourse/concourse-using-vars.html</link>
      <guid>https://www.boris1993.com/tools/concourse/concourse-using-vars.html</guid>
      <pubDate>Fri, 20 Mar 2020 06:48:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;在实际编写配置文件时，我们不可能保证所有相关的值都是一成不变的。有的值可能会根据运行时的状态来指定，也有可能它是类似 token 一样的机密信息，必须从一个可信渠道获取。为了应对这种情况，我们就需要在配置文件中引入变量。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在实际编写配置文件时，我们不可能保证所有相关的值都是一成不变的。有的值可能会根据运行时的状态来指定，也有可能它是类似 token 一样的机密信息，必须从一个可信渠道获取。为了应对这种情况，我们就需要在配置文件中引入变量。</p><span id="more"></span><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>在 Concourse 的语法规则中，如果要声明一个变量，就用双括号把变量名字包裹起来，就像这样：<code>((a-variable))</code>。借用 Concourse Tutorials 中的一个例子，我们看一下具体在配置文件中，是如何声明一个变量的。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">show-animal-names</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">show-animal-names</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">env</span></span><br><span class="line">            <span class="attr">args:</span> []</span><br><span class="line">          <span class="attr">params:</span></span><br><span class="line">            <span class="attr">CAT_NAME:</span> <span class="string">((cat-name))</span></span><br><span class="line">            <span class="attr">DOG_NAME:</span> <span class="string">((dog-name))</span></span><br></pre></td></tr></tbody></table></figure><p>这里需要穿插一个内容，就是 task 的 <code>params</code> 属性。它的作用是把里面指定的键值对作为环境变量传到容器中。</p><p>我们可以看到，它声明了两个变量：<code>cat-name</code> 和 <code>dog-name</code>，分别作为环境变量 <code>CAT_NAME</code> 和 <code>DOG_NAME</code> 的值。这样，就完成了变量的声明。</p><h2 id="为变量传值"><a href="#为变量传值" class="headerlink" title="为变量传值"></a>为变量传值</h2><p>变量声明好了，那就要传值了。Concourse 支持通过命令行参数、通过文件，以及通过密钥管理器 (credentials manager) 来传入变量的值。</p><p>这里有一点需要注意，通过命令行参数或者文件传入的值，是不会根据外部条件变化的，你可以将其理解成 fly 会先把配置文件做文本替换然后再注册到 Concourse。如果要修改变量的值，那么就需要重新运行 <code>fly set-pipeline</code> 命令来修改。</p><h3 id="通过命令行参数传值"><a href="#通过命令行参数传值" class="headerlink" title="通过命令行参数传值"></a>通过命令行参数传值</h3><p>我们可以在 <code>fly</code> 命令中使用 <code>-v</code> 参数来为变量传值，它的格式是 <code>-v key=value</code>，要对多个变量赋值就要使用多个 <code>-v</code> 参数。</p><p>如果要为上文提到的配置文件传值，那么我们可以这样执行命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为变量赋值并注册pipeline</span></span><br><span class="line">fly -t tutorial sp -p parameters -c pipeline.yml -v cat-name=garfield -v dog-name=odie</span><br></pre></td></tr></tbody></table></figure><p>然后我们可以执行 <code>fly -t tutorial trigger-job -j parameters/show-animal-names -w</code> 这条命令来触发任务执行，来检查传值是否成功。</p><h3 id="通过文件传值"><a href="#通过文件传值" class="headerlink" title="通过文件传值"></a>通过文件传值</h3><p>要使用文件传值，我们首先需要创建一个包含变量名和值的 YAML 文件。为了方便起见我直接用 heredoc 创建，当然你可以选择任何你喜欢的方式。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从标准输入创建文件</span></span><br><span class="line"><span class="comment"># 当接收到EOF这个字符串时停止接收内容</span></span><br><span class="line">$ cat &gt; credentials.yml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">heredoc&gt; cat-name: garfield</span></span><br><span class="line"><span class="string">heredoc&gt; dog-name: odie</span></span><br><span class="line"><span class="string">heredoc&gt; EOF</span></span><br></pre></td></tr></tbody></table></figure><p>这样我们就得到了一个这样的文件：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cat-name:</span> <span class="string">garfield</span></span><br><span class="line"><span class="attr">dog-name:</span> <span class="string">odie</span></span><br></pre></td></tr></tbody></table></figure><p>然后在 <code>fly</code> 命令中，我们就可以用 <code>-l</code> 参数来通过文件为变量赋值：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly -t tutorial sp -p parameters -c pipeline.yml -l credentials.yml</span><br></pre></td></tr></tbody></table></figure><h3 id="通过密钥管理器传值"><a href="#通过密钥管理器传值" class="headerlink" title="通过密钥管理器传值"></a>通过密钥管理器传值</h3><p>如上文所述，通过参数和文件赋值，不仅存在诸多不便，同时还无法保证机密信息的安全性。所以，Concourse 也支持与密钥管理器集成。Concourse 支持多种密钥管理器，具体的支持列表可以在官网的<span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL2NyZWRzLmh0bWw="> Credential Management<i class="fa fa-external-link-alt"></i></span>处查询。这里我们使用 Vault 进行演示。</p><p>由于 Vault 的安装和配置与本文无关，所以这里略过不讲。</p><h4 id="Concourse的配置"><a href="#Concourse的配置" class="headerlink" title="Concourse的配置"></a>Concourse 的配置</h4><p>Concourse 默认是没有配置密钥管理器的，如果要将 Vault 与 Concourse 集成起来，那么需要为 web 节点配置如下环境变量：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Vault的地址，协议可以是HTTP也可以是HTTPS</span></span><br><span class="line">CONCOURSE_VAULT_URL=https://vault.example.com:8200</span><br><span class="line"><span class="comment"># 你也可以为Concourse指定CA证书所在的位置</span></span><br><span class="line">CONCOURSE_VAULT_CA_CERT=path/to/ca.crt</span><br></pre></td></tr></tbody></table></figure><p>配置完毕后重启 web 节点，就完成了 Concourse 的配置。</p><h4 id="在Vault中的准备工作"><a href="#在Vault中的准备工作" class="headerlink" title="在Vault中的准备工作"></a>在 Vault 中的准备工作</h4><p>根据<span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL3ZhdWx0LWNyZWRlbnRpYWwtbWFuYWdlci5odG1s"> The Vault credential manager<i class="fa fa-external-link-alt"></i></span>的描述，Concourse 会在 Vault 中按照以下的规则查找变量的值，并取出其中 <code>value</code> 这个 key 所对应的内容：</p><ul><li><code>/concourse/TEAM_NAME/PIPELINE_NAME/VAR_NAME</code></li><li><code>/concourse/TEAM_NAME/VAR_NAME</code></li></ul><p>以上文提到的那个 pipeline 为例子，我使用系统自带的 <code>main</code> 这个 team，并将这个 pipeline 命名为了 <code>parameters</code>，那么在寻找 <code>cat-name</code> 这个变量时，Concourse 就会先后在 <code>/concourse/main/parameters/cat-name</code> 和 <code>/concourse/main/cat-name</code> 中查找。</p><p>所以为了满足这个条件，我们需要在 Vault 中完成以下几件事：</p><ol><li>新建一个 secret engine，将其命名为 <code>concourse</code></li><li>新建一个 secret，path 填写 <code>main/parameters/cat-name</code>，secret data 新增一条 key 为 <code>value</code>，值为 <code>garfield</code> 的记录</li><li>再新建一个 secret，path 填写 <code>main/parameters/dog-name</code>，secret data 新增一条 key 为 <code>value</code>，值为 <code>odie</code> 的记录</li></ol><p>这样，就在 Vault 中设定好了变量的值。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>此时，我们回到 Concourse，触发这个 task 执行，如果配置正确的话，就可以看到这样的输出了：</p><p><img data-src="https://sat02pap001files.storage.live.com/y4m2d6Feh8f5zRjol0RKMBbvG1GIxHNDDVghauBPBTr2XrsGvB9CBIQAsd03V08NuIctsniC2Nu--2Kfv4wQIDKBywyhr_rAjWvz4bcAg1S81YZLDsZI_GKzqPbHXk1xpTBm-4KvImjGjYLOpC0TY6Ev2zx13jTdxvCLhAJOrFuNxDLXYtns_3TNhgJnzmZcsQ6?width=2880&amp;height=1422&amp;cropmode=none" alt="Fetch parameter value from Vault"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnLw==">Concourse CI<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2U=">Concourse - GitHub<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2V0dXRvcmlhbC5jb20v">Concourse Tutorial<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/concourse/concourse-using-vars.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>学习 Concourse CI - 快速入门</title>
      <link>https://www.boris1993.com/tools/concourse/concourse-quick-start.html</link>
      <guid>https://www.boris1993.com/tools/concourse/concourse-quick-start.html</guid>
      <pubDate>Tue, 10 Mar 2020 06:38:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近公司需要用到一个名叫 &lt;code&gt;Concourse CI&lt;/code&gt; 的 &lt;code&gt;CI/CD&lt;/code&gt; 工具，那么我当然就要学习一下啦。顺便还能水一篇，啊不，写一篇博客，当作学习过程中的笔记。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近公司需要用到一个名叫 <code>Concourse CI</code> 的 <code>CI/CD</code> 工具，那么我当然就要学习一下啦。顺便还能水一篇，啊不，写一篇博客，当作学习过程中的笔记。</p><span id="more"></span><h2 id="安装Concourse-CI"><a href="#安装Concourse-CI" class="headerlink" title="安装Concourse CI"></a>安装 Concourse CI</h2><p>Concourse 在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2UtZG9ja2Vy"> concourse-docker - GitHub<i class="fa fa-external-link-alt"></i></span>提供了现成的 <code>docker-compose</code> 配置文件。</p><p>首先需要克隆这个库：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/concourse/concourse-docker.git</span><br><span class="line">Cloning into <span class="string">'concourse-docker'</span>...</span><br><span class="line">remote: Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 388 (delta 0), reused 1 (delta 0), pack-reused 385</span><br><span class="line">Receiving objects: 100% (388/388), 66.29 KiB | 205.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (200/200), <span class="keyword">done</span>.</span><br></pre></td></tr></tbody></table></figure><p>进入 <code>concourse-docker</code>，分别执行下面两个命令完成密钥生成和系统启动：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> concourse-docker</span><br><span class="line"><span class="comment"># 生成密钥</span></span><br><span class="line">$ ./keys/generate</span><br><span class="line"><span class="comment"># 第一次运行时会先下载concourse的Docker镜像，Docker输出这里略掉</span></span><br><span class="line">wrote private key to /keys/session_signing_key</span><br><span class="line">wrote private key to /keys/tsa_host_key</span><br><span class="line">wrote ssh public key to /keys/tsa_host_key.pub</span><br><span class="line">wrote private key to /keys/worker_key</span><br><span class="line">wrote ssh public key to /keys/worker_key.pub</span><br><span class="line"><span class="comment"># 启动concourse</span></span><br><span class="line">$ docker-compose up -d</span><br><span class="line">Creating network <span class="string">"concourse-docker_default"</span> with the default driver</span><br><span class="line">Creating concourse-docker_db_1 ... <span class="keyword">done</span></span><br><span class="line">Creating concourse-docker_web_1 ... <span class="keyword">done</span></span><br><span class="line">Creating concourse-docker_worker_1 ... <span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p>然后，用浏览器打开 <code>http://localhost:8080</code>，检查 Concourse 是否启动成功。</p><h2 id="安装Fly-CLI"><a href="#安装Fly-CLI" class="headerlink" title="安装Fly CLI"></a>安装 Fly CLI</h2><p>虽然 Concourse 带有一个 Web 界面，但是我们在 Web 界面里面干不了什么，因为它的所有管理操作都需要通过它的 <code>Fly CLI</code> 来完成。</p><p>要安装 <code>Fly CLI</code>，你可以从刚才打开的 Dashboard 里面下载，也可以到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2UvcmVsZWFzZXM="> Concourse 的 GitHub Releases<i class="fa fa-external-link-alt"></i></span>中下载。</p><p>macOS 用户可能会想，我能不能用 <code>Homebrew</code> 来安装这个东西？一开始我也是这么想的，但是后面我发现，在 <code>Homebrew</code> 官方源里面的版本并没有随着 Concourse 的发布而更新，虽然我在 Issues 里翻出来一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhaHVsa2ovaG9tZWJyZXctdGFw">个人维护的 tap<i class="fa fa-external-link-alt"></i></span>，但最后还是不想用。</p><p>所以，最后我选择直接从 Dashboard 里面下载，然后将其移动到 <code>/usr/local/bin</code> 中。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>世间万物都可以从一个 hello world 学起，Concourse 也不例外。</p><p>首先，需要在 <code>Fly CLI</code> 中登陆。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ fly -t tutorial login -c http://localhost:8080 -u <span class="built_in">test</span> -p <span class="built_in">test</span></span><br><span class="line">logging <span class="keyword">in</span> to team <span class="string">'main'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target saved</span><br></pre></td></tr></tbody></table></figure><p>上面命令中，我们创建了一个叫做 <code>tutorial</code> 的目标 (target)，地址是 <code>http://localhost:8080</code>，也就是我们刚才启动的这个节点，以 <code>test:test</code> 登陆。如果要想看一下 <code>Fly CLI</code> 中已保存的 target，可以执行这条命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ fly targets</span><br><span class="line">name      url                    team  expiry</span><br><span class="line">tutorial  http://localhost:8080  main  Wed, 11 Mar 2020 07:40:34 UTC</span><br></pre></td></tr></tbody></table></figure><p>然后，我们跟着 Concourse Tutorial<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Concourse Tutorial](https://concoursetutorial.com/)">[3]</span></a></sup> 中 <code>Hello World</code> 一节的描述，把这个 task 执行起来。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/starkandwayne/concourse-tutorial.git</span><br><span class="line">Cloning into <span class="string">'concourse-tutorial'</span>...</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3794 (delta 0), reused 4 (delta 0), pack-reused 3789</span><br><span class="line">Receiving objects: 100% (3794/3794), 11.18 MiB | 25.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (2270/2270), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> concourse-tutorial/tutorials/basic/task-hello-world</span><br><span class="line">$ fly -t tutorial execute -c task_hello_world.yml</span><br><span class="line">uploading task-hello-world <span class="keyword">done</span></span><br><span class="line">executing build 1 at http://localhost:8080/builds/1</span><br><span class="line">initializing</span><br><span class="line">waiting <span class="keyword">for</span> docker to come up...</span><br><span class="line">Pulling busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d...</span><br><span class="line">sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d: Pulling from library/busybox</span><br><span class="line">0669b0daf1fb: Pulling fs layer</span><br><span class="line">0669b0daf1fb: Verifying Checksum</span><br><span class="line">0669b0daf1fb: Download complete</span><br><span class="line">0669b0daf1fb: Pull complete</span><br><span class="line">Digest: sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d</span><br><span class="line"></span><br><span class="line">Successfully pulled busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d.</span><br><span class="line"></span><br><span class="line">running <span class="built_in">echo</span> hello world</span><br><span class="line">hello world</span><br><span class="line">succeeded</span><br></pre></td></tr></tbody></table></figure><p>可以看到，Concourse 收到这个 task 之后，下载了一个 Busybox 的 Docker 镜像，然后执行了 <code>echo hello world</code> 这条命令。那么，Concourse 是怎么知道要如何执行一个 task 呢？这就得从上面运行的 <code>task_hello_world.yml</code> 说起了。</p><h2 id="一个task的配置文件"><a href="#一个task的配置文件" class="headerlink" title="一个task的配置文件"></a>一个 task 的配置文件</h2><p>Task 是 Concourse 的流水线 (pipeline) 中最小的配置单元，我们可以把它理解成一个函数，在我们配置好它的行为之后，它将永远按照这个固定的逻辑进行操作。</p><p>上面的 <code>task_hello_world.yml</code> 就是配置了一个 task 所要进行的操作，它的内容不多，我们一块一块拆开来看。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image_resource:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">  <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line"></span><br><span class="line"><span class="attr">run:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">echo</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">hello</span> <span class="string">world</span>]</span><br></pre></td></tr></tbody></table></figure><p><code>platform</code> 属性指定了这个 task 要运行在哪种环境下。需要注意，这里指的是 worker 运行的环境，比如这里指定的 <code>linux</code>，就意味着 Concourse 将会挑选一个运行在 Linux 中的 worker。</p><p><code>image_resource</code> 属性指定了这个 task 将会运行在一个镜像容器中。其中的 <code>type</code> 属性说明这个镜像是一个 Docker 镜像，<code>source</code> 中 <code>{repository: busybox}</code> 说明了要使用 Docker 仓库中的 <code>busybox</code> 作为基础镜像。</p><p><code>run</code> 属性就是这个 task 实际要执行的任务，其中的 <code>path</code> 指定了要运行的命令，这里可以是指向命令的绝对路径、相对路径，如果命令在 <code>$PATH</code> 中，那么也可以直接写命令的名称；<code>args</code> 就是要传递给这个命令的参数。</p><p>如果要执行的命令非常复杂，我们也可以把命令写在一个 shell 脚本中，然后在 <code>run.path</code> 中指向这个脚本，比如这样：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">run:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./hello-world.sh</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，就很清楚了。这个 task 会在一台 Linux 宿主机中执行，它将在一个 busybox 镜像中运行 <code>echo hello world</code> 这条命令。</p><h2 id="把多个task串起来"><a href="#把多个task串起来" class="headerlink" title="把多个task串起来"></a>把多个 task 串起来</h2><p>虽然我们在上面已经有了一个能用的 task，但是上面说了，task 只是一个 pipeline 的最小组成部分。而且在正式环境中，一个 CI/CD 任务可能会用到多个 task 来完成完整的构建任务。那么，怎么把多个 task 串起来呢？手动去做这件事显然不现实，所以就有了 pipeline。</p><p>这里我们还是用 Concourse Tutorial<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Concourse Tutorial](https://concoursetutorial.com/)">[3]</span></a></sup> 中的示例来演示。</p><p>首先我们先看一下这个配置文件的内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">job-hello-world</span></span><br><span class="line">    <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">hello-world</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">echo</span></span><br><span class="line">            <span class="attr">args:</span> [<span class="string">hello</span> <span class="string">world</span>]</span><br></pre></td></tr></tbody></table></figure><p>一个 pipeline 可以有多个 job，这些 job 决定了这个 pipeline 将会以怎样的形式来执行。而一个 job 中最重要的配置，是 plan，即需要执行的步骤。一个 plan 中的作业步，可以用来获取或更新某个资源，也可以用来执行某一个 task。</p><p>上面这个 pipeline 只有一个名为 <code>job-hello-world</code> 的 job，这个 job 里面只有一个作业步，名为 <code>hello-world</code>，是一个 task，操作是在一个 busybox 镜像中执行 <code>echo hello world</code> 命令。</p><p>在使用这个 pipeline 之前，我们需要把它注册到 Concourse 中。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t 指明要操作的target</span></span><br><span class="line"><span class="comment"># -c 指明pipeline的配置文件</span></span><br><span class="line"><span class="comment"># -p 指明pipeline的名字</span></span><br><span class="line">$ fly -t tutorial set-pipeline -c pipeline.yml -p hello-world</span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  job job-hello-world has been added:</span><br><span class="line">+ name: job-hello-world</span><br><span class="line">+ plan:</span><br><span class="line">+ - config:</span><br><span class="line">+     container_limits: {}</span><br><span class="line">+     image_resource:</span><br><span class="line">+       <span class="built_in">source</span>:</span><br><span class="line">+         repository: busybox</span><br><span class="line">+       <span class="built_in">type</span>: docker-image</span><br><span class="line">+     platform: linux</span><br><span class="line">+     run:</span><br><span class="line">+       args:</span><br><span class="line">+       - hello world</span><br><span class="line">+       path: <span class="built_in">echo</span></span><br><span class="line">+   task: hello-world</span><br><span class="line">+ public: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">apply configuration? [yN]: y</span><br><span class="line">pipeline created!</span><br><span class="line">you can view your pipeline here: http://localhost:8080/teams/main/pipelines/hello-world</span><br><span class="line"></span><br><span class="line">the pipeline is currently paused. to unpause, either:</span><br><span class="line">  - run the unpause-pipeline <span class="built_in">command</span>:</span><br><span class="line">    fly -t tutorial unpause-pipeline -p hello-world</span><br><span class="line">  - click play next to the pipeline <span class="keyword">in</span> the web ui</span><br></pre></td></tr></tbody></table></figure><p>现在一个新的 pipeline 就被注册到 Concourse 中了。在它的 Web UI 中也能看到这个 pipeline。</p><p><img data-src="https://sat02pap001files.storage.live.com/y4mmQHgwq8rOkuyUZzTKamhYp3wK4z6JfV4tsAlhbyOLrka-i-1_O5zGFW1uL8cKjEvJmy2bGuTY0Kdyyi2Zu89Duq1fzwyBDegKH_UcaOvqpq_zy25VQInkmzKPdLwaueMw7POUbETACpHD0wgJXOb2vX6bCtTagJ2B4X6ELjtyWj11-wv908SSoz0KF7uEc_4?width=2880&amp;height=1422&amp;cropmode=none" alt="Pipeline"></p><p>但是，这个 pipeline 现在还是暂停状态的，需要把它恢复之后才能使用。那么怎么恢复呢？其实上面 <code>set-pipeline</code> 操作的输出已经告诉我们了。</p><blockquote><p>the pipeline is currently paused. to unpause, either:<br>- run the unpause-pipeline command:<br><code>fly -t tutorial unpause-pipeline -p hello-world</code><br>- click play next to the pipeline in the web ui</p><p>这个 pipeline 目前是被暂停的，如果要恢复，可以使用下面两种方法之一：<br>- 运行 unpause-pipeline 命令：<br><code>fly -t tutorial unpause-pipeline -p hello-world</code><br>- 在 Web UI 中点击 pipeline 的播放按钮</p></blockquote><p>在成功恢复 pipeline 之后，我们可以看到原来蓝色的 paused 字样变成了灰色的 pending 字样，说明现在这个 pipeline 正在等待任务。</p><p>接下来我们就可以手动执行一下这个 pipeline，来检查它是否正常。具体操作说起来太啰嗦，我直接借用 Concourse Tutorial 里面的一个动图来替我说明。</p><p><img data-src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaDhsUDBoXzdjVHRoZkpMMjhqR0RnTG5HRGFFcWc_ZT1CZ0RFTG0.gif" alt="Manually start a pipeline"></p><h2 id="自动触发job"><a href="#自动触发job" class="headerlink" title="自动触发job"></a>自动触发 job</h2><p>虽然我们在 Web UI 上点一下加号就能触发 job 开始执行，但是 CI/CD 讲究的就是一个自动化，每次更新都手动去点一下，显然谁都受不了这么折腾。所以，Concourse 也提供了几种自动触发 job 执行的方法。</p><p>一种方法是向 Concourse API 发送一个 <code>POST</code> 请求。这种就是 webhook，没什么特殊的，在版本控制系统里面配置好 webhook 的参数就好了。</p><p>另一种方法是让 Concourse 监视某一个资源，在资源发生改变之后自动触发 job 执行。下面我详细说说这个功能。</p><p>这里我们假设一个场景：我们有一个 Git 仓库，里面有一个名为 <code>test.txt</code> 的文件。我们想在每次这个仓库收到新 commit 之后，打印出 <code>test.txt</code> 的内容。</p><p>按照这个思路，我在 Concourse 中注册了如下的 pipeline：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 先定义一个Git资源</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">resource-git-test</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="comment"># 这里换成你自己的一个Git仓库</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">https://gitee.com/boris1993/git-test.git</span></span><br><span class="line">      <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># 如果想要这个任务定期执行，那么可以在这里定义一个计时器</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timer</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">time</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="comment"># 这里定义这个计时器</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">2m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># 定义一个job</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">job-show-file-content</span></span><br><span class="line">    <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="comment"># 第一步：获取resource-git-test中定义的资源</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">resource-git-test</span></span><br><span class="line">        <span class="comment"># 在资源发生更新的时候触发</span></span><br><span class="line">        <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 如果要让任务定期重复执行，那么这里也要将定时器作为一个资源</span></span><br><span class="line">      <span class="comment"># 并打开trigger开关</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">timer</span></span><br><span class="line">        <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 第二步：在控制台打印文件内容</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">show-file-content</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">inputs:</span></span><br><span class="line">            <span class="comment"># resource-git-test中定义的资源将作为这个步骤的输入资源</span></span><br><span class="line">            <span class="comment"># 即让resource-git-test中的文件对该步骤可见</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">resource-git-test</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="comment"># 因为我们都懂的原因，Docker中心仓库有可能会连不上</span></span><br><span class="line">            <span class="comment"># 而在执行构建的时候，Concourse会到仓库检查镜像的版本</span></span><br><span class="line">            <span class="comment"># 所以这里用registry_mirror配置了一个Docker仓库的镜像站</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>, <span class="attr">registry_mirror:</span> <span class="string">https://dockerhub.azk8s.cn</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">cat</span></span><br><span class="line">            <span class="comment"># 在引入input资源后，工作目录下就可以看到这个资源相关的文件夹</span></span><br><span class="line">            <span class="attr">args:</span> [<span class="string">"./resource-git-test/test.txt"</span>]</span><br></pre></td></tr></tbody></table></figure><p>创建 <code>git-test</code> 仓库、编辑 <code>test.txt</code> 等等操作不是重点，也没啥难度，这里不啰嗦了。在完成编辑文件，和 push 到远程仓库后，我们等待 Concourse 检查远程仓库更新，并执行构建步骤。</p><p>在 pipeline 视图中点击 <code>resource-git-test</code> 这个资源，就可以看到这个资源的检查历史，展开某条记录后，还可以看到这条历史相关的构建。</p><p><img data-src="https://sat02pap001files.storage.live.com/y4mVzBotY0qOX2Gc5L5oPrHPpHEFYESt2ttRp2CCNmZPm839-Def82bbhlTmbGSfrwvn-evLNyGuOyi7eR2uiglAcW9kSMj8S6SOC-JI3aq5NaWX34z-AHT3Xvvs5nssFo_8S7eqX21u04zg_J3B2XxW9nn0lJQOOakncs4ZGspXKTiCX_TQ6JFcJ0OQ-E2CXTI?width=2880&amp;height=1416&amp;cropmode=none" alt="Git resource trigger"></p><p>在 Concourse 检查到 git 仓库的更新后，就会执行下面指定的构建步骤。结果大概会是这个样子的：</p><p><img data-src="https://sat02pap001files.storage.live.com/y4mnYseLRJR_FBRSXV0UfhLKgsyzp7vtfhE3teXHgMBp6eDOYpc1H0bEY9lh3T6lt0g-tXFfZJSb0_Wp3-HgaBKuvzI8fjEnUmJ0yN6oRwMuqEZLmIl8maSyPrlvjEmV2mCjX95d2Ve5Y2r1Qm1xvDMIE1AiIk7gnQ6Eb3Znw4ccE8uhOAlKfr-1R-kMukak6CW?width=2880&amp;height=1418&amp;cropmode=none" alt="Git resource trigger execution result"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>至此，我们完整的配置了一个简单的 pipeline。后面我会根据文档，或者根据工作中遇到的情况，继续补充权限管理、复杂的 case 等相关的博文。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnLw==">Concourse CI<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2U=">Concourse - GitHub<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2V0dXRvcmlhbC5jb20v">Concourse Tutorial<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/concourse/concourse-quick-start.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 的内部类和 private 修饰符</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-inner-class-and-private-identifier.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-inner-class-and-private-identifier.html</guid>
      <pubDate>Mon, 24 Feb 2020 13:38:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;一个 &lt;code&gt;private&lt;/code&gt; 属性只能被它所在的类访问，这件事地球人都知道。但是，你有没有想过，这条规则有没有可能在某种情况下，会变得不成立？&lt;/p&gt;
&lt;p&gt;本文将通过一个小例子，来演示怎么让 &lt;code&gt;private&lt;/code&gt; 修饰符 “失效”，以及它为什么会 “失效”。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一个 <code>private</code> 属性只能被它所在的类访问，这件事地球人都知道。但是，你有没有想过，这条规则有没有可能在某种情况下，会变得不成立？</p><p>本文将通过一个小例子，来演示怎么让 <code>private</code> 修饰符 “失效”，以及它为什么会 “失效”。</p><span id="more"></span><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>废话不多说，先写一段代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String outerClassName = <span class="string">"outerClass"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOuterClassName</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(outerClassName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        OuterClass.InnerClass innerClass = outerClass.<span class="function">new <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        innerClass.printOuterClassName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码是不是感觉有一丝异样？为什么在内部类里，能直接访问到外部类的 <code>private</code> 属性？难道 <code>private</code> 修饰符真的 “失效” 了？</p><p>别急，待我们把这个 class 反编译了，从字节码层面来看看它到底有什么猫腻。毕竟，字节码可不会骗人。</p><h2 id="反编译外部类"><a href="#反编译外部类" class="headerlink" title="反编译外部类"></a>反编译外部类</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c OuterClass.class</span><br><span class="line">Compiled from <span class="string">"OuterClass.java"</span></span><br><span class="line">public class com.boris1993.OuterClass {</span><br><span class="line">  public com.boris1993.OuterClass();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial <span class="comment">#2                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       4: aload_0</span><br><span class="line">       5: ldc           <span class="comment">#3                  // String outerClass</span></span><br><span class="line">       7: putfield      <span class="comment">#1                  // Field outerClassName:Ljava/lang/String;</span></span><br><span class="line">      10: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           <span class="comment">#4                  // class com/boris1993/OuterClass</span></span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial <span class="comment">#5                  // Method "&lt;init&gt;":()V</span></span><br><span class="line">       7: astore_1</span><br><span class="line">       8: new           <span class="comment">#6                  // class com/boris1993/OuterClass$InnerClass</span></span><br><span class="line">      11: dup</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: dup</span><br><span class="line">      14: invokevirtual <span class="comment">#7                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span></span><br><span class="line">      17: pop</span><br><span class="line">      18: invokespecial <span class="comment">#8                  // Method com/boris1993/OuterClass$InnerClass."&lt;init&gt;":(Lcom/boris1993/OuterClass;)V</span></span><br><span class="line">      21: astore_2</span><br><span class="line">      22: aload_2</span><br><span class="line">      23: invokevirtual <span class="comment">#9                  // Method com/boris1993/OuterClass$InnerClass.printOuterClassName:()V</span></span><br><span class="line">      26: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  static java.lang.String access<span class="variable">$000</span>(com.boris1993.OuterClass);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      <span class="comment">#1                  // Field outerClassName:Ljava/lang/String;</span></span><br><span class="line">       4: areturn</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有没有发现，78 行出现了一个我们没有写过的方法 <code>access$000</code>？而且从注释来看，它接受一个 <code>OuterClass</code> 类型的参数，而且返回的正是外部类的 <code>outerClassName</code> 的值。</p><p>既然我们没定义这个方法，那就是编译器偷偷的给咱整了点活。至于为啥编译器要这么干，结合上面这个例子，也不难猜出来：这就是给内部类访问它的 <code>private</code> 属性用的。</p><h2 id="反编译内部类"><a href="#反编译内部类" class="headerlink" title="反编译内部类"></a>反编译内部类</h2><p>但是咱不能光猜啊，咱还得有证据。证据哪来？当然是内部类的字节码。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c OuterClass<span class="variable">$InnerClass</span>.class</span><br><span class="line">Compiled from <span class="string">"OuterClass.java"</span></span><br><span class="line">public class com.boris1993.OuterClass<span class="variable">$InnerClass</span> {</span><br><span class="line">  final com.boris1993.OuterClass this<span class="variable">$0</span>;</span><br><span class="line"></span><br><span class="line">  public com.boris1993.OuterClass<span class="variable">$InnerClass</span>(com.boris1993.OuterClass);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: aload_1</span><br><span class="line">       2: putfield      <span class="comment">#1                  // Field this$0:Lcom/boris1993/OuterClass;</span></span><br><span class="line">       5: aload_0</span><br><span class="line">       6: invokespecial <span class="comment">#2                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       9: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public void printOuterClassName();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       3: aload_0</span><br><span class="line">       4: getfield      <span class="comment">#1                  // Field this$0:Lcom/boris1993/OuterClass;</span></span><br><span class="line">       7: invokestatic  <span class="comment">#4                  // Method com/boris1993/OuterClass.access$000:(Lcom/boris1993/OuterClass;)Ljava/lang/String;</span></span><br><span class="line">      10: invokevirtual <span class="comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      13: <span class="built_in">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>嗯，果然没错，在第 20 行这一条指令里，它调用了上面我们看到的那个 <code>access$000()</code> 方法。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9kcm9pZHl1ZS5jb20vYmxvZy8yMDE0LzEwLzAyL3RoZS1wcml2YXRlLW1vZGlmaWVyLWluLWphdmEv"> 细话 Java："失效" 的 private 修饰符<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-inner-class-and-private-identifier.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring bean 的作用域</title>
      <link>https://www.boris1993.com/projects/spring/java-spring-bean-scopes.html</link>
      <guid>https://www.boris1993.com/projects/spring/java-spring-bean-scopes.html</guid>
      <pubDate>Sat, 22 Feb 2020 03:00:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;在 Spring 中，那些由 IoC 容器所管理的对象被称之为 bean。而一个 bean 的定义，其实只是一个 “蓝图”，指导着 Spring 如何去创建这样一个 bean。而在这个蓝图中，有一个属性叫做 “作用域”，它规定了这个 bean 的可见范围。这里我们看一下 Spring 的 bean 都有哪些作用域。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 Spring 中，那些由 IoC 容器所管理的对象被称之为 bean。而一个 bean 的定义，其实只是一个 “蓝图”，指导着 Spring 如何去创建这样一个 bean。而在这个蓝图中，有一个属性叫做 “作用域”，它规定了这个 bean 的可见范围。这里我们看一下 Spring 的 bean 都有哪些作用域。</p><span id="more"></span><h2 id="支持的作用域"><a href="#支持的作用域" class="headerlink" title="支持的作用域"></a>支持的作用域</h2><p>我们先来看一下 Spring 支持哪些作用域。</p><table><thead><tr><th align="right">作用域</th><th>说明</th></tr></thead><tbody><tr><td align="right"> singleton</td><td> 在 Spring 容器中仅存在一个 bean 的实例，bean 以单例形式存在。这是默认的作用域</td></tr><tr><td align="right"> prototype</td><td> 每次从容器中获取 bean 时，都将生成一个新的实例，即相当于每次都执行 <code>new xxxBean()</code></td></tr><tr><td align="right">request</td><td> 在 HTTP 请求 (request) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicatonContext</code> 环境</td></tr><tr><td align="right"> session</td><td> 在 HTTP 会话 (session) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td></tr><tr><td align="right"> globalSession</td><td> 在全局的 HTTP 会话 (session) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境，且通常只能用在 <code>Portlet</code> 环境中。</td></tr><tr><td align="right">application</td><td> 在 <code>ServletContext</code> 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td></tr><tr><td align="right"> websocket</td><td> 在 <code>WebSocket</code> 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td></tr></tbody></table><h2 id="指定bean的作用域"><a href="#指定bean的作用域" class="headerlink" title="指定bean的作用域"></a>指定 bean 的作用域</h2><p>要指定一个 bean 的作用域，我们可以通过 XML 的方式或注解的方式来设定。</p><p>使用 XML 指定配置 bean 时，可以通过 <code>scope</code> 属性来指定作用域：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"someBean"</span> <span class="attr">class</span>=<span class="string">"com.demo.SomeClass"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>使用注解方式配置 bean 时，可以通过 <code>@Scope</code> 注解来指定作用域：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>{</span><br><span class="line">    <span class="comment">// Class definitions goes here</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此外，如果使用注解方式配置作用域，Spring 也提供了一系列常量值来方便我们配置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在ConfigurableBeanFactory类中</span></span><br><span class="line">String SCOPE_SINGLETON = <span class="string">"singleton"</span>;</span><br><span class="line">String SCOPE_PROTOTYPE = <span class="string">"prototype"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在WebApplicationContext类中</span></span><br><span class="line">String SCOPE_REQUEST = <span class="string">"request"</span>;</span><br><span class="line">String SCOPE_SESSION = <span class="string">"session"</span>;</span><br><span class="line">String SCOPE_APPLICATION = <span class="string">"application"</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="singleton作用域"><a href="#singleton作用域" class="headerlink" title="singleton作用域"></a>singleton 作用域</h2><p><code>singleton</code> 是 Spring 容器中的默认作用域。这个作用域下，容器中只创建各管理一个 bean 实例，实例存在于缓存中，并在后续对该 bean 的请求中都返回这个实例。</p><h2 id="prototype作用域"><a href="#prototype作用域" class="headerlink" title="prototype作用域"></a>prototype 作用域</h2><p>与 <code>singleton</code> 正相反，每次对 <code>prototype</code> 作用域的 bean 的请求，Spring 都会生成一个新的实例，即类似我们手动使用 <code>new XxxBean()</code> 方式创建实例。</p><p>需要注意的是，Spring 不会完整的管理一个 <code>prototype</code> 的 bean 的生命周期。容器在初始化、配置，并将 bean 交由请求方 (client) 之后，就撒手不管了。也就是说，在销毁一个 <code>prototype</code> 的 bean 时，销毁 bean 的回调方法是不会被调用的，所以在销毁一个 <code>prototype</code> 的 bean 时，开发者必须手动释放它所使用的资源，或者可以尝试使用一个自定义的 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension-bpp"><code>bean post-processor</code></a>来让 Spring 做这些事。</p><p>对于有状态的 bean，应当使用 <code>prototype</code> 作用域；对于无状态的 bean，则应当使用 <code>singleton</code> 作用域。</p><h2 id="向singleton-bean注入prototype-bean"><a href="#向singleton-bean注入prototype-bean" class="headerlink" title="向singleton bean注入prototype bean"></a>向 singleton bean 注入 prototype bean</h2><p>因为 bean 的依赖关系在实例化 bean 时才会被解析，所以通常来说，我们不可以将一个 prototype bean 注入到一个 singleton bean 中。</p><p>如果我们向一个 singleton bean 中注入一个 prototype bean，因为这个 singleton bean 只会被实例化一次，使得它的依赖也只会被注入一次，最终导致它依赖的那个 singleton bean 也只存在一个实例。</p><h2 id="request、session、global-session、application和websocket作用域"><a href="#request、session、global-session、application和websocket作用域" class="headerlink" title="request、session、global session、application和websocket作用域"></a>request、session、global session、application 和 websocket 作用域</h2><p>这几种作用域只能用在 <code>web-aware</code> 的 Spring 上下文中，比如 <code>XmlWebApplicationContext</code>。如果用在一般的 IoC 容器中，比如 <code>ClassPathXmlApplicationContext</code> 中，那么容器会抛出一个 <code>IllegalStateException</code>。</p><p>要使用这几个作用域，你可能需要对你的应用进行一些配置。因为这些内容与本文无关，所以在这里就不详细说明了。感兴趣的话可以看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy9jdXJyZW50L3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL2NvcmUuaHRtbCNiZWFucy1mYWN0b3J5LXNjb3Blcy1vdGhlci13ZWItY29uZmlndXJhdGlvbg=="> Spring 参考手册中的内容<i class="fa fa-external-link-alt"></i></span>。</p><p>注：<code>web-aware</code> 这个词，我也不知道怎么翻译才合适。查阅了一些资料之后，感觉一个 <code>web-aware</code> 的 Spring 应用就是一个运行在 web 容器 (比如 Tomcat) 中的应用，因为上面提到的这些作用域也是与 web 应用相关的。如果有好的理解，请一定在留言区写下来让在下知道。</p><h3 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request 作用域</h3><p><code>request</code> 作用域下的 bean，在每次 HTTP 请求中，都会创建一个新的实例。当请求完成时，对应的 bean 就会被销毁。对一个实例的任何更改，对其他的所有实例来说都是不可见的。</p><h3 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session 作用域</h3><p><code>session</code> 作用域下的 bean，在每个活动的 HTTP 会话中，都有一个独自的实例，而当会话结束后，对应的 bean 就会被销毁。对一个实例的任何更改，对其他所有的实例来说都是不可见的。</p><h3 id="globalSession作用域"><a href="#globalSession作用域" class="headerlink" title="globalSession作用域"></a>globalSession 作用域</h3><p>这个作用域只能用在 <code>portlet</code> 应用中。一个 <code>portlet</code> 站点中可能有多个 <code>portlet</code> 应用，而它们相关的 session 中都会共享同一个 <code>globalSession</code> 作用域的 bean。</p><p>注：其实我也不知道 <code>portlet</code> 到底是个啥，就算看过维基百科的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmF2YV9Qb3J0bGV0X1NwZWNpZmljYXRpb24="> Portlet 条目<i class="fa fa-external-link-alt"></i></span>也没看明白。</p><h3 id="application作用域"><a href="#application作用域" class="headerlink" title="application作用域"></a>application 作用域</h3><p>在整个应用范围内，容器为每个 web 应用程序运行时创建一个实例。这个作用域与 <code>singleton</code> 很类似，但是还是有两个不同点：</p><ul><li>在不同 <code>ServletContext</code> 中有不同的 bean 单例对象；singleton 作用域的 bean 是每个 <code>ApplicationContext</code> 的单例对象。而一个应用可能有多个 <code>ApplicationContext</code></li><li>bean 作为 <code>ServletContext</code> 属性可见</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy9jdXJyZW50L3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL2NvcmUuaHRtbCNiZWFucy1mYWN0b3J5LXNjb3Blcw==">Bean Scopes - The IoC container<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGFkMTQ1NWYyNjVkYTViNjAwNmZhNmE=">Spring 系列四：Bean Scopes 作用域<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljYXJ1c193YW5nL2FydGljbGUvZGV0YWlscy81MTU4Njc3Ng==">Spring 学习（十五）Spring Bean 的 5 种作用域介绍<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/spring/java-spring-bean-scopes.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot 自动配置的原理</title>
      <link>https://www.boris1993.com/projects/spring/java-spring-autoconfiguration.html</link>
      <guid>https://www.boris1993.com/projects/spring/java-spring-autoconfiguration.html</guid>
      <pubDate>Thu, 20 Feb 2020 02:00:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;在使用 Spring Boot 时，最使我们收益的一个功能就是它的自动配置。但是，用了这么久的自动配置功能，有没有想过它是怎么实现的？本文将从源码入手，一步一步搞明白 Spring Boot 自动配置的原理。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在使用 Spring Boot 时，最使我们收益的一个功能就是它的自动配置。但是，用了这么久的自动配置功能，有没有想过它是怎么实现的？本文将从源码入手，一步一步搞明白 Spring Boot 自动配置的原理。</p><span id="more"></span><p>我这里就用一个简单的 Eureka server 的项目来举例。实际上只要是个 Spring Boot 项目就可以，我只是懒得再创建一个新的项目了。</p><p>它的启动代码我们都很熟悉，是这样子的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(EurekaServer.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>东西很简单，一共就这么几行。我们看看 <code>@SpringBootApplication</code> 里面有什么？</p><h2 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication 注解</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {</span><br><span class="line">    <span class="comment">// 因为里面的属性与本文关系不大，所以就略掉了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我们可以看到一个 <code>@EnableAutoConfiguration</code> 注解，顾名思义，这个注解是用来开启自动配置的。我们继续深入进去看看。</p><h2 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration 注解</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration {</span><br><span class="line"></span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">     * applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个注解上面还有一大段的 JavaDoc，因为篇幅太长，就不把全文放上来了。翻译过来的大意是这样的：</p><blockquote><p>这个注解可以启用 Spring 应用上下文的自动配置。开启这个配置后，Spring 将会尝试猜测你需要的类，并进行配置。Spring 通常会根据 ClassPath 和用户定义的 bean 来完成自动配置的操作。<br>举例来说，如果在你的 ClassPath 中出现了 tomcat-embedded.jar，那么你很可能会需要 TomcatServletWebServerFactory 这个类，除非你自己定义了 ServletWebServerFactory。</p></blockquote><p>看完 JavaDoc，我们大概知道了 Spring 是怎么判断哪些类需要自动配置。那么我们继续深入源码。</p><p>这里有两个注解比较重要：<code>@Import(AutoConfigurationImportSelector.class)</code> 和 <code>@AutoConfigurationPackage</code>。</p><h2 id="AutoConfigurationImportSelector类"><a href="#AutoConfigurationImportSelector类" class="headerlink" title="AutoConfigurationImportSelector类"></a>AutoConfigurationImportSelector 类</h2><p>Spring Boot 应用启动过程中使用 <code>ConfigurationClassParser</code> 分析配置类时，如果发现注解中存在 <code>@Import(ImportSelector)</code> 的情况，就会创建一个相应的 <code>ImportSelector</code> 对象， 并调用其方法 <code>public String[] selectImports(AnnotationMetadata annotationMetadata)</code>。所以我们就从 <code>selectImports</code> 方法开始看起。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从META-INF/spring-autoconfigure-metadata.properties中加载AutoConfigurationMetaData</span></span><br><span class="line">    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取自动配置项</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面方法通过 <code>getAutoConfigurationEntry</code> 获取到了需要自动配置的项，那么它是怎么知道哪些东西需要自动配置的呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the {<span class="doctag">@link</span> AutoConfigurationEntry} based on the {<span class="doctag">@link</span> AnnotationMetadata}</span></span><br><span class="line"><span class="comment"> * of the importing {<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>} class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoConfigurationMetadata the auto-configuration metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到注解里面的属性</span></span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到需要自动配置的类，并去重</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得要排除在自动配置之外的类的列表，并将其排除</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用过滤器AutoConfigurationImportFilter</span></span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播自动配置事件</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面我们看到，Spring Boot 通过 <code>getCandidateConfigurations</code> 方法找到了需要自动配置的类，那么它又是怎么工作的呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the auto-configuration class names that should be considered. By default</span></span><br><span class="line"><span class="comment"> * this method will load candidates using {<span class="doctag">@link</span> SpringFactoriesLoader} with</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #getSpringFactoriesLoaderFactoryClass()}.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the source metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes the {<span class="doctag">@link</span> #getAttributes(AnnotationMetadata) annotation</span></span><br><span class="line"><span class="comment"> * attributes}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list of candidate configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>{</span><br><span class="line">    <span class="comment">// 扫描ClassPath中所有的META-INF/spring.factories，并从中获取所有自动配置的类名</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">            + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the class used by {<span class="doctag">@link</span> SpringFactoriesLoader} to load configuration</span></span><br><span class="line"><span class="comment"> * candidates.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the factory class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() {</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">getBeanClassLoader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanClassLoader;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面 <code>getCandidateConfigurations</code> 方法又调用了 <code>loadFactoryNames</code> 方法来获取 <code>EnableAutoConfiguration</code> 注解相关的工厂类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The location to look for factories.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from {<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION}, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> null} to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>{</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上文我们知道，factoryClass传入的是EnableAutoConfiguration.class</span></span><br><span class="line">    <span class="comment">// 所以这里就是从spring.factories中寻找org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的自动配置类</span></span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从ClassPath中寻找所有spring.factories文件，并将其包装成一个Properties对象</span></span><br><span class="line"><span class="comment"> * 然后把Properties对象里面的各个条目包装到一个Map&lt;String, List&lt;String&gt;&gt;对象中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) {</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) {</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {</span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>这里我们用 <code>RedisAutoConfiguration</code> 类来说明一个具体的自动配置类是如何工作的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> EnableAutoConfiguration Auto-configuration} for Spring Data's Redis support.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andy Wilkinson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christian Dupuis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christoph Strobl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eddú Meléndez</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stephane Nicoll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Marco Aust</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Paluch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 说明这是一个配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span> <span class="comment">// 当RedisOperations类存在时这个配置类才会生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span> <span class="comment">// 将配置文件的字段与RedisProperties类绑定</span></span><br><span class="line"><span class="meta">@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })</span> <span class="comment">// 导入两个Redis连接池的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>{</span><br><span class="line">    <span class="comment">// 这里是初始化redisTemplate和stringRedisTemplate的代码，因为与本文无关，所以略掉了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据上文我们了解到的内容，我们可以推测出它是这样子被初始化的：</p><ul><li>首先 Spring 在 <code>spring.factories</code> 中，根据 <code>EnableAutoConfiguration</code> 发现了 <code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code></li><li>然后 Spring 会检查 <code>RedisOperations</code> 类是否存在于 ClassPath 中</li><li>如果存在，则会从配置文件的 <code>spring.redis</code> 字段中取值，并初始化 <code>RedisProperties</code></li><li>然后根据 <code>LettuceConnectionConfiguration</code> 和 <code>JedisConnectionConfiguration</code> 中的条件，选择使用哪个连接池，并将其初始化</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上文的分析，我们知道了 Spring 在启动时，会加载一系列的配置类，并会根据配置类中指定的条件，来决定是否对其实施自动配置。</p><p><code>xxAutoConfigurartion</code> 这样的类是自动配置类，用于向容器中添加组件。</p><p><code>xxProperties</code> 这样的类是属性类，用于封装配置文件中的属性，并规定了 Spring 应该从配置文件的哪个字段取值用于初始化。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/spring/java-spring-autoconfiguration.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>解决命令行中 Git 显示中文文件名乱码</title>
      <link>https://www.boris1993.com/tools/git/git-commandline-unescape-chinese-characters.html</link>
      <guid>https://www.boris1993.com/tools/git/git-commandline-unescape-chinese-characters.html</guid>
      <pubDate>Mon, 10 Feb 2020 02:15:34 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;在用 Git 管理包含中文的文件时，会出现类似这样的 “乱码”：&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在用 Git 管理包含中文的文件时，会出现类似这样的 “乱码”：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">    <span class="string">"\345\271\277\345\221\212\345\220\214\346\255\245\345\271\263\345\217\260\346\216\245\345\217\243\346\226\207\346\241\2432.0.docx.new"</span></span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></tbody></table></figure><p>解决方法是配置 Git 的全局属性 <code>core.quotepath</code> 为 <code>false</code>，即执行命令 <code>git config --global core.quotepath false</code>，然后再执行 <code>git status</code>，就可以看到中文正常显示了：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">    广告同步平台接口文档2.0.docx.new</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></tbody></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/git/git-commandline-unescape-chinese-characters.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 VisualVM 监控应用 GC</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/monitor-gc-with-visual-vm.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/monitor-gc-with-visual-vm.html</guid>
      <pubDate>Sun, 09 Feb 2020 09:38:42 GMT</pubDate>
      <description>
      
        &lt;p&gt;我们知道，使用 VisualVM 可以监控 Java 应用的各种运行时信息，包括资源占用、正在运行的线程等等。本文将简单介绍如何使用 VisualVM 的插件 &lt;code&gt;Visual GC&lt;/code&gt; 来监控 Java 应用的垃圾回收情况。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们知道，使用 VisualVM 可以监控 Java 应用的各种运行时信息，包括资源占用、正在运行的线程等等。本文将简单介绍如何使用 VisualVM 的插件 <code>Visual GC</code> 来监控 Java 应用的垃圾回收情况。</p><span id="more"></span><h2 id="安装Visual-GC插件"><a href="#安装Visual-GC插件" class="headerlink" title="安装Visual GC插件"></a>安装 <code>Visual GC</code> 插件</h2><p>因为 <code>Visual GC</code> 插件并不是随 VisualVM 附带的，需要到插件商店下载。</p><p>点击 <code>Tools</code>–&gt;<code>Plugins</code> 打开插件管理窗口，进入 <code>Available Plugins</code>，在左侧窗格中勾选 <code>Visual GC</code>，点击 <code>Install</code>，同意许可协议后，稍等片刻即可完成安装。安装完成之后无需重启 VisualVM。</p><p><img data-src="https://sat02pap001files.storage.live.com/y4mB0xUlwCwxRs1OYG5s7tct4fE9O8mEfB9d0TDUtr3n-dLtE-kCUaRDqQ0oiM-gl9yeFJFfj7p8AW6-mbEIWUPzYqJzYHMVkuxJudzUxbdUIfvP1GM2H1hOpngIdNk8RLyEna53-JFT96lhfYwTcdP15fXhdg1ojlCh9VPH7IY5s1US0SW31s6_daVwATD9ZrS?width=1782&amp;height=1080&amp;cropmode=none" alt="Install Visual GC"></p><h2 id="监控垃圾回收"><a href="#监控垃圾回收" class="headerlink" title="监控垃圾回收"></a>监控垃圾回收</h2><p>安装完成后，在 VisualVM 的 <code>Applications</code> 窗格中双击要监控的应用，然后在右侧窗格中进入 <code>Visual GC</code>，即可以图形化的方式查看当前该应用中各个内存区域的情况。</p><p><img data-src="https://sat02pap001files.storage.live.com/y4m3cQpYqJKAIsE9_gLv8JNhyqspQZRDmVo1Pwduk0crZlHkwXcRf8koN4u-Gput6JysCToZgM_uj8BAEJmWuYMpUaZJpheamTxNJ7Fq169nZsDuwNJTTl23jm_4PwsNlA4lneLgFjN7NSDNE4JeObrFPhmQRrAWfVd4AF_R6xPlwtKC3ZuqbYA7uRAR1VLTz19?width=2880&amp;height=1644&amp;cropmode=none" alt="Monitor GC"></p><p>窗格中的 <code>Spaces</code> 部分展示的是当前各个区域的占用情况；<code>Graphs</code> 部分则包括：</p><ul><li><code>Compile Time</code>：编译时间，包括编译的次数，和累计的编译时间。图表中的一次脉冲就代表一次编译，脉冲越宽代表编译时间越长</li><li><code>Class Loader Time</code>：类加载时间，包括加载了多少个类 (<code>loaded</code>)，卸载了多少个类 (<code>unloaded</code>)，和累计用于类加载的时间</li><li><code>GC Time</code>：垃圾回收时间，包括垃圾回收的次数，垃圾回收消耗的时间，和上一次垃圾回收的原因</li><li><code>Eden Space</code>：Eden 区的空间，括号中第一位是最大容量，第二位是当前容量，其后冒号跟着的是当前使用了的大小，再往后是发生垃圾回收的次数，和垃圾回收消耗的时间</li><li><code>Survivor 0</code> 和 <code>Survivor 1</code>：两个 <code>Survivor</code> 区的空间，同样包括最大容量、当前容量，和当前使用了的大小</li><li><code>Old Gen</code>：老年代的空间，同样包括最大容量、当前容量、当前使用了的大小、发生垃圾回收的次数，和垃圾回收消耗的时间</li><li><code>Metaspace</code>：Metaspace 的空间 (如果使用的是 Java 1.7 及之前版本，这里则是 <code>Perm Gen</code>)，包括最大容量、当前容量，和当前使用了的大小</li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/monitor-gc-with-visual-vm.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>简谈 JVM 中的几种引用</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-jvm-reference.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-jvm-reference.html</guid>
      <pubDate>Fri, 07 Feb 2020 03:36:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;在 &lt;a href=&quot;/projects/java/fundamentals/java-gc-algorithms.html&quot;&gt;Java 的垃圾回收算法&lt;/a&gt;一文中，我们知道 JVM 是根据一个对象有没有被引用来判断要不要对其进行垃圾回收的。但是，如果我们为了提升垃圾回收的效率，想要再把垃圾回收的条件更细化一些，比如只在内存非常紧张的时候才回收某些对象，那么光靠一个粗略的 “引用”，就显得心有余而力不足了。所以，在 &lt;code&gt;JDK 1.2&lt;/code&gt; 版本之后，Java 扩充了引用的概念，将其扩充成了&lt;code&gt;强引用&lt;/code&gt;，&lt;code&gt;软引用&lt;/code&gt;，&lt;code&gt;弱引用&lt;/code&gt;，&lt;code&gt;虚引用&lt;/code&gt;四个更细化的概念。&lt;/p&gt;
&lt;p&gt;本文将参考《深入理解 Java 虚拟机 (第 3 版)》中&lt;code&gt;再谈引用&lt;/code&gt;一节，简述一下这四种引用的概念，以及被引用的对象何时会被垃圾回收器回收。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 <a href="/projects/java/fundamentals/java-gc-algorithms.html">Java 的垃圾回收算法</a>一文中，我们知道 JVM 是根据一个对象有没有被引用来判断要不要对其进行垃圾回收的。但是，如果我们为了提升垃圾回收的效率，想要再把垃圾回收的条件更细化一些，比如只在内存非常紧张的时候才回收某些对象，那么光靠一个粗略的 “引用”，就显得心有余而力不足了。所以，在 <code>JDK 1.2</code> 版本之后，Java 扩充了引用的概念，将其扩充成了<code>强引用</code>，<code>软引用</code>，<code>弱引用</code>，<code>虚引用</code>四个更细化的概念。</p><p>本文将参考《深入理解 Java 虚拟机 (第 3 版)》中<code>再谈引用</code>一节，简述一下这四种引用的概念，以及被引用的对象何时会被垃圾回收器回收。</p><span id="more"></span><h2 id="强引用-Strongly-reference"><a href="#强引用-Strongly-reference" class="headerlink" title="强引用(Strongly reference)"></a>强引用 (Strongly reference)</h2><p>强引用是最传统的 “引用” 的定义，指在代码中普遍存在的引用赋值，比如 <code>Object obj = new Object()</code>。不论在任何情况下，只要强引用关系存在，那么垃圾回收器就永远不会回收掉被引用的对象。</p><h2 id="软引用-Soft-reference"><a href="#软引用-Soft-reference" class="headerlink" title="软引用(Soft reference)"></a>软引用 (Soft reference)</h2><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象纳入回收范围进行第二次回收，如果在回收之后仍没有足够的内存，才会抛出内存溢出异常。在 <code>JDK 1.2</code> 版本之后提供了 <code>SoftReference</code> 类来实现软引用。</p><p>软引用对象可以用在类似缓存的场景中，比如在一个图片编辑器中，应用可以将用户打开的文件读入一个软引用对象。</p><p>如果要创建一个软引用对象，那么可以使用如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; stringSoftReference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="string">"string"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="弱引用-Weak-reference"><a href="#弱引用-Weak-reference" class="headerlink" title="弱引用(Weak reference)"></a>弱引用 (Weak reference)</h2><p>弱引用也是用来被描述非必须的对象，但它的强度比软引用要更弱一些。被弱引用关联的对象只能生存到下一次垃圾回收发生时。当垃圾回收器开始工作后，无论当前剩余内存是否足够，被弱引用关联的对象都会被回收掉。在 <code>JDK 1.2</code> 版本之后提供了 <code>WeakReference</code> 类来实现弱引用。</p><p>弱引用常见于一些集合类中，尤其在哈希表中。因为哈希表的接口允许用户使用任何 Java 对象作为 key 来使用，而当一个键值被存入哈希表后，哈希表本身就有了对这些键和值的引用。如果这些引用是强引用，那么只要这个哈希表对象存活，哈希表关联的键和值也就永远不会被回收。如果这个哈希表同时又包含了大量的对象，那么就可能会长时间占用服务器的大量内存。这类问题的解决办法就是使用弱引用来关联这些对象，比如使用 <code>WeakHashMap</code>。</p><p>如果要创建一个弱引用对象，那么可以使用如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; stringWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="string">"string"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="虚引用-Phantom-reference"><a href="#虚引用-Phantom-reference" class="headerlink" title="虚引用(Phantom reference)"></a>虚引用 (Phantom reference)</h2><p>虚引用也叫 “幽灵引用” 或 “幻影引用”，是最弱的一种引用。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，同时用户也无法通过一个虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个系统通知。在 <code>JDK 1.2</code> 版本之后提供了 <code>PhantomReference</code> 类来实现虚引用。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMzIwMDI0NA==">Java 强软弱虚引用介绍及使用场景<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWpvcmNlbi9wLzM5NjgwMTguaHRtbA==">java 中四种引用类型<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-jvm-reference.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>看懂 ParallelGC 的日志</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-understand-parallel-gc-logs.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-understand-parallel-gc-logs.html</guid>
      <pubDate>Wed, 05 Feb 2020 06:45:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;在排查垃圾回收相关的问题时，一个必不可少的技能就是要能看懂 Java 的垃圾回收日志。本文将介绍打印 GC 日志相关的 JVM 参数，以及使用不同参数时 JVM 将会打印出的日志内容。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在排查垃圾回收相关的问题时，一个必不可少的技能就是要能看懂 Java 的垃圾回收日志。本文将介绍打印 GC 日志相关的 JVM 参数，以及使用不同参数时 JVM 将会打印出的日志内容。</p><span id="more"></span><h2 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK 版本</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version "1.8.0_232"</span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_232-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.232-b09, mixed mode)</span><br></pre></td></tr></tbody></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>在演示过程中，我们将通过在死循环中构造大对象的方式来触发垃圾回收</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCExample</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String[] strings;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            strings = <span class="keyword">new</span> String[<span class="number">1024</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同时，为了让垃圾回收更早的开始，我们还需要指定一个较小的堆内存，比如我选择只分配 10MB 的空间。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10m</span><br><span class="line">-Xms10m</span><br></pre></td></tr></tbody></table></figure><h2 id="GC日志相关的JVM参数"><a href="#GC日志相关的JVM参数" class="headerlink" title="GC日志相关的JVM参数"></a>GC 日志相关的 JVM 参数</h2><p>与 GC 日志相关的 JVM 参数有如下 8 个：</p><table><thead><tr><th>参数名</th><th>参数含义</th></tr></thead><tbody><tr><td> -XX:+PrintGC</td><td> 输出简要 GC 日志</td></tr><tr><td> -verbose:gc</td><td> 等同于 -XX:+PrintGC</td></tr><tr><td>-XX:+PrintGCDetails</td><td> 输出详细 GC 日志</td></tr><tr><td> -Xloggc:gc.log</td><td> 输出 GC 日志到文件 gc.log</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td> 输出 GC 的时间戳（以 JVM 启动到当期的总时长的时间戳形式）</td></tr><tr><td>-XX:+PrintGCDateStamps</td><td> 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td> 在进行 GC 的前后打印出堆的信息</td></tr><tr><td> -XX:+PrintReferenceGC</td><td> 打印年轻代各个引用的数量以及时长</td></tr></tbody></table><h3 id="XX-PrintGC与-verbose-gc"><a href="#XX-PrintGC与-verbose-gc" class="headerlink" title="-XX:+PrintGC与-verbose:gc"></a><code>-XX:+PrintGC</code> 与 <code>-verbose:gc</code></h3><p>虽然上面说这两个参数是等价的，但是，<code>-verbose:gc</code> 是一个标准的参数，而 <code>-XX:+PrintGC</code> 则在 JDK 9 之后被标为废弃的 (deprecated)，所以建议使用 <code>-verbose:gc</code> 代替 <code>-XX:+PrintGC</code>。</p><h2 id="打开-verbose-gc"><a href="#打开-verbose-gc" class="headerlink" title="打开-verbose:gc"></a>打开 <code>-verbose:gc</code></h2><p>使用这个参数将会打开简略的 GC 日志。打开这个参数并运行程序，很快就可以看到这样的 GC 日志：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  2520K-&gt;472K(9728K), 0.0005722 secs]</span><br></pre></td></tr></tbody></table></figure><p>我们将上面的日志拆分开来：</p><ul><li><code>GC</code> 代表这次垃圾回收的类型。<code>GC</code> 代表发生了 <code>Minor GC</code>，<code>Full GC</code> 代表发生了 <code>Full GC</code></li><li><code>Allocation Failure</code> 简述了发生 GC 的原因。在这个例子中，是因为在年轻代中没有合适的空间导致新的对象分配失败，从而发生 GC</li><li><code>2520K-&gt;472K</code> 说明了年轻代的占用量变化。在这个例子中，年轻代的使用量从 2520KB 减少到了 472KB</li><li><code>9728K</code> 表示整个堆的大小</li><li><code>0.0005722 secs</code> 表示了本次 GC 消耗的时间</li></ul><h2 id="打开-XX-PrintGCDetails"><a href="#打开-XX-PrintGCDetails" class="headerlink" title="打开-XX:+PrintGCDetails"></a>打开 <code>-XX:+PrintGCDetails</code></h2><p>使用这个参数后，将会打印详细的 GC 日志，它打印的内容包含了 <code>-verbose:gc</code> 参数打印的内容。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 2500K-&gt;452K(9728K), 0.0003785 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure><p>这个参数打印的日志与上一个参数打印的日志有一部分重合，这里我们关注新增的内容：</p><ul><li><code>[PSYoungGen: 2048K-&gt;0K(2560K)]</code> 表明了使用的垃圾回收器、年轻代的占用量变化，和年轻代的大小</li><li><code>2500K-&gt;452K(9728K)</code> 表明了整个堆的占用量变化，和整个堆的大小</li><li><code>[Times: user=0.00 sys=0.00, real=0.00 secs]</code> 表示本次 GC 消耗的时间<ul><li><code>user</code> 代表垃圾回收器消耗的 CPU 时间</li><li><code>sys</code> 代表系统调用或等待系统事件消耗的时间</li><li><code>real</code> 代表应用实际停止的时间，近似于 <code>(user + sys) / 垃圾回收器使用的线程数</code></li></ul></li></ul><h2 id="打开-XX-PrintGCTimeStamps"><a href="#打开-XX-PrintGCTimeStamps" class="headerlink" title="打开-XX:+PrintGCTimeStamps"></a>打开 <code>-XX:+PrintGCTimeStamps</code></h2><p>这个参数不影响日志的详细程度，在打开之后，日志中会出现从 JVM 启动到出现日志时的毫秒数，比如下面例子的 <code>1.523</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.523: [GC (Allocation Failure) [PSYoungGen: 2141K-&gt;96K(2560K)] 4805K-&gt;2776K(9728K), 0.0004359 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure><h2 id="打开-XX-PrintGCDateStamps"><a href="#打开-XX-PrintGCDateStamps" class="headerlink" title="打开-XX:+PrintGCDateStamps"></a>打开 <code>-XX:+PrintGCDateStamps</code></h2><p>这个参数也不影响日志的详细程度，在打开之后，日志头部会加上打印日志的时间和时区，比如下面例子的 <code>2020-02-06T10:13:08.634-0800</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-02-06T10:13:08.634-0800: 1.122: [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 3328K-&gt;1280K(9728K), 0.0004243 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure><h2 id="打开-XX-PrintHeapAtGC"><a href="#打开-XX-PrintHeapAtGC" class="headerlink" title="打开-XX:+PrintHeapAtGC"></a>打开 <code>-XX:+PrintHeapAtGC</code></h2><p>使用这个参数后，在打印 GC 日志时，会同时打印出堆在 GC 前后的信息，即根据不同的内存区域，分别显示在垃圾回收前后的空间使用情况。同时，日志中还以 <code>[bottom,top,end)</code> 的格式展现出了各个内存区域的地址，其中 <code>bottom</code> 为这个区域的起始位置，<code>top</code> 为这个区域当前的顶部位置，<code>end</code> 为这个区域可使用的地址上限 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Meaning of heap memory addresses in GC logs using -XX:+PrintHeapAtGC?](https://stackoverflow.com/questions/28344451/meaning-of-heap-memory-addresses-in-gc-logs-using-xxprintheapatgc)">[1]</span></a></sup>。</p><p>此外，日志中关于 <code>Metaspace</code> 相关的信息可以参考注脚 4<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Understanding metaspace line in JVM heap printout](https://stackoverflow.com/questions/40891433/understanding-metaspace-line-in-jvm-heap-printout)">[4]</span></a></sup> 指向的那篇回答。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">{Heap before GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 2560K, used 2047K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 99% used [0x00000007bfd00000,0x00000007bfeffe78,0x00000007bff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 0K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf600000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 3045K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 320K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">2020-02-06T10:21:05.317-0800: 0.219: [GC (Allocation Failure) [PSYoungGen: 2047K-&gt;496K(2560K)] 2047K-&gt;512K(9728K), 0.0019061 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span><br><span class="line">Heap after GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 2560K, used 496K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 0% used [0x00000007bfd00000,0x00000007bfd00000,0x00000007bff00000)</span><br><span class="line">  from space 512K, 96% used [0x00000007bff00000,0x00000007bff7c010,0x00000007bff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line"> ParOldGen       total 7168K, used 16K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf604000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 3045K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 320K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="打开-XX-PrintReferenceGC"><a href="#打开-XX-PrintReferenceGC" class="headerlink" title="打开-XX:+PrintReferenceGC"></a>打开 <code>-XX:+PrintReferenceGC</code></h2><p>打开这个参数后，就可以看到各种引用的数量，以及对其垃圾回收所消耗的时长。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [SoftReference, 0 refs, 0.0000125 secs][WeakReference, 0 refs, 0.0000054 secs][FinalReference, 0 refs, 0.0000045 secs][PhantomReference, 0 refs, 0 refs, 0.0000222 secs][JNI Weak Reference, 0.0000037 secs][PSYoungGen: 2112K-&gt;64K(2560K)] 3488K-&gt;1456K(9728K), 0.0005389 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjgzNDQ0NTEvbWVhbmluZy1vZi1oZWFwLW1lbW9yeS1hZGRyZXNzZXMtaW4tZ2MtbG9ncy11c2luZy14eHByaW50aGVhcGF0Z2M=">Meaning of heap memory addresses in GC logs using -XX:+PrintHeapAtGC?<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9wbHVtYnIuaW8vaGFuZGJvb2svZ2FyYmFnZS1jb2xsZWN0aW9uLWFsZ29yaXRobXMtaW1wbGVtZW50YXRpb25zL3BhcmFsbGVsLWdj">Parallel GC - Plumber<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9wbHVtYnIuaW8vaGFuZGJvb2svZ2FyYmFnZS1jb2xsZWN0aW9uLWFsZ29yaXRobXMtaW1wbGVtZW50YXRpb25zL3BhcmFsbGVsLWdjL3BhcmFsbGVsLWZ1bGwtZ2M=">Parallel Full GC - Plumber<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDA4OTE0MzMvdW5kZXJzdGFuZGluZy1tZXRhc3BhY2UtbGluZS1pbi1qdm0taGVhcC1wcmludG91dA==">Understanding metaspace line in JVM heap printout<i class="fa fa-external-link-alt"></i></span><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-understand-parallel-gc-logs.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 源码阅读 - HashMap</title>
      <link>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashmap.html</link>
      <guid>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashmap.html</guid>
      <pubDate>Mon, 06 Jan 2020 08:51:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。&lt;/p&gt;
&lt;p&gt;这次就来阅读一下 &lt;code&gt;HashMap&lt;/code&gt; 的源码。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p><p>这次就来阅读一下 <code>HashMap</code> 的源码。</p><span id="more"></span><h2 id="HashMap的特性"><a href="#HashMap的特性" class="headerlink" title="HashMap的特性"></a>HashMap 的特性</h2><p><code>HashMap</code> 有如下的特性：</p><ul><li><code>HashMap</code> 是根据键值对来存储数据的，多个数据之间的键不能重复。在键重复时，旧的数据将会被覆盖</li><li><code>HashMap</code> 中各个数据实际存放的位置与 <code>hashCode()</code> 方法的结果有关，但不是由其结果直接决定</li><li><code>HashMap</code> 只允许一个键是 <code>null</code>(因为存储多个键是 <code>null</code> 的数据就违反了第一条特性)，但是允许多个值是 <code>null</code> 的数据</li><li><code>HashMap</code> 中数据存储的位置是不确定的，并且可能会因为扩容而改变，所以它的遍历顺序是不确定的</li><li><code>HashMap</code> 不是线程安全的，如果需要线程安全性则可以使用 <code>ConcurrentHashMap</code></li></ul><h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></tbody></table></figure><p>上面代码声明了一个名为 <code>HashMap</code> 的泛型类，它继承了 <code>AbstractMap</code>，并实现了 <code>Map</code>，<code>Cloneable</code>，<code>Serializable</code> 接口。</p><p><code>AbstractMap</code> 是一个抽象类，它是一个骨架级的 <code>Map</code> 实现，来减少实现一个 Map 所需的工作量。</p><p><code>Map</code> 接口顾名思义，它定义了要实现一个 Map 时必须实现的方法。</p><h2 id="一些关键的常量和概念"><a href="#一些关键的常量和概念" class="headerlink" title="一些关键的常量和概念"></a>一些关键的常量和概念</h2><p>在深入了解 <code>HashMap</code> 前，有一些关键的概念我们需要知道：</p><ul><li>哈希桶 (bucket/bin)：一个数组元素中存放的链表，就是一个哈希桶</li><li>哈希表：即存放了各个哈希桶的数组</li><li>树化阈值：当一个桶的大小超过了树化阈值之后才会将其变成红黑树</li><li>非树化阈值：当一个已经变成红黑树的桶中节点数量小于该值时，这个红黑树会被变回链表</li><li>最小树化容量：在选择是否将一个链表变成红黑树时，除了会考虑链表长度外，还会考虑哈希表的长度。仅当哈希表长度超过最小树化容量，且某个链表长度超过树化阈值时，这个链表才会被变成红黑树</li></ul><p>与之对应的有这几个常量值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></tbody></table></figure><p>此外 <code>HashMap</code> 还针对哈希表的扩容定义了一系列的常量和变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量。为了保证添加和查找的高效性，HashMap的容量总是2的幂次</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认载荷因子。</span></span><br><span class="line"><span class="comment">// 载荷因子是哈希表在其容量自动增加之前被允许获得的最大数量的度量，决定了哈希表何时扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阈值。它的值等于哈希表容量乘以载荷因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的载荷因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></tbody></table></figure><h2 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h2><p><code>HashMap</code> 存储数据的方式有两种，而这两种方式也正是 <code>Java 1.7</code> 和 <code>Java 8</code> 的分界线，因为 <code>Java 8</code> 对于 <code>HashMap</code> 进行了底层上的改动。</p><h3 id="Java-1-7之前"><a href="#Java-1-7之前" class="headerlink" title="Java 1.7之前"></a>Java 1.7 之前</h3><p>因为 <code>HashMap</code> 是依靠 <code>hashCode()</code> 方法的结果来决定元素存储的位置的，而再完美的哈希函数也无法避免哈希碰撞的出现，所以 <code>HashMap</code> 选择采用<code>拉链法</code> (也叫<code>链地址法</code>) 来存储数据。</p><p>链地址法是一种结合了数组和链表的存储方式，在每个数组元素中存储的都是一个链表，这些链表被称为<code>桶(bucket/bin)</code>。</p><p>为了直观的展示，这里借用一下参考文章 1<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[搞懂 Java HashMap 源码](https://juejin.im/post/5ac83fa35188255c5668afd0)">[1]</span></a></sup> 中的一幅图：</p><p><img data-src="https://sat02pap001files.storage.live.com/y4mJImIQzo7ZMMsEDb7vR_c6mxo7QCNQvboyOYKqH6vn0hlP5mPHgvFYtMbZUPZ5ESx60LW-D4IkQ_QO4S4iljYy42qiROO96pgxQjgJTgYWI43ttutqnGR_hRmFCpMy199wWXZKJhhmS3SaGEkOcqc7V9O_5Zr0ZdRFzvLJMR6cSrsImOWoagfuQ-DgHG6HOZj?width=1440&amp;height=1264&amp;cropmode=none" alt="拉链法"></p><p>我们都知道，一个数组元素只能保存一个数据，但是多个数据经过哈希运算后可能得到相同的哈希值，所以 <code>HashMap</code> 会将哈希值相同的数据存放在相同数组位置中的一个链表中。而在取出元素时，<code>HashMap</code> 首先会根据哈希值找到数组中的位置，然后遍历其中的链表来找到数据。</p><h3 id="Java-8之后"><a href="#Java-8之后" class="headerlink" title="Java 8之后"></a>Java 8 之后</h3><p>在一个 <code>HashMap</code> 存储越来越多的数据之后，数据之间发声哈希碰撞的可能性也会越来越大，导致每个数组中的链表也会越来越长，而因为遍历链表操作的时间复杂度是 <code>O(n)</code>，所以链表越长，遍历的效率就越差。所以在 <code>Java 8</code> 中，当数组长度大于 <code>MIN_TREEIFY_CAPACITY</code>，且某个链表长度大于 <code>TREEIFY_THRESHOLD</code> 时，这个链表将会被转换成红黑树。</p><p>这里依旧借用参考文章 1<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[搞懂 Java HashMap 源码](https://juejin.im/post/5ac83fa35188255c5668afd0)">[1]</span></a></sup> 中的一幅图：</p><p><img data-src="https://sat02pap001files.storage.live.com/y4m0b6dqvceZY11lDlxjKGh4phasn-rDDxk_C8SR-2Xzl0mQ8vwrlc47YDHsaSJ9b9dvUvNldS7nJWfREWSLkpEM-aFKa8EfwhDPPvaOG9v9umRAG71Lk1cnnoU7SrhXKK81UzQJVt-VTBSGBRehwjf4f5t8UkntYpoXoG8ETlMDSPa8b79ULZDniM_nRZUgZUn?width=1386&amp;height=1346&amp;cropmode=none" alt="树化后"></p><h3 id="数据的存储单元"><a href="#数据的存储单元" class="headerlink" title="数据的存储单元"></a>数据的存储单元</h3><p><code>HashMap</code> 中定义了一个 <code>Node&lt;K,V&gt;</code> 型的数组 <code>table</code> 用于存储数据：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个就是哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></tbody></table></figure><p>分别针对树化前和树化后的数据，<code>HashMap</code> 定义了不同的内部类作为其数据的存储单元。</p><h4 id="树化前"><a href="#树化前" class="headerlink" title="树化前"></a>树化前</h4><p><code>HashMap</code> 中定义了一个内部类 <code>Node</code>，作为链表中各个元素的存储单元。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 这个节点的哈希，即数组的索引位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点所属的key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点的值</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表中的下一个元素</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) {</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>{ <span class="keyword">return</span> key; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>{ <span class="keyword">return</span> value; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>{ <span class="keyword">return</span> key + <span class="string">"="</span> + value; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的哈希值通过将key的哈希和value的哈希异或得到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换这个节点的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>{</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="树化后"><a href="#树化后" class="headerlink" title="树化后"></a>树化后</h4><p>针对树化后的红黑树，<code>HashMap</code> 定义了一个内部类 <code>TreeNode</code> 作为树中各个元素的存储单元。但是这个类的代码太长了，放在这里不太合适，后面我再单独开一篇博文专门给它。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>HashMap</code> 提供了四个构造方法，我们下面一个一个来看：</p><h3 id="可以指定容量和载荷因子的构造方法"><a href="#可以指定容量和载荷因子的构造方法" class="headerlink" title="可以指定容量和载荷因子的构造方法"></a>可以指定容量和载荷因子的构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{</span><br><span class="line">    <span class="comment">// 初始容量不能小于0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量不能大于最大允许容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 载荷因子必须大于等于0，且不能为无穷大(比如0.0f/0.0f)</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据期望容量返回一个大于等于cap的扩容阈值，并且保证扩容阈值一定是2的幂次</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然上面说<code>扩容阈值 = 哈希表容量 * 加载因子</code>，但是有没有发现，上面的构造方法里面其实并没有初始化 <code>table</code>？实际上，<code>table</code> 在第一次添加数据时才会被初始化，具体的操作我们放到后面再说。</p><h3 id="可以指定容量的构造方法"><a href="#可以指定容量的构造方法" class="headerlink" title="可以指定容量的构造方法"></a>可以指定容量的构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个构造方法就是把默认载荷因子和给定的初始容量传给上面说的那个构造方法，这里就不重复解释了。</p><h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用默认的载荷因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h2><p>我们知道，<code>HashMap</code> 既可以一次只新增一条数据，也可以一次新增多个数据。我们先看它是怎么新增单条数据的。</p><h3 id="新增单条数据"><a href="#新增单条数据" class="headerlink" title="新增单条数据"></a>新增单条数据</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>乍一看好像很简单的样子，一句话轻飘飘的完成了新增数据的任务。但是要展开看的话，信息量可就很大了。</p><p>我们从里面到外面一个一个的看。</p><h4 id="计算新元素的哈希值"><a href="#计算新元素的哈希值" class="headerlink" title="计算新元素的哈希值"></a>计算新元素的哈希值</h4><p>在上面提到的 <code>putVal</code> 方法中，第一个参数是这个数据的哈希值。那么这个哈希值是怎么计算出来的呢？在 <code>java 8</code> 中，<code>hash</code> 方法是这么实现的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 将key的hashCode与其无符号右移16位之后得到的值做一次异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面这段代码会对 key 的 hashCode 做一个扰动计算，来得到这个 key 在 <code>HashMap</code> 中的哈希值。这个扰动计算的目的就是为了降低发生哈希碰撞的可能性。</p><h4 id="向HashMap中增加数据"><a href="#向HashMap中增加数据" class="headerlink" title="向HashMap中增加数据"></a>向 HashMap 中增加数据</h4><p>在计算完 key 的哈希值后，<code>putVal</code> 方法会开始向 <code>HashMap</code> 中添加数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash就是key的哈希</span></span><br><span class="line"><span class="comment">// key就是key值</span></span><br><span class="line"><span class="comment">// value就是被添加的数据</span></span><br><span class="line"><span class="comment">// onlyIfAbsent如果是true则不替换数据</span></span><br><span class="line"><span class="comment">// evict如果是false，则说明是在初始化状态</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    <span class="comment">// 将指向哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在计算完本次要操作的哈希表下标后</span></span><br><span class="line">    <span class="comment">// p将指向哈希表的这个下标中的数据</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n将是哈希表的长度</span></span><br><span class="line">    <span class="comment">// 在计算完本次要操作的哈希表下标后，i将是这个下标值</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查哈希表是不是还没有被初始化过，或者哈希表长度为0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 对哈希表进行首次扩容，即初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 经过i = (n - 1) &amp; hash这步运算得到本次插入的位置，即哈希表的数组下标</span></span><br><span class="line">    <span class="comment">// 如果这个位置尚没有元素，说明没有发生哈希碰撞</span></span><br><span class="line">    <span class="comment">// 那么就直接将插入的数据放在这个位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果这个位置已经有元素存在了，那就说明发生了哈希碰撞</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希相同，且key值相同，则覆盖这个元素</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表的这个位置已经被变成红黑树了</span></span><br><span class="line">        <span class="comment">// 那么就要调用红黑树版本的putVal，即putTreeVal来完成插入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在哈希相同，key却不同的时候</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环整个单链表，同时使用binCount记录单链表的节点数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在单链表尾部拼接本次插入的数据</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果单链表的节点数量大于等于树化阈值时，就将这个单链表进行树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果在遍历过程中发现有数据的key与本次操作的key相同</span></span><br><span class="line">                <span class="comment">// 此时e指向要被替换value的节点，并结束遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果e != null，说明需要替换e所指节点的数据</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 这个方法在HashMap中是空实现</span></span><br><span class="line">            <span class="comment">// 但是LinkedHashMap中会有实现</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fail-fast机制</span></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果哈希表长度大于扩容阈值，则对哈希表扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 这个方法在HashMap中也是空的</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码可能看起来比较费劲，这里借用美团博客的一张图来展示 <code>put</code> 方法的执行流程：</p><p><img data-src="https://sat02pap001files.storage.live.com/y4mABPhdJqvs1fBTj2_huihzGVxiWIisocz1LFtnQ_baYEdAX-xUtjcOEspyFBT1jmW8LbZJhhPLGbWi_RrmjSWNs6poBFzpaFkXR09JLoFKQfKs247dJKoDUZBFJVkRpqcs9UUTA1nvCcfMyZyDU3geJZ-LmRSjWs25JasnP31pnmQCkAFEjkH-skMLkuL2B6Z?width=1716&amp;height=1360&amp;cropmode=none" alt="put方法执行流程"></p><h3 id="新增多条数据"><a href="#新增多条数据" class="headerlink" title="新增多条数据"></a>新增多条数据</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>{</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>依旧是调用了另一个方法实现的添加数据。那么继续深入进去看看。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    <span class="comment">// 传入的map的长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的map有数据，才进行后面的运算</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果哈希表尚未初始化，则先计算扩容阈值</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) { <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表已经初始化完成，但是传入的map的大小超过了扩容阈值</span></span><br><span class="line">        <span class="comment">// 那么就将哈希表扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历传入的map，然后逐个调用putVal方法增加元素</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap 扩容</h2><p>上面多次提到了 <code>HashMap</code> 的扩容操作，这里我们就详细看看它是怎么扩容的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    <span class="comment">// oldTab指向扩容前的哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// oldCap是扩容前的哈希表容量，如果哈希表尚未被初始化，那么容量就是0</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// oldThr是扩容前的扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// newCap为扩容后的容量，newThr是扩容后的扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果扩容前的哈希表容量已经是最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">            <span class="comment">// 那么就将扩容阈值设为Integer.MAX_VALUE</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 并停止扩容</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 新容量是旧容量的2倍，且新的扩容阈值也是旧扩容阈值的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果旧的扩容阈值大于0</span></span><br><span class="line">    <span class="comment">// 而同时旧的容量等于0</span></span><br><span class="line">    <span class="comment">// 那么说明已经使用带参数的构造方法设定了载荷因子和初始容量</span></span><br><span class="line">    <span class="comment">// 而且这次是首次扩容</span></span><br><span class="line">    <span class="comment">// 此时初始容量不等于期望容量，且大于期望容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 设定新的容量等于旧的扩容阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果旧的扩容阈值是0</span></span><br><span class="line">    <span class="comment">// 而同时旧的容量等于0</span></span><br><span class="line">    <span class="comment">// 那么说明这个HashMap是用默认构造方法初始化的</span></span><br><span class="line">    <span class="comment">// 而且这次是首次扩容</span></span><br><span class="line">    <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 那么新的容量就等于默认初始容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 新的扩容阈值等于(默认载荷因子 * 默认初始容量)</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的扩容阈值是0</span></span><br><span class="line">    <span class="comment">// 对应当前table为空，但是有阈值的情况</span></span><br><span class="line">    <span class="comment">// 那么就计算新的扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新HashMap的扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用扩容后的容量创建一个新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings({"rawtypes","unchecked"})</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将HashMap的哈希表指向新的哈希表</span></span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果旧的哈希表不为null</span></span><br><span class="line">    <span class="comment">// 则进行重新插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历旧的哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            <span class="comment">// 存储旧的哈希表对应位置中链表的头节点</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果这个位置有数据</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 释放掉旧的链表中的空间</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果这个链表中只有一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 则使用新哈希表的长度计算下标，并插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果这个节点是个红黑树</span></span><br><span class="line">                <span class="comment">// 那么需要选择是拆分这个红黑树，或者将其非树化</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 如果这个链表有数个节点</span></span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 因为扩容后的容量是扩容前容量的2倍</span></span><br><span class="line">                    <span class="comment">// 所以原链表上的节点，既有可能会被放在它原来的位置上(低位)</span></span><br><span class="line">                    <span class="comment">// 也有可能会被放到扩容后新增加的位置上(高位 = 低位 + 旧的容量)</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 低位链表的头节点和尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 高位链表的头节点和尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 存放原来链表中的节点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 遍历旧的链表</span></span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 利用哈希值和旧的容量进行与运算</span></span><br><span class="line">                        <span class="comment">// 如果结果等于0，那么就拼接到低位链表的末尾</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 否则拼接到高位链表的末尾</span></span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果低位链表非空，则将链表放到原位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 如果高位链表非空，则将链表放到新增加的位置</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 检查哈希表是不是空</span></span><br><span class="line">    <span class="comment">// 以及哈希表中对应下标的第一个元素是不是null，即这个位置是否有节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 因为第一个节点无所谓是链表节点还是红黑树节点</span></span><br><span class="line">        <span class="comment">// 所以先用一个简单的办法检查第一个节点是不是要找的节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 如果是，就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果第一个节点不是要找的节点</span></span><br><span class="line">        <span class="comment">// 而且它后面有别的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 如果后面的节点是红黑树，那么调用红黑树的方法取寻找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则遍历这个链表，寻找符合要求的节点并返回</span></span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配key来删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时匹配key和value来删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 检查哈希表是不是空</span></span><br><span class="line">    <span class="comment">// 以及哈希表中对应下标的第一个元素是不是null，即这个位置是否有节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 先检查链表中第一个元素是否匹配</span></span><br><span class="line">        <span class="comment">// 如果匹配就直接取出来</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 否则继续向后遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果后续的节点是红黑树，那么使用红黑树的方法寻找匹配的节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 否则遍历链表，根据hash和key寻找节点</span></span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) {</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    p = e;</span><br><span class="line">                } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果取到了节点，则开始删除</span></span><br><span class="line">        <span class="comment">// (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))构成了一个判断链条</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) {</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="迭代HashMap"><a href="#迭代HashMap" class="headerlink" title="迭代HashMap"></a>迭代 HashMap</h2><p><code>HashMap</code> 提供了多种迭代的方式，比如迭代 <code>EntrySet</code>，或者迭代 <code>KeySet</code>。</p><h3 id="迭代KeySet"><a href="#迭代KeySet" class="headerlink" title="迭代KeySet"></a>迭代 KeySet</h3><p>在迭代 <code>KeySet</code> 的时候，我们可以逐个得到 <code>HashMap</code> 中的 key，然后根据 key 来进行操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个KeySet实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>{</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) {</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 得到KeySet的长度，也是HashMap的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>{ <span class="keyword">return</span> size; }</span><br><span class="line">    <span class="comment">// 可以清空这个HashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>{ HashMap.<span class="keyword">this</span>.clear(); }</span><br><span class="line">    <span class="comment">// 得到一个KeyIterator迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>{ <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); }</span><br><span class="line">    <span class="comment">// 检查是否包含某个key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{ <span class="keyword">return</span> containsKey(o); }</span><br><span class="line">    <span class="comment">// 根据key删除某个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>{</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) {</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 得到下一个节点的key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextNode().key; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="迭代EntrySet"><a href="#迭代EntrySet" class="headerlink" title="迭代EntrySet"></a>迭代 EntrySet</h3><p>在迭代 <code>EntrySet</code> 的时候，我们可以同时得到一个节点的 key 和 value。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个EntrySet实例</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>{</span><br><span class="line">    <span class="comment">// 得到EntrySet的大小，即HashMap的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>{ <span class="keyword">return</span> size; }</span><br><span class="line">    <span class="comment">// 可以清空这个HashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>{ HashMap.<span class="keyword">this</span>.clear(); }</span><br><span class="line">    <span class="comment">// 得到一个EntryIterator迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查EntrySet中是否包含某个Entry</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据传入的Entry在HashMap中匹配并删除对应的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>{</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) {</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>{</span><br><span class="line">    <span class="comment">// 得到下一个节点的Entry</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextNode(); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h3><p>为什么上面看到 <code>KeyIterator</code> 和 <code>EntryIterator</code> 就停止了呢？因为它们两个都是继承于 <code>HashIterator</code>，这里我们集中看一下。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// 下一个要返回的Entry</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// 当前的Entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// 结合modCount实现fast-fail机制</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// 当前哈希表的下标</span></span><br><span class="line"></span><br><span class="line">    HashIterator() {</span><br><span class="line">        <span class="comment">// 取迭代时的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="comment">// 指向当前的哈希表</span></span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从哈希表中第一个不为空的位置获取第一个Entry</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) { <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> {} <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否还有节点可供迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>{</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 如果当前链表被遍历完了，那么就寻找下一个不是null的链表头</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">do</span> {} <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除当前被迭代的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 同步新的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面迭代时的算法可以看到，迭代器总是先遍历当前的链表或者红黑树，然后再去遍历哈希表，也就是说，它采用的是深度优先的算法。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWM4M2ZhMzUxODgyNTVjNTY2OGFmZDA="> 搞懂 Java HashMap 源码<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTYvMDYvMjQvamF2YS1oYXNobWFwLmh0bWw=">Java 8 系列之重新认识 HashMap<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cuenlidWx1by5jb20va2lyYVNhbGx5L25vdGUvODE5ODQz"> 集合番 @HashMap 一文通（1.7 版）<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjkyNjcyMg==">HashMap 源码详细分析 (JDK1.8)<i class="fa fa-external-link-alt"></i></span><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyNDA4NzcvYXJ0aWNsZS9kZXRhaWxzLzUzMzUxMTg4">Java 集合深入理解（16）：HashMap 主要特点和关键方法源码解读<i class="fa fa-external-link-alt"></i></span><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashmap.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 源码阅读 - equals 和 hashCode 方法</title>
      <link>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashcode-and-equals.html</link>
      <guid>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashcode-and-equals.html</guid>
      <pubDate>Mon, 06 Jan 2020 05:50:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。&lt;/p&gt;
&lt;p&gt;这次就来阅读一下 &lt;code&gt;Object&lt;/code&gt; 类里面 &lt;code&gt;hashCode&lt;/code&gt; 方法和 &lt;code&gt;equals&lt;/code&gt; 方法的源码。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p><p>这次就来阅读一下 <code>Object</code> 类里面 <code>hashCode</code> 方法和 <code>equals</code> 方法的源码。</p><span id="more"></span><h2 id="先看看代码"><a href="#先看看代码" class="headerlink" title="先看看代码"></a>先看看代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看出，<code>hashCode</code> 方法是一个 native 方法，<code>equals</code> 方法比较了两个对象是否指向同一个内存的地址。</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><h3 id="什么是hash"><a href="#什么是hash" class="headerlink" title="什么是hash"></a>什么是 hash</h3><p>要搞清楚 <code>hashCode</code> 干了什么，那就得要知道 <code>hash</code> 是什么。</p><blockquote><p>散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字 “指纹” 的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p></blockquote><h3 id="Java中的hashCode方法"><a href="#Java中的hashCode方法" class="headerlink" title="Java中的hashCode方法"></a>Java 中的 hashCode 方法</h3><p>在 <code>Object</code> 类中的 <code>hashCode</code> 方法是一个 native 方法，我们没办法直接得知它的实现方式，但是我们依旧可以从它的 JavaDoc 中得知一些信息。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">     * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> java.util.HashMap}.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of {<span class="doctag">@code</span> hashCode} is:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">     * class {<span class="doctag">@code</span> Object} does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">     * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">     * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">     * technique is not required by the</span></span><br><span class="line"><span class="comment">     * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>上面花了很大的篇幅讲了如果要重新实现 <code>hashCode</code> 方法所需要遵循的原则，但是很可惜，我们现在暂时不关注这些。我们现在关注的，是最后一段的内容。</p><p>在最后一段中，它讲了通常情况下，程序是怎样计算出 <code>hashCode</code> 的值的。</p><blockquote><p>This is typically implemented by converting the internal address of the object into an integer<br>通常来说，这是通过把内部的地址转换成一个整型数来实现的</p></blockquote><p>当然，并不是所有的类都使用了这个计算方法，比如 <code>String</code> 就重新实现了自己的 <code>hashCode</code> 方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) {</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        }</span><br><span class="line">        hash = h;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p><code>equals</code> 方法的作用是比较两个对象的内容是否相同。一般来说，<code>Object</code> 类中提供的 <code>equals</code> 方法是没办法满足各个类型自己的需要的，所以它们基本上都实现了自己的 <code>equals</code> 方法。</p><p>用一个简单的例子来讲：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;</span><br><span class="line">String str2 = <span class="string">"aaa"</span>;</span><br><span class="line">str1.equals(str2); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>显然，<code>str1</code> 和 <code>str2</code> 是两个不同的对象，如果直接比较它们的内存地址，那么得到的结果肯定是 false。所以可以肯定的是，<code>String</code> 类重写了 <code>equals</code> 方法。那么，我们就简单看一下 <code>String</code> 是怎样实现 <code>equals</code> 方法的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>{</span><br><span class="line">    <span class="comment">// 先检查两个对象的地址是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被比较的对象地址不同，但它类型相同</span></span><br><span class="line">    <span class="comment">// 那么继续进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) {</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果被比较的字符串与本字符串长度相同</span></span><br><span class="line">        <span class="comment">// 那么继续比较其中char数组中的每个元素是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) {</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>既然每个类型都可以实现自己的 <code>equals</code> 方法，那么必然有一个规则来约束它们的实现方式，以保证在何时何地 <code>equals</code> 都可以得到合理的结果。</p><p>在 <code>equals</code> 方法的 JavaDoc 中描述了重写该方法所需要遵守的规则：</p><blockquote><p>It is <i>reflexive</i>: for any non-null reference value <code>x</code>, <code>x.equals(x)</code> should return <code>true</code>.<br>It is <i>symmetric</i>: for any non-null reference values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code>.<br>It is <i>transitive</i>: for any non-null reference values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.<br>It is <i>consistent</i>: for any non-null reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in <code>equals</code> comparisons on the objects is modified.<br>For any non-null reference value <code>x</code>, <code>x.equals(null)</code> should return <code>false</code>.</p></blockquote><p>翻译过来就是：</p><blockquote><p>自反性：对于一个非 null 的引用值，<code>x.equals(x)</code> 应当返回 <code>true</code>。<br>对称性：对于两个非 null 的引用值 <code>x</code> 和 <code>y</code>，当且仅当 <code>y.equals(x)</code> 时，<code>x.equals(y)</code> 返回 <code>true</code>。<br>传递性：对于任意非 null 的引用值 <code>x</code>，<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，而且 <code>y.equals(z)</code> 返回 <code>true</code>，那么 <code>x.equals(z)</code> 也应返回 <code>true</code>。<br>一致性：对于任意非 null 的引用值 <code>x</code> 和 <code>y</code>，当两者都未被修改时，多次调用 <code>x.equals(y)</code> 都应一直返回 <code>true</code> 或者 <code>false</code>。<br>对于任意非 null 的引用值 <code>x</code>，<code>x.equals(null)</code> 应返回 <code>false</code>。</p></blockquote><h2 id="hashCode方法与equals方法的关系"><a href="#hashCode方法与equals方法的关系" class="headerlink" title="hashCode方法与equals方法的关系"></a>hashCode 方法与 equals 方法的关系</h2><p>在 <code>equals</code> 方法的 JavaDoc 上有这么一段话：</p><blockquote><p>Note that it is generally necessary to override the <code>hashCode</code> method whenever this method is overridden, so as to maintain the general contract for the <code>hashCode</code> method, which states that equal objects must have equal hash codes.<br>在重写 <code>equals</code> 方法时，通常也需要一并重写 <code>hashCode</code> 方法，以便维护 <code>hashCode</code> 方法的约定，即相等的对象必须拥有相同的哈希码</p></blockquote><p>而在 <code>hashCode</code> 方法的 JavaDoc 中，它有着这样的实现约定：</p><blockquote><p>Whenever it is invoked on the same object more than once during an execution of a Java application, the <code>hashCode</code> method must consistently return the same integer, provided no information used in <code>equals</code> comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</p><p>If two objects are equal according to the <code>equals(Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce the same integer result.</p><p>It is <em>not</em> required that if two objects are unequal according to the <code>java.lang.Object#equals(java.lang.Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce distinct integer results.  However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.</p></blockquote><p>即：</p><blockquote><p>在程序运行过程中，不论 <code>hashCode</code> 方法被调用了多少次，其返回结果都必须是一个恒定的整型值，以表明在使用 <code>equals</code> 比较对象时所需的信息没有被修改过。但是在程序每次运行之间，<code>hashCode</code> 返回的值则不需要保持一致</p><p>如果两个对象使用 <code>equals</code> 方法比较得出了相同 (equal) 的结论，那么对这两个对象执行 <code>hashCode</code> 方法得到的值也必须相同</p><p>在两个对象使用 <code>equals</code> 方法比较得出了不相同 (not equal) 的结论时，对这两个对象执行 <code>hashCode</code> 方法得到的值却可以相同。然而，开发人员需要意识到，给不同的对象返回不同的哈希码可以提升 hash table 的性能</p></blockquote><p>综上所述，我们可以得出如下结论：</p><ul><li>两个相同 (equal) 的对象必须拥有相同的哈希码</li><li>两个哈希码相同的对象却不一定相同 (equal)</li></ul><p>那么，这两条结论会对我们的程序造成什么影响呢？</p><p>首先我们看一下第一条。以 <code>Set</code> 举例，<code>Set</code> 会根据对象的 <code>hashCode</code> 来寻找对象的存储位置，那么可想而知，如果两个对象的值相同，哈希码却不同，那么就会导致 <code>Set</code> 中出现多个重复数据的情况。</p><p>而第二条结论出现的原因则是，目前没有任何一种哈希算法，可以保证对每个传入的值都可以计算出一个不同的哈希，这种情况的学名叫<code>哈希碰撞</code>，所以我们只能尽可能的减少出现哈希碰撞的可能性。至于 Java 如何应对哈希碰撞，我将在后续的博文中进行解释。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashcode-and-equals.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>手动编写代码调用 JSR-303 Bean Validation</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/programatically-call-jsr-303.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/programatically-call-jsr-303.html</guid>
      <pubDate>Mon, 06 Jan 2020 02:26:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近做了一个有点不一样的项目，它是将传入接口的业务参数以 JSON 的形式放在了一个统一的请求体里面，我要将它取出来，再反序列化到一个 Bean 里面。这样会带来一个问题，就是我不能直接使用 &lt;code&gt;@Valid&lt;/code&gt; 注解来让框架自行校验参数的合法性，而需要手动调用 &lt;code&gt;Validator&lt;/code&gt; 实现对 bean 的校验。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近做了一个有点不一样的项目，它是将传入接口的业务参数以 JSON 的形式放在了一个统一的请求体里面，我要将它取出来，再反序列化到一个 Bean 里面。这样会带来一个问题，就是我不能直接使用 <code>@Valid</code> 注解来让框架自行校验参数的合法性，而需要手动调用 <code>Validator</code> 实现对 bean 的校验。</p><span id="more"></span><p>在这里我就不去还原从请求体取出业务数据并反序列化这个过程了，因为这个操作对于我们实际要实现的功能没有关系。我将在这里新建一个简单的类，设定好适当的校验规则，然后通过一个简单的示例来演示。</p><h2 id="示例bean"><a href="#示例bean" class="headerlink" title="示例bean"></a>示例 bean</h2><p>示例的 bean 就是一个喜闻乐见的学生信息，使用 <code>javax.validation.constraints</code> 包中的注解来设定校验规则。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line">    <span class="comment">// 姓名是必填项</span></span><br><span class="line">    <span class="meta">@NotNull(message = "Student name is mandatory")</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别是必填项，仅接受male和female，首字母可以大写也可以小写</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = "(M|male)|(F|female)", message = "Only male or female are accepted")</span></span><br><span class="line">    <span class="meta">@NotNull(message = "Student gender is mandatory")</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成绩不是必填项</span></span><br><span class="line">    <span class="comment">// 成绩必须大于等于0，且小于等于100</span></span><br><span class="line">    <span class="comment">// 因为Max的值是开区间，所以得写101</span></span><br><span class="line">    <span class="meta">@Max(value = 101, message = "Maximum value of score is 100")</span></span><br><span class="line">    <span class="meta">@PositiveOrZero(message = "Score cannot be negative")</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编写实现"><a href="#编写实现" class="headerlink" title="编写实现"></a>编写实现</h2><p>实现的中心思想就是手动获得一个 <code>Validator</code> 实例，然后调用它来对传入的 bean 进行校验。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/student")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showStudent</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> </span>{</span><br><span class="line">        <span class="comment">// 取得一个Validator实例</span></span><br><span class="line">        Validator validator = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"Validating bean with validator {}"</span>, validator.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Validator#validate方法对这个bean进行校验</span></span><br><span class="line">        <span class="comment">// 所有的</span></span><br><span class="line">        <span class="comment">// ConstraintViolation的泛型类型要设定为被校验bean的类型</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Student&gt;&gt; errors = validator.validate(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里遍历errors这个set，打印出各个错误的信息</span></span><br><span class="line">        errors.forEach(error -&gt; {</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">            <span class="comment">// 对应校验规则里面的message属性</span></span><br><span class="line">            log.error(<span class="string">"Error message: {}"</span>, error.getMessage());</span><br><span class="line">            <span class="comment">// 校验失败的属性名</span></span><br><span class="line">            log.error(<span class="string">"Property path: {}"</span>, error.getPropertyPath());</span><br><span class="line">            <span class="comment">// 导致校验失败的值</span></span><br><span class="line">            log.error(<span class="string">"Error value: {}"</span>, error.getInvalidValue());</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 可以取出所有的校验失败信息，拼接起来之后返回给调用方</span></span><br><span class="line">            <span class="keyword">final</span> String errMessages = errors.stream()</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里为了省事直接抛出了RuntimeException</span></span><br><span class="line">            <span class="comment">// 实际使用时建议新建一个自定义业务异常代表这种情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(errMessages);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> student.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>我使用一个这样子的数据来测试上面的校验功能：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Boris"</span>,</span><br><span class="line">  <span class="attr">"score"</span>: <span class="number">180</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见，这个数据是无法通过校验的，它没有填写性别，而且分数超过了上限。请求发出去之后，我得到了这样的错误信息：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"timestamp"</span>: <span class="string">"2020-01-06T03:03:18.125+0000"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"Internal Server Error"</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Maximum value of score is 100, Student gender is mandatory"</span>,</span><br><span class="line">  <span class="attr">"path"</span>: <span class="string">"/student"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同时，控制台里出现了这样的日志：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-01-06 11:21:25.971  INFO 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Validating bean with validator org.hibernate.validator.internal.engine.ValidatorImpl</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Student gender is mandatory</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: gender</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: null</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Maximum value of score is 100</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: score</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: 180</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.252 ERROR 68021 --- [nio-9999-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100</span><br><span class="line">    at com.example.demo.StudentController.showStudent(StudentController.java:42) ~[classes/:na]</span><br><span class="line">    堆栈信息太多，下面的略掉了</span><br></pre></td></tr></tbody></table></figure><p>看来，校验的代码成功起作用了。</p><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>因为我们现在基本上都是面向 Spring 编程，所以其实上面那些手动获取 <code>Validator</code> 的代码也是不必要的。我们可以让 Spring 自动注入一个 <code>Validator</code> 来实现功能。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>{</span><br><span class="line">    <span class="comment">// 直接注入一个Validator的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/student")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showStudent</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> </span>{</span><br><span class="line">        <span class="comment">// 我们来看看它到底注入了谁</span></span><br><span class="line">        log.info(<span class="string">"Validating bean with validator {}"</span>, validator.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Validator#validate方法对这个bean进行校验</span></span><br><span class="line">        <span class="comment">// 所有的</span></span><br><span class="line">        <span class="comment">// ConstraintViolation的泛型类型要设定为被校验bean的类型</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Student&gt;&gt; errors = validator.validate(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里遍历errors这个set，打印出各个错误的信息</span></span><br><span class="line">        errors.forEach(error -&gt; {</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">            <span class="comment">// 对应校验规则里面的message属性</span></span><br><span class="line">            log.error(<span class="string">"Error message: {}"</span>, error.getMessage());</span><br><span class="line">            <span class="comment">// 校验失败的属性名</span></span><br><span class="line">            log.error(<span class="string">"Property path: {}"</span>, error.getPropertyPath());</span><br><span class="line">            <span class="comment">// 导致校验失败的值</span></span><br><span class="line">            log.error(<span class="string">"Error value: {}"</span>, error.getInvalidValue());</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 可以取出所有的校验失败信息，拼接起来之后返回给调用方</span></span><br><span class="line">            <span class="keyword">final</span> String errMessages = errors.stream()</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里为了省事直接抛出了RuntimeException</span></span><br><span class="line">            <span class="comment">// 实际使用时建议新建一个自定义业务异常代表这种情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(errMessages);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> student.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重新启动应用，并用相同的数据测试之后，我们得到了这样的日志：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-01-06 11:15:17.957  INFO 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Validating bean with validator org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</span><br><span class="line">2020-01-06 11:15:18.071 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Student gender is mandatory</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: gender</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: null</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Maximum value of score is 100</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: score</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: 180</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.089 ERROR 67745 --- [nio-9999-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100</span><br><span class="line">    at com.example.demo.StudentController.showStudent(StudentController.java:42) ~[classes/:na]</span><br><span class="line">    下面的堆栈信息依旧略掉</span><br></pre></td></tr></tbody></table></figure><p>看来这种方式使用了另一个 <code>Validator</code> 实现，但是没关系，我们依旧能得到正确的结果，并可以使用完全一样的方法来处理错误信息。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmV5b25kamF2YS5uZXQvaG93LXRvLWludm9rZS1qc3ItMzAzLWJlYW4tdmFsaWRhdGlvbi1wcm9ncmFtbWF0aWNhbGx5">How to Invoke JSR 303 Bean Validation Programmatically<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4NzA0MDI1LzM4MzM4NTg=">How to manually trigger spring validation? - StackOverflow<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/programatically-call-jsr-303.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>让 nohup 不输出 appending output to &#39;nohup.out&#39;</title>
      <link>https://www.boris1993.com/linux/suppress-appending-to-nohup-out-message.html</link>
      <guid>https://www.boris1993.com/linux/suppress-appending-to-nohup-out-message.html</guid>
      <pubDate>Fri, 27 Dec 2019 07:22:52 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;在使用 &lt;code&gt;nohup&lt;/code&gt; 的时候，它总会打印一条 &lt;co
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在使用 <code>nohup</code> 的时候，它总会打印一条 <code>nohup: appending output to 'nohup.out'</code> 这样的信息，并且必须敲一下回车。</p><p>因为 <code>nohup: appending output to 'nohup.out'</code> 这条信息是打印到 <code>STDERR</code> 的，所以解决的方法很简单，把 <code>STDERR</code> 重定向至 <code>STDOUT</code> 就可以了，比如这样：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup doSomething &gt; nohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></tbody></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/linux/suppress-appending-to-nohup-out-message.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
