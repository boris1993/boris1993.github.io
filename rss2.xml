<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Code Life</title>
    <link>https://www.boris1993.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>码农pilot的个人博客</description>
    <pubDate>Tue, 17 Dec 2019 06:48:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>去掉自定义异常中的堆栈跟踪信息</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/java-remove-stack-trace-in-customized-exceptions.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/java-remove-stack-trace-in-customized-exceptions.html</guid>
      <pubDate>Tue, 17 Dec 2019 06:00:55 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务异常基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBizException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseBizException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖fillInStackTrace()方法，抹掉异常中的堆栈跟踪信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/java-remove-stack-trace-in-customized-exceptions.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL Workbench中各个列属性的含义</title>
      <link>https://www.boris1993.com/database/mysql/column-flags-in-mysql-workbench.html</link>
      <guid>https://www.boris1993.com/database/mysql/column-flags-in-mysql-workbench.html</guid>
      <pubDate>Sat, 14 Dec 2019 03:22:29 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;&lt;code&gt;PK&lt;/code&gt;: 主键(Primary Key)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NN&lt;/code&gt;: 非空(Not Null)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UQ&lt;/code&gt;: 唯一索引(Unique Index)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIN&lt;/code&gt;: 二进制(Binary) 将数据储存为二进制字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UN&lt;/code&gt;: 无符号的(Unsigned)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZF&lt;/code&gt;: 零填充的(Zero Fill) 如：INT(5)的列中，&lt;code&gt;12&lt;/code&gt;会被填充为&lt;code&gt;00012&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AI&lt;/code&gt;: 自增长的(Auto Increment)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt;: 生成出来的(Generated) 如：根据公式从其它列中生成的数据&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><code>PK</code>: 主键(Primary Key)</li><li><code>NN</code>: 非空(Not Null)</li><li><code>UQ</code>: 唯一索引(Unique Index)</li><li><code>BIN</code>: 二进制(Binary) 将数据储存为二进制字符串</li><li><code>UN</code>: 无符号的(Unsigned)</li><li><code>ZF</code>: 零填充的(Zero Fill) 如：INT(5)的列中，<code>12</code>会被填充为<code>00012</code></li><li><code>AI</code>: 自增长的(Auto Increment)</li><li><code>G</code>: 生成出来的(Generated) 如：根据公式从其它列中生成的数据</li></ul><a id="more"></a><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM2NjM5NzEvMzgzMzg1OA==" title="https://stackoverflow.com/a/3663971/3833858">What do column flags mean in MySQL Workbench?<i class="fa fa-external-link"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy93b3JrYmVuY2gvZW4vd2ItdGFibGUtZWRpdG9yLWNvbHVtbnMtdGFiLmh0bWw=" title="https://dev.mysql.com/doc/workbench/en/wb-table-editor-columns-tab.html">Columns Tab - MySQL Workbench Manual<i class="fa fa-external-link"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/database/mysql/column-flags-in-mysql-workbench.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>浅谈MySQL中的校对规则(collation)</title>
      <link>https://www.boris1993.com/database/mysql/brief-talk-about-mysql-collations.html</link>
      <guid>https://www.boris1993.com/database/mysql/brief-talk-about-mysql-collations.html</guid>
      <pubDate>Sat, 14 Dec 2019 02:07:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;在我们开发过程中，最常见到的三种校对规则(collation)就是&lt;code&gt;utf8mb4_general_ci&lt;/code&gt;、&lt;code&gt;utf8mb4_unicode_ci&lt;/code&gt;，和&lt;code&gt;utf8mb4_bin&lt;/code&gt;。那么这三种排序规则之间有什么区别，在开发过程中又该怎么选择？这里就简单说一下我所了解到的知识，和我的理解。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在我们开发过程中，最常见到的三种校对规则(collation)就是<code>utf8mb4_general_ci</code>、<code>utf8mb4_unicode_ci</code>，和<code>utf8mb4_bin</code>。那么这三种排序规则之间有什么区别，在开发过程中又该怎么选择？这里就简单说一下我所了解到的知识，和我的理解。</p><a id="more"></a><h2 id="校对规则不会导致乱码"><a href="#校对规则不会导致乱码" class="headerlink" title="校对规则不会导致乱码"></a>校对规则不会导致乱码</h2><p>之前听到一名同事说，“这个东西(collation)你再研究下，搞不好中文会乱码的”。显然这位同事没搞清楚字符编码(encoding)和校对规则(collation)的区别。</p><p>字符集是一套符号和编码，它实实在在决定了每个字符应当以怎样的规则被编码为二进制数据，以及在取出一系列二进制数据之后，又应当以怎样的规则还原为字符。比如我们喜闻乐见的“锟斤拷”就是因为GBK编码与Unicode编码之间转换出现问题导致的乱码。</p><p>而校对规则本身并不会参与字符的编码，所以它当然不会产生文字乱码的问题。当然，使用了不合适的校对规则，也会对数据产生一定的影响，具体有什么影响后面我们慢慢说。</p><h2 id="校对规则是什么"><a href="#校对规则是什么" class="headerlink" title="校对规则是什么"></a>校对规则是什么</h2><p>校对规则是一套规范，它指明了数据在数据库中应当以哪种方式被比较和排序，包括排序的规则、是否大小写敏感，以及是否对重音标记敏感。</p><p>在<code>MySQL</code>中，校对规则通常按照<code>字符集_语言或地区_字符敏感特性</code>的规则来命名。</p><h2 id="这三种校对规则有什么区别"><a href="#这三种校对规则有什么区别" class="headerlink" title="这三种校对规则有什么区别"></a>这三种校对规则有什么区别</h2><p>首先，根据它们的后缀<code>_ci</code>可以知道，这三种校对规则都是对大小写不敏感(Case Insensitive)的。</p><p><code>utf8mb4_general_ci</code>是对大小写和重音字符都不敏感的。比如，拉丁字符<code>ÀÁÅåāă</code>是等同于字符<code>a</code>的。</p><p><code>utf8mb4_unicode_ci</code>是大小写不敏感，但是对重音字符敏感的。即，拉丁字符<code>Å</code>和<code>å</code>是等同的，但是和<code>a</code>是不同的。</p><p><code>utf8mb4_bin</code>则是直接比较每个字符的Unicode码点(code point)。</p><p>从效率上来讲，<code>utf8mb4_bin</code> &gt; <code>utf8mb4_general_ci</code> &gt; <code>utf8mb4_unicode_ci</code>。</p><h2 id="校对规则会产生什么影响"><a href="#校对规则会产生什么影响" class="headerlink" title="校对规则会产生什么影响"></a>校对规则会产生什么影响</h2><p>不同的排序规则，不仅对大小写和重音字符的处理不同，对于一些语言中特有的字符的处理也是不同的。</p><p>比如一个斯洛伐克人，他向数据库中插入了两条数据，其主键分别是<code>poistný</code>和<code>poistny</code>。但是因为他用了重音不敏感的<code>utf8mb4_general_ci</code>，导致数据库判定这两个字符串是一样的，而抛出了重复主键的错误。<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[斯洛伐克人的例子](https://stackoverflow.com/a/35482707/3833858)">[3]</span></a></sup></p><p>另一个例子是，对于德语中的<code>ß</code>，如果使用<code>utf8mb4_general_ci</code>，那么它等同于<code>s</code>，而如果使用<code>utf8mb4_unicode_ci</code>，它则等同于<code>ss</code>。</p><p>所以，如果数据涉及的语言中包含有特殊的字符或者重音符号，而其比对结果的正确性又很重要时，那么就应当选择<code>unicode_ci</code>系列的校对规则，否则，<code>general_ci</code>就够用了。当然，在必要的情况下，也可以选择这个语言对应的规则，比如<code>utf8_swedish_ci</code>。</p><p>对于中文来说，我在网上并没有找到相关的文章，同时根据自己的开发经验，<code>general_ci</code>和<code>unicode_ci</code>对于中文都没有什么明显的问题，所以两个都可以用。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bXMubXlzcWwuY29tL3JlYWQucGhwPzEwMywxODcwNDgsMTg4NzQ4" title="https://forums.mysql.com/read.php?103,187048,188748">Re: utf8_unicode_ci vs utf8_general_ci - MySQL Forums<i class="fa fa-external-link"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cDovL2NvbGxhdGlvbi1jaGFydHMub3JnL215c3FsNjAv" title="http://collation-charts.org/mysql60/">MySQL collation charts<i class="fa fa-external-link"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM1NDgyNzA3LzM4MzM4NTg=" title="https://stackoverflow.com/a/35482707/3833858">斯洛伐克人的例子<i class="fa fa-external-link"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/database/mysql/brief-talk-about-mysql-collations.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>IDEA警告Field injection is not recommended</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/idea-warninig-field-injection-is-not-recommended.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/idea-warninig-field-injection-is-not-recommended.html</guid>
      <pubDate>Fri, 29 Nov 2019 05:45:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;前些天在开发过程中，发现IDEA在一个&lt;code&gt;@Autowired&lt;/code&gt;注解上打了一个警告，内容是&lt;code&gt;Field injection is not recommended&lt;/code&gt;。多年面向Spring开发的经验告诉我，使用&lt;code&gt;@Autowired&lt;/code&gt;注解进行依赖注入，肯定是没有问题的。但是我的代码洁癖不允许我这么不明不白的留一个警告在这里。所以，带着我的洁癖，和我的好奇心，我开始研究起了这个警告。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前些天在开发过程中，发现IDEA在一个<code>@Autowired</code>注解上打了一个警告，内容是<code>Field injection is not recommended</code>。多年面向Spring开发的经验告诉我，使用<code>@Autowired</code>注解进行依赖注入，肯定是没有问题的。但是我的代码洁癖不允许我这么不明不白的留一个警告在这里。所以，带着我的洁癖，和我的好奇心，我开始研究起了这个警告。</p><a id="more"></a><h2 id="警告信息"><a href="#警告信息" class="headerlink" title="警告信息"></a>警告信息</h2><p>这个警告，和警告的处理建议，在IDEA中是这么写的：</p><p><img src="/images/idea-warninig-field-injection-is-not-recommended/warning-message.png" alt="Warning Message"></p><p>翻译过来是这个意思：</p><blockquote><p>不建议直接在字段上进行依赖注入。<br>Spring开发团队建议：在Java Bean中永远使用构造方法进行依赖注入。对于必须的依赖，永远使用断言来确认。</p></blockquote><h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>既然IDE给了警告，那就先着手修改。一开始，代码是这样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DependencyClass aDependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据提示，我将代码修改成了这样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DependencyClass aDependency;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AClass</span><span class="params">(DependencyClass aDependency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aDependency = aDependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后警告就消失了，同时运行没有问题，说明这个修改是可行的。</p><p>另外，如果你的项目中引入了<code>Lombok</code>，那么代码甚至可以精简成这样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该注解指示Lombok为所有没被初始化过的final的变量创建构造方法</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DependencyClass aDependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，光是改好代码还远远不够，我需要知道，为什么Spring团队会提出这一项要求，以及，直接使用<code>@Autowired</code>进行依赖注入有什么问题。</p><h2 id="依赖注入的类型"><a href="#依赖注入的类型" class="headerlink" title="依赖注入的类型"></a>依赖注入的类型</h2><p>经过我的了解，Spring有三种依赖注入的类型。</p><h3 id="基于field的注入"><a href="#基于field的注入" class="headerlink" title="基于field的注入"></a>基于field的注入</h3><p>所谓基于field的注入，就是在变量上使用<code>@Autowired</code>注解进行依赖注入。这是我们最熟悉的一种方式，同时，也正是Spring团队所不推荐的方式。它用起来就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DependencyClass aDependency;</span><br></pre></td></tr></table></figure><h3 id="基于setter方法的注入"><a href="#基于setter方法的注入" class="headerlink" title="基于setter方法的注入"></a>基于setter方法的注入</h3><p>通过<code>setter()</code>方法，以及在方法上加入<code>@Autowired</code>注解，来完成的依赖注入，就是基于setter方法的注入。它用起来就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DependencyClass aDependency;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setADependency</span><span class="params">(DependencyClass aDependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.aDependency = aDependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在<code>Spring 4.3</code>及以后的版本中，setter上面的<code>@Autowired</code>注解是可以不写的。</p><h3 id="基于构造方法的注入"><a href="#基于构造方法的注入" class="headerlink" title="基于构造方法的注入"></a>基于构造方法的注入</h3><p>将各个必需的依赖全部放在带有<code>@Autowired</code>注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。它用起来就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里 final 修饰符并不是必须的，但是我喜欢这么做</span></span><br><span class="line">    <span class="comment">// 因为这样不仅可以在代码上防止 aDependency 被修改</span></span><br><span class="line">    <span class="comment">// 在语义上也可以表明 aDependency 是不应该被修改的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DependencyClass aDependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AClass</span><span class="params">(DependencyClass aDependency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aDependency = aDependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在<code>Spring 4.3</code>及以后的版本中，如果这个类只有一个构造方法，那么这个构造方法上面也可以不写<code>@Autowired</code>注解。</p><h2 id="基于field的注入有什么问题"><a href="#基于field的注入有什么问题" class="headerlink" title="基于field的注入有什么问题"></a>基于field的注入有什么问题</h2><p>基于field的注入，虽然不是绝对禁止使用，但是它可能会带来一些隐含的问题。比如，在<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J1YW5nb25nMTIwMy9hcnRpY2xlL2RldGFpbHMvNTA5OTIxNDc=" title="https://blog.csdn.net/ruangong1203/article/details/50992147">这篇博客<i class="fa fa-external-link"></i></span>中，作者给出了这样的一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserAccountServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.school = user.getSchool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来好像没有什么问题，<code>User</code>类会被作为一个依赖被注入到当前类中，同时这个类的<code>school</code>属性将在初始化时通过<code>user.getSchool()</code>方法来获得值。但是，这个代码在运行时，却会抛出如下的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;...&apos; defined in file [....class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [...]: Constructor threw exception; nested exception is java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p>即，在执行<code>UserAccountServiceImpl()</code>这个构造方法时出现了NPE。</p><p>出现这个问题的原因是，Java在初始化一个类时，是按照<code>静态变量或静态语句块 –&gt; 实例变量或初始化语句块 –&gt; 构造方法 -&gt; @Autowired</code>的顺序<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Spring Bean: Is autowired attribute initialised before constructor?](https://stackoverflow.com/a/26231555/3833858)">[1]</span></a></sup>，那么显而易见，在执行这个类的构造方法时，<code>user</code>对象尚未被注入，它的值还是<code>null</code>，从而产生了NPE。</p><p>此外，在代码质量方面，因为基于field的注入用起来实在是太方便了，增加一个依赖只需要声明一个变量，然后给它加上<code>@Autowired</code>注解，就可以了。而这份便利，有可能会导致这个类的依赖变得越来越多，功能越来越杂，最终违反了单一功能原则。这虽然不会导致功能异常，但是这将增大后续维护的难度。（话虽然这么说，就算我用了基于构造方法的注入，但是用Lombok简化了构造方法，这么一来，增加一个依赖又变得更方便了，只需要加一行变量声明就行，如果在不注重代码质量的时候，这也会加剧类的膨胀。所以最后还是得靠工具和审查流程，以及开发者的自觉，来保证代码质量……）</p><p>还有一点我个人的感受，就是基于field的注解会占据过多的屏幕空间。按照我个人的代码习惯，每个注入之间都要插入一行空行，来把它们分割开来。这意味着，每个注入都将占据3行。如果这个类有过多的依赖，那么很有可能光是依赖注入的部分，就会占据大半个屏幕，这会让我看起来很不舒服。当然，出现这种情况，可能同时也意味着这个类已经过于膨胀，违反单一功能原则了。</p><h2 id="基于setter的注入和基于构造方法的注入该怎么选择，有什么优点"><a href="#基于setter的注入和基于构造方法的注入该怎么选择，有什么优点" class="headerlink" title="基于setter的注入和基于构造方法的注入该怎么选择，有什么优点"></a>基于setter的注入和基于构造方法的注入该怎么选择，有什么优点</h2><p>对于两种注入方式的取舍，Spring开发团队提供了他们的意见<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Setter-based dependency injection](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/beans.html#beans-setter-injection)">[3]</span></a></sup>：</p><blockquote><p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies.</p></blockquote><p>简而言之，<code>对于必需的依赖，使用基于构造方法的注入；对于可选的依赖，使用基于setter的注入</code>。</p><p>同时Spring开发团队也讲明了两种注入方式的优点。对于基于构造方法的注入，Spring团队是这么说的：</p><blockquote><p>The Spring team generally advocates constructor injection as it enables one to implement application components as immutable objects and to ensure that required dependencies are not null. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.<br>Spring团队提倡使用基于构造方法的注入，因为这样一方面可以将依赖注入到一个不可变的变量中(注：<code>final</code>修饰的变量)，另一方面也可以保证这些变量的值不会是null。此外，经过构造方法完成依赖注入的组件(注：比如各个<code>service</code>)，在被调用时可以保证它们都完全准备好了。与此同时，从代码质量的角度来看，一个巨大的构造方法通常代表着出现了代码异味，这个类可能承担了过多的责任。</p></blockquote><p>而对于基于setter的注入，他们是这么说的：</p><blockquote><p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later.<br>基于setter的注入，则只应该被用于注入非必需的依赖，同时在类中应该对这个依赖提供一个合理的默认值。如果使用setter注入必需的依赖，那么将会有过多的null检查充斥在代码中。使用setter注入的一个优点是，这个依赖可以很方便的被改变或者重新注入。</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>虽然上面洋洋洒洒写(chao)了那么多，又是分析优劣，又是分析场景的，但是按照我现在仅有的开发经验来看，好像怎么注入区别都不大(除了setter注入，这个我没用过)，要说我为什么一定要用构造方法注入，最大的原因其实就是为了去掉那个警告……</p><p>也有人说，都这么写习惯了，又没出啥问题，你把这个警告关了不就行了吗？我的回答是：</p><p><img src="/images/idea-warninig-field-injection-is-not-recommended/but-i-resist.png" alt="だが断る！"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2MjMxNTU1LzM4MzM4NTg=" title="https://stackoverflow.com/a/26231555/3833858">Spring Bean: Is autowired attribute initialised before constructor?<i class="fa fa-external-link"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cudm9qdGVjaHJ1emlja2EuY29tL2ZpZWxkLWRlcGVuZGVuY3ktaW5qZWN0aW9uLWNvbnNpZGVyZWQtaGFybWZ1bC8=" title="https://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/">Field Dependency Injection Considered Harmful<i class="fa fa-external-link"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy80LjIueC9zcHJpbmctZnJhbWV3b3JrLXJlZmVyZW5jZS9odG1sL2JlYW5zLmh0bWwjYmVhbnMtc2V0dGVyLWluamVjdGlvbg==" title="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/beans.html#beans-setter-injection">Setter-based dependency injection<i class="fa fa-external-link"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/idea-warninig-field-injection-is-not-recommended.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用FlatMap“展平”一系列数据</title>
      <link>https://www.boris1993.com/projects/java/flatten-a-group-of-data-by-flatmap.html</link>
      <guid>https://www.boris1993.com/projects/java/flatten-a-group-of-data-by-flatmap.html</guid>
      <pubDate>Thu, 26 Sep 2019 08:30:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;在处理业务数据时，偶尔会需要从一系列逗号分隔的数据中取出各个元素并去重。本文将介绍如何通过Java 8中的&lt;code&gt;FlatMap&lt;/code&gt;简化这个操作。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在处理业务数据时，偶尔会需要从一系列逗号分隔的数据中取出各个元素并去重。本文将介绍如何通过Java 8中的<code>FlatMap</code>简化这个操作。</p><a id="more"></a><h2 id="介绍需求"><a href="#介绍需求" class="headerlink" title="介绍需求"></a>介绍需求</h2><p>假设现在有这样子的一个排班信息：</p><table><thead><tr><th>日期</th><th>班组</th></tr></thead><tbody><tr><td>2019-01-02</td><td>Unit-2, Unit-3</td></tr><tr><td>2019-01-03</td><td>Unit-2</td></tr><tr><td>2019-01-04</td><td>Unit-1, Unit-3</td></tr><tr><td>2019-01-01</td><td>Unit-2, Unit-3</td></tr><tr><td>2019-01-05</td><td>Unit-3</td></tr><tr><td>2019-01-06</td><td>Unit-1, Unit-2</td></tr><tr><td>2019-01-07</td><td>Unit-1</td></tr><tr><td>2019-01-08</td><td>Unit-2, Unit-3</td></tr></tbody></table><p>而目标是，从中取出这个表中的所有班组，并去重和排序，即最终的结果是<code>Unit-1, Unit-2, Unit-3</code>。</p><h2 id="准备示例数据"><a href="#准备示例数据" class="headerlink" title="准备示例数据"></a>准备示例数据</h2><p>在代码中，我们这样来构造这些数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备假数据</span></span><br><span class="line">WorkSchedule workSchedule1 = <span class="keyword">new</span> WorkSchedule(<span class="string">"2019-01-01"</span>, <span class="string">"Unit-2, Unit-3"</span>);</span><br><span class="line">WorkSchedule workSchedule2 = <span class="keyword">new</span> WorkSchedule(<span class="string">"2019-01-02"</span>, <span class="string">"Unit-2"</span>);</span><br><span class="line">WorkSchedule workSchedule3 = <span class="keyword">new</span> WorkSchedule(<span class="string">"2019-01-03"</span>, <span class="string">"Unit-1, Unit-3"</span>);</span><br><span class="line">WorkSchedule workSchedule4 = <span class="keyword">new</span> WorkSchedule(<span class="string">"2019-01-04"</span>, <span class="string">"Unit-2, Unit-3"</span>);</span><br><span class="line">WorkSchedule workSchedule5 = <span class="keyword">new</span> WorkSchedule(<span class="string">"2019-01-05"</span>, <span class="string">"Unit-3"</span>);</span><br><span class="line">WorkSchedule workSchedule6 = <span class="keyword">new</span> WorkSchedule(<span class="string">"2019-01-06"</span>, <span class="string">"Unit-1, Unit-2"</span>);</span><br><span class="line">WorkSchedule workSchedule7 = <span class="keyword">new</span> WorkSchedule(<span class="string">"2019-01-07"</span>, <span class="string">"Unit-1"</span>);</span><br><span class="line">WorkSchedule workSchedule8 = <span class="keyword">new</span> WorkSchedule(<span class="string">"2019-01-08"</span>, <span class="string">"Unit-2, Unit-3"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;WorkSchedule&gt; workSchedules = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">workSchedules.add(workSchedule1);</span><br><span class="line">workSchedules.add(workSchedule2);</span><br><span class="line">workSchedules.add(workSchedule3);</span><br><span class="line">workSchedules.add(workSchedule4);</span><br><span class="line">workSchedules.add(workSchedule5);</span><br><span class="line">workSchedules.add(workSchedule6);</span><br><span class="line">workSchedules.add(workSchedule7);</span><br><span class="line">workSchedules.add(workSchedule8);</span><br></pre></td></tr></table></figure><h2 id="不使用流的做法"><a href="#不使用流的做法" class="headerlink" title="不使用流的做法"></a>不使用流的做法</h2><p>如果不使用流，那么我们可以通过<code>for</code>循环取数据，和使用<code>TreeSet</code>实现去重和排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; unitNames = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (WorkSchedule workSchedule : workSchedules) &#123;</span><br><span class="line">    String[] arrUnitName = workSchedule.getUnits().split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String unitName : arrUnitName) &#123;</span><br><span class="line">        unitNames.add(unitName.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用流的做法"><a href="#使用流的做法" class="headerlink" title="使用流的做法"></a>使用流的做法</h2><p>如果使用流，则可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; units = workSchedules.stream()</span><br><span class="line">        <span class="comment">// 根据逗号，将班组名拆分成 String[]</span></span><br><span class="line">        <span class="comment">// 这一步将生成8个新的 String[] 对象</span></span><br><span class="line">        .map(i -&gt; i.getUnits().split(<span class="string">","</span>))</span><br><span class="line">        <span class="comment">// 从上面的 String[] 生成一个新的</span></span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        <span class="comment">// 切掉每个元素两端的空格</span></span><br><span class="line">        .map(String::trim)</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        .distinct()</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        .sorted()</span><br><span class="line">        <span class="comment">// 收集到一个List中</span></span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>如果上面代码的注释还是无法让您理解，那么，我还准备了每一步流操作的示意图。(感谢<code>Intellij IDEA</code>提供了这个强大的功能)</p><p>首先，在<code>map</code>方法中，<code>List</code>的每个元素都会根据逗号分隔，并生成一个<code>String[]</code>对象。</p><p><img src="/images/flatten-a-group-of-data-by-flatmap/0-split.png" alt="Split"></p><p><code>flatmap</code>方法会将上面<code>map</code>方法返回的各个流“拼接”成为一个流，即“展平”。</p><p><img src="/images/flatten-a-group-of-data-by-flatmap/1-flatmap.png" alt="FlatMap"></p><p>接下来继续使用<code>map</code>方法，对流中的每个元素进行<code>trim</code>操作。</p><p><img src="/images/flatten-a-group-of-data-by-flatmap/2-trim.png" alt="Trim"></p><p>然后调用<code>distinct</code>和<code>sorted</code>方法实现去重和排序。</p><p><img src="/images/flatten-a-group-of-data-by-flatmap/3-distinct.png" alt="Distinct"><br><img src="/images/flatten-a-group-of-data-by-flatmap/4-sort.png" alt="Sort"></p><p>最后，使用<code>collect</code>方法，将流中的数据“收集”到一个<code>List</code>中。</p><p><img src="/images/flatten-a-group-of-data-by-flatmap/5-collect.png" alt="Collect"></p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/flatten-a-group-of-data-by-flatmap.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在Java bean中实现setter的链式调用</title>
      <link>https://www.boris1993.com/projects/java/java-bean-chaining-setters.html</link>
      <guid>https://www.boris1993.com/projects/java/java-bean-chaining-setters.html</guid>
      <pubDate>Tue, 24 Sep 2019 07:08:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;在经年累月的开发中，你是不是已经对动辄数行的&lt;code&gt;.setXXX()&lt;/code&gt;方法厌烦了呢？在这篇博文中，我将介绍一个小技巧，可以稍稍让你的代码变得美观一些。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在经年累月的开发中，你是不是已经对动辄数行的<code>.setXXX()</code>方法厌烦了呢？在这篇博文中，我将介绍一个小技巧，可以稍稍让你的代码变得美观一些。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常来说，一个POJO大致上会是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(Integer score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在赋值的时候，会是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student james = <span class="keyword">new</span> Student();</span><br><span class="line">james.setName(<span class="string">"James"</span>);</span><br><span class="line">james.setAge(<span class="number">22</span>);</span><br><span class="line">james.setScore(<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>上面这三行set方法，本来没干什么事，却要写3行代码六十多个字，是不是看起来很难受，写起来很费劲？</p><p>那么，这时候就可以通过链式调用setter来显著减少代码行数。</p><h2 id="Setter的链式调用"><a href="#Setter的链式调用" class="headerlink" title="Setter的链式调用"></a>Setter的链式调用</h2><p>首先，要实现链式调用setter，就得稍微修改一下setter方法。放心，改动量是很小的，对业务是没有影响的，操作也是一劳永逸的。</p><p>具体做法呢，就是让setter返回这个POJO类型，而不是void，然后将<code>this</code>返回，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">setScore</span><span class="params">(Integer score)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在创建对象的时候，就可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student().setName(<span class="string">"james"</span>).setAge(<span class="number">22</span>).setScore(<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>怎么样？是不是突然变得很短很简洁？写起来是不是很方便？</p><p>但是，要一个个改那么多setter，也挺麻烦的，特别是IDE里面还不一定能自动化，有没有更好的办法？</p><p>答案是，有！</p><p>是啥呢？</p><p>Lombok！</p><h2 id="用Lombok实现setter的链式调用"><a href="#用Lombok实现setter的链式调用" class="headerlink" title="用Lombok实现setter的链式调用"></a>用Lombok实现setter的链式调用</h2><p>Lombok是一个自动生成模版代码的工具，像构造方法啊、getter和setter啊，都可以用一个或多个注解来代替，然后在编译期由Lombok替你写这部分的代码。如果你还没用过，那么请务必学习和试用一下，它可以为你省下那些浪费在模版代码上的时间。</p><p>在引入了Lombok之后，你就可以把上文的<code>Student</code>类重构成这样子了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，你不再需要去写getter和setter了，更不需要一个个的去修改来让它支持链式调用了。只需要两个注解，就可以完成上面的一大片工作。</p><p>第一行的<code>@Data</code>注解，是一系列注解的集合，用来生成一系列的模版代码。由于这不是本文重点，所以就不再展开说了。</p><p>第二行的<code>@Accessors</code>注解，就是这里的重点了，它用来设定Lombok应该怎样生成setter和getter代码。而其中的<code>chain</code>属性，就是打开链式setter的开关，将它打开之后，就可以生成支持链式调用的setter方法。</p><p>然后，你就可以像上文一样，去享受链式调用了。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/java-bean-chaining-setters.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>分环境为Git指定单独的配置</title>
      <link>https://www.boris1993.com/tools/git/specify-different-git-config-for-different-environments.html</link>
      <guid>https://www.boris1993.com/tools/git/specify-different-git-config-for-different-environments.html</guid>
      <pubDate>Wed, 18 Sep 2019 07:42:07 GMT</pubDate>
      <description>
      
        &lt;p&gt;有的小伙伴，在公司需要使用公司的Git来干活，同时自己也有些托管在GitHub等其他仓库的代码，在这种情况下会有一个烦恼，就是怎么样在多个仓库之间使用不同的配置。比如在公司仓库和个人仓库之间使用不同的身份信息，或者在公司仓库和个人仓库之间，使用不同的GPG签名。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;2.13&lt;/code&gt;版本之前，大概你就只能单独为每一个仓库单独设定这些信息了，但是，在&lt;code&gt;2.13&lt;/code&gt;这个版本中，Git引入了一个名为“按条件引入”(Conditional includes)的功能。这个功能允许用户通过指定一定的条件，来使Git从不同的配置文件中取得配置项。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有的小伙伴，在公司需要使用公司的Git来干活，同时自己也有些托管在GitHub等其他仓库的代码，在这种情况下会有一个烦恼，就是怎么样在多个仓库之间使用不同的配置。比如在公司仓库和个人仓库之间使用不同的身份信息，或者在公司仓库和个人仓库之间，使用不同的GPG签名。</p><p>在<code>2.13</code>版本之前，大概你就只能单独为每一个仓库单独设定这些信息了，但是，在<code>2.13</code>这个版本中，Git引入了一个名为“按条件引入”(Conditional includes)的功能。这个功能允许用户通过指定一定的条件，来使Git从不同的配置文件中取得配置项。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>“按条件引入”功能可以根据<strong>目录</strong>或者<strong>分支</strong>来决定使用哪个配置，显然根据分支无法区分工作环境和私人环境，所以首先需要分别为工作环境和私人环境创建各自的目录。比如将目录划分为这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">projects</span><br><span class="line">├── work     &lt;== 工作相关</span><br><span class="line">└── personal &lt;== 私人项目</span><br></pre></td></tr></table></figure><h2 id="拆分配置"><a href="#拆分配置" class="headerlink" title="拆分配置"></a>拆分配置</h2><p>接下来，需要为全局、工作、私人分别编写配置文件。本文中，全局配置文件<code>.gitconfig</code>位于<code>$HOME</code>下，各环境的配置文件位于<code>~/.config/git</code>下。</p><h3 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[core]</span></span><br><span class="line">  excludesfile = ~/.gitignore_global</span><br><span class="line">  editor = vim</span><br><span class="line"><span class="section">[includeIf "gitdir:~/projects/work/"]</span></span><br><span class="line">  path = ~/.config/git/gitconfig-work</span><br><span class="line"><span class="section">[includeIf "gitdir:~/projects/personal/"]</span></span><br><span class="line">  path = ~/.config/git/gitconfig-personal</span><br></pre></td></tr></table></figure><p>第4行和第6行的<code>includeIf</code>段，就是“按条件引入”的配置。在这里需要注意这几点：</p><ul><li><code>gitdir:</code>参数用于匹配本地Git仓库的路径。<ul><li>如果文件系统是大小写不敏感的，并且路径同时包含大写和小写字母，那么需要使用<code>gitdir/i:</code>来匹配。</li><li>如果要匹配某个目录下面的所有子目录，那么在路径最后需要加上<code>/</code>或者<code>/**</code>。（实际上，Git会自动在末尾的<code>/</code>后面附加<code>**</code>）</li><li>反之，如果只要匹配到某一个目录，而不递归包含其下面的所有子目录，那么路径末尾就不要有<code>/</code>。</li></ul></li><li><code>path</code>指定了在满足条件时要使用的配置文件</li></ul><p>综上所述，位于<code>~/projects/work/</code>下的所有Git仓库，都套用<code>~/.config/git/gitconfig-work</code>中的配置；位于<code>~/projects/personal/</code>下的所有Git仓库，都套用<code>~/.config/git/gitconfig-personal</code>中的配置。</p><h3 id="私人环境和工作环境的配置文件"><a href="#私人环境和工作环境的配置文件" class="headerlink" title="私人环境和工作环境的配置文件"></a>私人环境和工作环境的配置文件</h3><p>这两个环境各自的配置文件就没有什么新鲜的东西了，就只有面向各个环境的身份信息、GPG签名信息等。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">  signingkey = 1122334455667788</span><br><span class="line">  name = Your Name</span><br><span class="line">  email = test@example.com</span><br><span class="line"><span class="section">[commit]</span></span><br><span class="line">  gpgsign = true</span><br><span class="line">  template = ~/.stCommitMsg</span><br><span class="line"><span class="section">[gpg]</span></span><br><span class="line">  program = /usr/local/bin/gpg</span><br></pre></td></tr></table></figure><h2 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h2><p>写完了配置文件，还是要检查一下是不是生效了的。首先，在一个不包含任何Git仓库的位置执行<code>git config -l</code>，返回的信息中就只有全局配置中的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">core.excludesfile=~/.gitignore_global</span><br><span class="line">core.editor=vim</span><br><span class="line">includeif.gitdir:~/projects/mininglamp/.path=~/.config/git/gitconfig-mininglamp</span><br><span class="line">includeif.gitdir:~/projects/personal/.path=~/.config/git/gitconfig-default</span><br></pre></td></tr></table></figure><p>然后，进入私人环境的某个Git仓库，再执行<code>git config -l</code>，就可以看到私人环境相关的配置文件被引入了。（仓库自己的配置其实也会被显示出来，这里为了减小篇幅将其略掉了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">core.excludesfile=~/.gitignore_global</span><br><span class="line">core.editor=vim</span><br><span class="line">includeif.gitdir:~/projects/mininglamp/.path=~/.config/git/gitconfig-mininglamp</span><br><span class="line">includeif.gitdir:~/projects/personal/.path=~/.config/git/gitconfig-default</span><br><span class="line">user.signingkey=1122334455667788</span><br><span class="line">user.name=Your Name</span><br><span class="line">user.email=test@example.com</span><br><span class="line">commit.gpgsign=true</span><br><span class="line">commit.template=~/.stCommitMsg</span><br><span class="line">gpg.program=/usr/local/bin/gpg</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1jb25maWcjX2luY2x1ZGVz" title="https://git-scm.com/docs/git-config#_includes">Git官方文档的<code>Includes</code>部分<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuYmxvZy8yMDE3LTA1LTEwLWdpdC0yLTEzLWhhcy1iZWVuLXJlbGVhc2VkLw==" title="https://github.blog/2017-05-10-git-2-13-has-been-released/">Git 2.13 有趣的新功能介绍 - GitHub<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubW90b3dpbGxpYW1zLmNvbS9jb25kaXRpb25hbC1pbmNsdWRlcy1mb3ItZ2l0LWNvbmZpZw==" title="https://www.motowilliams.com/conditional-includes-for-git-config">Conditional Includes For Git Config<i class="fa fa-external-link"></i></span></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/git/specify-different-git-config-for-different-environments.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>让MyBatis把查询结果以Map形式返回</title>
      <link>https://www.boris1993.com/projects/mybatis/mybatis-return-query-results-in-a-map.html</link>
      <guid>https://www.boris1993.com/projects/mybatis/mybatis-return-query-results-in-a-map.html</guid>
      <pubDate>Thu, 12 Sep 2019 07:27:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;在使用MyBatis查询数据库时，偶尔会出现短时间高频查询的情况。或者，会被短时间高频率查询的数据需要通过另一个微服务的接口来获取。显而易见，高频率的查询数据库，或者高频率的调用微服务的接口，是会对性能产生一定影响的。&lt;/p&gt;
&lt;p&gt;在这种情况下，或许可以考虑将相关的数据一次性全部查询出来，然后根据某一列作为key，将其存放在一个Map中，把这个Map当成一个临时的缓存。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在使用MyBatis查询数据库时，偶尔会出现短时间高频查询的情况。或者，会被短时间高频率查询的数据需要通过另一个微服务的接口来获取。显而易见，高频率的查询数据库，或者高频率的调用微服务的接口，是会对性能产生一定影响的。</p><p>在这种情况下，或许可以考虑将相关的数据一次性全部查询出来，然后根据某一列作为key，将其存放在一个Map中，把这个Map当成一个临时的缓存。</p><a id="more"></a><h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><p>假设有这样的一组数据，其中保存了某公司的一系列基地的信息，包括基地名称、基地代号，和基地所在的区。</p><table><thead><tr><th>id</th><th>base_name</th><th>base_code</th><th>location</th></tr></thead><tbody><tr><td>1</td><td>梅陇</td><td>ML</td><td>徐汇区</td></tr><tr><td>2</td><td>富锦路</td><td>FJL</td><td>宝山区</td></tr><tr><td>3</td><td>龙阳路</td><td>LYL</td><td>浦东新区</td></tr><tr><td>4</td><td>北翟路</td><td>BDL</td><td>普陀区</td></tr><tr><td>5</td><td>川沙</td><td>CS</td><td>浦东新区</td></tr><tr><td>6</td><td>石龙路</td><td>SLL</td><td>闵行区</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>MyBatis查询的代码还是同往常一样，一个SELECT查询，返回类型就是这个表对应的实体类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBaseByNameInMap"</span> <span class="attr">resultType</span>=<span class="string">"com.boris1993.demoapp.entity.BaseDTO"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        `id`,</span><br><span class="line">        `base_name`,</span><br><span class="line">        `base_code`,</span><br><span class="line">        `location`</span><br><span class="line">        FROM `base`</span><br><span class="line">        WHERE del_flag = '0'</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"baseName != null and baseName != ''"</span>&gt;</span></span><br><span class="line">            AND `base_name` = #&#123;baseName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在Mapper接口中，需要在对应的方法上面加上<code>@MapKey()</code>注解。这个注解向MyBatis指明了使用<strong>实体的哪一个属性</strong>(而不是列名)作为Map的key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"baseName"</span>)</span><br><span class="line"><span class="function">Map&lt;String, BaseDTO&gt; <span class="title">queryBaseByNameInMap</span><span class="params">(@Param(<span class="string">"baseName"</span>)</span> String baseName)</span>;</span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>编写service、controller等部分不是本文重点，按下不表。在不传递<code>baseName</code>时，就可以查出这样子的数据了：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"北翟路"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"4"</span>,</span><br><span class="line">    <span class="attr">"baseName"</span>: <span class="string">"北翟路"</span>,</span><br><span class="line">    <span class="attr">"baseCode"</span>: <span class="string">"BDL"</span>,</span><br><span class="line">    <span class="attr">"location"</span>: <span class="string">"普陀区"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"龙阳路"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"3"</span>,</span><br><span class="line">    <span class="attr">"baseName"</span>: <span class="string">"龙阳路"</span>,</span><br><span class="line">    <span class="attr">"baseCode"</span>: <span class="string">"LYL"</span>,</span><br><span class="line">    <span class="attr">"location"</span>: <span class="string">"浦东新区"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"梅陇"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"baseName"</span>: <span class="string">"梅陇"</span>,</span><br><span class="line">    <span class="attr">"baseCode"</span>: <span class="string">"ML"</span>,</span><br><span class="line">    <span class="attr">"location"</span>: <span class="string">"徐汇区"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"富锦路"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"2"</span>,</span><br><span class="line">    <span class="attr">"baseName"</span>: <span class="string">"富锦路"</span>,</span><br><span class="line">    <span class="attr">"baseCode"</span>: <span class="string">"FJL"</span>,</span><br><span class="line">    <span class="attr">"location"</span>: <span class="string">"宝山区"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"石龙路"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"6"</span>,</span><br><span class="line">    <span class="attr">"baseName"</span>: <span class="string">"石龙路"</span>,</span><br><span class="line">    <span class="attr">"baseCode"</span>: <span class="string">"SLL"</span>,</span><br><span class="line">    <span class="attr">"location"</span>: <span class="string">"闵行区"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"川沙"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"5"</span>,</span><br><span class="line">    <span class="attr">"baseName"</span>: <span class="string">"川沙"</span>,</span><br><span class="line">    <span class="attr">"baseCode"</span>: <span class="string">"CS"</span>,</span><br><span class="line">    <span class="attr">"location"</span>: <span class="string">"浦东新区"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有什么用呢"><a href="#有什么用呢" class="headerlink" title="有什么用呢"></a>有什么用呢</h2><p>试想一下，在某个表中，只保存了相关基地的名字，但是在业务中又需要返回这个基地的代号等信息，那么就可以这么做了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，调用另一个微服务的接口，把这些基地的信息取出来</span></span><br><span class="line">Map&lt;String, BaseDTO&gt; bases = baseDataFeignClient.queryBaseByNameInMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，按照业务需要，查询出了一个List</span></span><br><span class="line"><span class="comment">// 在这个List中，就包含了一系列的基地的名称</span></span><br><span class="line">List&lt;SomethingOutputVO&gt; aListOfSomething = fetchAListOfSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，遍历这个List，逐个从bases中取得基地的代号</span></span><br><span class="line"><span class="keyword">for</span> (SomethingOutputVO item : aListOfSomething) &#123;</span><br><span class="line">    item.setBaseCode(bases.get(item.getBaseName()).get(<span class="string">"baseCode"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，这个Map就变成了一个小的缓存，避免了在循环中反复查询数据库或者反复调用微服务接口的问题。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/mybatis/mybatis-return-query-results-in-a-map.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JDBC错误Illegal mix of collations解决方法</title>
      <link>https://www.boris1993.com/projects/java/jdbc/illegal-mix-of-collations.html</link>
      <guid>https://www.boris1993.com/projects/java/jdbc/illegal-mix-of-collations.html</guid>
      <pubDate>Thu, 22 Aug 2019 09:43:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近项目开发时遇到了一个错误，内容是&lt;br&gt;&lt;code&gt;Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation &amp;#39;=&amp;#39;&lt;/code&gt;&lt;br&gt;经查是关联查询时两个表的排序规则(collation)不同导致的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近项目开发时遇到了一个错误，内容是<br><code>Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation &#39;=&#39;</code><br>经查是关联查询时两个表的排序规则(collation)不同导致的。</p><a id="more"></a><p>解决方法也很简单，有两种方法：</p><p>一种是在查询的SQL中指定另一张表的collation，这是一种权宜之计，治标不治本。代码是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设左表的排序规则是 utf8_general_ci,</span></span><br><span class="line"><span class="comment">-- 而右表的排序规则是 utf8_unicode_ci</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="string">`a`</span>.<span class="string">`column1`</span>,</span><br><span class="line">    <span class="string">`b`</span>.<span class="string">`column2`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`table_1`</span> <span class="keyword">AS</span> <span class="string">`a`</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`table_2`</span> <span class="keyword">AS</span> <span class="string">`b`</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="string">`a`</span>.<span class="string">`id`</span> = <span class="string">`b`</span>.<span class="string">`id`</span></span><br><span class="line">    <span class="keyword">COLLATE</span> <span class="string">`utf8_general_ci`</span></span><br></pre></td></tr></table></figure><p>另一种方法是修改表和列的排序规则，将其统一。这个方法从根本上解决了这个问题。操作方法可以参考<a href="/database/mysql/mysql-convert-tables-and-columns-collation.html">在 MySQL 中修改表和列的排序规则</a>。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/jdbc/illegal-mix-of-collations.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在MySQL中修改表和列的排序规则</title>
      <link>https://www.boris1993.com/database/mysql/mysql-convert-tables-and-columns-collation.html</link>
      <guid>https://www.boris1993.com/database/mysql/mysql-convert-tables-and-columns-collation.html</guid>
      <pubDate>Thu, 22 Aug 2019 03:33:45 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;使用如下SQL语句即可更新一张表的字符集(character set)和排序
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用如下SQL语句即可更新一张表的字符集(character set)和排序规则(collation)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此处假设使用utf8字符集，以及使用utf8_unicode_ci排序规则</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_unicode_ci;</span><br></pre></td></tr></table></figure><p>然后可以使用如下SQL查询表和列的字符集和排序规则是否修改成功：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询表的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`TABLE_SCHEMA`</span>, <span class="string">`TABLE_NAME`</span>, <span class="string">`TABLE_COLLATION`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`TABLES`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`TABLE_NAME`</span> = <span class="string">'table_name'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询表中每个列的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`TABLE_SCHEMA`</span>, <span class="string">`TABLE_NAME`</span>, <span class="string">`COLUMN_NAME`</span>, <span class="string">`COLLATION_NAME`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`COLUMNS`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`TABLE_NAME`</span> = <span class="string">'table_name'</span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/database/mysql/mysql-convert-tables-and-columns-collation.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>突然情绪爆发，暴哭了一场</title>
      <link>https://www.boris1993.com/others/i-cried-just-now.html</link>
      <guid>https://www.boris1993.com/others/i-cried-just-now.html</guid>
      <pubDate>Sun, 18 Aug 2019 02:55:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;刚才久违的暴哭了一场。&lt;/p&gt;
&lt;p&gt;嘛，其实也没暴走多久，满打满算，也就暴走了一个刘强东那么久。&lt;/p&gt;
&lt;p&gt;无奈，最近一段时间里，发生了太多闹心的事。&lt;/p&gt;
&lt;p&gt;有多闹心呢？你想想，能让一个网瘾少年连游戏都不想玩了，你就想这是有多闹心吧。&lt;/p&gt;
&lt;p&gt;已经不记得上次哭是什么时候了，甚至，已经忘了该怎么哭了。&lt;/p&gt;
&lt;p&gt;我说我连该怎么引导自己哭出来，都是查的知乎，你信吗。&lt;/p&gt;
&lt;p&gt;当然也不是没来由的就哭了，主要还是最近心力交瘁，最后因为一件屁事情绪爆发了。&lt;/p&gt;
&lt;p&gt;您要是想看个来龙去脉呢，那就继续往下，看我这个祥林嫂的絮叨吧。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>刚才久违的暴哭了一场。</p><p>嘛，其实也没暴走多久，满打满算，也就暴走了一个刘强东那么久。</p><p>无奈，最近一段时间里，发生了太多闹心的事。</p><p>有多闹心呢？你想想，能让一个网瘾少年连游戏都不想玩了，你就想这是有多闹心吧。</p><p>已经不记得上次哭是什么时候了，甚至，已经忘了该怎么哭了。</p><p>我说我连该怎么引导自己哭出来，都是查的知乎，你信吗。</p><p>当然也不是没来由的就哭了，主要还是最近心力交瘁，最后因为一件屁事情绪爆发了。</p><p>您要是想看个来龙去脉呢，那就继续往下，看我这个祥林嫂的絮叨吧。</p><a id="more"></a><p>起初呢，是年中那会，经过哥们啊、领导们啊、当然还有我自己的努力，争取到了一个外派的机会</p><p>嗯，这里插句嘴，其实现在我心里都抱着一点歉意的，因为当时领导也是有在挽留的，怎奈当时王八吃秤砣，铁了心的要出去看看这个大世界，最后就还是出来了。</p><p>那既然外派出来了，那当然是想要好好的干啊。一方面呢，当时本来就是奔着这边有没玩过的技术，我是来学习的；另一方面呢，我毕竟是外派出来的，也挂着咱老东家的脸呢，出来混，丢啥不能丢老东家的脸呐。</p><p>头先派我俩活，一个我忘了是啥了，另一个是给现有的一个系统设计并新增一个功能。</p><p>这两次呢，也没跟我规定啥时候交货。我寻思着，按照这个难度，我设计啊编码啊给你做的精细点，一星期也差不多吧。</p><p>结果周五验收的时候，负责人表示，我觉得你时间有点太长了。</p><p>第一个活，负责人表示我快了一天就搞定，最慢也就三天，按你这效率我不如不要你了。</p><p>第二个呢，负责人表示，这个应该四天就能解决的。</p><p>这就不太对了吧。开始的时候也没有定一个deadline，可最后又说你不应该花这么多时间，这是什么操作啊？</p><p>第二个活呢，我当时上交设计文档的时候，负责人表示没有什么要修改的，那么我就按照我自己的设计稿去做了。可到了交货的时候，却砍了一个功能。</p><p>为啥我要把这个被砍了的功能拎出来说呢？因为那天上午，我就是在写这个功能。如果一开始就砍了不要，那我真的确确实实就只花了四天就完成了。</p><p>当时想，算了算了，屁大点事，懒得反驳了，没劲。大不了我后面再证明我自己嘛。</p><p>但是我错了。</p><p>在上面发生的事情之后不久，我们开始从头设计和开发一个新的系统。而今天这次暴走，也是从这时候开始埋下了雷。</p><p>在这个新项目开始不久，某一天，老东家那边的领导跟我讲，这边对我的效率好像不太满意，有一点不想再要我的意思。</p><p>我一听，这不行啊。真就这么给我踹回去了，我无所谓，可是这多少会影响那哥们，和老东家的面子啊。</p><p>你看啊，咱哥们，又是拼缝，又是联系，里外里没少折腾，最后就整进来这么个怂蛋，这要是后面咱哥们再想介绍谁过来，那他领导不也得犯嘀咕，他可别再给我整个怂蛋来啊。</p><p>再看咱老东家，也是费劲巴拉的没少折腾了，结果这废物没干几天就让踹回去了，脸上也不好看啊。</p><p>那咋整呢？废话，更玩命的干呗。豁出去命挣个脸皮呗。</p><p>可事实整明，我还是 too young too naive 了。脸皮没那么好挣，但是精神却可以消耗的很快。</p><p>从谈话之后，我就开始5*8的满负载工作。去卫生间，要快。喝水，要快。任何事，都不能影响我的进度。</p><p>然后，有一天，就在临下班的时候，突然一阵头晕，我发现我的右眼的上半部分，看不见了。</p><p>具体是什么症状呢？就像是一张损坏的图片。下半部分还是画面本来的样子。而上半部分，只剩下一片灰色。</p><p>所幸，不是永久的。它只持续了不到一分钟。</p><p>但是，我很害怕。我怕下次，就变成了一只眼睛半只瞎。我怕下次，就变成了两只眼睛一只瞎。</p><p>当天挂了眼科急诊，第二天又挂了眼科门诊。好在经过各种检查，眼睛没有任何问题，诊断是一时性的供血不足。而且时间很短，没有对眼睛造成什么永久性的损伤。</p><p>但是大夫后面说了一句话，让我不淡定了。</p><p>“这种一过性的症状，通常不是眼睛的病变，而有可能是脑部的问题。”</p><p>啥？老子年纪轻轻的，脑子就坏了？老子不答应！</p><p>可我不答应没用啊，还是得拿诊断结果说话。再联系到那段时间总有右脑隐隐的偏头疼，所以也害怕是有肿瘤或者血栓在里面。</p><p>于是就先后做了脑CT和MRI。</p><p>又是各种请假。而且都这种情况了，我个废物还在考虑会不会拖团队的后腿。</p><p>最后结果出来，也算是意料之中，检查都是正常。</p><p>脑子里没有什么不该有的东西。血管也很通畅。死不掉，也瘫不了。悬下的心，算是放下了。</p><p>既然没事了，那就继续干活吧。</p><p>可是好景不长，没过一两天，右耳开始感觉耳鸣。</p><p>一开始没管它，结果越是不管，声音越是大。正巧那两天虫子开始叫起来。我一时分不清是真的耳鸣，还是虫子太响。</p><p>既然有疑惑，那就得去查。越拖着，疑心越重，没病都能拖出癔症。</p><p>其实我是个很胆小的人。我害怕的，不是虫子骑脸，不是被疯子攮了。我怕的是，突然生大病，让远在半个中国以北的爹妈操碎心。</p><p>看耳朵的时候，大夫倒是干脆，直接就说，耳屎太多了。开了瓶药，滴两天，把耳屎泡软了之后，找大夫给我取出来，就解决了。</p><p>但是这事吧，它就不能平平稳稳的过去。</p><p>取耳屎的前一天晚上，滴完了药之后，耳朵眼里开始觉得肿胀，而且，右耳几乎听不见了。</p><p>我干哦！最后一天晚上都不让我好好过吗？而且急诊又没有耳鼻喉科！玩我呢吧！</p><p>没办法求助万能的网络，结果是，耳屎彻底泡发了，涨起来堵住了耳道，造成传导性耳聋。</p><p>哦。耳屎堵了啊。好吧睡觉。明天给孙子掏出来。</p><p>第二天，也就是昨天，一大早心事重重的就醒了。赶了早班车，挂最早的号，去掏耳屎。</p><p>中间发生了一个插曲。大夫掏耳屎用的是一个吸气的管子，来把耳屎吸出来。而这个管子，让我弄堵住了。是的耳屎太多把管子堵了。</p><p>大夫都一脸很受不了的表情，说这玩意都给堵了。</p><p>吸完右耳吸左耳。你以为吸完了就完了？右耳里面，还有块钉子户你敢信？</p><p>我还得滴两天药水，再过来掏一次。</p><p>然后一整天去体检、去退还光猫，这些杂事就按下不表。</p><p>晚上回去之后，也不知道是心太累，还是天太热，只觉得心烦意乱。哥几个联机打游戏，我都没法专心的去玩，不知道思绪在哪，一团乱麻。</p><p>想着，也到了吃饭的时候了吧，于是就去做饭。做饭的时候，也是心神不宁。</p><p>菜出来了，吃了一口，咸，没法吃。</p><p>这时候，突然情绪就爆发了。</p><p>为什么？为什么就这么多破事？为什么工作也干不好，身体也养不好，就连菜都炒不好？</p><p>当时就觉得想哭。但是，又哭不出来。</p><p>就像前两天，上海一位住户，住着数百万的房子，却在台风天坏了马桶，蹲地痛哭。区别只是，我没哭出来。</p><p>忍着恶心，扔掉饭菜，出门觅食。虽然当时一点胃口都没有，但还是强迫自己吃了一碗小馄饨。</p><p>因为，任由自己的坏心情折腾自己，只会让自己离抑郁更近一步。老子，不答应。老子，要乐呵的活着。</p><p>然后就是一觉醒来，到了今天5点。时间是睡饱了，可是精神还是没有恢复。</p><p>早饭是逼着自己吃的。想出去走走，结果隔一分钟换一个目的地。</p><p>而且，还是半憋着想哭。</p><p>这不是个事，这样下去，解决不了。这样下去，老子要崩。</p><p>果断掉头回住处。上网搜，“想哭哭不出来”。嗯，网络就是好，各路大神给支招。</p><p>挑了个简单的，只需要三步。</p><p>刚做完一步半，感觉就上来了。眼泪啊，kua的一下，就出来了。</p><p>来的快，去的也快。感觉已经哭爽了，再也哭不出来之后，整理思绪，写下了这些絮絮叨叨的东西。</p><p>果然啊，心情不好的时候，哭一场，就什么都过去了。</p><p>谢谢您耐着性子，跟着这个胆小的家伙，回顾了一下这段波折的人生。</p><p>我写这么多呢，就是为了发泄一下。您呢，就当看了一篇文笔拙劣的小说吧。</p><p>$EOF.</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/others/i-cried-just-now.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用Docker配置Redis哨兵</title>
      <link>https://www.boris1993.com/database/Redis/redis-sentinel-in-docker.html</link>
      <guid>https://www.boris1993.com/database/Redis/redis-sentinel-in-docker.html</guid>
      <pubDate>Wed, 05 Jun 2019 02:08:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;接上文&lt;a href=&quot;/database/Redis/redis-replication-in-docker.html&quot;&gt;使用Docker配置Redis主从复制&lt;/a&gt;完成之后，这篇文章主要介绍如何使用Docker在本机搭建Redis的哨兵，内容包括涉及的目录结构、&lt;code&gt;docker-compose.yml&lt;/code&gt;的编写。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>接上文<a href="/database/Redis/redis-replication-in-docker.html">使用Docker配置Redis主从复制</a>完成之后，这篇文章主要介绍如何使用Docker在本机搭建Redis的哨兵，内容包括涉及的目录结构、<code>docker-compose.yml</code>的编写。</p><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>本文将采用如下的目录结构，其中<code>data</code>目录将用于存放各个容器的数据，<code>server</code>目录存放<code>docker-compose.yml</code>以及针对<code>master</code>和<code>slave</code>节点的配置文件，<code>sentinel</code>目录存放哨兵的配置文件和<code>docker-compose.yml</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-master</span><br><span class="line">│   │   └── dump.rdb</span><br><span class="line">│   ├── redis-slave-1</span><br><span class="line">│   │   └── dump.rdb</span><br><span class="line">│   └── redis-slave-2</span><br><span class="line">│       └── dump.rdb</span><br><span class="line">├── sentinel</span><br><span class="line">│   ├── docker-compose.yml</span><br><span class="line">│   └── redis-sentinel.conf</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    └── redis-slave.conf</span><br></pre></td></tr></table></figure><h2 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h2><h3 id="节点配置示意图"><a href="#节点配置示意图" class="headerlink" title="节点配置示意图"></a>节点配置示意图</h3><p>下面的示意图中，将采用Redis官方文档所使用的表示方法，<code>M</code>代表一个Master节点，<code>R</code>代表一个Replica节点，<code>S</code>代表一个Sentinel节点。</p><p>从整个集群的稳定性角度考虑，首先Master节点和各个Replica节点不应同时处于同一台服务器上，以避免单台虚拟机或物理机不可用造成整个集群失效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br><span class="line"></span><br><span class="line">配置最少投票节点为2，即有2个哨兵节点投票选举出新的Master即可完成切换。</span><br></pre></td></tr></table></figure><p>在本示例中，我将使用如下的节点配置，各个节点运行在不同的Docker容器中，来模拟运行在不同服务器中的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----+   +----+   +----+</span><br><span class="line">| M1 |   | R1 |   | R2 |</span><br><span class="line">+----+   +----+   +----+</span><br><span class="line">  |        |        |</span><br><span class="line">  +--------+--------+</span><br><span class="line">  |        |        |</span><br><span class="line">+----+   +----+   +----+</span><br><span class="line">| S1 |   | S2 |   | S3 |</span><br><span class="line">+----+   +----+   +----+</span><br></pre></td></tr></table></figure><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>编辑<code>redis-sentinel-1.conf</code>，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 哨兵的端口号</span><br><span class="line"># 因为各个哨兵节点会运行在单独的Docker容器中</span><br><span class="line"># 所以无需担心端口重复使用</span><br><span class="line"># 如果需要在单机</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 配置哨兵的监控参数</span><br><span class="line"># 格式：sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># master-name是为这个被监控的master起的名字</span><br><span class="line"># ip是被监控的master的IP或主机名。因为Docker容器之间可以使用容器名访问，所以这里写master节点的容器名</span><br><span class="line"># redis-port是被监控节点所监听的端口号</span><br><span class="line"># quorom设定了当几个哨兵判定这个节点失效后，才认为这个节点真的失效了</span><br><span class="line">sentinel monitor local-master 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"># 连接主节点的密码</span><br><span class="line"># 格式：sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass local-master redis</span><br><span class="line"></span><br><span class="line"># master在连续多长时间无法响应PING指令后，就会主观判定节点下线，默认是30秒</span><br><span class="line"># 格式：sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds local-master 30000</span><br></pre></td></tr></table></figure><p>编辑<code>redis-sentinel-2.conf</code>和<code>redis-sentinel-3.conf</code>，分别修改监听端口号为<code>26380</code>和<code>26381</code>，其余部分不变。</p><h2 id="配置及启动容器"><a href="#配置及启动容器" class="headerlink" title="配置及启动容器"></a>配置及启动容器</h2><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写<code>docker-compose.yml</code></h3><p>这里继续使用<code>docker-compose</code>管理容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  redis-sentinel-1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-sentinel-1</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="comment"># 为了规避Docker中端口映射可能带来的问题</span></span><br><span class="line">    <span class="comment"># 这里选择使用host网络</span></span><br><span class="line"><span class="attr">    network_mode:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-sentinel-1.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line">    <span class="comment"># 指定时区，保证容器内时间正确</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-sentinel",</span> <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  redis-sentinel-2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-sentinel-2</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    network_mode:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-sentinel-2.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-sentinel",</span> <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  redis-sentinel-3:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-sentinel-3</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    network_mode:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-sentinel-3.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-sentinel",</span> <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>这里同样使用<code>docker-compose up -d</code>启动容器，启动日志中可以看到哨兵开始监控Master节点，以及哨兵完成互相发现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:33:06.871 # +monitor master local-master 127.0.0.1 6379 quorum 2</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:33:08.996 * +sentinel sentinel 3dc4e0bff631b994a492d51e99a7ebc48e35a054 127.0.0.1 26381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:06.990 # +monitor master local-master 127.0.0.1 6379 quorum 2</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:07.001 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:07.010 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:08.876 * +sentinel sentinel 6f646433feb264b582ffa73b5d6bed6626b97966 127.0.0.1 26380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:08.968 * +sentinel sentinel c3b07d8c4ac3686511e436e71043a615e9b1d420 127.0.0.1 26379 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:33:06.948 # +monitor master local-master 127.0.0.1 6379 quorum 2</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:33:08.997 * +sentinel sentinel 3dc4e0bff631b994a492d51e99a7ebc48e35a054 127.0.0.1 26381 @ local-master 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>然后使用<code>redis-cli</code>连接到哨兵节点，连接成功后，可以使用<code>info sentinel</code>检查哨兵的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379&gt; info sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=local-master,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><p>其中，<code>sentinel_masters:1</code>说明这个哨兵在监控一个master，最后一行中写明了<code>master0</code>这个节点别名为<code>local-master</code>，状态为<code>OK</code>，地址是<code>10.1.0.2:6379</code>，有2个从节点，并有3个哨兵在监控。</p><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>哨兵光是启动了还是不够的，还需要测试一下当被监控节点下线之后，哨兵是否能作出反应。</p><p>我先停掉一个从节点，redis-server-slave-2，等了30秒后，三个哨兵主观认为redis-server-slave-2下线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:37:42.232 # +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:37:42.290 # +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:37:42.291 # +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>重新启动redis-server-slave-2后，三个哨兵节点都宣布不再主观认为该节点下线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:40:19.160 * +reboot slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:40:19.243 # -sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:40:19.403 * +reboot slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:40:19.161 * +reboot slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:40:19.242 # -sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:40:19.502 # -sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>这次我停掉主节点，并经过30秒后，哨兵输出了一大堆日志，不要紧，我们一边看一边解读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:11.639 # +sdown master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.695 # +sdown master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.752 # +new-epoch 1</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.755 # +vote-for-leader 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.758 # +odown master local-master 127.0.0.1 6379 #quorum 3/2</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.759 # Next failover delay: I will not start a failover before Mon Nov 11 14:50:11 2019</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.661 # +sdown master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.746 # +odown master local-master 127.0.0.1 6379 #quorum 2/2</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.746 # +new-epoch 1</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.747 # +try-failover master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.749 # +vote-for-leader 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.755 # c3b07d8c4ac3686511e436e71043a615e9b1d420 voted for 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.756 # 6f646433feb264b582ffa73b5d6bed6626b97966 voted for 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:11.753 # +new-epoch 1</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:11.754 # +vote-for-leader 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.826 # +elected-leader master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.832 # +failover-state-select-slave master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.894 # +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.895 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.971 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:12.436 # +config-update-from sentinel 3dc4e0bff631b994a492d51e99a7ebc48e35a054 127.0.0.1 26381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:12.436 # +switch-master local-master 127.0.0.1 6379 127.0.0.1 6380</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:12.437 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:12.439 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:12.434 # +config-update-from sentinel 3dc4e0bff631b994a492d51e99a7ebc48e35a054 127.0.0.1 26381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:12.435 # +switch-master local-master 127.0.0.1 6379 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:12.435 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:12.437 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.372 # +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.373 # +failover-state-reconf-slaves master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.433 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.753 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.920 # -odown master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.825 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.883 # +failover-end master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.883 # +switch-master local-master 127.0.0.1 6379 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.884 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.885 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:42.446 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:42.465 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:43.887 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br></pre></td></tr></table></figure><p>首先，三台哨兵都宣布Master节点主观下线。</p><p>因为在配置文件中，我们指定了当最少2个哨兵认为Master节点失效后就会开始选举(就是quorom)，所以哨兵2提出选举新的Master节点。</p><p>接下来，哨兵将开始投票，从Slave节点中选举出新的Master节点。在达成一致后，被选举的Slave节点将成为新的Master节点，其配置文件将会被改写，来让这个变动永久生效。</p><p>然后，哨兵会通知这个集群的其他节点来加入新的Master，包括挂掉的那个之前的Master。</p><p>这样就完成了一次failover切换。</p><p>此时，如果重启之前的Master节点，哨兵会发现节点上线，并不再主观认为该节点下线。但是，现在这个节点已经变成了一个Slave节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:56:32.936 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:56:33.202 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:56:33.707 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby90b3BpY3Mvc2VudGluZWwjc2VudGluZWwtZG9ja2VyLW5hdC1hbmQtcG9zc2libGUtaXNzdWVz" title="https://redis.io/topics/sentinel#sentinel-docker-nat-and-possible-issues">Sentinel, Docker, NAT, and possible issues - Redis Sentinel Documentation<i class="fa fa-external-link"></i></span></li></ul><h2 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h2><ul><li><a href="/database/Redis/redis-replication-in-docker.html">使用Docker配置Redis主从复制</a></li><li><a href="/database/Redis/redis-sentinel-in-docker.html">使用Docker配置Redis哨兵</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/database/Redis/redis-sentinel-in-docker.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用Docker配置Redis主从复制</title>
      <link>https://www.boris1993.com/database/Redis/redis-replication-in-docker.html</link>
      <guid>https://www.boris1993.com/database/Redis/redis-replication-in-docker.html</guid>
      <pubDate>Thu, 23 May 2019 07:22:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;这篇文章主要介绍如何使用Docker在本机搭建一个带有主从复制功能的Redis环境，内容包括涉及的目录结构、&lt;code&gt;docker-compose.yml&lt;/code&gt;的编写，以及结果的验证。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这篇文章主要介绍如何使用Docker在本机搭建一个带有主从复制功能的Redis环境，内容包括涉及的目录结构、<code>docker-compose.yml</code>的编写，以及结果的验证。</p><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>本文将采用如下的目录结构，其中<code>data</code>目录将用于存放各个容器的数据，<code>server</code>目录存放<code>docker-compose.yml</code>以及针对<code>master</code>和<code>slave</code>节点的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    ├── redis-slave1.conf</span><br><span class="line">    └── redis-slave2.conf</span><br></pre></td></tr></table></figure><h2 id="配置Redis节点"><a href="#配置Redis节点" class="headerlink" title="配置Redis节点"></a>配置Redis节点</h2><h3 id="配置master节点"><a href="#配置master节点" class="headerlink" title="配置master节点"></a>配置<code>master</code>节点</h3><p>编辑<code>redis-master.conf</code>，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br></pre></td></tr></table></figure><h3 id="配置slave节点"><a href="#配置slave节点" class="headerlink" title="配置slave节点"></a>配置<code>slave</code>节点</h3><p>创建<code>redis-slave1.conf</code>，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br><span class="line"></span><br><span class="line"># 配置master节点信息</span><br><span class="line"># 格式：</span><br><span class="line">#slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"># 此处masterip所指定的redis-server-master是运行master节点的容器名</span><br><span class="line"># Docker容器间可以使用容器名代替实际的IP地址来通信</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"># 设定连接主节点所使用的密码</span><br><span class="line">masterauth &quot;redis&quot;</span><br></pre></td></tr></table></figure><p>创建<code>redis-slave2.conf</code>，修改监听端口号为<code>6381</code>，其余配置与<code>redis-slave1.conf</code>相同。</p><h2 id="配置及启动容器"><a href="#配置及启动容器" class="headerlink" title="配置及启动容器"></a>配置及启动容器</h2><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写<code>docker-compose.yml</code></h3><p>本例中使用<code>docker-compose</code>编排相关容器。要说为什么不用<code>Kubernetes</code>，那是因为对于一个示例来说这玩意太重了。<del>说的一套一套的还不是因为不会用</del></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 主节点的容器</span></span><br><span class="line"><span class="attr">  redis-server-master:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-server-master</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="comment"># 为了规避Docker中端口映射可能带来的问题</span></span><br><span class="line">    <span class="comment"># 这里选择使用host网络</span></span><br><span class="line"><span class="attr">    network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="comment"># 指定时区，保证容器内时间正确</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">      <span class="comment"># 映射配置文件和数据目录</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-master.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-master:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="comment"># 必要的内核参数</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="comment"># 从节点1的容器</span></span><br><span class="line"><span class="attr">  redis-server-slave-1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-server-slave-1</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    network_mode:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis-server-master</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-slave1.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-slave-1:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br><span class="line">  <span class="comment"># 从节点2的容器</span></span><br><span class="line"><span class="attr">  redis-server-slave-2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis-server-slave-2</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    network_mode:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis-server-master</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis-slave2.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../data/redis-slave-2:/data</span></span><br><span class="line"><span class="attr">    sysctls:</span></span><br><span class="line">      <span class="string">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">["redis-server",</span> <span class="string">"/usr/local/etc/redis/redis.conf"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>在<code>docker-compose.yml</code>所在位置执行<code>docker-compose up</code>即可启动上述三个容器，<code>docker-compose</code>会将容器日志打印到终端，在日志中可以看到三个<code>Redis</code>服务器在启动过程中的动作，以及从节点加入主节点的信息。</p><p>启动成功后，可以在本机使用<code>redis-cli</code>连接至主节点。连接成功后，可以使用<code>info replication</code>命令检查主从复制的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=14,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6380,state=online,offset=14,lag=1</span><br><span class="line">master_replid:156ad6d206def2c9d423ef95f5311365d454f57d</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure><p>其中第5行的<code>role:master</code>指示该节点为主节点，第6行的<code>connected_slaves:2</code>说明当前有2个从节点，第7、8行则是两个从节点的信息，包括它们的地址、端口号，和状态。</p><p>如果此时查看该项目的目录结构，则可以发现在<code>data</code>目录中增加了三个Redis服务器的数据目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-master</span><br><span class="line">│   │   └── dump.rdb</span><br><span class="line">│   ├── redis-slave-1</span><br><span class="line">│   │   └── dump.rdb</span><br><span class="line">│   └── redis-slave-2</span><br><span class="line">│       └── dump.rdb</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    └── redis-slave.conf</span><br></pre></td></tr></table></figure><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>光是启动成功还不够，还需要测试一下从节点是否能同步主节点的数据。</p><p>首先连接到主节点，新增一个set：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure><p>好的，在主节点里面成功添加了一条数据。那么接下来连接到<code>slave-1</code>，看一下数据有没有同步过去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">127.0.0.1:6380&gt; set foo baz</span><br><span class="line">(error) READONLY You can&apos;t write against a read only replica.</span><br></pre></td></tr></table></figure><p>看来<code>slave-1</code>成功的从主节点同步了数据，并且这个节点也按照设定，是一个只读的节点。那么<code>slave-2</code>呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">127.0.0.1:6381&gt; set foo baz</span><br><span class="line">(error) READONLY You can&apos;t write against a read only replica.</span><br></pre></td></tr></table></figure><p>OK，<code>slave-2</code>也成功的同步了数据，并且正在作为一个只读节点运行着。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby90b3BpY3MvcmVwbGljYXRpb24jY29uZmlndXJpbmctcmVwbGljYXRpb24taW4tZG9ja2VyLWFuZC1uYXQ=" title="https://redis.io/topics/replication#configuring-replication-in-docker-and-nat">Configuring replication in Docker and NAT - Redis Replication Document<i class="fa fa-external-link"></i></span></li></ul><h2 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h2><ul><li><a href="/database/Redis/redis-replication-in-docker.html">使用Docker配置Redis主从复制</a></li><li><a href="/database/Redis/redis-sentinel-in-docker.html">使用Docker配置Redis哨兵</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/database/Redis/redis-replication-in-docker.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM的栈帧</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-jvm-stack-frame.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-jvm-stack-frame.html</guid>
      <pubDate>Tue, 02 Apr 2019 02:08:33 GMT</pubDate>
      <description>
      
        &lt;p&gt;栈帧是支持JVM进行方法调用和执行的数据结构，它是&lt;a href=&quot;/projects/java/fundamentals/java-jvm-runtime-data-areas.html&quot;&gt;JVM 运行时的数据区域&lt;/a&gt;的栈元素，其中包含了方法的局部变量表、操作数栈、动态链接方法，和返回地址等信息。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>栈帧是支持JVM进行方法调用和执行的数据结构，它是<a href="/projects/java/fundamentals/java-jvm-runtime-data-areas.html">JVM 运行时的数据区域</a>的栈元素，其中包含了方法的局部变量表、操作数栈、动态链接方法，和返回地址等信息。</p><a id="more"></a><p>局部变量表和操作数栈的空间，在编译期就已经可以确定下来，并会随着方法表的code属性一并提供给JVM，所以每个栈帧的空间不会受运行时数据的影响，而仅取决于JVM的实现。</p><p>每当一个方法被调用都会生成一个栈帧，并在方法执行完毕后被销毁，并且对于每个活动的线程，只有栈顶的栈帧是活动的，这个栈帧被称为“活动栈帧”，与其相关联的方法被称为“活动方法”，以及与其相关联的类被称为“活动类”。</p><h1 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h1><p>每个栈帧中都会有一个被称为“局部变量表”的数组，其中保存着方法的局部变量。局部变量表的大小在编译期就已经确定下来，并保存在class文件的code区。各个变量可通过数组下标的方式被定位到，对于需要占用两个元素的数据类型，比如<code>long</code>和<code>double</code>，其对应的下标使用较小的那个值。</p><p>在方法执行时，JVM使用局部变量表完成参数值到参数列表的传递过程的。如果调用的是类方法，那么参数会从局部变量表第0位开始向后排列。如果调用的是实例方法(非static方法)，则局部变量表第0位默认用于传递方法所属对象的实例的引用，在方法中使用<code>this</code>关键字可以访问到这个隐含的参数，其余的参数则从第1位开始向后排列；在参数表分配完毕后，方法体内部定义的变量会按照其顺序和作用域分配剩余的位置。</p><h1 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h1><p>每个栈帧中都有一个被称为“操作数栈”的栈。操作数栈的最大深度也是在编译期就可以确定下来，并保存在class文件的code区。</p><p>在栈帧创建初期，其中的操作数栈是空的。JVM提供了一系列的指令，用于将值压入操作数栈，同时也有指令来从操作数栈中取出值并进行计算，并将计算结果压入操作数栈。比如<code>iadd</code>指令会从操作数栈中取出最顶部的两个<code>int</code>数值，将其相加，然后将结果压入操作数栈。</p><p>压入操作数栈的元素的类型必须与指令的要求严格匹配，比如使用<code>iadd</code>指令将一个<code>float</code>和一个<code>double</code>相加是不允许的，这一点不仅在编译期会被严格确定，在类校验阶段也会进行检查。</p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>每个栈帧都包含一个指向运行时常量池的引用，用来支持方法调用过程中的动态链接。</p><p>字节码中的方法调用指令会以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用时转化成直接引用，这种称为静态解析；另一部分将在每一次运行期间转化为直接引用，这种称为动态链接。</p><h1 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h1><p>当一个方法开始执行后，只有两种方式可以退出这个方法：执行方法返回的指令，和遇到未处理的异常。</p><p>执行方法返回的指令称为“正常方法调用出口(Normal Method Invocation Completion)”，在这种情况下，如果方法有返回值，那么返回值将会被传递到上方的调用者。此时，当前栈帧将被用来恢复调用者的状态，包括调用者的本地变量表和操作数栈，并会修改pc寄存器的值来跳过方法调用指令。</p><p>当方法执行期间遇到了异常，并没有找到对应的异常处理器时，导致的方法返回称为“异常方法调用出口(Abrupt Method Invocation Completion)”，在这种情况下将不会有值被传回上方调用者。</p><h1 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h1><p>虚拟机规范允许具体的JVM实现增加一些规范中没有的信息到栈帧中，比如调试信息等，这些信息的内容将取决于JVM的具体实现。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-jvm-stack-frame.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java的垃圾回收算法</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-gc-algorithms.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-gc-algorithms.html</guid>
      <pubDate>Thu, 28 Mar 2019 06:29:41 GMT</pubDate>
      <description>
      
        &lt;p&gt;在&lt;a href=&quot;/projects/java/fundamentals/java-jvm-runtime-data-areas.html&quot;&gt;JVM运行时的数据区域&lt;/a&gt;中了解到了JVM的内存模型，那么既然使用了内存，就要考虑如何回收内存。与C语言不同，Java不需要开发人员人工回收内存，而是交给Java的垃圾回收机制来完成。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在<a href="/projects/java/fundamentals/java-jvm-runtime-data-areas.html">JVM运行时的数据区域</a>中了解到了JVM的内存模型，那么既然使用了内存，就要考虑如何回收内存。与C语言不同，Java不需要开发人员人工回收内存，而是交给Java的垃圾回收机制来完成。</p><a id="more"></a><h1 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h1><p>在Java中，GC的对象是堆和方法区。栈中的栈帧随着方法的调用和退出，会自行完成压栈和出栈操作，每个栈帧所需的内存空间也是在类结构确定下来时就已知的，所以不怎么需要考虑内存的回收问题。但是堆和方法区则不一样，这部分的空间是动态分配和回收的，同时也只有在运行时才可得知要生成哪些对象以及需要多少空间。</p><p>判断对象是否可以被回收通常有两种算法：<code>引用计数法</code>和<code>可达性分析法</code>。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法会给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就会加一；反之，每当一个引用失效时，计数器就会减一。任何时候，如果引用计数为0，则说明这个对象可以被回收。</p><p><img src="/images/java-gc-algorithms/reference-counter.png" alt="Reference counter"></p><p>但是，这个算法有一个问题，那就是无法处理循环引用，即这样：</p><p><img src="/images/java-gc-algorithms/circular-reference.png" alt="Circular reference"></p><p>此时，<code>对象1</code>，<code>对象2</code>，<code>对象3</code>都是不可达状态，理论上这三个对象都应该被回收，但是因为它们三个形成循环引用，引用计数器不为零，导致GC不会回收它们的空间。所以实际上，JVM并没有采用这种判断方法。</p><h2 id="可达性分析法-根搜索算法"><a href="#可达性分析法-根搜索算法" class="headerlink" title="可达性分析法(根搜索算法)"></a>可达性分析法(根搜索算法)</h2><p>可达性分析法的原理是，从根对象(GC Root)开始向下搜索，搜索走过的路径称为“引用链”，对象与引用链可以形成一个图，当任一个对象没有到根对象的引用链，即在这个图中该对象是不可达的，那么就判定这个对象是可以被回收的。</p><p>Java语言使用如下几种GC Root对象：</p><blockquote><ol><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol></blockquote><p>还是用上面这个循环引用作为示例：</p><p><img src="/images/java-gc-algorithms/circular-reference.png" alt="Circular reference"></p><p>此时虽然<code>对象1</code>、<code>对象2</code>、<code>对象3</code>互相之间存在引用，但是从根对象开始无法找到到达它们的路径，即它们三个都是<code>不可达</code>的，也就是可以被回收的。</p><h1 id="如何进行回收"><a href="#如何进行回收" class="headerlink" title="如何进行回收"></a>如何进行回收</h1><p>在根搜索算法的基础上，现代虚拟机中实现了三种算法：<code>标记-清除算法</code>，<code>复制算法</code>，<code>标记-整理算法</code>。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除算法把垃圾回收过程分成标记和清除两个阶段。在标记阶段，通过根节点标记所有可达的对象，也就是说，未被标记的对象都是不可达的对象。然后在清除阶段回收所有未被标记的对象。详细来说的话，就是当堆中的有效内存空间被耗尽时，就会停止整个程序(stop the world)，然后逐步开始标记和清除工作。</p><p>标记的过程，实际上是遍历所有的GC Roots，并标记所有可达的对象。而清除的过程，则是遍历堆中所有的对象，并清除没有被标记的对象。</p><p>在回收过程中一定要停止程序运行的原因，是为了避免在标记完成而尚未开始清除时，有新的可达的对象被创建出来。一旦出现这种情况，因为新创建的对象没有被标记，所以在清除阶段这个对象又会被清除。如果停止了程序的运行，那么在清除过程中，对象的状态不会发生变化，也就不会发生前面说的这种问题。</p><p>这个算法尽管可以有效的回收内存，但是也有两个比较大的缺点：</p><ol><li>遍历所有对象的效率比较低，导致程序停止运行的时间比较长</li><li>这种方法清理出的内存空间是不连续的，会造成空闲空间碎片化，并会影响数组分配空间。同时为了得知哪些空间是可用的，JVM还需要额外维护内存闲置空间的信息。</li></ol><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法的思想，是将原有的内存空间分成两部分，每次只使用其中一部分。在垃圾回收时，会从正在使用的部分中，将标记的对象复制到另一块内存中，然后清除正在使用的内存块，并交换两块内存的角色，来完成空间的回收。</p><p>该算法比标记-清除算法的效率高，但是该算法不适合活动对象较多的场合，比如老年代空间。此外，该算法会造成一定程度的内存空间浪费，因为总是有一片内存空间是被闲置的。为了节省空间，考虑到新生代空间中的对象存活时间大多不会很长，所以虚拟机可以选择不将内存对半分，而是将内存分割成一块比较大的Eden空间和两块比较小的Survivor空间(<code>From Survivor</code>和<code>To Survivor</code>)，每次同时使用Eden和其中一个Survivor。比如HotSpot虚拟机默认为Eden分配80%的空间，为两个Survivor各分配10%的空间。</p><p>Eden区，如其名字“伊甸园”一般，对象在被创建时，首先会放在这个区域；Survivor区，也如其名字“幸存者区”一样，存放的是每次垃圾回收后被保留下来的对象。</p><p>在每次垃圾回收时，Eden区中不能被回收的对象，和From Survivor区中不能被回收的对象，都将被复制到To Survivor区中，然后回收Eden区和From Survivor区的空间，并且幸存下来的对象的age属性会加一，最后From Survivor和To Survivor两者的角色对调。如果发生Survivor空间不足以存放所有活动对象时，则会使用老年代来进行分配担保，大的对象会跳过Survivor区直接进入老年代。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>因为复制算法在活动对象较多时，会发生很多的复制操作，导致算法效率比较低，而老年代的特点就是活动的对象比较多。“标记-整理”算法就是为了应对这一情况而诞生的。</p><p>标记-整理算法把垃圾回收过程分成标记和整理两个阶段。标记阶段的做法与“标记-清除”算法一样，遍历所有的GC Roots并标记出活动的对象；而在整理阶段，所有的活动对象都会向内存空间的一端移动(比如全部从内存空间的其实位置开始排列)，然后将边界以外的内存直接清理。</p><p>该算法的另一个优点是，因为该算法不会分割内存空间，而且每次回收后对象占用的空间肯定小于回收前所占用的空间，所以不再需要额外的空间进行分配担保。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>分代收集算法实际上就是根据不同内存空间的特性，一般是将堆分为新生代和老年代，并根据其各自的特点，在新生代使用复制算法回收，在老年代使用标记-整理算法回收。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-gc-algorithms.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM运行时的数据区域</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-jvm-runtime-data-areas.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-jvm-runtime-data-areas.html</guid>
      <pubDate>Wed, 27 Mar 2019 02:19:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;JVM在运行时，会按照程序执行的需要来创建一系列的运行时数据区域。有的区域只会随JVM起停而被创建和销毁，有的区域则会独立分配给各个线程，并随线程的起停而创建和销毁。这些运行时区域，按照功能和性质不同，会分成如下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程专有&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#pc-register&quot;&gt;pc(program counter)寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-stacks&quot;&gt;JVM栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-native-method-stack&quot;&gt;本地方法栈&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程间共享&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-heap&quot;&gt;堆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-method-area&quot;&gt;方法区&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm-constant-pool&quot;&gt;运行时常量池&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>JVM在运行时，会按照程序执行的需要来创建一系列的运行时数据区域。有的区域只会随JVM起停而被创建和销毁，有的区域则会独立分配给各个线程，并随线程的起停而创建和销毁。这些运行时区域，按照功能和性质不同，会分成如下几部分：</p><ul><li>线程专有<ul><li><a href="#pc-register">pc(program counter)寄存器</a></li><li><a href="#jvm-stacks">JVM栈</a></li><li><a href="#jvm-native-method-stack">本地方法栈</a></li></ul></li><li>线程间共享<ul><li><a href="#jvm-heap">堆</a></li><li><a href="#jvm-method-area">方法区</a><ul><li><a href="#jvm-constant-pool">运行时常量池</a></li></ul></li></ul></li></ul><a id="more"></a><h1 id="pc-program-counter-寄存器"><a href="#pc-program-counter-寄存器" class="headerlink" title="pc(program counter)寄存器"></a><a name="pc-register"></a>pc(program counter)寄存器</h1><p>JVM允许同时运行多个线程，每个线程都有它自己的PC寄存器。在任意时刻，每个JVM线程都在执行一个方法中的某条语句，而这个正在被执行的方法，就叫做这个线程的“当前方法”。</p><p>如果当前方法不是一个本地(native)方法，那么PC寄存器的内容是当前正在执行的指令的地址；如果当前方法是本地方法，那么PC寄存器的值则是空(undefined)的。</p><h1 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a><a name="jvm-stacks"></a>JVM栈</h1><p>每个JVM都会在其启动时创建自己私有的JVM栈，栈之中存储的是<a href="/projects/java/fundamentals/java-jvm-stack-frame.html">栈帧</a>，用于存储局部变量和方法调用信息。</p><p>规范中允许栈的深度可以是固定的，也可以根据要求动态的扩展和收缩。如果是固定深度的栈，那么每个栈的深度会在其创建时按照需要独立指定。</p><p>当请求创建的栈大于所允许的深度，那么JVM会抛出<code>StackOverflowError</code>异常；当程序试图扩大一个可以动态伸缩的栈，或者试图为新的线程创建一个栈，但是可用内存不足以完成这个操作时，那么JVM会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><a name="jvm-native-method-stack"></a>本地方法栈</h1><p>本地方法栈与JVM栈类似，保存了本地方法的调用信息。</p><p>本地方法栈的空间可以是固定的，也可以是动态伸缩的。</p><p>当程序申请了大于所允许的本地方法栈空间，那么JVM会抛出<code>StackOverflowError</code>异常；如果程序申请扩展一个可以动态伸缩的本地方法栈，或者试图创建一个栈，但是可用内存不足以满足要求时，JVM会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a><a name="jvm-heap"></a>堆</h1><p>在JVM启动时，会创建一个共享于所有线程的堆空间，其中存放着所有的对象，和被分配好空间的数组。用于存放对象的空间由一个自动化的存储空间管理机制，即垃圾回收机制(garbage collector)，来进行管理。堆空间可以是固定大小的，也可以是按需伸缩的。</p><p>如果程序试图申请扩大堆空间，但是存储管理机制无法满足需求时，JVM会抛出<code>OutOfMemory</code>异常。</p><p>在堆中，JVM又根据作用不同，将内存空间分为如下几部分：</p><h2 id="新生代-New-generation"><a href="#新生代-New-generation" class="headerlink" title="新生代(New generation)"></a>新生代(New generation)</h2><p>新生代保留的是生命周期短，并且很快就会被回收掉的对象。其中的空间又随着“复制算法”这一垃圾回收算法而被分为<code>Eden Space</code>和<code>Survivor Space</code>。具体可以参考<a href="/projects/java/fundamentals/java-gc-algorithms.html">Java的垃圾回收算法</a>这篇博文。</p><h2 id="老年代-Tenured-generation"><a href="#老年代-Tenured-generation" class="headerlink" title="老年代(Tenured generation)"></a>老年代(Tenured generation)</h2><p>在多次垃圾回收后仍然存活的对象，将会被放到老年代空间中。因此可以认为，老年代中的对象的生命周期都是比较长的。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><a name="jvm-method-area"></a>方法区</h1><p>方法区(method area)是一个共享于所有JVM线程的空间，创建于JVM启动时，其中存放着各个类的结构，如运行时常量池、属性、方法，以及方法和<a href="/projects/java/fundamentals/java-jvm-special-methods.html">特殊方法(special methods)</a>的代码。</p><p>方法区的大小可以是固定的，也可以是按需伸缩的，但是根据虚拟机实现的不同，垃圾回收机制可能不会回收或压缩方法区的空间。</p><p>如果方法区的可用内存无法满足一次申请空间的请求，那么JVM会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><a name="jvm-constant-pool"></a>运行时常量池</h1><p>运行时常量池对应class文件中的<a href="/projects/java/fundamentals/java-jvm-constant-pool.html"><code>constant_pool</code>表</a>。</p><p>运行时常量池中包含了数值常量和属性的引用。每个运行时常量池的空间都会在类或接口被创建时生成，并且从方法区中分配空间。在创建运行时方法区时，如果申请的空间大于方法区可提供的空间，那么JVM会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>《The Java Virtual Machine Specification (Java SE 8 Edition)》 - 2.5 Run-Time Data Areas</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-jvm-runtime-data-areas.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java源码阅读 - ArrayList</title>
      <link>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-arraylist.html</link>
      <guid>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-arraylist.html</guid>
      <pubDate>Fri, 22 Mar 2019 08:07:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。&lt;/p&gt;
&lt;p&gt;这次就来阅读一下&lt;code&gt;ArrayList&lt;/code&gt;的源码。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p><p>这次就来阅读一下<code>ArrayList</code>的源码。</p><a id="more"></a><h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>上面代码声明了一个叫<code>ArrayList</code>的泛型类，继承了<code>AbstractList</code>，并实现了<code>List</code>，<code>RandomAccess</code>，<code>Cloneable</code>，<code>Serializable</code>接口。</p><p><code>AbstractList</code>抽象类提供了一个“骨架”级别的<code>List</code>接口的实现，用来减少实现一个支持随机存储的<code>List</code>的工作量。</p><p><code>RandomAccess</code>中没有声明任何方法，是一个标记接口(marker interface)，表明了这个类支持快速(通常是<code>O(1)</code>时间复杂度)的随机存取。在遍历一个集合前，可以用<code>instanceof</code>判断这个集合是否实现了<code>RandomAccess</code>，来选择合适的遍历方法。</p><p><code>Cloneable</code>也是一个标记接口，表明了这个类允许使用<code>Object.clone()</code>命令进行属性到属性的复制。</p><p><code>Serializable</code>也是一个标记接口，表明在这个类上启用Java的序列化功能。</p><h1 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><code>elementData</code>数组用来实际存放数据，<code>ArrayList</code>的空间(capacity)对应这个数组的长度(size)。<code>ArrayList</code>实现了自己的序列化(<code>ArrayList#writeObject()</code>)和反序列化(<code>ArrayList#readObject()</code>)方法，所以加上<code>transient</code>关键字来使<code>elementData</code>不参与Java自带的序列化和反序列化过程。</p><p><code>size</code>成员变量记录当前<code>ArrayList</code>中元素的数量。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p><code>ArrayList</code>有三个构造方法</p><ul><li>使用默认大小的<code>ArrayList()</code></li><li>指定最初大小的<code>ArrayList(int initialCapacity)</code></li><li>根据一个给定集合来初始化的<code>ArrayList(Collection&lt;? extends E&gt; c)</code></li></ul><h2 id="使用默认大小"><a href="#使用默认大小" class="headerlink" title="使用默认大小"></a>使用默认大小</h2><p>类中首先指定了默认的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>但是，在它下面，还有这么一个东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>在最初被构造时，<code>elementData</code>会先指向<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，而不是直接创建一个容量为10的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处在于可以更合理的利用空间。试想一下，如果某个场景中需要创建5个<code>ArrayList</code>备用，如果直接就分配好空间的话，那么就会消耗掉至少50个元素所需要的空间。所以Java选择先将<code>elementData</code>指向一个空数组，在向<code>ArrayList</code>中添加数据时，再去创建合适大小的数组。</p><h2 id="指定最初大小"><a href="#指定最初大小" class="headerlink" title="指定最初大小"></a>指定最初大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当指定的大小是一个正整数时，Java会创建好对应大小的数组，并将<code>elementData</code>指向这个数组；如果指定的大小为零，那么Java也会将<code>elementData</code>指向一个共享的空数组<code>EMPTY_ELEMENTDATA</code>，注意这个空数组与上文提到的不是同一个；如果指定的大小为负数，则抛出一个异常。</p><p>那么为什么要专门把<code>EMPTY_ELEMENTDATA</code>和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>区分出来呢？<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>的JavaDoc是这么说的：</p><blockquote><p>We distinguish this from <code>EMPTY_ELEMENTDATA</code> to know how much to inflate when first element is added.<br>我们将它与<code>EMPTY_ELEMENTDATA</code>区分开来，是方便在添加第一个元素时计算要扩张多少空间。</p></blockquote><h2 id="根据给定的集合初始化"><a href="#根据给定的集合初始化" class="headerlink" title="根据给定的集合初始化"></a>根据给定的集合初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先试图调用给定集合的<code>Collection#toArray()</code>方法，将集合转换成一个<code>Object[]</code>数组。</p><p>当数组中有元素时，检查<code>elementData</code>的数据类型是否为<code>Object[]</code>类型，如果不是则使用<code>Arrays.copyOf()</code>方法重新复制元素到一个<code>Object[]</code>对象中；而当数组中没有元素时，则重新使<code>elementData</code>指向<code>EMPTY_ELEMENTDATA</code>。</p><h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>当添加元素时，首先会调用<code>ensureCapacityInternal()</code>方法，来保证空间足够。保证有足够空间后，就会向<code>elementData[size]</code>处放置被添加的元素，并且使<code>size</code>加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p><code>ensureCapacityInternal()</code>方法用于确保在添加元素时有足够的空间。如果空间不足，则会调用<code>grow()</code>方法扩容。</p><p><code>grow()</code>方法会将<code>elementData</code>扩张为当前的1.5倍空间，并使用<code>Arrays.copyOf()</code>方法将元素放入新的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算扩容目标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 检查目标容量是否大于当前已有容量</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 增加容量，以确保至少可以容纳minCapacity所指定个数的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity 目标最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newCapacity = olcCapacity + (oldCapacity / 2)</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><p><code>ArrayList</code>提供了两种方式来删除一个元素：根据元素位置(index)删除，和匹配元素删除。</p><h2 id="根据位置删除"><a href="#根据位置删除" class="headerlink" title="根据位置删除"></a>根据位置删除</h2><p>根据位置删除时，首先会检查给定的位置是否越界。如果没有越界，就会先取出被删除的元素，用来向调用方返回。</p><p>删除元素的方法是将<code>index+1</code>后面的元素重新放在<code>index</code>起始的位置上。可以看出，删除操作的消耗是比较高的。</p><p>在重新排列元素后，数组中最后一个元素将与倒数第二个元素重复。所以还需要将最后一个元素置为null，并将size减一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要移动的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(</span><br><span class="line">            <span class="comment">// 源</span></span><br><span class="line">            elementData,</span><br><span class="line">            <span class="comment">// 源位置</span></span><br><span class="line">            index+<span class="number">1</span>,</span><br><span class="line">            <span class="comment">// 目标</span></span><br><span class="line">            elementData,</span><br><span class="line">            <span class="comment">// 目标位置</span></span><br><span class="line">            index,</span><br><span class="line">            <span class="comment">// 要复制的个数</span></span><br><span class="line">            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配元素删除"><a href="#匹配元素删除" class="headerlink" title="匹配元素删除"></a>匹配元素删除</h2><p>如果向<code>remove()</code>方法提供了一个对象，那么<code>ArrayList</code>会遍历<code>elementData</code>，并会删除第一个与给定对象匹配的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缩减容量"><a href="#缩减容量" class="headerlink" title="缩减容量"></a>缩减容量</h1><p><code>ArrayList#trimToSize()</code>方法可以将<code>ArrayList</code>的容量缩减至当前元素个数。这个操作需要通过<code>Arrays.copyOf()</code>方法进行，所以成本也是比较高的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the</span></span><br><span class="line"><span class="comment"> * list's current size.  An application can use this operation to minimize</span></span><br><span class="line"><span class="comment"> * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Fail-fast"><a href="#Fail-fast" class="headerlink" title="Fail fast"></a>Fail fast</h1><p>在会改变<code>elementData</code>大小的方法中，经常会看到类似<code>modCount++</code>这样的操作。那么这个操作的目的是什么呢？</p><p>首先来看看<code>modCount</code>成员变量的JavaDoc是怎么说的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the size of the</span></span><br><span class="line"><span class="comment"> * list, or otherwise perturb it in such a fashion that iterations in</span></span><br><span class="line"><span class="comment"> * progress may yield incorrect results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This field is used by the iterator and list iterator implementation</span></span><br><span class="line"><span class="comment"> * returned by the &#123;<span class="doctag">@code</span> iterator&#125; and &#123;<span class="doctag">@code</span> listIterator&#125; methods.</span></span><br><span class="line"><span class="comment"> * If the value of this field changes unexpectedly, the iterator (or list</span></span><br><span class="line"><span class="comment"> * iterator) will throw a &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; in</span></span><br><span class="line"><span class="comment"> * response to the &#123;<span class="doctag">@code</span> next&#125;, &#123;<span class="doctag">@code</span> remove&#125;, &#123;<span class="doctag">@code</span> previous&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> set&#125; or &#123;<span class="doctag">@code</span> add&#125; operations.  This provides</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in</span></span><br><span class="line"><span class="comment"> * the face of concurrent modification during iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass</span></span><br><span class="line"><span class="comment"> * wishes to provide fail-fast iterators (and list iterators), then it</span></span><br><span class="line"><span class="comment"> * merely has to increment this field in its &#123;<span class="doctag">@code</span> add(int, E)&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> remove(int)&#125; methods (and any other methods that it overrides</span></span><br><span class="line"><span class="comment"> * that result in structural modifications to the list).  A single call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> add(int, E)&#125; or &#123;<span class="doctag">@code</span> remove(int)&#125; must add no more than</span></span><br><span class="line"><span class="comment"> * one to this field, or the iterators (and list iterators) will throw</span></span><br><span class="line"><span class="comment"> * bogus &#123;<span class="doctag">@code</span> ConcurrentModificationExceptions&#125;.  If an implementation</span></span><br><span class="line"><span class="comment"> * does not wish to provide fail-fast iterators, this field may be</span></span><br><span class="line"><span class="comment"> * ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>也就是说，<code>modCount</code>记录了一个<code>List</code>的结构被修改的次数，并且提到了如果在迭代过程中修改了<code>List</code>的结构，那么可能会导致得到错误的结果。</p><p>在迭代或者序列化的过程中，程序会检查<code>modCount</code>的值是否被修改过，如果被修改，就会抛出<code>ConcurrentModificationException</code>异常。比如<code>ArrayList.Itr#next()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><p>如上文所说，<code>ArrayList</code>实现了自己的序列化与反序列化方法，所以<code>elementData</code>使用<code>transient</code>修饰。</p><p>在序列化时，程序并不是直接序列化<code>elementData</code>这个数组，而是只取出数组中有效的元素(包括null元素)，并逐个序列化每个元素的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment"> * is, serialize it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反序列化时，首先会使<code>elementData</code>指向<code>EMPTY_ELEMENTDATA</code>，只在有元素会被反序列化时，才会为<code>elementData</code>扩容并逐个反序列化对应的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-arraylist.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java自定义注解</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-customized-annotations.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-customized-annotations.html</guid>
      <pubDate>Fri, 15 Mar 2019 01:49:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;注解是Java 5引入的一个新特性，它提供了一个用来将信息和元数据与程序元素相关联的能力，其作用如同一个修饰符，本身并不包含任何程序逻辑。&lt;/p&gt;
&lt;p&gt;本文将介绍如何创建和使用自定义的注解。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>注解是Java 5引入的一个新特性，它提供了一个用来将信息和元数据与程序元素相关联的能力，其作用如同一个修饰符，本身并不包含任何程序逻辑。</p><p>本文将介绍如何创建和使用自定义的注解。</p><a id="more"></a><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>Java自带了四个作用于注解上的注解，即元注解，分别是：</p><ul><li><code>@Documented</code>，用于注明该注解是否包含于JavaDoc中</li><li><code>@Retention</code>，用于注明这个注解将保留到什么时候</li><li><code>@Target</code>，用于注明这个注解将作用于哪些元素上</li><li><code>@Inherit</code>，用于注明该注解是否会被子类继承</li></ul><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><code>@Retention</code></h2><p><code>@Retention</code>元注解定义了这个注解的生命周期，即这个注解将保留到什么时候。注解的生命周期有这三种：</p><ul><li><code>RetentionPolicy.SOURCE</code>：仅在源码中保留，在编译期就会被丢弃。比如<code>@Override</code>和<code>@SuppressWarnings</code>就属于这类注解</li><li><code>RetentionPolicy.CLASS</code>：注解将会被写入到字节码中，但是在运行时会被丢弃。这个是默认的生命周期。</li><li><code>RetentionPolicy.RUNTIME</code>：该注解将保留至运行时。这意味着在运行时可以通过反射机制读取到注解的信息。</li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h2><p><code>@Target</code>元注解指定了该注解将可用于哪些元素上。可用的参数有如下几种：</p><ul><li><code>ElementType.ANNOTATION_TYPE</code>，用于描述注解。<code>@Target(ElementType.ANNOTATION_TYPE)</code>标注的注解将成为一个元注解。</li><li><code>ElementType.CONSTRUCTOR</code>，用于描述构造方法</li><li><code>ElementType.FIELD</code>，用于描述成员变量、对象、属性（包括enum实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>，用于描述局部变量</li><li><code>ElementType.METHOD</code>，用于描述方法</li><li><code>ElementType.PACKAGE</code>，用于描述包</li><li><code>ElementType.PARAMETER</code>，用于描述参数</li><li><code>ElementType.TYPE</code>，用于描述类、接口（包括注解）、enum生命声明</li></ul><p>Java 8中又新增了两个参数：</p><ul><li><code>ElementType.TYPE_PARAMETER</code>，可以用在Type的声明前</li><li><code>ElementType.TYPE_USE</code>，可以用在使用Type的地方</li></ul><h1 id="编写自定义注解及相关方法"><a href="#编写自定义注解及相关方法" class="headerlink" title="编写自定义注解及相关方法"></a>编写自定义注解及相关方法</h1><p>自定义注解的类型为<code>@interface</code>，注解中可以包含方法，方法名将作为注解的属性。</p><p>注解中的方法不可以有参数，也不可以抛出异常，同时方法只能返回原始类型、<code>String</code>、<code>Class</code>、<code>enums</code>、注解类型，以及上述类型的数组。方法的默认值不可以是<code>null</code>。</p><p>下面将通过一个示例演示如何编写和使用自定义注解相关的方法。</p><p>示例将分别创建两个名为<code>@JsonSerializable</code>和<code>@JsonElement</code>的注解，以及一个名为<code>JsonUtils</code>的工具类。</p><p><code>@JsonSerializable</code>标记一个类可以被序列化成JSON，<code>@JsonElement</code>标记一个成员变量将会被包含在这个JSON中；<code>JsonUtils</code>工具类包含将对象序列化为JSON的方法。</p><h2 id="JsonSerializable"><a href="#JsonSerializable" class="headerlink" title="@JsonSerializable"></a><code>@JsonSerializable</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记一个类可以被序列化成JSON</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解要在运行时通过反射获取，所以retention为runtime</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解作用于一个类，所以target为type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonSerializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JsonElement"><a href="#JsonElement" class="headerlink" title="@JsonElement"></a><code>@JsonElement</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记一个成员变量将会被包含在这个JSON中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解要在运行时通过反射获取，所以retention为runtime</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解作用于成员变量，所以target为field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonElement &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定该成员变量在JSON中的key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JsonUtils"><a href="#JsonUtils" class="headerlink" title="JsonUtils"></a><code>JsonUtils</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象序列化为JSON</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 要序列化的对象，需要有&#123;<span class="doctag">@link</span> JsonSerializable&#125;注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 序列化后的JSON字符串，如果不可序列化则是null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serializeToJson</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查对象是否可以被序列化</span></span><br><span class="line">        <span class="keyword">if</span> (!isSerializable(object)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得对象所属的类</span></span><br><span class="line">        Class clazz = object.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得类中的所有方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得所有方法的方法名，后面用于搜索</span></span><br><span class="line">        List&lt;String&gt; methodNames = Arrays.stream(methods).map(Method::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得类中所有成员变量，包括public、protected、private、和默认访问权限的</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个空的HashMap，用于存放要序列化的属性的名字和值</span></span><br><span class="line">        Map&lt;String, String&gt; elements = <span class="keyword">new</span> HashMap&lt;&gt;(fields.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有成员变量</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 如果有JsonElement注解</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(JsonElement.class)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取得变量名</span></span><br><span class="line">                String fieldName = field.getName();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拼接其对应getter方法名</span></span><br><span class="line">                <span class="comment">// 不直接使用setAccessible()方法是因为我不喜欢这么干，这会破坏封装性</span></span><br><span class="line">                String getterName = <span class="string">"get"</span> + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查这个变量是否有getter方法</span></span><br><span class="line">                <span class="keyword">if</span> (methodNames.contains(getterName)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果有getter方法，则根据方法名取得对应的方法实例</span></span><br><span class="line">                    Method method = clazz.getMethod(getterName);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取得JsonElement注解中设定的key值</span></span><br><span class="line">                    String keyName = field.getAnnotation(JsonElement.class).key();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果key的值为空字符串，则使用属性名作为JSON中的key名</span></span><br><span class="line">                    <span class="comment">// 否则取指定的key名</span></span><br><span class="line">                    <span class="comment">// 并调用变量对应的getter方法取得变量的值</span></span><br><span class="line">                    <span class="comment">// 最后放入HashMap中</span></span><br><span class="line">                    elements.put(<span class="string">""</span>.equals(keyName) ? field.getName() : keyName, String.valueOf(method.invoke(object)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历HashMap，构造JSON内容</span></span><br><span class="line">        String jsonBody = elements.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                <span class="comment">// 取得每个元素的key名和值，拼接成 \t"key":"value" 的形式</span></span><br><span class="line">                .map(entry -&gt; <span class="string">"\t\""</span> + entry.getKey() + <span class="string">"\":\""</span> + entry.getValue() + <span class="string">"\""</span>)</span><br><span class="line">                <span class="comment">// 每行元素间插入分隔符，逗号分隔每行数据，\n实现换行</span></span><br><span class="line">                .collect(Collectors.joining(<span class="string">",\n"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后拼接JSON首尾的大括号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;\n"</span> + jsonBody + <span class="string">"\n&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查对象是否可被序列化成JSON</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 将被序列化的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否可被序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSerializable</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// null不可被序列化</span></span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class clazz = object.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有JsonSerializable注解，即可被序列化</span></span><br><span class="line">        <span class="keyword">return</span> clazz.isAnnotationPresent(JsonSerializable.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用自定义注解"><a href="#使用自定义注解" class="headerlink" title="使用自定义注解"></a>使用自定义注解</h1><p>首先创建一个<code>BookModel</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 书籍信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JsonSerializable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement</span>(key = <span class="string">"bookname"</span>) <span class="comment">// 在JSON中将bookName重命名为bookname</span></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement</span></span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookModel&#123;"</span> +</span><br><span class="line">                <span class="string">"bookName='"</span> + bookName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", category='"</span> + category + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getter，setter和构造方法略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在main方法里构造对象，并将其序列化成JSON：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BookModel book = <span class="keyword">new</span> BookModel(<span class="string">"Head First Java"</span>, <span class="string">"Java"</span>, <span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(JsonUtils.serializeToJson(book));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化后的结果将是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bookname"</span>:<span class="string">"Head First Java"</span>,</span><br><span class="line">    <span class="attr">"category"</span>:<span class="string">"Java"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="string">"55"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-customized-annotations.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>循序渐进写一个Servlet(5) - Filter</title>
      <link>https://www.boris1993.com/projects/java/Servlet/java-servlet-5-filter.html</link>
      <guid>https://www.boris1993.com/projects/java/Servlet/java-servlet-5-filter.html</guid>
      <pubDate>Wed, 13 Mar 2019 07:47:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。&lt;/p&gt;
&lt;p&gt;这篇博文将演示如何创建和使用filter。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。</p><p>这篇博文将演示如何创建和使用filter。</p><a id="more"></a><h1 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是<code>Filter</code></h1><p>当客户端向servlet容器发送请求时，请求通常会直接发送到servlet进行处理，就像下图这样：</p><p><img src="/images/java-servlet-5-filter/request-flow-without-filter.png" alt="Request flow without Filter"></p><p>但是，如果希望在请求被servlet处理之前和之后，再进行一些附加的处理，就可以使用<code>Filter</code>完成。</p><p><img src="/images/java-servlet-5-filter/request-flow-with-filter.png" alt="Request flow with Filter"></p><p>一个常见的使用场景是，在filter中定义如何检查请求是否合法，比如请求头中是否携带了有效的认证和鉴权信息；或者可以在filter中针对请求和响应记录日志。</p><h1 id="怎么使用Filter"><a href="#怎么使用Filter" class="headerlink" title="怎么使用Filter"></a>怎么使用<code>Filter</code></h1><p><code>javax.servlet.Filter</code>接口定义了一个filter的生命周期，要创建一个filter，就要实现<code>Filter</code>接口。</p><p><code>Filter</code>接口包含下列方法声明：</p><ol><li><code>init()</code>，用于定义在初始化这个filter时要执行的操作，该方法在filter的生命周期内只会执行一次；</li><li><code>doFilter()</code>，用于定义这个filter要进行的操作，每当有请求被发送到与该filter绑定的资源时，该方法都会被执行一次；</li><li><code>destroy()</code>，用于定义在停止这个filter时要执行的操作，只会在一个filter被销毁时执行。</li></ol><h2 id="创建一个实现Filter接口的类"><a href="#创建一个实现Filter接口的类" class="headerlink" title="创建一个实现Filter接口的类"></a>创建一个实现<code>Filter</code>接口的类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter1</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义这个filter的行为"><a href="#定义这个filter的行为" class="headerlink" title="定义这个filter的行为"></a>定义这个filter的行为</h2><p>在<code>doFilter()</code>方法内定义这个filter的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在处理请求前打印信息</span></span><br><span class="line">    System.out.println(<span class="string">"Request passing through Filter 1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交由FilterChain将请求交给下一个filter或交给servlet处理</span></span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// servlet发送响应后打印信息</span></span><br><span class="line">    System.out.println(<span class="string">"Response passing througe Filter 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在容器中注册filter"><a href="#在容器中注册filter" class="headerlink" title="在容器中注册filter"></a>在容器中注册filter</h2><p>与servlet一样，filter也需要在容器中注册之后才能发挥作用。注册filter也有两种方式：通过<code>web.xml</code>，或者通过<code>@WebFilter</code>注解。</p><p>这里有一点需要注意，虽然filter之间没有依赖关系，但是如果要保证filter的执行顺序，那么必须使用<code>web.xml</code>来注册。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5vcmFjbGUuY29tL290bmRvY3MvamNwL3NlcnZsZXQtMy4wLWZyLWV2YWwtb3RoLUpTcGVjLw==" title="https://download.oracle.com/otndocs/jcp/servlet-3.0-fr-eval-oth-JSpec/">Servlet 3.0 规范<i class="fa fa-external-link"></i></span>的<code>8.2.3</code>节中有如下说明：</p><blockquote><p>If the order in which the listeners, servlets, filters are invoked is important to an application then a deployment descriptor must be used.</p></blockquote><p>因为使用注解注册的filter，其调用顺序没有在规范中指定。</p><blockquote><p>As described above, when using annotations to define the listeners, servlets and filters, the order in which they are invoked is unspecified.</p></blockquote><p>如果一定要使用注解并保证filter的执行顺序，那么可以参考<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY1NjE4MTYvMzgzMzg1OA==" title="https://stackoverflow.com/a/6561816/3833858">Stack Overflow中这篇回答<i class="fa fa-external-link"></i></span>。</p><p>为了演示filter的执行顺序，这里再增加一个名为<code>Filter2</code>的filter，内容与<code>Filter1</code>类似。</p><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><code>web.xml</code></h3><p>在<code>web.xml</code>中增加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.boris.tomcatlistener.filter.Filter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demoServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.boris.tomcatlistener.filter.Filter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demoServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>filter</code>标签描述了一个filter的基本信息，其中filter名称(<code>filter-name</code>)和filter所在类(<code>filter-class</code>)为必填项。</p><p><code>filter-mapping</code>标签描述了一个filter将与哪个URL或者与哪个servlet绑定，<code>filter-name</code>指定使用哪个filter处理请求，<code>url-pattern</code>指定发往哪个URL的请求会触发这个filter，<code>servlet-name</code>指定发往哪个servlet的请求会触发这个filter。<code>url-pattern</code>和<code>servlet-name</code>可以同时存在，也可以同时存在多个。</p><p><code>filter-mapping</code>标签的先后顺序，将决定filter链中各个filter被调用的先后顺序。如上文中先配置了<code>filter1</code>后配置了<code>filter2</code>，那么在请求到达时，会先执行<code>filter1</code>然后再执行<code>filter2</code>。</p><p>配置完毕后部署并运行该项目，向<code>http://localhost:8080/servletdemo/DemoServlet</code>发送一个请求，在控制台可以看到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request passing through Filter 1</span><br><span class="line">Request passing through Filter 2</span><br><span class="line">Response passing througe Filter 2</span><br><span class="line">Response passing througe Filter 1</span><br></pre></td></tr></table></figure><h3 id="WebFilter注解"><a href="#WebFilter注解" class="headerlink" title="@WebFilter注解"></a><code>@WebFilter</code>注解</h3><p><code>@WebFilter</code>是<code>Servlet 3.0</code>中新增的特性，在<code>Tomcat 7</code>及以前版本中将无法工作。</p><p>以<code>Filter1</code>为例，为其添加如下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(</span><br><span class="line">    filterName = <span class="string">"filter1"</span>,</span><br><span class="line">    urlPatterns = <span class="string">"/demoServlet"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>filter-name</code>属性指定了这个filter的名称。</p><p>有三个属性可以指定filter的触发条件：</p><ol><li><code>value</code></li><li><code>urlPatterns</code></li><li><code>servletNames</code></li></ol><p>以上三个属性都可以接受一个字符串，或者用大括号包括起来的多个字符串。</p><p>在注解只有一个参数，并且该参数是指定要匹配的URL时，建议使用<code>value</code>属性，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value为默认的属性</span></span><br><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/demoServlet"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式指定value属性</span></span><br><span class="line"><span class="meta">@WebFilter</span>(value = <span class="string">"/demoServlet"</span>)</span><br></pre></td></tr></table></figure><p>否则，建议使用<code>urlPatterns</code>属性和<code>servletNames</code>属性。不允许<code>value</code>和<code>urlPatterns</code>同时出现。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5vcmFjbGUuY29tL290bmRvY3MvamNwL3NlcnZsZXQtMy4wLWZyLWV2YWwtb3RoLUpTcGVjLw==" title="https://download.oracle.com/otndocs/jcp/servlet-3.0-fr-eval-oth-JSpec/">Servlet 3.0 规范<i class="fa fa-external-link"></i></span>的<code>8.1.2 @WebFilter</code>节中说明原文如下：</p><blockquote><p>It is recommended to use value when the only attribute on the annotation is the url pattern and to use the urlPatterns attribute when the other attributes are also used. It is illegal to have both value and urlPatterns attribute used together on the same annotation.</p></blockquote><p>配置完毕后部署并运行该项目，向<code>http://localhost:8080/servletdemo/DemoServlet</code>发送一个请求，在控制台可以看到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request passing through Filter 1</span><br><span class="line">Response passing througe Filter 1</span><br></pre></td></tr></table></figure><h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul><li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个Servlet(1) - 介绍相关的接口和类</a></li><li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个Servlet(2) - 第一个servlet</a></li><li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个Servlet(3) - 分别处理GET和POST</a></li><li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个Servlet(4) - 会话追踪</a></li><li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个Servlet(5) - Filter</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/Servlet/java-servlet-5-filter.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>循序渐进写一个Servlet(4) - 会话追踪</title>
      <link>https://www.boris1993.com/projects/java/Servlet/java-servlet-4-session-tracking.html</link>
      <guid>https://www.boris1993.com/projects/java/Servlet/java-servlet-4-session-tracking.html</guid>
      <pubDate>Tue, 12 Mar 2019 03:26:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。&lt;/p&gt;
&lt;p&gt;这篇博文将演示如何使用&lt;code&gt;cookie&lt;/code&gt;和&lt;code&gt;session&lt;/code&gt;进行会话追踪。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。本系列将一步步地写出一个Servlet程序。</p><p>这篇博文将演示如何使用<code>cookie</code>和<code>session</code>进行会话追踪。</p><a id="more"></a><p>HTTP协议是一个无状态的协议，也就是说，在服务器眼中，每一个HTTP请求都是一个全新的请求，每个请求之间没有关联。所以我们需要一个可以管理请求中携带的用户信息的方法。而会话追踪就是一个可以管理用户信息的方法。</p><p>会话追踪可以通过下列几个方式实现：</p><ol><li>Cookie</li><li>表单隐藏域</li><li>URL改写</li><li>HttpSession</li></ol><p>本文将主要演示<code>Cookie</code>和<code>HttpSession</code>的用法。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h1><h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><p><code>Cookie</code>是一串可以持久化于各个请求之间的信息片段。每个cookie都有一个名字，并有一个值，同时可以包含备注、路径、域名、过期时间、版本等附加信息。</p><p>Cookie有两种：</p><ol><li>非持久cookie，这种cookie只在会话中存留，并且不具有过期时间属性，一旦用户关闭浏览器(或者标签页)，也就是使这个会话失效，这个cookie就会丢失。</li><li>持久化cookie，这种cookie可以被用于多个会话中，而且只会在到达过期时间，或者用户主动使该cookie失效后，才会被删除。</li></ol><p>可以使用<code>HttpServletResponse#addCookie(Cookie)</code>方法在HTTP响应中携带cookie。</p><h2 id="保存cookie"><a href="#保存cookie" class="headerlink" title="保存cookie"></a>保存cookie</h2><p>首先修改前文中的<code>doPost()</code>方法，将请求中的参数取出来，并存入cookie。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有参数，得到一个Map</span></span><br><span class="line">    Map parameterMap = request.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历parameterMap</span></span><br><span class="line">        parameterMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将参数以 key = value 形式输出</span></span><br><span class="line">            writer.print(k + <span class="string">" = "</span> + ((String[]) v)[<span class="number">0</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数的key作为cookie的name，参数的value作为cookie的value</span></span><br><span class="line">            response.addCookie(<span class="keyword">new</span> Cookie(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发送一个<code>POST</code>请求，在返回中可以看到请求中的参数已经被放到cookie中，并返回到了客户端。</p><p><img src="/images/java-servlet-4-session-tracking/post-request-with-cookie.png" alt="POST request with cookie"></p><h2 id="使用cookie"><a href="#使用cookie" class="headerlink" title="使用cookie"></a>使用cookie</h2><p>一旦cookie被保存到了客户端，那么在下次访问这个cookie所对应的地址时，客户端就会自动将相关的cookie带入请求一并发送到服务端。所以客户端不需要对cookie主动做任何操作。</p><p>修改前文中的<code>doGet()</code>方法，使其可以取出cookie的值，并输出到页面上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类简化null判断</span></span><br><span class="line">    Optional&lt;String&gt; optionalQueryString = Optional.ofNullable(request.getQueryString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出每个参数</span></span><br><span class="line">    String[] queryStrings = optionalQueryString.isPresent() ? optionalQueryString.get().split(<span class="string">"&amp;"</span>) : <span class="keyword">new</span> String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Parameters: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (String query : queryStrings) &#123;</span><br><span class="line">            <span class="comment">// 取出参数的key和value</span></span><br><span class="line">            String[] q = query.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            writer.print(q[<span class="number">0</span>] + <span class="string">" = "</span> + q[<span class="number">1</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Cookies:&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从request中取出cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历各个cookie</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="comment">// 输出其name和value</span></span><br><span class="line">            writer.print(cookie.getName() + <span class="string">" = "</span> + cookie.getValue());</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发送一个<code>GET</code>请求，在返回中可以看到cookie中的内容已经被输出到页面上。</p><p><img src="/images/java-servlet-4-session-tracking/get-request-with-cookie.png" alt="GET request with cookie"></p><h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h2><p>将cookie的存活时间设为0，并返回到客户端，即可从客户端中删除这个cookie。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        <span class="comment">// JSESSIONID存放的是当前session的ID</span></span><br><span class="line">        <span class="comment">// 如果删掉这个cookie，那么当前的session也会被丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"JSESSIONID"</span>.equalsIgnoreCase(cookie.getName())) &#123;</span><br><span class="line">            <span class="comment">// 设定存活时间为0秒</span></span><br><span class="line">            cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将修改过的cookie放入响应中返回到客户端</span></span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = resp.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 因为response需要输出到客户端，才可以使新的cookie被送到客户端</span></span><br><span class="line">        <span class="comment">// 但是又懒得输出那么多东西了</span></span><br><span class="line">        <span class="comment">// 所以就输出了一个空字符串</span></span><br><span class="line">        <span class="comment">// 实际上输出内容不影响对cookie的操作</span></span><br><span class="line">        writer.print(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a><code>HttpSession</code></h1><h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h2><p>Session记录着一次会话相关的信息。</p><p>当一个请求到达服务器后，服务器会检查请求中是否包含session ID信息，比如在Tomcat中就是检查有无<code>JSESSIONID</code>这个cookie，或者URL中有无<code>JSESSIONID</code>这个查询字符串。如果找到了对应的session，则服务器会将这个session检索出来使用；请求中没有包含session ID，或者对应的session已经被销毁，则服务器会创建一个新的session并返回其ID。</p><p>Session ID通常以cookie的形式返回到客户端，如果客户端禁用了cookie，那么服务端则会使用URL重写技术将session ID写到URL中。</p><p>Session中可以键值对的形式保存附加数据，称为attributes。</p><p>与cookie不同，session保存于服务器端，而且它能保存的数据也不仅限于字符串。</p><h2 id="保存attribute"><a href="#保存attribute" class="headerlink" title="保存attribute"></a>保存attribute</h2><p>修改<code>doPost()</code>方法，编写修改session的代码。修改完成后发送一个带有参数的<code>POST</code>请求，以向session中写入一些数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有参数，得到一个Map</span></span><br><span class="line">    Map parameterMap = request.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    <span class="comment">// 如果没有，则会新建一个session并返回其ID</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历parameterMap</span></span><br><span class="line">        parameterMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将参数以 key = value 形式输出</span></span><br><span class="line">            writer.print(k + <span class="string">" = "</span> + ((String[]) v)[<span class="number">0</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数的key作为cookie的name，参数的value作为cookie的value</span></span><br><span class="line">            Cookie cookie = <span class="keyword">new</span> Cookie(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]);</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将各个参数放到session的attributes中</span></span><br><span class="line">            session.setAttribute(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取出attribute"><a href="#取出attribute" class="headerlink" title="取出attribute"></a>取出attribute</h2><p>修改<code>doGet()</code>方法，使其可以从session中取出attributes并显示在页面上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类简化null判断</span></span><br><span class="line">    Optional&lt;String&gt; optionalQueryString = Optional.ofNullable(request.getQueryString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有attribute的name</span></span><br><span class="line">    Enumeration&lt;String&gt; attributeNames = session.getAttributeNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出每个参数</span></span><br><span class="line">    String[] queryStrings = optionalQueryString.isPresent() ? optionalQueryString.get().split(<span class="string">"&amp;"</span>) : <span class="keyword">new</span> String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Parameters: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (String query : queryStrings) &#123;</span><br><span class="line">            <span class="comment">// 取出参数的key和value</span></span><br><span class="line">            String[] q = query.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            writer.print(q[<span class="number">0</span>] + <span class="string">" = "</span> + q[<span class="number">1</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Cookies:&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从request中取出cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历各个cookie</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="comment">// 输出其name和value</span></span><br><span class="line">            writer.print(cookie.getName() + <span class="string">" = "</span> + cookie.getValue());</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Attributes: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历attribute的各个name</span></span><br><span class="line">        <span class="keyword">while</span>(attributeNames.hasMoreElements()) &#123;</span><br><span class="line">            String key = attributeNames.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出attribute的值</span></span><br><span class="line">            String value = String.valueOf(session.getAttribute(key));</span><br><span class="line"></span><br><span class="line">            writer.print(key + <span class="string">" = "</span> + value);</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发送一个<code>GET</code>请求，在返回中就可以看到刚才保存在session中的数据：</p><p><img src="/images/java-servlet-4-session-tracking/get-request-with-session-attribute.png" alt="GET request with session attribute"></p><h2 id="删除attribute"><a href="#删除attribute" class="headerlink" title="删除attribute"></a>删除attribute</h2><p>此外<code>HttpSession</code>类提供了<code>removeAttribute()</code>方法用于删除一个attribute。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">    Enumeration&lt;String&gt; attributeNames = session.getAttributeNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        <span class="comment">// JSESSIONID存放的是当前session的ID</span></span><br><span class="line">        <span class="comment">// 如果删掉这个cookie，那么当前的session也会被丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"JSESSIONID"</span>.equalsIgnoreCase(cookie.getName())) &#123;</span><br><span class="line">            <span class="comment">// 设定存活时间为0秒</span></span><br><span class="line">            cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将修改过的cookie放入响应中返回到客户端</span></span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历attribute names</span></span><br><span class="line">        <span class="keyword">while</span>(attributeNames.hasMoreElements()) &#123;</span><br><span class="line">            String key = attributeNames.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将其从session中移除</span></span><br><span class="line">            session.removeAttribute(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (PrintWriter writer = resp.getWriter()) &#123;</span><br><span class="line">        <span class="comment">// 因为response需要输出到客户端，才可以使新的cookie被送到客户端</span></span><br><span class="line">        <span class="comment">// 但是又懒得输出那么多东西了</span></span><br><span class="line">        <span class="comment">// 所以就输出了一个空字符串</span></span><br><span class="line">        <span class="comment">// 实际上输出内容不影响对cookie的操作</span></span><br><span class="line">        writer.print(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul><li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个Servlet(1) - 介绍相关的接口和类</a></li><li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个Servlet(2) - 第一个servlet</a></li><li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个Servlet(3) - 分别处理GET和POST</a></li><li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个Servlet(4) - 会话追踪</a></li><li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个Servlet(5) - Filter</a></li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/Servlet/java-servlet-4-session-tracking.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
