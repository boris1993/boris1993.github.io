<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Code Life</title>
    <link>https://www.boris1993.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>码农pilot的个人博客</description>
    <pubDate>Sun, 30 Aug 2020 08:32:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>在 Google Cloud Logging 的日志输出中增加类名、方法名和行数</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/gcp-logging-show-class-and-method-name.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/gcp-logging-show-class-and-method-name.html</guid>
      <pubDate>Sun, 30 Aug 2020 06:09:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;由于我司目前的项目都运行在 Google Cloud Platform (以下简称 GCP) 上，那么自然而然的，我们选择了使用 GCP 的 Logging 来查看日志。在使用过程中，我们发现了一个问题，那就是我们无法直观的看到日志是从什么地方打印出来的，经常需要通过日志内容，在代码里面通过全文搜索来定位。这样就产生了一个需求：可不可以把这条日志所在的类、方法，和行数一起打印在日志中？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>由于我司目前的项目都运行在 Google Cloud Platform (以下简称 GCP) 上，那么自然而然的，我们选择了使用 GCP 的 Logging 来查看日志。在使用过程中，我们发现了一个问题，那就是我们无法直观的看到日志是从什么地方打印出来的，经常需要通过日志内容，在代码里面通过全文搜索来定位。这样就产生了一个需求：可不可以把这条日志所在的类、方法，和行数一起打印在日志中？</p><a id="more"></a><h2 id="日志是怎么生成的"><a href="#日志是怎么生成的" class="headerlink" title="日志是怎么生成的"></a>日志是怎么生成的</h2><p>既然要实现自动化地修改日志的内容，那么我们首先得要知道，日志的内容是怎么产生的。根据我们的 <code>logback-spring.xml</code> 中的配置，我们可以定位到，日志是从 <code>StackdriverJsonLayout</code> 这个类中生成出来的。</p><p>打开这个文件，阅读源码，发现有一个名为 <code>toJsonMap</code> 的方法很像我们这次的目标，为了大家省事，我从 GitHub 上把这段源码拿到了这里。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a logging event into a Map.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the logging event</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map which should get rendered as JSON</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">toJsonMap</span><span class="params">(ILoggingEvent event)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeMDC) {</span><br><span class="line">        event.getMDCPropertyMap().forEach((key, value) -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (!FILTERED_MDC_FIELDS.contains(key)) {</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeTimestamp) {</span><br><span class="line">        map.put(StackdriverTraceConstants.TIMESTAMP_SECONDS_ATTRIBUTE,</span><br><span class="line">                TimeUnit.MILLISECONDS.toSeconds(event.getTimeStamp()));</span><br><span class="line">        map.put(StackdriverTraceConstants.TIMESTAMP_NANOS_ATTRIBUTE,</span><br><span class="line">                TimeUnit.MILLISECONDS.toNanos(event.getTimeStamp() % <span class="number">1_000</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    add(StackdriverTraceConstants.SEVERITY_ATTRIBUTE, <span class="keyword">this</span>.includeLevel,</span><br><span class="line">            String.valueOf(event.getLevel()), map);</span><br><span class="line">    add(JsonLayout.THREAD_ATTR_NAME, <span class="keyword">this</span>.includeThreadName, event.getThreadName(), map);</span><br><span class="line">    add(JsonLayout.LOGGER_ATTR_NAME, <span class="keyword">this</span>.includeLoggerName, event.getLoggerName(), map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意看这个if块，我们的日志语句就是在这里被处理的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeFormattedMessage) {</span><br><span class="line">        String message = event.getFormattedMessage();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.includeExceptionInMessage) {</span><br><span class="line">            IThrowableProxy throwableProxy = event.getThrowableProxy();</span><br><span class="line">            <span class="keyword">if</span> (throwableProxy != <span class="keyword">null</span>) {</span><br><span class="line">                String stackTrace = getThrowableProxyConverter().convert(event);</span><br><span class="line">                <span class="keyword">if</span> (stackTrace != <span class="keyword">null</span> &amp;&amp; !stackTrace.equals(<span class="string">""</span>)) {</span><br><span class="line">                    message += <span class="string">"\n"</span> + stackTrace;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, message);</span><br><span class="line">    }</span><br><span class="line">    add(JsonLayout.MESSAGE_ATTR_NAME, <span class="keyword">this</span>.includeMessage, event.getMessage(), map);</span><br><span class="line">    add(JsonLayout.CONTEXT_ATTR_NAME, <span class="keyword">this</span>.includeContextName, event.getLoggerContextVO().getName(), map);</span><br><span class="line">    addThrowableInfo(JsonLayout.EXCEPTION_ATTR_NAME, <span class="keyword">this</span>.includeException, event, map);</span><br><span class="line">    addTraceId(event, map);</span><br><span class="line">    add(StackdriverTraceConstants.SPAN_ID_ATTRIBUTE, <span class="keyword">this</span>.includeSpanId,</span><br><span class="line">            event.getMDCPropertyMap().get(StackdriverTraceConstants.MDC_FIELD_SPAN_ID), map);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.serviceContext != <span class="keyword">null</span>) {</span><br><span class="line">        map.put(StackdriverTraceConstants.SERVICE_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.serviceContext);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customJson != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.customJson.isEmpty()) {</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : <span class="keyword">this</span>.customJson.entrySet()) {</span><br><span class="line">            map.putIfAbsent(entry.getKey(), entry.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addCustomDataToJsonMap(map, event);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看起来篇幅好像很大，但是仔细一看，不难明白，它就是生成了一个 <code>Map</code>，而这个 <code>Map</code> 里面放的，就是最后我们在 GCP Logging 里面将要看到的日志。好了，目标找到了，那就准备动手吧。</p><h2 id="修改日志内容"><a href="#修改日志内容" class="headerlink" title="修改日志内容"></a>修改日志内容</h2><p>要修改的方法找到了，但是我们仍不知道应该怎么取得类名、方法和行号。经过又一顿网上冲浪，加上在源码里面一刨一刨的翻，和一点小小的灵感，最后得知这些信息全部可以通过 <code>ILoggingEvent#getCallerData()</code> 方法取得。请原谅因为时间过去的有点久，我已经找不到当时给我指路的文章，所以也就不能放在下面的参考中了。</p><p>那么我们就开始着手实现这个需求吧。首先在项目里面新建一个类，因为我们的目的是重写 <code>toJsonMap</code> 这个方法，所以要让它继承 <code>StackdriverJsonLayout</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcpLoggingLayout</span> <span class="keyword">extends</span> <span class="title">StackdriverJsonLayout</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">toJsonMap</span><span class="params">(ILoggingEvent event)</span> </span>{</span><br><span class="line">        <span class="comment">// 先调用原本的方法，把日志的信息全部生成好</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>.toJsonMap(event);</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] callerData = event.getCallerData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有callerData，那后面也没法操作了</span></span><br><span class="line">        <span class="keyword">if</span> (callerData == <span class="keyword">null</span> || callerData.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素就是这个日志所在位置的信息</span></span><br><span class="line">        StackTraceElement stackTraceElement = callerData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我只需要类名，不需要前面的包名</span></span><br><span class="line">        <span class="comment">// 而 getClassName() 会返回类的全限定名</span></span><br><span class="line">        <span class="comment">// 所以我把它拆了，取最后一个元素，也就是类名</span></span><br><span class="line">        String[] classNameParts = stackTraceElement.getClassName().split(<span class="string">"\\."</span>);</span><br><span class="line">        String callerClass = classNameParts[classNameParts.size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        String methodName = stackTraceElement.getMethodName();</span><br><span class="line">        String lineNumber = stackTraceElement.getLineNumber().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个是原本的日志信息</span></span><br><span class="line">        String originalMessage = map.get(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把类名、方法名、行数附加在原本的信息前面</span></span><br><span class="line">        String enhancedMessage = <span class="string">"class="</span> + callerClass + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"method="</span> + methodName + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"line="</span> + lineNumber + <span class="string">" "</span></span><br><span class="line">                                + originalMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把改好的日志放回去</span></span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, enhancedMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们的日志里就带上了类名、方法名，和行号了。但是到了这里并没有结束，因为上面的代码有一个问题：框架打出来的日志也带上了这些信息。虽然不影响使用，但是它不好看，我不想要。所以我决定继续优化一下。</p><h2 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h2><p>稍加思索，我提出了两个新的需求：</p><ul><li>要根据包名过滤，只给指定的包里面的类加上这些信息。这样，我就可以排除掉所有无关的包。</li><li>还要根据类名过滤，遇到被指定的类，我就不加上这些信息。因为对于启动类 (就是放 <code>main</code> 方法那个)，和一些用于健康检查的类，它们打出的日志也没必要加上这些信息。</li></ul><p>但是很明显，原厂的功能并不足以实现这两个需求。我为了这两个需求，新增了两个参数：<code>appPackage</code> 用来指定应用的包名，<code>excludedClassNames</code> 用来指定要被排除的类。</p><p>增加了参数，那必然也要修改代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcpLoggingLayout</span> <span class="keyword">extends</span> <span class="title">StackdriverJsonLayout</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String appPackage;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; excludedClassNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppPackage</span><span class="params">(String appPackage)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.appPackage = appPackage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppPackage</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.appPackage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要注意</span></span><br><span class="line">    <span class="comment">// 我为了 logback-spring.xml 写起来方便，所以在XML中这个属性是一个逗号分隔的字符串</span></span><br><span class="line">    <span class="comment">// 但是在代码里面，我为了用 contains 方法，所以用了一个List来存放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExcludedClassNames</span><span class="params">(String excludedClassNames)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.excludedClassNames =</span><br><span class="line">            Arrays.stream(excludedClassNames.split(<span class="string">","</span>))</span><br><span class="line">                .map(String::trim)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter就没啥讲究了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getExcludedClassNames</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.excludedClassNames;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">toJsonMap</span><span class="params">(ILoggingEvent event)</span> </span>{</span><br><span class="line">        <span class="comment">// 先调用原本的方法，把日志的信息全部生成好</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>。toJsonMap(event);</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] callerData = event.getCallerData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有callerData，那后面也没法操作了</span></span><br><span class="line">        <span class="keyword">if</span> (callerData == <span class="keyword">null</span> || callerData.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素就是这个日志所在位置的信息</span></span><br><span class="line">        StackTraceElement stackTraceElement = callerData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了通过包名匹配，所以先拿出来全限定名</span></span><br><span class="line">        String callerClassFullName = stackTraceElement.getClassName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是应用所在的包打出来的日志，那么不处理</span></span><br><span class="line">        <span class="keyword">if</span> (!callerClassFullName.contains(appPackage)) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        String[] classNameParts = stackTraceElement.getClassName().split(<span class="string">"\\."</span>);</span><br><span class="line">        String callerClass = classNameParts[classNameParts.size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类是被排除的，那就不处理</span></span><br><span class="line">        <span class="keyword">if</span> (excludedClassNames.contains(callerClass)) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        String methodName = stackTraceElement.getMethodName();</span><br><span class="line">        String lineNumber = String.valueOf(stackTraceElement.getLineNumber());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个是原本的日志信息</span></span><br><span class="line">        String originalMessage = map.get(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把类名、方法名、行数附加在原本的信息前面</span></span><br><span class="line">        String enhancedMessage = <span class="string">"class="</span> + callerClass + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"method="</span> + methodName + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"line="</span> + lineNumber + <span class="string">" "</span></span><br><span class="line">                                + originalMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把改好的日志放回去</span></span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, enhancedMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>除了修改代码，日志配置文件 <code>logback-spring.xml</code> 也要针对我们新增的两个属性作出修改。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/cloud/gcp/autoconfigure/logging/logback-appender.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/cloud/gcp/logging/logback-json-appender.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/defaults.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- CONSOLE输出部分略 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE_JSON"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.encoder.LayoutWrappingEncoder"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指向我们上面写的GcpLoggingLayout --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"com.boris1993.myapplication.config.GcpLoggingLayout"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 应用的包名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appPackage</span>&gt;</span>com.boris1993.myapplication<span class="tag">&lt;/<span class="name">appPackage</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要排除的类名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逗号后面的空格可有可无，为了好看我选择加上，反正最后会被trim掉 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludedClassNames</span>&gt;</span>APP, HealthCheck<span class="tag">&lt;/<span class="name">excludedClassNames</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他GCP Logging配置略 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- springProfile配置略 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后就可以部署到 GCP 上面看效果了，或者在本机使用对应的 profile 启动，然后检查控制台里面打印出来的 JSON。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5zcHJpbmcuaW8vc3ByaW5nLWNsb3VkLWdjcC9tdWx0aS9tdWx0aV9fc3RhY2tkcml2ZXJfbG9nZ2luZy5odG1s">Stackdriver Logging<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1jbG91ZC9zcHJpbmctY2xvdWQtZ2NwL2Jsb2IvMTRhNzQ3YTVkOGZkMzYyYWI3NzNlNDNhY2FmYWU1ZWNhZWJiZDcyZC9zcHJpbmctY2xvdWQtZ2NwLWxvZ2dpbmcvc3JjL21haW4vamF2YS9vcmcvc3ByaW5nZnJhbWV3b3JrL2Nsb3VkL2djcC9sb2dnaW5nL1N0YWNrZHJpdmVySnNvbkxheW91dC5qYXZhI0w0NQ==">StackdriverJsonLayout.java - GitHub<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/gcp-logging-show-class-and-method-name.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 Spring 中通过配置类注入配置文件的值</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/spring-injecting-property-value-with-configuration-bean.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/spring-injecting-property-value-with-configuration-bean.html</guid>
      <pubDate>Sun, 03 May 2020 10:44:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;我们在开发过程中，为了保证项目的灵活性，经常会选择将一些值放在配置文件中，并在代码中将它注入并使用。将值注入代码最常见的一种方法，则是使用 &lt;code&gt;@Value()&lt;/code&gt; 注解搭配 SpEL 直接注入我们需要的属性。但是鲁迅先生有云：从来如此，便对吗？这里，我想介绍一个我个人认为更好的实践：通过配置类来注入属性的值。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们在开发过程中，为了保证项目的灵活性，经常会选择将一些值放在配置文件中，并在代码中将它注入并使用。将值注入代码最常见的一种方法，则是使用 <code>@Value()</code> 注解搭配 SpEL 直接注入我们需要的属性。但是鲁迅先生有云：从来如此，便对吗？这里，我想介绍一个我个人认为更好的实践：通过配置类来注入属性的值。</p><a id="more"></a><h2 id="旧的做法有什么问题"><a href="#旧的做法有什么问题" class="headerlink" title="旧的做法有什么问题"></a>旧的做法有什么问题</h2><p>假设我们现在有这样一个 <code>application.yml</code>，其中 <code>credentials</code> 部分是我自定义的一个属性：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="attr">credentials:</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">A_VERY_SECRET_TOKEN</span></span><br></pre></td></tr></tbody></table></figure><p>然后，我们会在用到它的地方，直接通过 <code>@Value</code> 注解把它注入进来，就像这样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value("${credientials.token}")</span></span><br><span class="line">  <span class="keyword">private</span> String token;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>好像没什么问题对吧，直接用表达式把值拿进来，然后该怎么用就怎么用。但是我不知道你们有没有注意过，这种做法其实既不利于后期重构，也不利于为代码生成好的文档。</p><p>比如说，这个值在多个类中都有被引用，但某一天，我们觉得这个名字不够直观，我们想改成 <code>contactServiceAppToken</code>，那么我们就只能先改掉属性的名字，然后在代码里面全文替换，把 <code>credentials.token</code> 批量替换成 <code>credentials.contactServiceAppToken</code>。我不知道你们是怎么想的，我每次做这种文本批量替换都很慌，生怕一个没看见而改掉了不应该改的东西。</p><p>而对于生成文档，我们都知道，在 Java 代码上面我们可以使用 JavaDoc 来编写文档，阐明这个类的作用等等。而对于 YAML 文件，则没有类似的东西，我们只能在属性上面写普通的注释。可是，大篇幅的注释又有可能会影响 YAML 文件的可读性，更不用说有谁会在看代码的时候专程去看 YAML 文件？</p><p>所以，我会建议团队使用配置类，也就是本文下面要讲的这个东西，来管理和注入这些自定义的属性。</p><h2 id="来个示例"><a href="#来个示例" class="headerlink" title="来个示例"></a>来个示例</h2><p>首先，我们需要创建一个配置类，来给这些属性找一个家。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个注解是重点，说明我们要把配置文件的 credentials 部分映射到这里</span></span><br><span class="line"><span class="meta">@ConfigurationProperties("credentials")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>{</span><br><span class="line">  <span class="comment">// 属性名与变量名保持一致即可，Spring会自动处理两者的绑定关系</span></span><br><span class="line">  <span class="comment">// 同时，Spring会自动完成不同命名方式的转换，比如 kebab-case 变成 camelCase</span></span><br><span class="line">  <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，在要使用这些属性的地方，把这个配置类注入，然后直接 get 属性的值，就可以了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Credentials credentials;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SomeService</span><span class="params">(Credentials credentials)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> String token = credentials.getToken();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与直接取值的方法比较起来，使用配置类有这么几个优点：</p><ul><li>如果在重构的时候要改变属性名，那么我们只需要修改配置文件里面的属性名，和配置类里面的属性名。当然要记得使用 IDE 里面的重构功能改名，这样 IDE 会自动分析这个属性的引用，并自动改正过来。</li><li>使用配置类还可以方便我们生成文档。如果直接在配置文件里面写文档，一方面是不一定易读，另一方面，也不是所有人都会想到在配置文件里面还有文档。而使用配置类的话，我们只需要在类上面加上 JavaDoc 就好了。</li><li>而且，我们还不需要担心打错字，导致 <code>@Value</code> 注入失败而使得应用起不来。虽然这不是什么大问题，改正就行了，但毕竟还是麻烦。</li></ul><h2 id="多层属性怎么办"><a href="#多层属性怎么办" class="headerlink" title="多层属性怎么办"></a>多层属性怎么办</h2><p>上面只是演示了只有一级子属性的情况，如果下面包含了多层属性，那配置类应该怎么写呢？</p><p>假设现在配置文件变成了这样：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">credentials:</span></span><br><span class="line">  <span class="attr">token:</span></span><br><span class="line">    <span class="attr">contact:</span> <span class="string">TOKEN_FOR_CONTACT_API</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">TOKEN_FOR_USER_API</span></span><br><span class="line">  <span class="attr">oauth:</span></span><br><span class="line">    <span class="attr">client-id:</span> <span class="string">CLIENT_ID</span></span><br><span class="line">    <span class="attr">client-secret:</span> <span class="string">CLIENT_SECRET</span></span><br><span class="line"></span><br><span class="line"><span class="attr">endpoint:</span></span><br><span class="line">  <span class="attr">contact:</span></span><br><span class="line">    <span class="attr">v1:</span> <span class="string">URL_FOR_CONTACT_API_VERSION_1</span></span><br><span class="line">    <span class="attr">v2:</span> <span class="string">URL_FOR_CONTACT_API_VERSION_2</span></span><br></pre></td></tr></tbody></table></figure><p>对于 <code>credentials</code> 部分，因为里面子属性的名字大致是确定的，我们用一个内部类就可以搞定（其实写在单独的类里面也可以，只是我不喜欢那么做）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties("credentials")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> Token token;</span><br><span class="line">  <span class="keyword">private</span> Oauth oauth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String contact;</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Oauth</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>取值的时候呢，逐层取到就好了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Credentials credentials;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SomeService</span><span class="params">(Credentials credentials)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> String contactApiToken = credentials.getToken().getContact();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是对于 <code>endpoint</code> 部分，因为里面的值是某个 API 各个版本的 URL，考虑到 API 还有可能会有新版本，每加一个版本都要再改配置类有点麻烦，所以我们可以直接用一个 Map 来存放。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties("endpoint")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, String&gt; contact;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在取值的时候，就还是一样的套路，注入这个配置类，然后从 Map 中取值就行了。Map 的 key 就是属性名，比如 <code>v1</code>，值就是属性的值。当然这样做的话，就要处理一下取到 null 的情况。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Endpoint endpoint;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SomeService</span><span class="params">(Endpoint endpoint)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.endpoint = endpoint;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> String contactV1Url = endpoint.getContact().get(<span class="string">"v1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contactV1Url == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="comment">// handle it here</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="给配置文件加上自动提示"><a href="#给配置文件加上自动提示" class="headerlink" title="给配置文件加上自动提示"></a>给配置文件加上自动提示</h2><p>其实，<code>Configuration properties</code> 配置类除了可以方便我们管理属性之外，他还可以搭配 <code>spring-boot-configuration-processor</code> 来实现配置文件的自动提示，当然这也需要 IDE 的支持。</p><p>在 <code>pom.xml</code> 中加入如下依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后在编写完配置类之后，执行一下 build 操作，或者 <code>mvn compile</code>，来让它帮我们生成一个 <code>additional-spring-configuration-metadata.json</code> 文件。有了这个文件之后，IDE 就会参照它在配置文件里面给我们提供自动提示。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/spring-injecting-property-value-with-configuration-bean.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 NexT 主题中接入 Google AdSense</title>
      <link>https://www.boris1993.com/others/hexo-next-enable-google-adsense.html</link>
      <guid>https://www.boris1993.com/others/hexo-next-enable-google-adsense.html</guid>
      <pubDate>Sun, 05 Apr 2020 06:58:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;这个博客从建站到现在，也差不多有两三年时间了，一直以来也都是一种 “用爱发电” 的状况，看到其他博主都开始通过接入广告联盟来挣零花钱，说不心动那是不可能的。所以就研究了一下怎么在这个博客里面接入 Google AdSense。&lt;/p&gt;
&lt;p&gt;在使用本文介绍的方法前，请检查您的 NexT 主题版本是否为 &lt;code&gt;v6.0.2&lt;/code&gt; 或后续版本，因为本文涉及的功能是在 &lt;code&gt;v6.0.2&lt;/code&gt; 引入的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这个博客从建站到现在，也差不多有两三年时间了，一直以来也都是一种 “用爱发电” 的状况，看到其他博主都开始通过接入广告联盟来挣零花钱，说不心动那是不可能的。所以就研究了一下怎么在这个博客里面接入 Google AdSense。</p><p>在使用本文介绍的方法前，请检查您的 NexT 主题版本是否为 <code>v6.0.2</code> 或后续版本，因为本文涉及的功能是在 <code>v6.0.2</code> 引入的。</p><a id="more"></a><p>虽然网上已经有很多类似的博文了，我为什么还要再写一篇呢？主要是因为，很多文章在添加认证代码的时候，都是直接修改 <code>themes/next/layout/_partials/head.swig</code> 或者 <code>themes/next/layout/_custom/google_adsense.ejs</code> 等位置，说白了就是在 NexT 主题所在的目录动手了，而我并不喜欢这种侵入性强的操作。经过一点简单的搜索，我发现是可以通过数据文件来实现非侵入性的修改的，所以就想讲一下我的做法。<del>当然借此机会还能水一篇博文何乐而不为 / 滑稽</del></p><p>那么言归正传，一起来看一下我是怎么配置的吧。</p><h2 id="注册Google-AdSense"><a href="#注册Google-AdSense" class="headerlink" title="注册Google AdSense"></a>注册 Google AdSense</h2><p>要接入 AdSense，那当然要有一个 AdSense 的账户。进入<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNuL2Fkc2Vuc2Uvc3RhcnQv"> Google AdSense<i class="fa fa-external-link-alt"></i></span>主页，点击 “开始使用”，跟随页面提示填好各项信息，这部分操作很简单，就不多废话了。</p><p>但是这里可能有一个坑，就是我只能接入一个裸域名，不知道是我的问题还是 AdSense 就是这么要求的。我的博客地址是 <code>https://www.boris1993.com</code>，但是在页面上输入网站地址之后，AdSense 会把 <code>www</code> 这个二级域名去掉，变成裸域名 <code>https://boris1993.com</code>，所以我只好把裸域名也关联到了我的博客站上。你们在配置的时候，记得注意一下这个地方。如果你知道具体的原因，或者解决方案，那么也请不吝赐教，在留言区告诉我。</p><h2 id="添加AdSense代码"><a href="#添加AdSense代码" class="headerlink" title="添加AdSense代码"></a>添加 AdSense 代码</h2><p>在注册完成后，AdSense 会给你一串代码，并要求你把这串代码放在 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中。注意这里就是我跟他们不一样的地方了。</p><p>同时再次提醒确认你的 NexT 主题的版本是不是 <code>v6.0.2</code> 或后续版本。如果不是的话，你要么考虑升级，要么可以点❌关闭了。</p><p>首先，我们需要在主题配置文件中指定自定义 layout 文件的位置。当然，这步也是在数据文件中操作的。什么？你还没有用数据文件这个功能？那你赶紧学习并且用起来吧，省的每次更新主题还要担心丢配置。</p><p>在 <code>source/_data/next.yml</code> 中增加如下配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置的原文可以在themes/next/_config.yml的24行找到(针对v7.5.0)</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment"># 因为我们只需要自定义head部分，所以就只配置head这一个属性，其他都保持默认</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br></pre></td></tr></tbody></table></figure><p>指定好 <code>head.swig</code> 的位置之后，我们继续在 <code>source/_data</code> 中创建 <code>head.swig</code> 文件，并把 AdSense 给我们的那串代码放在 <code>head.swig</code> 里面，就像这样：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-ad-client</span>=<span class="string">"██████████"</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后可以重新启动一下本地的 Hexo 环境，检查 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中有没有出现刚才添加的代码。检查没有问题之后，就可以部署到生产环境使上面的修改生效了。为了保险起见，在生产环境上也要检查一下 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中有没有出现刚才添加的代码。确认没有问题之后，就可以回到 AdSense 页面中点击验证按钮了。</p><p>注意，如果 AdSense 告诉你检查不通过，你一定不要频繁点击再次检查，一定要先确定检查不通过的原因，并在排除问题之后再重新检查，因为每天检查次数是有限制的，如果超过限制，就只能等 24 小时之后再检查了<del>（别问我是怎么知道的</del>。</p><p>然后 AdSense 会开始审核阶段，这期间我们静静等待审核结果的邮件就好了。</p><p><del>因为在写这篇博文的时候，我也在等 AdSense 审核，所以这篇文章暂且先告一段落，等有了结果我再更新后面的内容。</del></p><p>等了这么久，终于收到 Google 的邮件说我通过了审核，可以开始投放广告了。那么，我们也可以开始继续完成后面的工作了。</p><h2 id="配置广告模块"><a href="#配置广告模块" class="headerlink" title="配置广告模块"></a>配置广告模块</h2><p>进入 AdSense 管理后台之后，进入侧边栏的<code>广告 -&gt; 概览</code>。在这里我们可以配置广告会在什么位置展示了。</p><p>因为我并不希望让我的网站满地都是广告，而影响正常内容的展示，而是，只在首页左侧边栏最下面，和在每篇博文结束的位置，各放置一个广告。所以我就需要到<code>按广告单元</code>这个页面手动配置两个广告模块。在这个截图里我们可以看到已经有了两个广告模块，那是因为我已经配置好了。</p><p><img src="/images/hexo-next-enable-google-adsense/adsense-conf-ad-module.png" alt="Configuring ad modules"></p><h3 id="添加广告模块"><a href="#添加广告模块" class="headerlink" title="添加广告模块"></a>添加广告模块</h3><p>点击<code>展示广告</code>按钮来新建一个类型为<code>展示</code>的广告。在顶部文本框填入广告模块的名字，比如 <code>side ad</code>，然后在右边栏选择广告的尺寸，是自适应的，还是固定长宽的。如果是自适应尺寸，那么还需要选择广告的大致形状。配置完毕后，点击<code>保存</code>按钮，一个广告模块就配置好了。</p><p><img src="/images/hexo-next-enable-google-adsense/adsense-conf-ad-module-sidebar.png" alt="Sidebar ad module"></p><p>按照同样的操作，继续添加一个名为 <code>bottom ad</code> 的展示广告。这样，我们就添加好了两个广告模块。</p><h3 id="配置博客页面"><a href="#配置博客页面" class="headerlink" title="配置博客页面"></a>配置博客页面</h3><p>广告模块是创建好了，但是我们还需要配置广告展示的位置。这里我依旧使用数据文件功能，来实现非侵入性的修改。</p><p>首先，在 <code>source/_data/</code> 目录新建两个文件，分别命名为 <code>sidebar.swig</code> 和 <code>post-body-end.swig</code>，分别用来存放侧边栏广告和文章底部广告的代码。</p><p>还记得刚才添加完广告模块之后弹出的那一片代码吗？把它们原样默写到这两个文件里就好啦。开玩笑的，谁记得住那一大堆东西啊。回到<code>按广告单元</code>这个页面，在刚才添加的广告单元那里，有一个形似 <code>&lt;&gt;</code> 的按钮，点击它，就可以看到这个广告单元的配置代码了。</p><p>把 <code>side ad</code> 的代码复制到 <code>sidebar.swig</code> 中，来把这个侧边栏广告真正的放到侧边栏上。比如我的广告代码是这样的：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- side ad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span> <span class="attr">class</span>=<span class="string">"adsbygoogle"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">style</span>=<span class="string">"display:block"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-client</span>=<span class="string">"████████████████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-slot</span>=<span class="string">"██████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-format</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-full-width-responsive</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="comment">// 因为直接执行AdSense的代码会出现 No slot size for availableWidth=0 的错误</span></span></span><br><span class="line"><span class="javascript">     <span class="comment">// 并且这个广告位会无法正常展示</span></span></span><br><span class="line"><span class="javascript">     <span class="comment">// 所以加一个 event listener，在页面加载完毕之后再执行</span></span></span><br><span class="line"><span class="javascript">     <span class="comment">// 参考：https://stackoverflow.com/a/37822404/3833858</span></span></span><br><span class="line"><span class="javascript">     <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">          (adsbygoogle = <span class="built_in">window</span>.adsbygoogle || []).push({});</span></span><br><span class="line">     });</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后把 <code>bottom ad</code> 的代码复制到 <code>post-body-end.swig</code>，来把这个广告放到文章底部。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bottom ad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span> <span class="attr">class</span>=<span class="string">"adsbygoogle"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">style</span>=<span class="string">"display:block"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-client</span>=<span class="string">"████████████████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-slot</span>=<span class="string">"██████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-format</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-full-width-responsive</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     (adsbygoogle = <span class="built_in">window</span>.adsbygoogle || []).push({});</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>接下来继续修改 <code>source/_data/next.yml</code> 中 <code>custom_file_path</code> 的配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br><span class="line">  <span class="comment"># 加入下面两行</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="string">source/_data/sidebar.swig</span> <span class="comment"># 侧边栏广告</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.swig</span> <span class="comment"># 博文末尾广告</span></span><br></pre></td></tr></tbody></table></figure><p>这样，广告就放置好了。接下来，把博客发布上去，就可以开始打广告了。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/others/hexo-next-enable-google-adsense.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>解决 Maven 的 unable to find valid certification path to requested target 错误</title>
      <link>https://www.boris1993.com/tools/maven/maven-unable-to-find-valid-certification-path-to-requested-target.html</link>
      <guid>https://www.boris1993.com/tools/maven/maven-unable-to-find-valid-certification-path-to-requested-target.html</guid>
      <pubDate>Mon, 30 Mar 2020 03:13:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天我在从公司的 Maven 私库上下载依赖时，Maven 报出了 &lt;code&gt;unable to find valid certification path to requested target&lt;/code&gt; 的问题，经查询是因为没有将私库使用的自签名证书导入到 Java 的 keystore。这里写一下我的两个解决方案，方便发生了同样问题的人参考。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天我在从公司的 Maven 私库上下载依赖时，Maven 报出了 <code>unable to find valid certification path to requested target</code> 的问题，经查询是因为没有将私库使用的自签名证书导入到 Java 的 keystore。这里写一下我的两个解决方案，方便发生了同样问题的人参考。</p><a id="more"></a><h2 id="让Maven忽略证书错误"><a href="#让Maven忽略证书错误" class="headerlink" title="让Maven忽略证书错误"></a>让 Maven 忽略证书错误</h2><p>因为在默认情况下，自签名证书是不受信任的，那么我们只要让 Maven 忽略证书错误，就可以解决这个问题了。</p><p>我们可以在<code>.bashrc</code> 或<code>.zshrc</code>（或者其他位置，看你用哪个 shell 了）里面加入如下语句：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_OPTS=<span class="string">'-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Djsse.enableSNIExtension=false'</span></span><br></pre></td></tr></tbody></table></figure><p>或者，也可以在 <code>~/.mavenrc</code> 中配置这个参数：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MAVEN_OPTS</span>=<span class="string">"-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Djsse.enableSNIExtension=false"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="导入证书到keystore"><a href="#导入证书到keystore" class="headerlink" title="导入证书到keystore"></a>导入证书到 keystore</h2><p>首先使用这个命令得到网站上面的证书：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意将mavenrepository.mycompany.com替换成实际的地址</span></span><br><span class="line">openssl s_client -showcerts -connect mavenrepository.mycompany.com:443</span><br></pre></td></tr></tbody></table></figure><p>在输出中可以看到类似这样的证书信息：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s:/C=US/ST=North Carolina/L=Raleigh/O=Red Hat, Inc./OU=Red Hat Network/CN=Entitlement Master CA/emailAddress=ca-support@redhat.com</span><br><span class="line"></span><br><span class="line">i:/C=US/ST=North Carolina/L=Raleigh/O=Red Hat, Inc./OU=Red Hat Network/CN=Entitlement Master CA/emailAddress=ca-support@redhat.com</span><br></pre></td></tr></tbody></table></figure><p>我们要在这里面寻找 <code>issuer(i:)</code> 和 <code>subject(s:)</code> 相同的证书，这个就是我们要导出的根证书。找到之后，保存证书的哈希（即以 <code>—–BEGIN CERTIFICATE—–</code>开始，以 <code>—–END CERTIFICATE—–</code>结束的这部分内容）到一个文件中，比如 <code>root.crt</code>。</p><p>接下来，我们需要使用 <code>keytool</code> 把这个证书导入到 Java 的 keystore 中，命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo keytool \</span><br><span class="line">    -importcert \</span><br><span class="line">    <span class="comment"># keystore文件位置需要修改成实际的位置</span></span><br><span class="line">    -keystore /usr/<span class="built_in">local</span>/java/jdk1.8.0_60/jre/lib/security/cacerts \</span><br><span class="line">    <span class="comment"># keystore密码需要修改成实际的密码，默认密码是changeit</span></span><br><span class="line">    -storepass changeit \</span><br><span class="line">    <span class="comment"># 要导入的证书，就是刚才保存的那个，注意使用实际的位置</span></span><br><span class="line">    -file ~/Downloads/root.crt \</span><br><span class="line">    <span class="comment"># 给证书起个名字</span></span><br><span class="line">    -<span class="built_in">alias</span> <span class="string">"mavenrepository-mycompany"</span></span><br></pre></td></tr></tbody></table></figure><p>执行后 keytool 会询问是否信任这个证书，输入 <code>yes</code> 来信任。</p><p>导入完成后，Maven 就可以从这个私库下载依赖了。如果你使用 IDEA 的话，那么可能需要重新启动一下 IDEA 才会使新的 keystore 生效。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9qZnJvZy5jb20va25vd2xlZGdlLWJhc2UvaG93LXRvLXJlc29sdmUtdW5hYmxlLXRvLWZpbmQtdmFsaWQtY2VydGlmaWNhdGlvbi1wYXRoLXRvLXJlcXVlc3RlZC10YXJnZXQtZXJyb3Iv">How to resolve “unable to find valid certification path to requested target” error? - JFrog<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjEyNTI4MDAvaG93LXRvLXRlbGwtbWF2ZW4tdG8tZGlzcmVnYXJkLXNzbC1lcnJvcnMtYW5kLXRydXN0aW5nLWFsbC1jZXJ0cw==">How to tell Maven to disregard SSL errors (and trusting all certs)?<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/maven/maven-unable-to-find-valid-certification-path-to-requested-target.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>学习 Concourse CI - 使用变量</title>
      <link>https://www.boris1993.com/tools/concourse/concourse-using-vars.html</link>
      <guid>https://www.boris1993.com/tools/concourse/concourse-using-vars.html</guid>
      <pubDate>Fri, 20 Mar 2020 06:48:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;在实际编写配置文件时，我们不可能保证所有相关的值都是一成不变的。有的值可能会根据运行时的状态来指定，也有可能它是类似 token 一样的机密信息，必须从一个可信渠道获取。为了应对这种情况，我们就需要在配置文件中引入变量。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在实际编写配置文件时，我们不可能保证所有相关的值都是一成不变的。有的值可能会根据运行时的状态来指定，也有可能它是类似 token 一样的机密信息，必须从一个可信渠道获取。为了应对这种情况，我们就需要在配置文件中引入变量。</p><a id="more"></a><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>在 Concourse 的语法规则中，如果要声明一个变量，就用双括号把变量名字包裹起来，就像这样：<code>((a-variable))</code>。借用 Concourse Tutorials 中的一个例子，我们看一下具体在配置文件中，是如何声明一个变量的。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">show-animal-names</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">show-animal-names</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">env</span></span><br><span class="line">            <span class="attr">args:</span> []</span><br><span class="line">          <span class="attr">params:</span></span><br><span class="line">            <span class="attr">CAT_NAME:</span> <span class="string">((cat-name))</span></span><br><span class="line">            <span class="attr">DOG_NAME:</span> <span class="string">((dog-name))</span></span><br></pre></td></tr></tbody></table></figure><p>这里需要穿插一个内容，就是 task 的 <code>params</code> 属性。它的作用是把里面指定的键值对作为环境变量传到容器中。</p><p>我们可以看到，它声明了两个变量：<code>cat-name</code> 和 <code>dog-name</code>，分别作为环境变量 <code>CAT_NAME</code> 和 <code>DOG_NAME</code> 的值。这样，就完成了变量的声明。</p><h2 id="为变量传值"><a href="#为变量传值" class="headerlink" title="为变量传值"></a>为变量传值</h2><p>变量声明好了，那就要传值了。Concourse 支持通过命令行参数、通过文件，以及通过密钥管理器 (credentials manager) 来传入变量的值。</p><p>这里有一点需要注意，通过命令行参数或者文件传入的值，是不会根据外部条件变化的，你可以将其理解成 fly 会先把配置文件做文本替换然后再注册到 Concourse。如果要修改变量的值，那么就需要重新运行 <code>fly set-pipeline</code> 命令来修改。</p><h3 id="通过命令行参数传值"><a href="#通过命令行参数传值" class="headerlink" title="通过命令行参数传值"></a>通过命令行参数传值</h3><p>我们可以在 <code>fly</code> 命令中使用 <code>-v</code> 参数来为变量传值，它的格式是 <code>-v key=value</code>，要对多个变量赋值就要使用多个 <code>-v</code> 参数。</p><p>如果要为上文提到的配置文件传值，那么我们可以这样执行命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为变量赋值并注册pipeline</span></span><br><span class="line">fly -t tutorial sp -p parameters -c pipeline.yml -v cat-name=garfield -v dog-name=odie</span><br></pre></td></tr></tbody></table></figure><p>然后我们可以执行 <code>fly -t tutorial trigger-job -j parameters/show-animal-names -w</code> 这条命令来触发任务执行，来检查传值是否成功。</p><h3 id="通过文件传值"><a href="#通过文件传值" class="headerlink" title="通过文件传值"></a>通过文件传值</h3><p>要使用文件传值，我们首先需要创建一个包含变量名和值的 YAML 文件。为了方便起见我直接用 heredoc 创建，当然你可以选择任何你喜欢的方式。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从标准输入创建文件</span></span><br><span class="line"><span class="comment"># 当接收到EOF这个字符串时停止接收内容</span></span><br><span class="line">$ cat &gt; credentials.yml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">heredoc&gt; cat-name: garfield</span></span><br><span class="line"><span class="string">heredoc&gt; dog-name: odie</span></span><br><span class="line"><span class="string">heredoc&gt; EOF</span></span><br></pre></td></tr></tbody></table></figure><p>这样我们就得到了一个这样的文件：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cat-name:</span> <span class="string">garfield</span></span><br><span class="line"><span class="attr">dog-name:</span> <span class="string">odie</span></span><br></pre></td></tr></tbody></table></figure><p>然后在 <code>fly</code> 命令中，我们就可以用 <code>-l</code> 参数来通过文件为变量赋值：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fly -t tutorial sp -p parameters -c pipeline.yml -l credentials.yml</span><br></pre></td></tr></tbody></table></figure><h3 id="通过密钥管理器传值"><a href="#通过密钥管理器传值" class="headerlink" title="通过密钥管理器传值"></a>通过密钥管理器传值</h3><p>如上文所述，通过参数和文件赋值，不仅存在诸多不便，同时还无法保证机密信息的安全性。所以，Concourse 也支持与密钥管理器集成。Concourse 支持多种密钥管理器，具体的支持列表可以在官网的<span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL2NyZWRzLmh0bWw="> Credential Management<i class="fa fa-external-link-alt"></i></span>处查询。这里我们使用 Vault 进行演示。</p><p>由于 Vault 的安装和配置与本文无关，所以这里略过不讲。</p><h4 id="Concourse的配置"><a href="#Concourse的配置" class="headerlink" title="Concourse的配置"></a>Concourse 的配置</h4><p>Concourse 默认是没有配置密钥管理器的，如果要将 Vault 与 Concourse 集成起来，那么需要为 web 节点配置如下环境变量：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Vault的地址，协议可以是HTTP也可以是HTTPS</span></span><br><span class="line">CONCOURSE_VAULT_URL=https://vault.example.com:8200</span><br><span class="line"><span class="comment"># 你也可以为Concourse指定CA证书所在的位置</span></span><br><span class="line">CONCOURSE_VAULT_CA_CERT=path/to/ca.crt</span><br></pre></td></tr></tbody></table></figure><p>配置完毕后重启 web 节点，就完成了 Concourse 的配置。</p><h4 id="在Vault中的准备工作"><a href="#在Vault中的准备工作" class="headerlink" title="在Vault中的准备工作"></a>在 Vault 中的准备工作</h4><p>根据<span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL3ZhdWx0LWNyZWRlbnRpYWwtbWFuYWdlci5odG1s"> The Vault credential manager<i class="fa fa-external-link-alt"></i></span>的描述，Concourse 会在 Vault 中按照以下的规则查找变量的值，并取出其中 <code>value</code> 这个 key 所对应的内容：</p><ul><li><code>/concourse/TEAM_NAME/PIPELINE_NAME/VAR_NAME</code></li><li><code>/concourse/TEAM_NAME/VAR_NAME</code></li></ul><p>以上文提到的那个 pipeline 为例子，我使用系统自带的 <code>main</code> 这个 team，并将这个 pipeline 命名为了 <code>parameters</code>，那么在寻找 <code>cat-name</code> 这个变量时，Concourse 就会先后在 <code>/concourse/main/parameters/cat-name</code> 和 <code>/concourse/main/cat-name</code> 中查找。</p><p>所以为了满足这个条件，我们需要在 Vault 中完成以下几件事：</p><ol><li>新建一个 secret engine，将其命名为 <code>concourse</code></li><li>新建一个 secret，path 填写 <code>main/parameters/cat-name</code>，secret data 新增一条 key 为 <code>value</code>，值为 <code>garfield</code> 的记录</li><li>再新建一个 secret，path 填写 <code>main/parameters/dog-name</code>，secret data 新增一条 key 为 <code>value</code>，值为 <code>odie</code> 的记录</li></ol><p>这样，就在 Vault 中设定好了变量的值。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>此时，我们回到 Concourse，触发这个 task 执行，如果配置正确的话，就可以看到这样的输出了：</p><p><img src="/images/concourse-using-vars/concourse-fetch-parameter-value-from-vault.png" alt="Fetch parameter value from Vault"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnLw==">Concourse CI<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2U=">Concourse - GitHub<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2V0dXRvcmlhbC5jb20v">Concourse Tutorial<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/concourse/concourse-using-vars.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>学习 Concourse CI - 快速入门</title>
      <link>https://www.boris1993.com/tools/concourse/concourse-quick-start.html</link>
      <guid>https://www.boris1993.com/tools/concourse/concourse-quick-start.html</guid>
      <pubDate>Tue, 10 Mar 2020 06:38:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近公司需要用到一个名叫 &lt;code&gt;Concourse CI&lt;/code&gt; 的 &lt;code&gt;CI/CD&lt;/code&gt; 工具，那么我当然就要学习一下啦。顺便还能水一篇，啊不，写一篇博客，当作学习过程中的笔记。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近公司需要用到一个名叫 <code>Concourse CI</code> 的 <code>CI/CD</code> 工具，那么我当然就要学习一下啦。顺便还能水一篇，啊不，写一篇博客，当作学习过程中的笔记。</p><a id="more"></a><h2 id="安装Concourse-CI"><a href="#安装Concourse-CI" class="headerlink" title="安装Concourse CI"></a>安装 Concourse CI</h2><p>Concourse 在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2UtZG9ja2Vy"> concourse-docker - GitHub<i class="fa fa-external-link-alt"></i></span>提供了现成的 <code>docker-compose</code> 配置文件。</p><p>首先需要克隆这个库：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/concourse/concourse-docker.git</span><br><span class="line">Cloning into <span class="string">'concourse-docker'</span>...</span><br><span class="line">remote: Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 388 (delta 0), reused 1 (delta 0), pack-reused 385</span><br><span class="line">Receiving objects: 100% (388/388), 66.29 KiB | 205.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (200/200), <span class="keyword">done</span>.</span><br></pre></td></tr></tbody></table></figure><p>进入 <code>concourse-docker</code>，分别执行下面两个命令完成密钥生成和系统启动：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> concourse-docker</span><br><span class="line"><span class="comment"># 生成密钥</span></span><br><span class="line">$ ./keys/generate</span><br><span class="line"><span class="comment"># 第一次运行时会先下载concourse的Docker镜像，Docker输出这里略掉</span></span><br><span class="line">wrote private key to /keys/session_signing_key</span><br><span class="line">wrote private key to /keys/tsa_host_key</span><br><span class="line">wrote ssh public key to /keys/tsa_host_key.pub</span><br><span class="line">wrote private key to /keys/worker_key</span><br><span class="line">wrote ssh public key to /keys/worker_key.pub</span><br><span class="line"><span class="comment"># 启动concourse</span></span><br><span class="line">$ docker-compose up -d</span><br><span class="line">Creating network <span class="string">"concourse-docker_default"</span> with the default driver</span><br><span class="line">Creating concourse-docker_db_1 ... <span class="keyword">done</span></span><br><span class="line">Creating concourse-docker_web_1 ... <span class="keyword">done</span></span><br><span class="line">Creating concourse-docker_worker_1 ... <span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p>然后，用浏览器打开 <code>http://localhost:8080</code>，检查 Concourse 是否启动成功。</p><h2 id="安装Fly-CLI"><a href="#安装Fly-CLI" class="headerlink" title="安装Fly CLI"></a>安装 Fly CLI</h2><p>虽然 Concourse 带有一个 Web 界面，但是我们在 Web 界面里面干不了什么，因为它的所有管理操作都需要通过它的 <code>Fly CLI</code> 来完成。</p><p>要安装 <code>Fly CLI</code>，你可以从刚才打开的 Dashboard 里面下载，也可以到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2UvcmVsZWFzZXM="> Concourse 的 GitHub Releases<i class="fa fa-external-link-alt"></i></span>中下载。</p><p>macOS 用户可能会想，我能不能用 <code>Homebrew</code> 来安装这个东西？一开始我也是这么想的，但是后面我发现，在 <code>Homebrew</code> 官方源里面的版本并没有随着 Concourse 的发布而更新，虽然我在 Issues 里翻出来一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhaHVsa2ovaG9tZWJyZXctdGFw">个人维护的 tap<i class="fa fa-external-link-alt"></i></span>，但最后还是不想用。</p><p>所以，最后我选择直接从 Dashboard 里面下载，然后将其移动到 <code>/usr/local/bin</code> 中。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>世间万物都可以从一个 hello world 学起，Concourse 也不例外。</p><p>首先，需要在 <code>Fly CLI</code> 中登陆。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ fly -t tutorial login -c http://localhost:8080 -u <span class="built_in">test</span> -p <span class="built_in">test</span></span><br><span class="line">logging <span class="keyword">in</span> to team <span class="string">'main'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target saved</span><br></pre></td></tr></tbody></table></figure><p>上面命令中，我们创建了一个叫做 <code>tutorial</code> 的目标 (target)，地址是 <code>http://localhost:8080</code>，也就是我们刚才启动的这个节点，以 <code>test:test</code> 登陆。如果要想看一下 <code>Fly CLI</code> 中已保存的 target，可以执行这条命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ fly targets</span><br><span class="line">name      url                    team  expiry</span><br><span class="line">tutorial  http://localhost:8080  main  Wed, 11 Mar 2020 07:40:34 UTC</span><br></pre></td></tr></tbody></table></figure><p>然后，我们跟着 Concourse Tutorial<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Concourse Tutorial](https://concoursetutorial.com/)">[3]</span></a></sup> 中 <code>Hello World</code> 一节的描述，把这个 task 执行起来。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/starkandwayne/concourse-tutorial.git</span><br><span class="line">Cloning into <span class="string">'concourse-tutorial'</span>...</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3794 (delta 0), reused 4 (delta 0), pack-reused 3789</span><br><span class="line">Receiving objects: 100% (3794/3794), 11.18 MiB | 25.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (2270/2270), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> concourse-tutorial/tutorials/basic/task-hello-world</span><br><span class="line">$ fly -t tutorial execute -c task_hello_world.yml</span><br><span class="line">uploading task-hello-world <span class="keyword">done</span></span><br><span class="line">executing build 1 at http://localhost:8080/builds/1</span><br><span class="line">initializing</span><br><span class="line">waiting <span class="keyword">for</span> docker to come up...</span><br><span class="line">Pulling busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d...</span><br><span class="line">sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d: Pulling from library/busybox</span><br><span class="line">0669b0daf1fb: Pulling fs layer</span><br><span class="line">0669b0daf1fb: Verifying Checksum</span><br><span class="line">0669b0daf1fb: Download complete</span><br><span class="line">0669b0daf1fb: Pull complete</span><br><span class="line">Digest: sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d</span><br><span class="line"></span><br><span class="line">Successfully pulled busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d.</span><br><span class="line"></span><br><span class="line">running <span class="built_in">echo</span> hello world</span><br><span class="line">hello world</span><br><span class="line">succeeded</span><br></pre></td></tr></tbody></table></figure><p>可以看到，Concourse 收到这个 task 之后，下载了一个 Busybox 的 Docker 镜像，然后执行了 <code>echo hello world</code> 这条命令。那么，Concourse 是怎么知道要如何执行一个 task 呢？这就得从上面运行的 <code>task_hello_world.yml</code> 说起了。</p><h2 id="一个task的配置文件"><a href="#一个task的配置文件" class="headerlink" title="一个task的配置文件"></a>一个 task 的配置文件</h2><p>Task 是 Concourse 的流水线 (pipeline) 中最小的配置单元，我们可以把它理解成一个函数，在我们配置好它的行为之后，它将永远按照这个固定的逻辑进行操作。</p><p>上面的 <code>task_hello_world.yml</code> 就是配置了一个 task 所要进行的操作，它的内容不多，我们一块一块拆开来看。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image_resource:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">  <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line"></span><br><span class="line"><span class="attr">run:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">echo</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">hello</span> <span class="string">world</span>]</span><br></pre></td></tr></tbody></table></figure><p><code>platform</code> 属性指定了这个 task 要运行在哪种环境下。需要注意，这里指的是 worker 运行的环境，比如这里指定的 <code>linux</code>，就意味着 Concourse 将会挑选一个运行在 Linux 中的 worker。</p><p><code>image_resource</code> 属性指定了这个 task 将会运行在一个镜像容器中。其中的 <code>type</code> 属性说明这个镜像是一个 Docker 镜像，<code>source</code> 中 <code>{repository: busybox}</code> 说明了要使用 Docker 仓库中的 <code>busybox</code> 作为基础镜像。</p><p><code>run</code> 属性就是这个 task 实际要执行的任务，其中的 <code>path</code> 指定了要运行的命令，这里可以是指向命令的绝对路径、相对路径，如果命令在 <code>$PATH</code> 中，那么也可以直接写命令的名称；<code>args</code> 就是要传递给这个命令的参数。</p><p>如果要执行的命令非常复杂，我们也可以把命令写在一个 shell 脚本中，然后在 <code>run.path</code> 中指向这个脚本，比如这样：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">run:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./hello-world.sh</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，就很清楚了。这个 task 会在一台 Linux 宿主机中执行，它将在一个 busybox 镜像中运行 <code>echo hello world</code> 这条命令。</p><h2 id="把多个task串起来"><a href="#把多个task串起来" class="headerlink" title="把多个task串起来"></a>把多个 task 串起来</h2><p>虽然我们在上面已经有了一个能用的 task，但是上面说了，task 只是一个 pipeline 的最小组成部分。而且在正式环境中，一个 CI/CD 任务可能会用到多个 task 来完成完整的构建任务。那么，怎么把多个 task 串起来呢？手动去做这件事显然不现实，所以就有了 pipeline。</p><p>这里我们还是用 Concourse Tutorial<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Concourse Tutorial](https://concoursetutorial.com/)">[3]</span></a></sup> 中的示例来演示。</p><p>首先我们先看一下这个配置文件的内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">job-hello-world</span></span><br><span class="line">    <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">hello-world</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">echo</span></span><br><span class="line">            <span class="attr">args:</span> [<span class="string">hello</span> <span class="string">world</span>]</span><br></pre></td></tr></tbody></table></figure><p>一个 pipeline 可以有多个 job，这些 job 决定了这个 pipeline 将会以怎样的形式来执行。而一个 job 中最重要的配置，是 plan，即需要执行的步骤。一个 plan 中的作业步，可以用来获取或更新某个资源，也可以用来执行某一个 task。</p><p>上面这个 pipeline 只有一个名为 <code>job-hello-world</code> 的 job，这个 job 里面只有一个作业步，名为 <code>hello-world</code>，是一个 task，操作是在一个 busybox 镜像中执行 <code>echo hello world</code> 命令。</p><p>在使用这个 pipeline 之前，我们需要把它注册到 Concourse 中。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t 指明要操作的target</span></span><br><span class="line"><span class="comment"># -c 指明pipeline的配置文件</span></span><br><span class="line"><span class="comment"># -p 指明pipeline的名字</span></span><br><span class="line">$ fly -t tutorial set-pipeline -c pipeline.yml -p hello-world</span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  job job-hello-world has been added:</span><br><span class="line">+ name: job-hello-world</span><br><span class="line">+ plan:</span><br><span class="line">+ - config:</span><br><span class="line">+     container_limits: {}</span><br><span class="line">+     image_resource:</span><br><span class="line">+       <span class="built_in">source</span>:</span><br><span class="line">+         repository: busybox</span><br><span class="line">+       <span class="built_in">type</span>: docker-image</span><br><span class="line">+     platform: linux</span><br><span class="line">+     run:</span><br><span class="line">+       args:</span><br><span class="line">+       - hello world</span><br><span class="line">+       path: <span class="built_in">echo</span></span><br><span class="line">+   task: hello-world</span><br><span class="line">+ public: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">apply configuration? [yN]: y</span><br><span class="line">pipeline created!</span><br><span class="line">you can view your pipeline here: http://localhost:8080/teams/main/pipelines/hello-world</span><br><span class="line"></span><br><span class="line">the pipeline is currently paused. to unpause, either:</span><br><span class="line">  - run the unpause-pipeline <span class="built_in">command</span>:</span><br><span class="line">    fly -t tutorial unpause-pipeline -p hello-world</span><br><span class="line">  - click play next to the pipeline <span class="keyword">in</span> the web ui</span><br></pre></td></tr></tbody></table></figure><p>现在一个新的 pipeline 就被注册到 Concourse 中了。在它的 Web UI 中也能看到这个 pipeline。</p><p><img src="/images/concourse-quick-start/concourse-with-pipeline.png" alt="Pipeline"></p><p>但是，这个 pipeline 现在还是暂停状态的，需要把它恢复之后才能使用。那么怎么恢复呢？其实上面 <code>set-pipeline</code> 操作的输出已经告诉我们了。</p><blockquote><p>the pipeline is currently paused. to unpause, either:<br>- run the unpause-pipeline command:<br><code>fly -t tutorial unpause-pipeline -p hello-world</code><br>- click play next to the pipeline in the web ui</p><p>这个 pipeline 目前是被暂停的，如果要恢复，可以使用下面两种方法之一：<br>- 运行 unpause-pipeline 命令：<br><code>fly -t tutorial unpause-pipeline -p hello-world</code><br>- 在 Web UI 中点击 pipeline 的播放按钮</p></blockquote><p>在成功恢复 pipeline 之后，我们可以看到原来蓝色的 paused 字样变成了灰色的 pending 字样，说明现在这个 pipeline 正在等待任务。</p><p>接下来我们就可以手动执行一下这个 pipeline，来检查它是否正常。具体操作说起来太啰嗦，我直接借用 Concourse Tutorial 里面的一个动图来替我说明。</p><p><img src="/images/concourse-quick-start/concourse-manually-run-pipeline.gif" alt="Manually start a pipeline"></p><h2 id="自动触发job"><a href="#自动触发job" class="headerlink" title="自动触发job"></a>自动触发 job</h2><p>虽然我们在 Web UI 上点一下加号就能触发 job 开始执行，但是 CI/CD 讲究的就是一个自动化，每次更新都手动去点一下，显然谁都受不了这么折腾。所以，Concourse 也提供了几种自动触发 job 执行的方法。</p><p>一种方法是向 Concourse API 发送一个 <code>POST</code> 请求。这种就是 webhook，没什么特殊的，在版本控制系统里面配置好 webhook 的参数就好了。</p><p>另一种方法是让 Concourse 监视某一个资源，在资源发生改变之后自动触发 job 执行。下面我详细说说这个功能。</p><p>这里我们假设一个场景：我们有一个 Git 仓库，里面有一个名为 <code>test.txt</code> 的文件。我们想在每次这个仓库收到新 commit 之后，打印出 <code>test.txt</code> 的内容。</p><p>按照这个思路，我在 Concourse 中注册了如下的 pipeline：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 先定义一个Git资源</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">resource-git-test</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="comment"># 这里换成你自己的一个Git仓库</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">https://gitee.com/boris1993/git-test.git</span></span><br><span class="line">      <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># 如果想要这个任务定期执行，那么可以在这里定义一个计时器</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timer</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">time</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="comment"># 这里定义这个计时器</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">2m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># 定义一个job</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">job-show-file-content</span></span><br><span class="line">    <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="comment"># 第一步：获取resource-git-test中定义的资源</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">resource-git-test</span></span><br><span class="line">        <span class="comment"># 在资源发生更新的时候触发</span></span><br><span class="line">        <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 如果要让任务定期重复执行，那么这里也要将定时器作为一个资源</span></span><br><span class="line">      <span class="comment"># 并打开trigger开关</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">timer</span></span><br><span class="line">        <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 第二步：在控制台打印文件内容</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">show-file-content</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">inputs:</span></span><br><span class="line">            <span class="comment"># resource-git-test中定义的资源将作为这个步骤的输入资源</span></span><br><span class="line">            <span class="comment"># 即让resource-git-test中的文件对该步骤可见</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">resource-git-test</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="comment"># 因为我们都懂的原因，Docker中心仓库有可能会连不上</span></span><br><span class="line">            <span class="comment"># 而在执行构建的时候，Concourse会到仓库检查镜像的版本</span></span><br><span class="line">            <span class="comment"># 所以这里用registry_mirror配置了一个Docker仓库的镜像站</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>, <span class="attr">registry_mirror:</span> <span class="string">https://dockerhub.azk8s.cn</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">cat</span></span><br><span class="line">            <span class="comment"># 在引入input资源后，工作目录下就可以看到这个资源相关的文件夹</span></span><br><span class="line">            <span class="attr">args:</span> [<span class="string">"./resource-git-test/test.txt"</span>]</span><br></pre></td></tr></tbody></table></figure><p>创建 <code>git-test</code> 仓库、编辑 <code>test.txt</code> 等等操作不是重点，也没啥难度，这里不啰嗦了。在完成编辑文件，和 push 到远程仓库后，我们等待 Concourse 检查远程仓库更新，并执行构建步骤。</p><p>在 pipeline 视图中点击 <code>resource-git-test</code> 这个资源，就可以看到这个资源的检查历史，展开某条记录后，还可以看到这条历史相关的构建。</p><p><img src="/images/concourse-quick-start/concourse-git-resource-trigger.png" alt="Git resource trigger"></p><p>在 Concourse 检查到 git 仓库的更新后，就会执行下面指定的构建步骤。结果大概会是这个样子的：</p><p><img src="/images/concourse-quick-start/concourse-git-resource-trigger-result.png" alt="Git resource trigger execution result"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>至此，我们完整的配置了一个简单的 pipeline。后面我会根据文档，或者根据工作中遇到的情况，继续补充权限管理、复杂的 case 等相关的博文。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnLw==">Concourse CI<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2U=">Concourse - GitHub<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2V0dXRvcmlhbC5jb20v">Concourse Tutorial<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/concourse/concourse-quick-start.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 的内部类和 private 修饰符</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-inner-class-and-private-identifier.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-inner-class-and-private-identifier.html</guid>
      <pubDate>Mon, 24 Feb 2020 13:38:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;一个 &lt;code&gt;private&lt;/code&gt; 属性只能被它所在的类访问，这件事地球人都知道。但是，你有没有想过，这条规则有没有可能在某种情况下，会变得不成立？&lt;/p&gt;
&lt;p&gt;本文将通过一个小例子，来演示怎么让 &lt;code&gt;private&lt;/code&gt; 修饰符 “失效”，以及它为什么会 “失效”。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一个 <code>private</code> 属性只能被它所在的类访问，这件事地球人都知道。但是，你有没有想过，这条规则有没有可能在某种情况下，会变得不成立？</p><p>本文将通过一个小例子，来演示怎么让 <code>private</code> 修饰符 “失效”，以及它为什么会 “失效”。</p><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>废话不多说，先写一段代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String outerClassName = <span class="string">"outerClass"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOuterClassName</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(outerClassName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        OuterClass.InnerClass innerClass = outerClass.<span class="function">new <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        innerClass.printOuterClassName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码是不是感觉有一丝异样？为什么在内部类里，能直接访问到外部类的 <code>private</code> 属性？难道 <code>private</code> 修饰符真的 “失效” 了？</p><p>别急，待我们把这个 class 反编译了，从字节码层面来看看它到底有什么猫腻。毕竟，字节码可不会骗人。</p><h2 id="反编译外部类"><a href="#反编译外部类" class="headerlink" title="反编译外部类"></a>反编译外部类</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c OuterClass.class</span><br><span class="line">Compiled from <span class="string">"OuterClass.java"</span></span><br><span class="line">public class com.boris1993.OuterClass {</span><br><span class="line">  public com.boris1993.OuterClass();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial <span class="comment">#2                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       4: aload_0</span><br><span class="line">       5: ldc           <span class="comment">#3                  // String outerClass</span></span><br><span class="line">       7: putfield      <span class="comment">#1                  // Field outerClassName:Ljava/lang/String;</span></span><br><span class="line">      10: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           <span class="comment">#4                  // class com/boris1993/OuterClass</span></span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial <span class="comment">#5                  // Method "&lt;init&gt;":()V</span></span><br><span class="line">       7: astore_1</span><br><span class="line">       8: new           <span class="comment">#6                  // class com/boris1993/OuterClass$InnerClass</span></span><br><span class="line">      11: dup</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: dup</span><br><span class="line">      14: invokevirtual <span class="comment">#7                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span></span><br><span class="line">      17: pop</span><br><span class="line">      18: invokespecial <span class="comment">#8                  // Method com/boris1993/OuterClass$InnerClass."&lt;init&gt;":(Lcom/boris1993/OuterClass;)V</span></span><br><span class="line">      21: astore_2</span><br><span class="line">      22: aload_2</span><br><span class="line">      23: invokevirtual <span class="comment">#9                  // Method com/boris1993/OuterClass$InnerClass.printOuterClassName:()V</span></span><br><span class="line">      26: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  static java.lang.String access<span class="variable">$000</span>(com.boris1993.OuterClass);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      <span class="comment">#1                  // Field outerClassName:Ljava/lang/String;</span></span><br><span class="line">       4: areturn</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有没有发现，78 行出现了一个我们没有写过的方法 <code>access$000</code>？而且从注释来看，它接受一个 <code>OuterClass</code> 类型的参数，而且返回的正是外部类的 <code>outerClassName</code> 的值。</p><p>既然我们没定义这个方法，那就是编译器偷偷的给咱整了点活。至于为啥编译器要这么干，结合上面这个例子，也不难猜出来：这就是给内部类访问它的 <code>private</code> 属性用的。</p><h2 id="反编译内部类"><a href="#反编译内部类" class="headerlink" title="反编译内部类"></a>反编译内部类</h2><p>但是咱不能光猜啊，咱还得有证据。证据哪来？当然是内部类的字节码。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c OuterClass<span class="variable">$InnerClass</span>.class</span><br><span class="line">Compiled from <span class="string">"OuterClass.java"</span></span><br><span class="line">public class com.boris1993.OuterClass<span class="variable">$InnerClass</span> {</span><br><span class="line">  final com.boris1993.OuterClass this<span class="variable">$0</span>;</span><br><span class="line"></span><br><span class="line">  public com.boris1993.OuterClass<span class="variable">$InnerClass</span>(com.boris1993.OuterClass);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: aload_1</span><br><span class="line">       2: putfield      <span class="comment">#1                  // Field this$0:Lcom/boris1993/OuterClass;</span></span><br><span class="line">       5: aload_0</span><br><span class="line">       6: invokespecial <span class="comment">#2                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       9: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public void printOuterClassName();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       3: aload_0</span><br><span class="line">       4: getfield      <span class="comment">#1                  // Field this$0:Lcom/boris1993/OuterClass;</span></span><br><span class="line">       7: invokestatic  <span class="comment">#4                  // Method com/boris1993/OuterClass.access$000:(Lcom/boris1993/OuterClass;)Ljava/lang/String;</span></span><br><span class="line">      10: invokevirtual <span class="comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      13: <span class="built_in">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>嗯，果然没错，在第 20 行这一条指令里，它调用了上面我们看到的那个 <code>access$000()</code> 方法。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9kcm9pZHl1ZS5jb20vYmxvZy8yMDE0LzEwLzAyL3RoZS1wcml2YXRlLW1vZGlmaWVyLWluLWphdmEv"> 细话 Java："失效" 的 private 修饰符<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-inner-class-and-private-identifier.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring bean 的作用域</title>
      <link>https://www.boris1993.com/projects/spring/java-spring-bean-scopes.html</link>
      <guid>https://www.boris1993.com/projects/spring/java-spring-bean-scopes.html</guid>
      <pubDate>Sat, 22 Feb 2020 03:00:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;在 Spring 中，那些由 IoC 容器所管理的对象被称之为 bean。而一个 bean 的定义，其实只是一个 “蓝图”，指导着 Spring 如何去创建这样一个 bean。而在这个蓝图中，有一个属性叫做 “作用域”，它规定了这个 bean 的可见范围。这里我们看一下 Spring 的 bean 都有哪些作用域。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 Spring 中，那些由 IoC 容器所管理的对象被称之为 bean。而一个 bean 的定义，其实只是一个 “蓝图”，指导着 Spring 如何去创建这样一个 bean。而在这个蓝图中，有一个属性叫做 “作用域”，它规定了这个 bean 的可见范围。这里我们看一下 Spring 的 bean 都有哪些作用域。</p><a id="more"></a><h2 id="支持的作用域"><a href="#支持的作用域" class="headerlink" title="支持的作用域"></a>支持的作用域</h2><p>我们先来看一下 Spring 支持哪些作用域。</p><table><thead><tr><th align="right">作用域</th><th>说明</th></tr></thead><tbody><tr><td align="right"> singleton</td><td> 在 Spring 容器中仅存在一个 bean 的实例，bean 以单例形式存在。这是默认的作用域</td></tr><tr><td align="right"> prototype</td><td> 每次从容器中获取 bean 时，都将生成一个新的实例，即相当于每次都执行 <code>new xxxBean()</code></td></tr><tr><td align="right">request</td><td> 在 HTTP 请求 (request) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicatonContext</code> 环境</td></tr><tr><td align="right"> session</td><td> 在 HTTP 会话 (session) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td></tr><tr><td align="right"> globalSession</td><td> 在全局的 HTTP 会话 (session) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境，且通常只能用在 <code>Portlet</code> 环境中。</td></tr><tr><td align="right">application</td><td> 在 <code>ServletContext</code> 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td></tr><tr><td align="right"> websocket</td><td> 在 <code>WebSocket</code> 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td></tr></tbody></table><h2 id="指定bean的作用域"><a href="#指定bean的作用域" class="headerlink" title="指定bean的作用域"></a>指定 bean 的作用域</h2><p>要指定一个 bean 的作用域，我们可以通过 XML 的方式或注解的方式来设定。</p><p>使用 XML 指定配置 bean 时，可以通过 <code>scope</code> 属性来指定作用域：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"someBean"</span> <span class="attr">class</span>=<span class="string">"com.demo.SomeClass"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>使用注解方式配置 bean 时，可以通过 <code>@Scope</code> 注解来指定作用域：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>{</span><br><span class="line">    <span class="comment">// Class definitions goes here</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此外，如果使用注解方式配置作用域，Spring 也提供了一系列常量值来方便我们配置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在ConfigurableBeanFactory类中</span></span><br><span class="line">String SCOPE_SINGLETON = <span class="string">"singleton"</span>;</span><br><span class="line">String SCOPE_PROTOTYPE = <span class="string">"prototype"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在WebApplicationContext类中</span></span><br><span class="line">String SCOPE_REQUEST = <span class="string">"request"</span>;</span><br><span class="line">String SCOPE_SESSION = <span class="string">"session"</span>;</span><br><span class="line">String SCOPE_APPLICATION = <span class="string">"application"</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="singleton作用域"><a href="#singleton作用域" class="headerlink" title="singleton作用域"></a>singleton 作用域</h2><p><code>singleton</code> 是 Spring 容器中的默认作用域。这个作用域下，容器中只创建各管理一个 bean 实例，实例存在于缓存中，并在后续对该 bean 的请求中都返回这个实例。</p><h2 id="prototype作用域"><a href="#prototype作用域" class="headerlink" title="prototype作用域"></a>prototype 作用域</h2><p>与 <code>singleton</code> 正相反，每次对 <code>prototype</code> 作用域的 bean 的请求，Spring 都会生成一个新的实例，即类似我们手动使用 <code>new XxxBean()</code> 方式创建实例。</p><p>需要注意的是，Spring 不会完整的管理一个 <code>prototype</code> 的 bean 的生命周期。容器在初始化、配置，并将 bean 交由请求方 (client) 之后，就撒手不管了。也就是说，在销毁一个 <code>prototype</code> 的 bean 时，销毁 bean 的回调方法是不会被调用的，所以在销毁一个 <code>prototype</code> 的 bean 时，开发者必须手动释放它所使用的资源，或者可以尝试使用一个自定义的 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension-bpp"><code>bean post-processor</code></a>来让 Spring 做这些事。</p><p>对于有状态的 bean，应当使用 <code>prototype</code> 作用域；对于无状态的 bean，则应当使用 <code>singleton</code> 作用域。</p><h2 id="向singleton-bean注入prototype-bean"><a href="#向singleton-bean注入prototype-bean" class="headerlink" title="向singleton bean注入prototype bean"></a>向 singleton bean 注入 prototype bean</h2><p>因为 bean 的依赖关系在实例化 bean 时才会被解析，所以通常来说，我们不可以将一个 prototype bean 注入到一个 singleton bean 中。</p><p>如果我们向一个 singleton bean 中注入一个 prototype bean，因为这个 singleton bean 只会被实例化一次，使得它的依赖也只会被注入一次，最终导致它依赖的那个 singleton bean 也只存在一个实例。</p><h2 id="request、session、global-session、application和websocket作用域"><a href="#request、session、global-session、application和websocket作用域" class="headerlink" title="request、session、global session、application和websocket作用域"></a>request、session、global session、application 和 websocket 作用域</h2><p>这几种作用域只能用在 <code>web-aware</code> 的 Spring 上下文中，比如 <code>XmlWebApplicationContext</code>。如果用在一般的 IoC 容器中，比如 <code>ClassPathXmlApplicationContext</code> 中，那么容器会抛出一个 <code>IllegalStateException</code>。</p><p>要使用这几个作用域，你可能需要对你的应用进行一些配置。因为这些内容与本文无关，所以在这里就不详细说明了。感兴趣的话可以看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy9jdXJyZW50L3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL2NvcmUuaHRtbCNiZWFucy1mYWN0b3J5LXNjb3Blcy1vdGhlci13ZWItY29uZmlndXJhdGlvbg=="> Spring 参考手册中的内容<i class="fa fa-external-link-alt"></i></span>。</p><p>注：<code>web-aware</code> 这个词，我也不知道怎么翻译才合适。查阅了一些资料之后，感觉一个 <code>web-aware</code> 的 Spring 应用就是一个运行在 web 容器 (比如 Tomcat) 中的应用，因为上面提到的这些作用域也是与 web 应用相关的。如果有好的理解，请一定在留言区写下来让在下知道。</p><h3 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request 作用域</h3><p><code>request</code> 作用域下的 bean，在每次 HTTP 请求中，都会创建一个新的实例。当请求完成时，对应的 bean 就会被销毁。对一个实例的任何更改，对其他的所有实例来说都是不可见的。</p><h3 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session 作用域</h3><p><code>session</code> 作用域下的 bean，在每个活动的 HTTP 会话中，都有一个独自的实例，而当会话结束后，对应的 bean 就会被销毁。对一个实例的任何更改，对其他所有的实例来说都是不可见的。</p><h3 id="globalSession作用域"><a href="#globalSession作用域" class="headerlink" title="globalSession作用域"></a>globalSession 作用域</h3><p>这个作用域只能用在 <code>portlet</code> 应用中。一个 <code>portlet</code> 站点中可能有多个 <code>portlet</code> 应用，而它们相关的 session 中都会共享同一个 <code>globalSession</code> 作用域的 bean。</p><p>注：其实我也不知道 <code>portlet</code> 到底是个啥，就算看过维基百科的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmF2YV9Qb3J0bGV0X1NwZWNpZmljYXRpb24="> Portlet 条目<i class="fa fa-external-link-alt"></i></span>也没看明白。</p><h3 id="application作用域"><a href="#application作用域" class="headerlink" title="application作用域"></a>application 作用域</h3><p>在整个应用范围内，容器为每个 web 应用程序运行时创建一个实例。这个作用域与 <code>singleton</code> 很类似，但是还是有两个不同点：</p><ul><li>在不同 <code>ServletContext</code> 中有不同的 bean 单例对象；singleton 作用域的 bean 是每个 <code>ApplicationContext</code> 的单例对象。而一个应用可能有多个 <code>ApplicationContext</code></li><li>bean 作为 <code>ServletContext</code> 属性可见</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy9jdXJyZW50L3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL2NvcmUuaHRtbCNiZWFucy1mYWN0b3J5LXNjb3Blcw==">Bean Scopes - The IoC container<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGFkMTQ1NWYyNjVkYTViNjAwNmZhNmE=">Spring 系列四：Bean Scopes 作用域<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljYXJ1c193YW5nL2FydGljbGUvZGV0YWlscy81MTU4Njc3Ng==">Spring 学习（十五）Spring Bean 的 5 种作用域介绍<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/spring/java-spring-bean-scopes.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot 自动配置的原理</title>
      <link>https://www.boris1993.com/projects/spring/java-spring-autoconfiguration.html</link>
      <guid>https://www.boris1993.com/projects/spring/java-spring-autoconfiguration.html</guid>
      <pubDate>Thu, 20 Feb 2020 02:00:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;在使用 Spring Boot 时，最使我们收益的一个功能就是它的自动配置。但是，用了这么久的自动配置功能，有没有想过它是怎么实现的？本文将从源码入手，一步一步搞明白 Spring Boot 自动配置的原理。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在使用 Spring Boot 时，最使我们收益的一个功能就是它的自动配置。但是，用了这么久的自动配置功能，有没有想过它是怎么实现的？本文将从源码入手，一步一步搞明白 Spring Boot 自动配置的原理。</p><a id="more"></a><p>我这里就用一个简单的 Eureka server 的项目来举例。实际上只要是个 Spring Boot 项目就可以，我只是懒得再创建一个新的项目了。</p><p>它的启动代码我们都很熟悉，是这样子的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(EurekaServer.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>东西很简单，一共就这么几行。我们看看 <code>@SpringBootApplication</code> 里面有什么？</p><h2 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication 注解</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {</span><br><span class="line">    <span class="comment">// 因为里面的属性与本文关系不大，所以就略掉了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我们可以看到一个 <code>@EnableAutoConfiguration</code> 注解，顾名思义，这个注解是用来开启自动配置的。我们继续深入进去看看。</p><h2 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration 注解</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration {</span><br><span class="line"></span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">     * applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个注解上面还有一大段的 JavaDoc，因为篇幅太长，就不把全文放上来了。翻译过来的大意是这样的：</p><blockquote><p>这个注解可以启用 Spring 应用上下文的自动配置。开启这个配置后，Spring 将会尝试猜测你需要的类，并进行配置。Spring 通常会根据 ClassPath 和用户定义的 bean 来完成自动配置的操作。<br>举例来说，如果在你的 ClassPath 中出现了 tomcat-embedded.jar，那么你很可能会需要 TomcatServletWebServerFactory 这个类，除非你自己定义了 ServletWebServerFactory。</p></blockquote><p>看完 JavaDoc，我们大概知道了 Spring 是怎么判断哪些类需要自动配置。那么我们继续深入源码。</p><p>这里有两个注解比较重要：<code>@Import(AutoConfigurationImportSelector.class)</code> 和 <code>@AutoConfigurationPackage</code>。</p><h2 id="AutoConfigurationImportSelector类"><a href="#AutoConfigurationImportSelector类" class="headerlink" title="AutoConfigurationImportSelector类"></a>AutoConfigurationImportSelector 类</h2><p>Spring Boot 应用启动过程中使用 <code>ConfigurationClassParser</code> 分析配置类时，如果发现注解中存在 <code>@Import(ImportSelector)</code> 的情况，就会创建一个相应的 <code>ImportSelector</code> 对象， 并调用其方法 <code>public String[] selectImports(AnnotationMetadata annotationMetadata)</code>。所以我们就从 <code>selectImports</code> 方法开始看起。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从META-INF/spring-autoconfigure-metadata.properties中加载AutoConfigurationMetaData</span></span><br><span class="line">    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取自动配置项</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面方法通过 <code>getAutoConfigurationEntry</code> 获取到了需要自动配置的项，那么它是怎么知道哪些东西需要自动配置的呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the {<span class="doctag">@link</span> AutoConfigurationEntry} based on the {<span class="doctag">@link</span> AnnotationMetadata}</span></span><br><span class="line"><span class="comment"> * of the importing {<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>} class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoConfigurationMetadata the auto-configuration metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到注解里面的属性</span></span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到需要自动配置的类，并去重</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得要排除在自动配置之外的类的列表，并将其排除</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用过滤器AutoConfigurationImportFilter</span></span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播自动配置事件</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面我们看到，Spring Boot 通过 <code>getCandidateConfigurations</code> 方法找到了需要自动配置的类，那么它又是怎么工作的呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the auto-configuration class names that should be considered. By default</span></span><br><span class="line"><span class="comment"> * this method will load candidates using {<span class="doctag">@link</span> SpringFactoriesLoader} with</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #getSpringFactoriesLoaderFactoryClass()}.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the source metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes the {<span class="doctag">@link</span> #getAttributes(AnnotationMetadata) annotation</span></span><br><span class="line"><span class="comment"> * attributes}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list of candidate configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>{</span><br><span class="line">    <span class="comment">// 扫描ClassPath中所有的META-INF/spring.factories，并从中获取所有自动配置的类名</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">            + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the class used by {<span class="doctag">@link</span> SpringFactoriesLoader} to load configuration</span></span><br><span class="line"><span class="comment"> * candidates.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the factory class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() {</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">getBeanClassLoader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanClassLoader;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面 <code>getCandidateConfigurations</code> 方法又调用了 <code>loadFactoryNames</code> 方法来获取 <code>EnableAutoConfiguration</code> 注解相关的工厂类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The location to look for factories.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from {<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION}, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> null} to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>{</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上文我们知道，factoryClass传入的是EnableAutoConfiguration.class</span></span><br><span class="line">    <span class="comment">// 所以这里就是从spring.factories中寻找org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的自动配置类</span></span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从ClassPath中寻找所有spring.factories文件，并将其包装成一个Properties对象</span></span><br><span class="line"><span class="comment"> * 然后把Properties对象里面的各个条目包装到一个Map&lt;String, List&lt;String&gt;&gt;对象中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) {</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) {</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {</span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>这里我们用 <code>RedisAutoConfiguration</code> 类来说明一个具体的自动配置类是如何工作的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> EnableAutoConfiguration Auto-configuration} for Spring Data's Redis support.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andy Wilkinson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christian Dupuis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christoph Strobl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eddú Meléndez</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stephane Nicoll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Marco Aust</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Paluch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 说明这是一个配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span> <span class="comment">// 当RedisOperations类存在时这个配置类才会生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span> <span class="comment">// 将配置文件的字段与RedisProperties类绑定</span></span><br><span class="line"><span class="meta">@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })</span> <span class="comment">// 导入两个Redis连接池的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>{</span><br><span class="line">    <span class="comment">// 这里是初始化redisTemplate和stringRedisTemplate的代码，因为与本文无关，所以略掉了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据上文我们了解到的内容，我们可以推测出它是这样子被初始化的：</p><ul><li>首先 Spring 在 <code>spring.factories</code> 中，根据 <code>EnableAutoConfiguration</code> 发现了 <code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code></li><li>然后 Spring 会检查 <code>RedisOperations</code> 类是否存在于 ClassPath 中</li><li>如果存在，则会从配置文件的 <code>spring.redis</code> 字段中取值，并初始化 <code>RedisProperties</code></li><li>然后根据 <code>LettuceConnectionConfiguration</code> 和 <code>JedisConnectionConfiguration</code> 中的条件，选择使用哪个连接池，并将其初始化</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上文的分析，我们知道了 Spring 在启动时，会加载一系列的配置类，并会根据配置类中指定的条件，来决定是否对其实施自动配置。</p><p><code>xxAutoConfigurartion</code> 这样的类是自动配置类，用于向容器中添加组件。</p><p><code>xxProperties</code> 这样的类是属性类，用于封装配置文件中的属性，并规定了 Spring 应该从配置文件的哪个字段取值用于初始化。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/spring/java-spring-autoconfiguration.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>解决命令行中 Git 显示中文文件名乱码</title>
      <link>https://www.boris1993.com/tools/git/git-commandline-unescape-chinese-characters.html</link>
      <guid>https://www.boris1993.com/tools/git/git-commandline-unescape-chinese-characters.html</guid>
      <pubDate>Mon, 10 Feb 2020 02:15:34 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;在用 Git 管理包含中文的文件时，会出现类似这样的 “乱码”：&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在用 Git 管理包含中文的文件时，会出现类似这样的 “乱码”：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">    <span class="string">"\345\271\277\345\221\212\345\220\214\346\255\245\345\271\263\345\217\260\346\216\245\345\217\243\346\226\207\346\241\2432.0.docx.new"</span></span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></tbody></table></figure><p>解决方法是配置 Git 的全局属性 <code>core.quotepath</code> 为 <code>false</code>，即执行命令 <code>git config --global core.quotepath false</code>，然后再执行 <code>git status</code>，就可以看到中文正常显示了：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">    广告同步平台接口文档2.0.docx.new</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></tbody></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/tools/git/git-commandline-unescape-chinese-characters.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 VisualVM 监控应用 GC</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/monitor-gc-with-visual-vm.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/monitor-gc-with-visual-vm.html</guid>
      <pubDate>Sun, 09 Feb 2020 09:38:42 GMT</pubDate>
      <description>
      
        &lt;p&gt;我们知道，使用 VisualVM 可以监控 Java 应用的各种运行时信息，包括资源占用、正在运行的线程等等。本文将简单介绍如何使用 VisualVM 的插件 &lt;code&gt;Visual GC&lt;/code&gt; 来监控 Java 应用的垃圾回收情况。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们知道，使用 VisualVM 可以监控 Java 应用的各种运行时信息，包括资源占用、正在运行的线程等等。本文将简单介绍如何使用 VisualVM 的插件 <code>Visual GC</code> 来监控 Java 应用的垃圾回收情况。</p><a id="more"></a><h2 id="安装Visual-GC插件"><a href="#安装Visual-GC插件" class="headerlink" title="安装Visual GC插件"></a>安装 <code>Visual GC</code> 插件</h2><p>因为 <code>Visual GC</code> 插件并不是随 VisualVM 附带的，需要到插件商店下载。</p><p>点击 <code>Tools</code>–&gt;<code>Plugins</code> 打开插件管理窗口，进入 <code>Available Plugins</code>，在左侧窗格中勾选 <code>Visual GC</code>，点击 <code>Install</code>，同意许可协议后，稍等片刻即可完成安装。安装完成之后无需重启 VisualVM。</p><p><img src="/images/monitor-gc-with-visualvm/install-visual-gc.png" alt="Install Visual GC"></p><h2 id="监控垃圾回收"><a href="#监控垃圾回收" class="headerlink" title="监控垃圾回收"></a>监控垃圾回收</h2><p>安装完成后，在 VisualVM 的 <code>Applications</code> 窗格中双击要监控的应用，然后在右侧窗格中进入 <code>Visual GC</code>，即可以图形化的方式查看当前该应用中各个内存区域的情况。</p><p><img src="/images/monitor-gc-with-visualvm/monitor-gc.png" alt="Monitor GC"></p><p>窗格中的 <code>Spaces</code> 部分展示的是当前各个区域的占用情况；<code>Graphs</code> 部分则包括：</p><ul><li><code>Compile Time</code>：编译时间，包括编译的次数，和累计的编译时间。图表中的一次脉冲就代表一次编译，脉冲越宽代表编译时间越长</li><li><code>Class Loader Time</code>：类加载时间，包括加载了多少个类 (<code>loaded</code>)，卸载了多少个类 (<code>unloaded</code>)，和累计用于类加载的时间</li><li><code>GC Time</code>：垃圾回收时间，包括垃圾回收的次数，垃圾回收消耗的时间，和上一次垃圾回收的原因</li><li><code>Eden Space</code>：Eden 区的空间，括号中第一位是最大容量，第二位是当前容量，其后冒号跟着的是当前使用了的大小，再往后是发生垃圾回收的次数，和垃圾回收消耗的时间</li><li><code>Survivor 0</code> 和 <code>Survivor 1</code>：两个 <code>Survivor</code> 区的空间，同样包括最大容量、当前容量，和当前使用了的大小</li><li><code>Old Gen</code>：老年代的空间，同样包括最大容量、当前容量、当前使用了的大小、发生垃圾回收的次数，和垃圾回收消耗的时间</li><li><code>Metaspace</code>：Metaspace 的空间 (如果使用的是 Java 1.7 及之前版本，这里则是 <code>Perm Gen</code>)，包括最大容量、当前容量，和当前使用了的大小</li></ul>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/monitor-gc-with-visual-vm.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>简谈 JVM 中的几种引用</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-jvm-reference.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-jvm-reference.html</guid>
      <pubDate>Fri, 07 Feb 2020 03:36:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;在 &lt;a href=&quot;/projects/java/fundamentals/java-gc-algorithms.html&quot;&gt;Java 的垃圾回收算法&lt;/a&gt;一文中，我们知道 JVM 是根据一个对象有没有被引用来判断要不要对其进行垃圾回收的。但是，如果我们为了提升垃圾回收的效率，想要再把垃圾回收的条件更细化一些，比如只在内存非常紧张的时候才回收某些对象，那么光靠一个粗略的 “引用”，就显得心有余而力不足了。所以，在 &lt;code&gt;JDK 1.2&lt;/code&gt; 版本之后，Java 扩充了引用的概念，将其扩充成了&lt;code&gt;强引用&lt;/code&gt;，&lt;code&gt;软引用&lt;/code&gt;，&lt;code&gt;弱引用&lt;/code&gt;，&lt;code&gt;虚引用&lt;/code&gt;四个更细化的概念。&lt;/p&gt;
&lt;p&gt;本文将参考《深入理解 Java 虚拟机 (第 3 版)》中&lt;code&gt;再谈引用&lt;/code&gt;一节，简述一下这四种引用的概念，以及被引用的对象何时会被垃圾回收器回收。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 <a href="/projects/java/fundamentals/java-gc-algorithms.html">Java 的垃圾回收算法</a>一文中，我们知道 JVM 是根据一个对象有没有被引用来判断要不要对其进行垃圾回收的。但是，如果我们为了提升垃圾回收的效率，想要再把垃圾回收的条件更细化一些，比如只在内存非常紧张的时候才回收某些对象，那么光靠一个粗略的 “引用”，就显得心有余而力不足了。所以，在 <code>JDK 1.2</code> 版本之后，Java 扩充了引用的概念，将其扩充成了<code>强引用</code>，<code>软引用</code>，<code>弱引用</code>，<code>虚引用</code>四个更细化的概念。</p><p>本文将参考《深入理解 Java 虚拟机 (第 3 版)》中<code>再谈引用</code>一节，简述一下这四种引用的概念，以及被引用的对象何时会被垃圾回收器回收。</p><a id="more"></a><h2 id="强引用-Strongly-reference"><a href="#强引用-Strongly-reference" class="headerlink" title="强引用(Strongly reference)"></a>强引用 (Strongly reference)</h2><p>强引用是最传统的 “引用” 的定义，指在代码中普遍存在的引用赋值，比如 <code>Object obj = new Object()</code>。不论在任何情况下，只要强引用关系存在，那么垃圾回收器就永远不会回收掉被引用的对象。</p><h2 id="软引用-Soft-reference"><a href="#软引用-Soft-reference" class="headerlink" title="软引用(Soft reference)"></a>软引用 (Soft reference)</h2><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象纳入回收范围进行第二次回收，如果在回收之后仍没有足够的内存，才会抛出内存溢出异常。在 <code>JDK 1.2</code> 版本之后提供了 <code>SoftReference</code> 类来实现软引用。</p><p>软引用对象可以用在类似缓存的场景中，比如在一个图片编辑器中，应用可以将用户打开的文件读入一个软引用对象。</p><p>如果要创建一个软引用对象，那么可以使用如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; stringSoftReference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="string">"string"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="弱引用-Weak-reference"><a href="#弱引用-Weak-reference" class="headerlink" title="弱引用(Weak reference)"></a>弱引用 (Weak reference)</h2><p>弱引用也是用来被描述非必须的对象，但它的强度比软引用要更弱一些。被弱引用关联的对象只能生存到下一次垃圾回收发生时。当垃圾回收器开始工作后，无论当前剩余内存是否足够，被弱引用关联的对象都会被回收掉。在 <code>JDK 1.2</code> 版本之后提供了 <code>WeakReference</code> 类来实现弱引用。</p><p>弱引用常见于一些集合类中，尤其在哈希表中。因为哈希表的接口允许用户使用任何 Java 对象作为 key 来使用，而当一个键值被存入哈希表后，哈希表本身就有了对这些键和值的引用。如果这些引用是强引用，那么只要这个哈希表对象存活，哈希表关联的键和值也就永远不会被回收。如果这个哈希表同时又包含了大量的对象，那么就可能会长时间占用服务器的大量内存。这类问题的解决办法就是使用弱引用来关联这些对象，比如使用 <code>WeakHashMap</code>。</p><p>如果要创建一个弱引用对象，那么可以使用如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; stringWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="string">"string"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="虚引用-Phantom-reference"><a href="#虚引用-Phantom-reference" class="headerlink" title="虚引用(Phantom reference)"></a>虚引用 (Phantom reference)</h2><p>虚引用也叫 “幽灵引用” 或 “幻影引用”，是最弱的一种引用。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，同时用户也无法通过一个虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个系统通知。在 <code>JDK 1.2</code> 版本之后提供了 <code>PhantomReference</code> 类来实现虚引用。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMzIwMDI0NA==">Java 强软弱虚引用介绍及使用场景<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWpvcmNlbi9wLzM5NjgwMTguaHRtbA==">java 中四种引用类型<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-jvm-reference.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>看懂 ParallelGC 的日志</title>
      <link>https://www.boris1993.com/projects/java/fundamentals/java-understand-parallel-gc-logs.html</link>
      <guid>https://www.boris1993.com/projects/java/fundamentals/java-understand-parallel-gc-logs.html</guid>
      <pubDate>Wed, 05 Feb 2020 06:45:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;在排查垃圾回收相关的问题时，一个必不可少的技能就是要能看懂 Java 的垃圾回收日志。本文将介绍打印 GC 日志相关的 JVM 参数，以及使用不同参数时 JVM 将会打印出的日志内容。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在排查垃圾回收相关的问题时，一个必不可少的技能就是要能看懂 Java 的垃圾回收日志。本文将介绍打印 GC 日志相关的 JVM 参数，以及使用不同参数时 JVM 将会打印出的日志内容。</p><a id="more"></a><h2 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK 版本</h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version "1.8.0_232"</span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_232-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.232-b09, mixed mode)</span><br></pre></td></tr></tbody></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>在演示过程中，我们将通过在死循环中构造大对象的方式来触发垃圾回收</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCExample</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String[] strings;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            strings = <span class="keyword">new</span> String[<span class="number">1024</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同时，为了让垃圾回收更早的开始，我们还需要指定一个较小的堆内存，比如我选择只分配 10MB 的空间。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10m</span><br><span class="line">-Xms10m</span><br></pre></td></tr></tbody></table></figure><h2 id="GC日志相关的JVM参数"><a href="#GC日志相关的JVM参数" class="headerlink" title="GC日志相关的JVM参数"></a>GC 日志相关的 JVM 参数</h2><p>与 GC 日志相关的 JVM 参数有如下 8 个：</p><table><thead><tr><th>参数名</th><th>参数含义</th></tr></thead><tbody><tr><td> -XX:+PrintGC</td><td> 输出简要 GC 日志</td></tr><tr><td> -verbose:gc</td><td> 等同于 -XX:+PrintGC</td></tr><tr><td>-XX:+PrintGCDetails</td><td> 输出详细 GC 日志</td></tr><tr><td> -Xloggc:gc.log</td><td> 输出 GC 日志到文件 gc.log</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td> 输出 GC 的时间戳（以 JVM 启动到当期的总时长的时间戳形式）</td></tr><tr><td>-XX:+PrintGCDateStamps</td><td> 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td> 在进行 GC 的前后打印出堆的信息</td></tr><tr><td> -XX:+PrintReferenceGC</td><td> 打印年轻代各个引用的数量以及时长</td></tr></tbody></table><h3 id="XX-PrintGC与-verbose-gc"><a href="#XX-PrintGC与-verbose-gc" class="headerlink" title="-XX:+PrintGC与-verbose:gc"></a><code>-XX:+PrintGC</code> 与 <code>-verbose:gc</code></h3><p>虽然上面说这两个参数是等价的，但是，<code>-verbose:gc</code> 是一个标准的参数，而 <code>-XX:+PrintGC</code> 则在 JDK 9 之后被标为废弃的 (deprecated)，所以建议使用 <code>-verbose:gc</code> 代替 <code>-XX:+PrintGC</code>。</p><h2 id="打开-verbose-gc"><a href="#打开-verbose-gc" class="headerlink" title="打开-verbose:gc"></a>打开 <code>-verbose:gc</code></h2><p>使用这个参数将会打开简略的 GC 日志。打开这个参数并运行程序，很快就可以看到这样的 GC 日志：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  2520K-&gt;472K(9728K), 0.0005722 secs]</span><br></pre></td></tr></tbody></table></figure><p>我们将上面的日志拆分开来：</p><ul><li><code>GC</code> 代表这次垃圾回收的类型。<code>GC</code> 代表发生了 <code>Minor GC</code>，<code>Full GC</code> 代表发生了 <code>Full GC</code></li><li><code>Allocation Failure</code> 简述了发生 GC 的原因。在这个例子中，是因为在年轻代中没有合适的空间导致新的对象分配失败，从而发生 GC</li><li><code>2520K-&gt;472K</code> 说明了年轻代的占用量变化。在这个例子中，年轻代的使用量从 2520KB 减少到了 472KB</li><li><code>9728K</code> 表示整个堆的大小</li><li><code>0.0005722 secs</code> 表示了本次 GC 消耗的时间</li></ul><h2 id="打开-XX-PrintGCDetails"><a href="#打开-XX-PrintGCDetails" class="headerlink" title="打开-XX:+PrintGCDetails"></a>打开 <code>-XX:+PrintGCDetails</code></h2><p>使用这个参数后，将会打印详细的 GC 日志，它打印的内容包含了 <code>-verbose:gc</code> 参数打印的内容。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 2500K-&gt;452K(9728K), 0.0003785 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure><p>这个参数打印的日志与上一个参数打印的日志有一部分重合，这里我们关注新增的内容：</p><ul><li><code>[PSYoungGen: 2048K-&gt;0K(2560K)]</code> 表明了使用的垃圾回收器、年轻代的占用量变化，和年轻代的大小</li><li><code>2500K-&gt;452K(9728K)</code> 表明了整个堆的占用量变化，和整个堆的大小</li><li><code>[Times: user=0.00 sys=0.00, real=0.00 secs]</code> 表示本次 GC 消耗的时间<ul><li><code>user</code> 代表垃圾回收器消耗的 CPU 时间</li><li><code>sys</code> 代表系统调用或等待系统事件消耗的时间</li><li><code>real</code> 代表应用实际停止的时间，近似于 <code>(user + sys) / 垃圾回收器使用的线程数</code></li></ul></li></ul><h2 id="打开-XX-PrintGCTimeStamps"><a href="#打开-XX-PrintGCTimeStamps" class="headerlink" title="打开-XX:+PrintGCTimeStamps"></a>打开 <code>-XX:+PrintGCTimeStamps</code></h2><p>这个参数不影响日志的详细程度，在打开之后，日志中会出现从 JVM 启动到出现日志时的毫秒数，比如下面例子的 <code>1.523</code>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.523: [GC (Allocation Failure) [PSYoungGen: 2141K-&gt;96K(2560K)] 4805K-&gt;2776K(9728K), 0.0004359 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure><h2 id="打开-XX-PrintGCDateStamps"><a href="#打开-XX-PrintGCDateStamps" class="headerlink" title="打开-XX:+PrintGCDateStamps"></a>打开 <code>-XX:+PrintGCDateStamps</code></h2><p>这个参数也不影响日志的详细程度，在打开之后，日志头部会加上打印日志的时间和时区，比如下面例子的 <code>2020-02-06T10:13:08.634-0800</code>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-02-06T10:13:08.634-0800: 1.122: [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 3328K-&gt;1280K(9728K), 0.0004243 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure><h2 id="打开-XX-PrintHeapAtGC"><a href="#打开-XX-PrintHeapAtGC" class="headerlink" title="打开-XX:+PrintHeapAtGC"></a>打开 <code>-XX:+PrintHeapAtGC</code></h2><p>使用这个参数后，在打印 GC 日志时，会同时打印出堆在 GC 前后的信息，即根据不同的内存区域，分别显示在垃圾回收前后的空间使用情况。同时，日志中还以 <code>[bottom,top,end)</code> 的格式展现出了各个内存区域的地址，其中 <code>bottom</code> 为这个区域的起始位置，<code>top</code> 为这个区域当前的顶部位置，<code>end</code> 为这个区域可使用的地址上限 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Meaning of heap memory addresses in GC logs using -XX:+PrintHeapAtGC?](https://stackoverflow.com/questions/28344451/meaning-of-heap-memory-addresses-in-gc-logs-using-xxprintheapatgc)">[1]</span></a></sup>。</p><p>此外，日志中关于 <code>Metaspace</code> 相关的信息可以参考注脚 4<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Understanding metaspace line in JVM heap printout](https://stackoverflow.com/questions/40891433/understanding-metaspace-line-in-jvm-heap-printout)">[4]</span></a></sup> 指向的那篇回答。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">{Heap before GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 2560K, used 2047K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 99% used [0x00000007bfd00000,0x00000007bfeffe78,0x00000007bff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 0K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf600000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 3045K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 320K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">2020-02-06T10:21:05.317-0800: 0.219: [GC (Allocation Failure) [PSYoungGen: 2047K-&gt;496K(2560K)] 2047K-&gt;512K(9728K), 0.0019061 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span><br><span class="line">Heap after GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 2560K, used 496K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 0% used [0x00000007bfd00000,0x00000007bfd00000,0x00000007bff00000)</span><br><span class="line">  from space 512K, 96% used [0x00000007bff00000,0x00000007bff7c010,0x00000007bff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line"> ParOldGen       total 7168K, used 16K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf604000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 3045K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 320K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="打开-XX-PrintReferenceGC"><a href="#打开-XX-PrintReferenceGC" class="headerlink" title="打开-XX:+PrintReferenceGC"></a>打开 <code>-XX:+PrintReferenceGC</code></h2><p>打开这个参数后，就可以看到各种引用的数量，以及对其垃圾回收所消耗的时长。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [SoftReference, 0 refs, 0.0000125 secs][WeakReference, 0 refs, 0.0000054 secs][FinalReference, 0 refs, 0.0000045 secs][PhantomReference, 0 refs, 0 refs, 0.0000222 secs][JNI Weak Reference, 0.0000037 secs][PSYoungGen: 2112K-&gt;64K(2560K)] 3488K-&gt;1456K(9728K), 0.0005389 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjgzNDQ0NTEvbWVhbmluZy1vZi1oZWFwLW1lbW9yeS1hZGRyZXNzZXMtaW4tZ2MtbG9ncy11c2luZy14eHByaW50aGVhcGF0Z2M=">Meaning of heap memory addresses in GC logs using -XX:+PrintHeapAtGC?<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9wbHVtYnIuaW8vaGFuZGJvb2svZ2FyYmFnZS1jb2xsZWN0aW9uLWFsZ29yaXRobXMtaW1wbGVtZW50YXRpb25zL3BhcmFsbGVsLWdj">Parallel GC - Plumber<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9wbHVtYnIuaW8vaGFuZGJvb2svZ2FyYmFnZS1jb2xsZWN0aW9uLWFsZ29yaXRobXMtaW1wbGVtZW50YXRpb25zL3BhcmFsbGVsLWdjL3BhcmFsbGVsLWZ1bGwtZ2M=">Parallel Full GC - Plumber<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDA4OTE0MzMvdW5kZXJzdGFuZGluZy1tZXRhc3BhY2UtbGluZS1pbi1qdm0taGVhcC1wcmludG91dA==">Understanding metaspace line in JVM heap printout<i class="fa fa-external-link-alt"></i></span><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/fundamentals/java-understand-parallel-gc-logs.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 源码阅读 - HashMap</title>
      <link>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashmap.html</link>
      <guid>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashmap.html</guid>
      <pubDate>Mon, 06 Jan 2020 08:51:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。&lt;/p&gt;
&lt;p&gt;这次就来阅读一下 &lt;code&gt;HashMap&lt;/code&gt; 的源码。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p><p>这次就来阅读一下 <code>HashMap</code> 的源码。</p><a id="more"></a><h2 id="HashMap的特性"><a href="#HashMap的特性" class="headerlink" title="HashMap的特性"></a>HashMap 的特性</h2><p><code>HashMap</code> 有如下的特性：</p><ul><li><code>HashMap</code> 是根据键值对来存储数据的，多个数据之间的键不能重复。在键重复时，旧的数据将会被覆盖</li><li><code>HashMap</code> 中各个数据实际存放的位置与 <code>hashCode()</code> 方法的结果有关，但不是由其结果直接决定</li><li><code>HashMap</code> 只允许一个键是 <code>null</code>(因为存储多个键是 <code>null</code> 的数据就违反了第一条特性)，但是允许多个值是 <code>null</code> 的数据</li><li><code>HashMap</code> 中数据存储的位置是不确定的，并且可能会因为扩容而改变，所以它的遍历顺序是不确定的</li><li><code>HashMap</code> 不是线程安全的，如果需要线程安全性则可以使用 <code>ConcurrentHashMap</code></li></ul><h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></tbody></table></figure><p>上面代码声明了一个名为 <code>HashMap</code> 的泛型类，它继承了 <code>AbstractMap</code>，并实现了 <code>Map</code>，<code>Cloneable</code>，<code>Serializable</code> 接口。</p><p><code>AbstractMap</code> 是一个抽象类，它是一个骨架级的 <code>Map</code> 实现，来减少实现一个 Map 所需的工作量。</p><p><code>Map</code> 接口顾名思义，它定义了要实现一个 Map 时必须实现的方法。</p><h2 id="一些关键的常量和概念"><a href="#一些关键的常量和概念" class="headerlink" title="一些关键的常量和概念"></a>一些关键的常量和概念</h2><p>在深入了解 <code>HashMap</code> 前，有一些关键的概念我们需要知道：</p><ul><li>哈希桶 (bucket/bin)：一个数组元素中存放的链表，就是一个哈希桶</li><li>哈希表：即存放了各个哈希桶的数组</li><li>树化阈值：当一个桶的大小超过了树化阈值之后才会将其变成红黑树</li><li>非树化阈值：当一个已经变成红黑树的桶中节点数量小于该值时，这个红黑树会被变回链表</li><li>最小树化容量：在选择是否将一个链表变成红黑树时，除了会考虑链表长度外，还会考虑哈希表的长度。仅当哈希表长度超过最小树化容量，且某个链表长度超过树化阈值时，这个链表才会被变成红黑树</li></ul><p>与之对应的有这几个常量值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></tbody></table></figure><p>此外 <code>HashMap</code> 还针对哈希表的扩容定义了一系列的常量和变量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量。为了保证添加和查找的高效性，HashMap的容量总是2的幂次</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认载荷因子。</span></span><br><span class="line"><span class="comment">// 载荷因子是哈希表在其容量自动增加之前被允许获得的最大数量的度量，决定了哈希表何时扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阈值。它的值等于哈希表容量乘以载荷因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的载荷因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></tbody></table></figure><h2 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h2><p><code>HashMap</code> 存储数据的方式有两种，而这两种方式也正是 <code>Java 1.7</code> 和 <code>Java 8</code> 的分界线，因为 <code>Java 8</code> 对于 <code>HashMap</code> 进行了底层上的改动。</p><h3 id="Java-1-7之前"><a href="#Java-1-7之前" class="headerlink" title="Java 1.7之前"></a>Java 1.7 之前</h3><p>因为 <code>HashMap</code> 是依靠 <code>hashCode()</code> 方法的结果来决定元素存储的位置的，而再完美的哈希函数也无法避免哈希碰撞的出现，所以 <code>HashMap</code> 选择采用<code>拉链法</code> (也叫<code>链地址法</code>) 来存储数据。</p><p>链地址法是一种结合了数组和链表的存储方式，在每个数组元素中存储的都是一个链表，这些链表被称为<code>桶(bucket/bin)</code>。</p><p>为了直观的展示，这里借用一下参考文章 1<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[搞懂 Java HashMap 源码](https://juejin.im/post/5ac83fa35188255c5668afd0)">[1]</span></a></sup> 中的一幅图：</p><p><img src="/images/java-read-src-hashmap/hashing.jpg" alt="拉链法"></p><p>我们都知道，一个数组元素只能保存一个数据，但是多个数据经过哈希运算后可能得到相同的哈希值，所以 <code>HashMap</code> 会将哈希值相同的数据存放在相同数组位置中的一个链表中。而在取出元素时，<code>HashMap</code> 首先会根据哈希值找到数组中的位置，然后遍历其中的链表来找到数据。</p><h3 id="Java-8之后"><a href="#Java-8之后" class="headerlink" title="Java 8之后"></a>Java 8 之后</h3><p>在一个 <code>HashMap</code> 存储越来越多的数据之后，数据之间发声哈希碰撞的可能性也会越来越大，导致每个数组中的链表也会越来越长，而因为遍历链表操作的时间复杂度是 <code>O(n)</code>，所以链表越长，遍历的效率就越差。所以在 <code>Java 8</code> 中，当数组长度大于 <code>MIN_TREEIFY_CAPACITY</code>，且某个链表长度大于 <code>TREEIFY_THRESHOLD</code> 时，这个链表将会被转换成红黑树。</p><p>这里依旧借用参考文章 1<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[搞懂 Java HashMap 源码](https://juejin.im/post/5ac83fa35188255c5668afd0)">[1]</span></a></sup> 中的一幅图：</p><p><img src="/images/java-read-src-hashmap/treeified.jpg" alt="树化后"></p><h3 id="数据的存储单元"><a href="#数据的存储单元" class="headerlink" title="数据的存储单元"></a>数据的存储单元</h3><p><code>HashMap</code> 中定义了一个 <code>Node&lt;K,V&gt;</code> 型的数组 <code>table</code> 用于存储数据：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个就是哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></tbody></table></figure><p>分别针对树化前和树化后的数据，<code>HashMap</code> 定义了不同的内部类作为其数据的存储单元。</p><h4 id="树化前"><a href="#树化前" class="headerlink" title="树化前"></a>树化前</h4><p><code>HashMap</code> 中定义了一个内部类 <code>Node</code>，作为链表中各个元素的存储单元。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 这个节点的哈希，即数组的索引位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点所属的key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点的值</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表中的下一个元素</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) {</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>{ <span class="keyword">return</span> key; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>{ <span class="keyword">return</span> value; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>{ <span class="keyword">return</span> key + <span class="string">"="</span> + value; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的哈希值通过将key的哈希和value的哈希异或得到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换这个节点的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>{</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="树化后"><a href="#树化后" class="headerlink" title="树化后"></a>树化后</h4><p>针对树化后的红黑树，<code>HashMap</code> 定义了一个内部类 <code>TreeNode</code> 作为树中各个元素的存储单元。但是这个类的代码太长了，放在这里不太合适，后面我再单独开一篇博文专门给它。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>HashMap</code> 提供了四个构造方法，我们下面一个一个来看：</p><h3 id="可以指定容量和载荷因子的构造方法"><a href="#可以指定容量和载荷因子的构造方法" class="headerlink" title="可以指定容量和载荷因子的构造方法"></a>可以指定容量和载荷因子的构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{</span><br><span class="line">    <span class="comment">// 初始容量不能小于0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量不能大于最大允许容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 载荷因子必须大于等于0，且不能为无穷大(比如0.0f/0.0f)</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据期望容量返回一个大于等于cap的扩容阈值，并且保证扩容阈值一定是2的幂次</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然上面说<code>扩容阈值 = 哈希表容量 * 加载因子</code>，但是有没有发现，上面的构造方法里面其实并没有初始化 <code>table</code>？实际上，<code>table</code> 在第一次添加数据时才会被初始化，具体的操作我们放到后面再说。</p><h3 id="可以指定容量的构造方法"><a href="#可以指定容量的构造方法" class="headerlink" title="可以指定容量的构造方法"></a>可以指定容量的构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个构造方法就是把默认载荷因子和给定的初始容量传给上面说的那个构造方法，这里就不重复解释了。</p><h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用默认的载荷因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h2><p>我们知道，<code>HashMap</code> 既可以一次只新增一条数据，也可以一次新增多个数据。我们先看它是怎么新增单条数据的。</p><h3 id="新增单条数据"><a href="#新增单条数据" class="headerlink" title="新增单条数据"></a>新增单条数据</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>乍一看好像很简单的样子，一句话轻飘飘的完成了新增数据的任务。但是要展开看的话，信息量可就很大了。</p><p>我们从里面到外面一个一个的看。</p><h4 id="计算新元素的哈希值"><a href="#计算新元素的哈希值" class="headerlink" title="计算新元素的哈希值"></a>计算新元素的哈希值</h4><p>在上面提到的 <code>putVal</code> 方法中，第一个参数是这个数据的哈希值。那么这个哈希值是怎么计算出来的呢？在 <code>java 8</code> 中，<code>hash</code> 方法是这么实现的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 将key的hashCode与其无符号右移16位之后得到的值做一次异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面这段代码会对 key 的 hashCode 做一个扰动计算，来得到这个 key 在 <code>HashMap</code> 中的哈希值。这个扰动计算的目的就是为了降低发生哈希碰撞的可能性。</p><h4 id="向HashMap中增加数据"><a href="#向HashMap中增加数据" class="headerlink" title="向HashMap中增加数据"></a>向 HashMap 中增加数据</h4><p>在计算完 key 的哈希值后，<code>putVal</code> 方法会开始向 <code>HashMap</code> 中添加数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash就是key的哈希</span></span><br><span class="line"><span class="comment">// key就是key值</span></span><br><span class="line"><span class="comment">// value就是被添加的数据</span></span><br><span class="line"><span class="comment">// onlyIfAbsent如果是true则不替换数据</span></span><br><span class="line"><span class="comment">// evict如果是false，则说明是在初始化状态</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    <span class="comment">// 将指向哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在计算完本次要操作的哈希表下标后</span></span><br><span class="line">    <span class="comment">// p将指向哈希表的这个下标中的数据</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n将是哈希表的长度</span></span><br><span class="line">    <span class="comment">// 在计算完本次要操作的哈希表下标后，i将是这个下标值</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查哈希表是不是还没有被初始化过，或者哈希表长度为0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 对哈希表进行首次扩容，即初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 经过i = (n - 1) &amp; hash这步运算得到本次插入的位置，即哈希表的数组下标</span></span><br><span class="line">    <span class="comment">// 如果这个位置尚没有元素，说明没有发生哈希碰撞</span></span><br><span class="line">    <span class="comment">// 那么就直接将插入的数据放在这个位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果这个位置已经有元素存在了，那就说明发生了哈希碰撞</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希相同，且key值相同，则覆盖这个元素</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表的这个位置已经被变成红黑树了</span></span><br><span class="line">        <span class="comment">// 那么就要调用红黑树版本的putVal，即putTreeVal来完成插入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在哈希相同，key却不同的时候</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环整个单链表，同时使用binCount记录单链表的节点数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在单链表尾部拼接本次插入的数据</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果单链表的节点数量大于等于树化阈值时，就将这个单链表进行树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果在遍历过程中发现有数据的key与本次操作的key相同</span></span><br><span class="line">                <span class="comment">// 此时e指向要被替换value的节点，并结束遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果e != null，说明需要替换e所指节点的数据</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 这个方法在HashMap中是空实现</span></span><br><span class="line">            <span class="comment">// 但是LinkedHashMap中会有实现</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fail-fast机制</span></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果哈希表长度大于扩容阈值，则对哈希表扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 这个方法在HashMap中也是空的</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码可能看起来比较费劲，这里借用美团博客的一张图来展示 <code>put</code> 方法的执行流程：</p><p><img src="/images/java-read-src-hashmap/putting.png" alt="put方法执行流程"></p><h3 id="新增多条数据"><a href="#新增多条数据" class="headerlink" title="新增多条数据"></a>新增多条数据</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>{</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>依旧是调用了另一个方法实现的添加数据。那么继续深入进去看看。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    <span class="comment">// 传入的map的长度</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的map有数据，才进行后面的运算</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果哈希表尚未初始化，则先计算扩容阈值</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) { <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表已经初始化完成，但是传入的map的大小超过了扩容阈值</span></span><br><span class="line">        <span class="comment">// 那么就将哈希表扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历传入的map，然后逐个调用putVal方法增加元素</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap 扩容</h2><p>上面多次提到了 <code>HashMap</code> 的扩容操作，这里我们就详细看看它是怎么扩容的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    <span class="comment">// oldTab指向扩容前的哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// oldCap是扩容前的哈希表容量，如果哈希表尚未被初始化，那么容量就是0</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// oldThr是扩容前的扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// newCap为扩容后的容量，newThr是扩容后的扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果扩容前的哈希表容量已经是最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">            <span class="comment">// 那么就将扩容阈值设为Integer.MAX_VALUE</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 并停止扩容</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 新容量是旧容量的2倍，且新的扩容阈值也是旧扩容阈值的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果旧的扩容阈值大于0</span></span><br><span class="line">    <span class="comment">// 而同时旧的容量等于0</span></span><br><span class="line">    <span class="comment">// 那么说明已经使用带参数的构造方法设定了载荷因子和初始容量</span></span><br><span class="line">    <span class="comment">// 而且这次是首次扩容</span></span><br><span class="line">    <span class="comment">// 此时初始容量不等于期望容量，且大于期望容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 设定新的容量等于旧的扩容阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果旧的扩容阈值是0</span></span><br><span class="line">    <span class="comment">// 而同时旧的容量等于0</span></span><br><span class="line">    <span class="comment">// 那么说明这个HashMap是用默认构造方法初始化的</span></span><br><span class="line">    <span class="comment">// 而且这次是首次扩容</span></span><br><span class="line">    <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 那么新的容量就等于默认初始容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 新的扩容阈值等于(默认载荷因子 * 默认初始容量)</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的扩容阈值是0</span></span><br><span class="line">    <span class="comment">// 对应当前table为空，但是有阈值的情况</span></span><br><span class="line">    <span class="comment">// 那么就计算新的扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新HashMap的扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用扩容后的容量创建一个新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings({"rawtypes","unchecked"})</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将HashMap的哈希表指向新的哈希表</span></span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果旧的哈希表不为null</span></span><br><span class="line">    <span class="comment">// 则进行重新插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历旧的哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            <span class="comment">// 存储旧的哈希表对应位置中链表的头节点</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果这个位置有数据</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 释放掉旧的链表中的空间</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果这个链表中只有一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 则使用新哈希表的长度计算下标，并插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果这个节点是个红黑树</span></span><br><span class="line">                <span class="comment">// 那么需要选择是拆分这个红黑树，或者将其非树化</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 如果这个链表有数个节点</span></span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 因为扩容后的容量是扩容前容量的2倍</span></span><br><span class="line">                    <span class="comment">// 所以原链表上的节点，既有可能会被放在它原来的位置上(低位)</span></span><br><span class="line">                    <span class="comment">// 也有可能会被放到扩容后新增加的位置上(高位 = 低位 + 旧的容量)</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 低位链表的头节点和尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 高位链表的头节点和尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 存放原来链表中的节点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 遍历旧的链表</span></span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 利用哈希值和旧的容量进行与运算</span></span><br><span class="line">                        <span class="comment">// 如果结果等于0，那么就拼接到低位链表的末尾</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 否则拼接到高位链表的末尾</span></span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果低位链表非空，则将链表放到原位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 如果高位链表非空，则将链表放到新增加的位置</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 检查哈希表是不是空</span></span><br><span class="line">    <span class="comment">// 以及哈希表中对应下标的第一个元素是不是null，即这个位置是否有节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 因为第一个节点无所谓是链表节点还是红黑树节点</span></span><br><span class="line">        <span class="comment">// 所以先用一个简单的办法检查第一个节点是不是要找的节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 如果是，就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果第一个节点不是要找的节点</span></span><br><span class="line">        <span class="comment">// 而且它后面有别的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 如果后面的节点是红黑树，那么调用红黑树的方法取寻找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则遍历这个链表，寻找符合要求的节点并返回</span></span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配key来删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时匹配key和value来删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 检查哈希表是不是空</span></span><br><span class="line">    <span class="comment">// 以及哈希表中对应下标的第一个元素是不是null，即这个位置是否有节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) {</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 先检查链表中第一个元素是否匹配</span></span><br><span class="line">        <span class="comment">// 如果匹配就直接取出来</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 否则继续向后遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果后续的节点是红黑树，那么使用红黑树的方法寻找匹配的节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 否则遍历链表，根据hash和key寻找节点</span></span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) {</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    p = e;</span><br><span class="line">                } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果取到了节点，则开始删除</span></span><br><span class="line">        <span class="comment">// (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))构成了一个判断链条</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) {</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="迭代HashMap"><a href="#迭代HashMap" class="headerlink" title="迭代HashMap"></a>迭代 HashMap</h2><p><code>HashMap</code> 提供了多种迭代的方式，比如迭代 <code>EntrySet</code>，或者迭代 <code>KeySet</code>。</p><h3 id="迭代KeySet"><a href="#迭代KeySet" class="headerlink" title="迭代KeySet"></a>迭代 KeySet</h3><p>在迭代 <code>KeySet</code> 的时候，我们可以逐个得到 <code>HashMap</code> 中的 key，然后根据 key 来进行操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个KeySet实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>{</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) {</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 得到KeySet的长度，也是HashMap的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>{ <span class="keyword">return</span> size; }</span><br><span class="line">    <span class="comment">// 可以清空这个HashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>{ HashMap.<span class="keyword">this</span>.clear(); }</span><br><span class="line">    <span class="comment">// 得到一个KeyIterator迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>{ <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); }</span><br><span class="line">    <span class="comment">// 检查是否包含某个key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{ <span class="keyword">return</span> containsKey(o); }</span><br><span class="line">    <span class="comment">// 根据key删除某个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>{</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) {</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 得到下一个节点的key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextNode().key; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="迭代EntrySet"><a href="#迭代EntrySet" class="headerlink" title="迭代EntrySet"></a>迭代 EntrySet</h3><p>在迭代 <code>EntrySet</code> 的时候，我们可以同时得到一个节点的 key 和 value。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个EntrySet实例</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>{</span><br><span class="line">    <span class="comment">// 得到EntrySet的大小，即HashMap的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>{ <span class="keyword">return</span> size; }</span><br><span class="line">    <span class="comment">// 可以清空这个HashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>{ HashMap.<span class="keyword">this</span>.clear(); }</span><br><span class="line">    <span class="comment">// 得到一个EntryIterator迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查EntrySet中是否包含某个Entry</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据传入的Entry在HashMap中匹配并删除对应的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>{</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) {</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>{</span><br><span class="line">    <span class="comment">// 得到下一个节点的Entry</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextNode(); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h3><p>为什么上面看到 <code>KeyIterator</code> 和 <code>EntryIterator</code> 就停止了呢？因为它们两个都是继承于 <code>HashIterator</code>，这里我们集中看一下。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// 下一个要返回的Entry</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// 当前的Entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// 结合modCount实现fast-fail机制</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// 当前哈希表的下标</span></span><br><span class="line"></span><br><span class="line">    HashIterator() {</span><br><span class="line">        <span class="comment">// 取迭代时的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="comment">// 指向当前的哈希表</span></span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从哈希表中第一个不为空的位置获取第一个Entry</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) { <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> {} <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否还有节点可供迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>{</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 如果当前链表被遍历完了，那么就寻找下一个不是null的链表头</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">do</span> {} <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除当前被迭代的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 同步新的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面迭代时的算法可以看到，迭代器总是先遍历当前的链表或者红黑树，然后再去遍历哈希表，也就是说，它采用的是深度优先的算法。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWM4M2ZhMzUxODgyNTVjNTY2OGFmZDA="> 搞懂 Java HashMap 源码<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTYvMDYvMjQvamF2YS1oYXNobWFwLmh0bWw=">Java 8 系列之重新认识 HashMap<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cuenlidWx1by5jb20va2lyYVNhbGx5L25vdGUvODE5ODQz"> 集合番 @HashMap 一文通（1.7 版）<i class="fa fa-external-link-alt"></i></span><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjkyNjcyMg==">HashMap 源码详细分析 (JDK1.8)<i class="fa fa-external-link-alt"></i></span><a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyNDA4NzcvYXJ0aWNsZS9kZXRhaWxzLzUzMzUxMTg4">Java 集合深入理解（16）：HashMap 主要特点和关键方法源码解读<i class="fa fa-external-link-alt"></i></span><a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashmap.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 源码阅读 - equals 和 hashCode 方法</title>
      <link>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashcode-and-equals.html</link>
      <guid>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashcode-and-equals.html</guid>
      <pubDate>Mon, 06 Jan 2020 05:50:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。&lt;/p&gt;
&lt;p&gt;这次就来阅读一下 &lt;code&gt;Object&lt;/code&gt; 类里面 &lt;code&gt;hashCode&lt;/code&gt; 方法和 &lt;code&gt;equals&lt;/code&gt; 方法的源码。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p><p>这次就来阅读一下 <code>Object</code> 类里面 <code>hashCode</code> 方法和 <code>equals</code> 方法的源码。</p><a id="more"></a><h2 id="先看看代码"><a href="#先看看代码" class="headerlink" title="先看看代码"></a>先看看代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看出，<code>hashCode</code> 方法是一个 native 方法，<code>equals</code> 方法比较了两个对象是否指向同一个内存的地址。</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><h3 id="什么是hash"><a href="#什么是hash" class="headerlink" title="什么是hash"></a>什么是 hash</h3><p>要搞清楚 <code>hashCode</code> 干了什么，那就得要知道 <code>hash</code> 是什么。</p><blockquote><p>散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字 “指纹” 的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p></blockquote><h3 id="Java中的hashCode方法"><a href="#Java中的hashCode方法" class="headerlink" title="Java中的hashCode方法"></a>Java 中的 hashCode 方法</h3><p>在 <code>Object</code> 类中的 <code>hashCode</code> 方法是一个 native 方法，我们没办法直接得知它的实现方式，但是我们依旧可以从它的 JavaDoc 中得知一些信息。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">     * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> java.util.HashMap}.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of {<span class="doctag">@code</span> hashCode} is:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">     * class {<span class="doctag">@code</span> Object} does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">     * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">     * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">     * technique is not required by the</span></span><br><span class="line"><span class="comment">     * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>上面花了很大的篇幅讲了如果要重新实现 <code>hashCode</code> 方法所需要遵循的原则，但是很可惜，我们现在暂时不关注这些。我们现在关注的，是最后一段的内容。</p><p>在最后一段中，它讲了通常情况下，程序是怎样计算出 <code>hashCode</code> 的值的。</p><blockquote><p>This is typically implemented by converting the internal address of the object into an integer<br>通常来说，这是通过把内部的地址转换成一个整型数来实现的</p></blockquote><p>当然，并不是所有的类都使用了这个计算方法，比如 <code>String</code> 就重新实现了自己的 <code>hashCode</code> 方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) {</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        }</span><br><span class="line">        hash = h;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p><code>equals</code> 方法的作用是比较两个对象的内容是否相同。一般来说，<code>Object</code> 类中提供的 <code>equals</code> 方法是没办法满足各个类型自己的需要的，所以它们基本上都实现了自己的 <code>equals</code> 方法。</p><p>用一个简单的例子来讲：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;</span><br><span class="line">String str2 = <span class="string">"aaa"</span>;</span><br><span class="line">str1.equals(str2); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>显然，<code>str1</code> 和 <code>str2</code> 是两个不同的对象，如果直接比较它们的内存地址，那么得到的结果肯定是 false。所以可以肯定的是，<code>String</code> 类重写了 <code>equals</code> 方法。那么，我们就简单看一下 <code>String</code> 是怎样实现 <code>equals</code> 方法的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>{</span><br><span class="line">    <span class="comment">// 先检查两个对象的地址是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被比较的对象地址不同，但它类型相同</span></span><br><span class="line">    <span class="comment">// 那么继续进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) {</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果被比较的字符串与本字符串长度相同</span></span><br><span class="line">        <span class="comment">// 那么继续比较其中char数组中的每个元素是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) {</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>既然每个类型都可以实现自己的 <code>equals</code> 方法，那么必然有一个规则来约束它们的实现方式，以保证在何时何地 <code>equals</code> 都可以得到合理的结果。</p><p>在 <code>equals</code> 方法的 JavaDoc 中描述了重写该方法所需要遵守的规则：</p><blockquote><p>It is <i>reflexive</i>: for any non-null reference value <code>x</code>, <code>x.equals(x)</code> should return <code>true</code>.<br>It is <i>symmetric</i>: for any non-null reference values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code>.<br>It is <i>transitive</i>: for any non-null reference values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.<br>It is <i>consistent</i>: for any non-null reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in <code>equals</code> comparisons on the objects is modified.<br>For any non-null reference value <code>x</code>, <code>x.equals(null)</code> should return <code>false</code>.</p></blockquote><p>翻译过来就是：</p><blockquote><p>自反性：对于一个非 null 的引用值，<code>x.equals(x)</code> 应当返回 <code>true</code>。<br>对称性：对于两个非 null 的引用值 <code>x</code> 和 <code>y</code>，当且仅当 <code>y.equals(x)</code> 时，<code>x.equals(y)</code> 返回 <code>true</code>。<br>传递性：对于任意非 null 的引用值 <code>x</code>，<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，而且 <code>y.equals(z)</code> 返回 <code>true</code>，那么 <code>x.equals(z)</code> 也应返回 <code>true</code>。<br>一致性：对于任意非 null 的引用值 <code>x</code> 和 <code>y</code>，当两者都未被修改时，多次调用 <code>x.equals(y)</code> 都应一直返回 <code>true</code> 或者 <code>false</code>。<br>对于任意非 null 的引用值 <code>x</code>，<code>x.equals(null)</code> 应返回 <code>false</code>。</p></blockquote><h2 id="hashCode方法与equals方法的关系"><a href="#hashCode方法与equals方法的关系" class="headerlink" title="hashCode方法与equals方法的关系"></a>hashCode 方法与 equals 方法的关系</h2><p>在 <code>equals</code> 方法的 JavaDoc 上有这么一段话：</p><blockquote><p>Note that it is generally necessary to override the <code>hashCode</code> method whenever this method is overridden, so as to maintain the general contract for the <code>hashCode</code> method, which states that equal objects must have equal hash codes.<br>在重写 <code>equals</code> 方法时，通常也需要一并重写 <code>hashCode</code> 方法，以便维护 <code>hashCode</code> 方法的约定，即相等的对象必须拥有相同的哈希码</p></blockquote><p>而在 <code>hashCode</code> 方法的 JavaDoc 中，它有着这样的实现约定：</p><blockquote><p>Whenever it is invoked on the same object more than once during an execution of a Java application, the <code>hashCode</code> method must consistently return the same integer, provided no information used in <code>equals</code> comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</p><p>If two objects are equal according to the <code>equals(Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce the same integer result.</p><p>It is <em>not</em> required that if two objects are unequal according to the <code>java.lang.Object#equals(java.lang.Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce distinct integer results.  However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.</p></blockquote><p>即：</p><blockquote><p>在程序运行过程中，不论 <code>hashCode</code> 方法被调用了多少次，其返回结果都必须是一个恒定的整型值，以表明在使用 <code>equals</code> 比较对象时所需的信息没有被修改过。但是在程序每次运行之间，<code>hashCode</code> 返回的值则不需要保持一致</p><p>如果两个对象使用 <code>equals</code> 方法比较得出了相同 (equal) 的结论，那么对这两个对象执行 <code>hashCode</code> 方法得到的值也必须相同</p><p>在两个对象使用 <code>equals</code> 方法比较得出了不相同 (not equal) 的结论时，对这两个对象执行 <code>hashCode</code> 方法得到的值却可以相同。然而，开发人员需要意识到，给不同的对象返回不同的哈希码可以提升 hash table 的性能</p></blockquote><p>综上所述，我们可以得出如下结论：</p><ul><li>两个相同 (equal) 的对象必须拥有相同的哈希码</li><li>两个哈希码相同的对象却不一定相同 (equal)</li></ul><p>那么，这两条结论会对我们的程序造成什么影响呢？</p><p>首先我们看一下第一条。以 <code>Set</code> 举例，<code>Set</code> 会根据对象的 <code>hashCode</code> 来寻找对象的存储位置，那么可想而知，如果两个对象的值相同，哈希码却不同，那么就会导致 <code>Set</code> 中出现多个重复数据的情况。</p><p>而第二条结论出现的原因则是，目前没有任何一种哈希算法，可以保证对每个传入的值都可以计算出一个不同的哈希，这种情况的学名叫<code>哈希碰撞</code>，所以我们只能尽可能的减少出现哈希碰撞的可能性。至于 Java 如何应对哈希碰撞，我将在后续的博文中进行解释。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-hashcode-and-equals.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>手动编写代码调用 JSR-303 Bean Validation</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/programatically-call-jsr-303.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/programatically-call-jsr-303.html</guid>
      <pubDate>Mon, 06 Jan 2020 02:26:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近做了一个有点不一样的项目，它是将传入接口的业务参数以 JSON 的形式放在了一个统一的请求体里面，我要将它取出来，再反序列化到一个 Bean 里面。这样会带来一个问题，就是我不能直接使用 &lt;code&gt;@Valid&lt;/code&gt; 注解来让框架自行校验参数的合法性，而需要手动调用 &lt;code&gt;Validator&lt;/code&gt; 实现对 bean 的校验。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近做了一个有点不一样的项目，它是将传入接口的业务参数以 JSON 的形式放在了一个统一的请求体里面，我要将它取出来，再反序列化到一个 Bean 里面。这样会带来一个问题，就是我不能直接使用 <code>@Valid</code> 注解来让框架自行校验参数的合法性，而需要手动调用 <code>Validator</code> 实现对 bean 的校验。</p><a id="more"></a><p>在这里我就不去还原从请求体取出业务数据并反序列化这个过程了，因为这个操作对于我们实际要实现的功能没有关系。我将在这里新建一个简单的类，设定好适当的校验规则，然后通过一个简单的示例来演示。</p><h2 id="示例bean"><a href="#示例bean" class="headerlink" title="示例bean"></a>示例 bean</h2><p>示例的 bean 就是一个喜闻乐见的学生信息，使用 <code>javax.validation.constraints</code> 包中的注解来设定校验规则。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line">    <span class="comment">// 姓名是必填项</span></span><br><span class="line">    <span class="meta">@NotNull(message = "Student name is mandatory")</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别是必填项，仅接受male和female，首字母可以大写也可以小写</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = "(M|male)|(F|female)", message = "Only male or female are accepted")</span></span><br><span class="line">    <span class="meta">@NotNull(message = "Student gender is mandatory")</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成绩不是必填项</span></span><br><span class="line">    <span class="comment">// 成绩必须大于等于0，且小于等于100</span></span><br><span class="line">    <span class="comment">// 因为Max的值是开区间，所以得写101</span></span><br><span class="line">    <span class="meta">@Max(value = 101, message = "Maximum value of score is 100")</span></span><br><span class="line">    <span class="meta">@PositiveOrZero(message = "Score cannot be negative")</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编写实现"><a href="#编写实现" class="headerlink" title="编写实现"></a>编写实现</h2><p>实现的中心思想就是手动获得一个 <code>Validator</code> 实例，然后调用它来对传入的 bean 进行校验。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/student")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showStudent</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> </span>{</span><br><span class="line">        <span class="comment">// 取得一个Validator实例</span></span><br><span class="line">        Validator validator = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"Validating bean with validator {}"</span>, validator.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Validator#validate方法对这个bean进行校验</span></span><br><span class="line">        <span class="comment">// 所有的</span></span><br><span class="line">        <span class="comment">// ConstraintViolation的泛型类型要设定为被校验bean的类型</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Student&gt;&gt; errors = validator.validate(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里遍历errors这个set，打印出各个错误的信息</span></span><br><span class="line">        errors.forEach(error -&gt; {</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">            <span class="comment">// 对应校验规则里面的message属性</span></span><br><span class="line">            log.error(<span class="string">"Error message: {}"</span>, error.getMessage());</span><br><span class="line">            <span class="comment">// 校验失败的属性名</span></span><br><span class="line">            log.error(<span class="string">"Property path: {}"</span>, error.getPropertyPath());</span><br><span class="line">            <span class="comment">// 导致校验失败的值</span></span><br><span class="line">            log.error(<span class="string">"Error value: {}"</span>, error.getInvalidValue());</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 可以取出所有的校验失败信息，拼接起来之后返回给调用方</span></span><br><span class="line">            <span class="keyword">final</span> String errMessages = errors.stream()</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里为了省事直接抛出了RuntimeException</span></span><br><span class="line">            <span class="comment">// 实际使用时建议新建一个自定义业务异常代表这种情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(errMessages);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> student.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>我使用一个这样子的数据来测试上面的校验功能：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Boris"</span>,</span><br><span class="line">  <span class="attr">"score"</span>: <span class="number">180</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见，这个数据是无法通过校验的，它没有填写性别，而且分数超过了上限。请求发出去之后，我得到了这样的错误信息：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"timestamp"</span>: <span class="string">"2020-01-06T03:03:18.125+0000"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"Internal Server Error"</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Maximum value of score is 100, Student gender is mandatory"</span>,</span><br><span class="line">  <span class="attr">"path"</span>: <span class="string">"/student"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同时，控制台里出现了这样的日志：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-01-06 11:21:25.971  INFO 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Validating bean with validator org.hibernate.validator.internal.engine.ValidatorImpl</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Student gender is mandatory</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: gender</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: null</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Maximum value of score is 100</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: score</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: 180</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.252 ERROR 68021 --- [nio-9999-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100</span><br><span class="line">    at com.example.demo.StudentController.showStudent(StudentController.java:42) ~[classes/:na]</span><br><span class="line">    堆栈信息太多，下面的略掉了</span><br></pre></td></tr></tbody></table></figure><p>看来，校验的代码成功起作用了。</p><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>因为我们现在基本上都是面向 Spring 编程，所以其实上面那些手动获取 <code>Validator</code> 的代码也是不必要的。我们可以让 Spring 自动注入一个 <code>Validator</code> 来实现功能。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>{</span><br><span class="line">    <span class="comment">// 直接注入一个Validator的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/student")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showStudent</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> </span>{</span><br><span class="line">        <span class="comment">// 我们来看看它到底注入了谁</span></span><br><span class="line">        log.info(<span class="string">"Validating bean with validator {}"</span>, validator.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Validator#validate方法对这个bean进行校验</span></span><br><span class="line">        <span class="comment">// 所有的</span></span><br><span class="line">        <span class="comment">// ConstraintViolation的泛型类型要设定为被校验bean的类型</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Student&gt;&gt; errors = validator.validate(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里遍历errors这个set，打印出各个错误的信息</span></span><br><span class="line">        errors.forEach(error -&gt; {</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">            <span class="comment">// 对应校验规则里面的message属性</span></span><br><span class="line">            log.error(<span class="string">"Error message: {}"</span>, error.getMessage());</span><br><span class="line">            <span class="comment">// 校验失败的属性名</span></span><br><span class="line">            log.error(<span class="string">"Property path: {}"</span>, error.getPropertyPath());</span><br><span class="line">            <span class="comment">// 导致校验失败的值</span></span><br><span class="line">            log.error(<span class="string">"Error value: {}"</span>, error.getInvalidValue());</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 可以取出所有的校验失败信息，拼接起来之后返回给调用方</span></span><br><span class="line">            <span class="keyword">final</span> String errMessages = errors.stream()</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里为了省事直接抛出了RuntimeException</span></span><br><span class="line">            <span class="comment">// 实际使用时建议新建一个自定义业务异常代表这种情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(errMessages);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> student.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重新启动应用，并用相同的数据测试之后，我们得到了这样的日志：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-01-06 11:15:17.957  INFO 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Validating bean with validator org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</span><br><span class="line">2020-01-06 11:15:18.071 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Student gender is mandatory</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: gender</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: null</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Maximum value of score is 100</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: score</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: 180</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.089 ERROR 67745 --- [nio-9999-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100</span><br><span class="line">    at com.example.demo.StudentController.showStudent(StudentController.java:42) ~[classes/:na]</span><br><span class="line">    下面的堆栈信息依旧略掉</span><br></pre></td></tr></tbody></table></figure><p>看来这种方式使用了另一个 <code>Validator</code> 实现，但是没关系，我们依旧能得到正确的结果，并可以使用完全一样的方法来处理错误信息。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmV5b25kamF2YS5uZXQvaG93LXRvLWludm9rZS1qc3ItMzAzLWJlYW4tdmFsaWRhdGlvbi1wcm9ncmFtbWF0aWNhbGx5">How to Invoke JSR 303 Bean Validation Programmatically<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4NzA0MDI1LzM4MzM4NTg=">How to manually trigger spring validation? - StackOverflow<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/programatically-call-jsr-303.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>让 nohup 不输出 appending output to &#39;nohup.out&#39;</title>
      <link>https://www.boris1993.com/linux/suppress-appending-to-nohup-out-message.html</link>
      <guid>https://www.boris1993.com/linux/suppress-appending-to-nohup-out-message.html</guid>
      <pubDate>Fri, 27 Dec 2019 07:22:52 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;在使用 &lt;code&gt;nohup&lt;/code&gt; 的时候，它总会打印一条 &lt;co
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在使用 <code>nohup</code> 的时候，它总会打印一条 <code>nohup: appending output to 'nohup.out'</code> 这样的信息，并且必须敲一下回车。</p><p>因为 <code>nohup: appending output to 'nohup.out'</code> 这条信息是打印到 <code>STDERR</code> 的，所以解决的方法很简单，把 <code>STDERR</code> 重定向至 <code>STDOUT</code> 就可以了，比如这样：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup doSomething &gt; nohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></tbody></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/linux/suppress-appending-to-nohup-out-message.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java 源码阅读 - LinkedList</title>
      <link>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-linkedlist.html</link>
      <guid>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-linkedlist.html</guid>
      <pubDate>Wed, 25 Dec 2019 04:55:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。&lt;/p&gt;
&lt;p&gt;这次就来阅读一下 &lt;code&gt;LinkedList&lt;/code&gt; 的源码。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p><p>这次就来阅读一下 <code>LinkedList</code> 的源码。</p><a id="more"></a><h2 id="LinkedList的特性"><a href="#LinkedList的特性" class="headerlink" title="LinkedList的特性"></a>LinkedList 的特性</h2><p><code>LinkedList</code> 有如下几个特性：</p><ul><li>底层的数据结构是双向链表</li><li>存储的数据允许为 <code>null</code></li><li>允许存放重复的数据</li><li>元素在 List 中的顺序由添加顺序决定</li><li>不是线程安全的</li></ul><h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></tbody></table></figure><p>上面代码声明了一个名为 <code>LinkedList</code> 的泛型类，继承了 <code>AbstractSequentialList</code>，并实现了 <code>List</code>，<code>Deque</code>，<code>Cloneable</code>，<code>Serializable</code> 接口。</p><p><code>AbstractSequentialList</code> 抽象类提供了一个 “骨架” 级别的 List 实现，用来减少实现一个支持顺序读写的 <code>List</code> 的工作量。</p><p><code>Deque</code> 接口约定了要实现一个双向队列 (Double Ended Queue) 所必须要实现的方法。</p><p><code>Cloneable</code> 是一个标记接口，表明了这个类允许使用 <code>Object.clone()</code> 命令进行属性到属性的复制。</p><p><code>Serializable</code> 也是一个标记接口，表明在这个类上启用 Java 的序列化功能。</p><h2 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to first node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to last node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></tbody></table></figure><p><code>first</code> 和 <code>last</code> 是两个 <code>Node</code> 对象，分别指向了链表中的第一个节点和最后一个节点。<code>size</code> 保存了这个链表中元素的个数。</p><p><code>Node</code> 类是 <code>LinkedList</code> 类中的一个内部类，它定义了一个元素实际上是如何被存储的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>item</code> 是实际存储的数据，<code>next</code> 和 <code>prev</code> 则分别指向了下一个元素和上一个元素。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>LinkedList</code> 有两个构造方法，分别用来初始化一个空的链表，和从一个给定的集合中取出元素来初始化一个链表。</p><h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>无参的构造方法实际上什么都没有做，返回的 <code>LinkedList</code> 对象中，<code>size</code> 为默认值 <code>0</code>，<code>first</code> 和 <code>last</code> 的值都是 <code>null</code>。</p><h3 id="从集合初始化的构造方法"><a href="#从集合初始化的构造方法" class="headerlink" title="从集合初始化的构造方法"></a>从集合初始化的构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个构造方法首先创建了一个空的 <code>LinkedList</code>，然后调用了 <code>addAll</code> 方法将集合中的数据放到这个链表中。</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>在 <code>LinkedList</code> 中插入数据有三种方式：在头部增加节点、在尾部增加节点，和在某个元素间插入节点。</p><h3 id="在头部增加节点"><a href="#在头部增加节点" class="headerlink" title="在头部增加节点"></a>在头部增加节点</h3><p>要在链表头部增加节点，可以使用 <code>addFirst(E)</code> 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the beginning of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    linkFirst(e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该方法又调用了一个 <code>private</code> 方法 <code>linkFirst(E)</code> 实现在头部插入数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as first element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>linkFirst(E)</code> 方法首先取出当前的头部元素 <code>first</code>，然后构造了一个新的 <code>Node</code> 对象，新对象的 <code>prev</code> 值为 <code>null</code>，代表它是一个头部元素，<code>next</code> 值为原来的 <code>first</code>，它存储的数据则是这次插入的数据。然后它将链表的 <code>first</code> 设为这次新增加的元素。</p><p>根据链表的特性可以知道，如果一个链表不是空的，那么它的 <code>first</code> 必定非空；反之，如果它的 <code>first</code> 为 <code>null</code>，那么这个链表一定为空。所以根据这个规则，它会判断在插入元素前，这个链表是不是空的，如果是空的，那么新元素就同时作为链表的尾 <code>last</code>；如果不是空的，那么就让原来的 <code>first</code> 的 <code>prev</code> 指向新插入的元素。这样操作之后，新元素与原 <code>first</code> 元素之间就出现了一个双向的引用，即完成了一个小的双向链表。</p><p>最后使链表的 <code>size</code> 加一，就完成了一次新增头元素的操作。</p><h3 id="在尾部增加节点"><a href="#在尾部增加节点" class="headerlink" title="在尾部增加节点"></a>在尾部增加节点</h3><p>在尾部增加节点，可以使用 <code>add(E)</code> 方法或 <code>addLast(E)</code> 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to {<span class="doctag">@link</span> #add}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    linkLast(e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to {<span class="doctag">@link</span> #addLast}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看出，两个方法都是通过一个 <code>private</code> 方法 <code>linkLast(E)</code> 实现的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在尾部插入数据的操作与在头部插入数据的操作类似，依旧是构造一个新的节点，使原来的 <code>last</code> 节点指向新节点，然后根据原链表是否为空执行后续操作。在这里就不多赘述了。</p><h3 id="在中间增加节点"><a href="#在中间增加节点" class="headerlink" title="在中间增加节点"></a>在中间增加节点</h3><p>要在链表中间插入数据，可以使用 <code>add(int, E)</code> 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>{</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个方法所做的操作，简单来说就是，将新的元素放到指定位置，并将原来处于这个位置的元素及其所有后续元素全部后移一个位置。</p><p>首先它调用了 <code>checkPositionIndex(int)</code> 方法，我们看看它干了什么。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tells if the argument is the index of a valid position for an</span></span><br><span class="line"><span class="comment"> * iterator or an add operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an IndexOutOfBoundsException detail message.</span></span><br><span class="line"><span class="comment"> * Of the many possible refactorings of the error handling code,</span></span><br><span class="line"><span class="comment"> * this "outlining" performs best with both server and client VMs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个方法检查了用户输入的插入位置是不是一个合法的位置，规则就是插入位置必须大于等于 0 且小于等于最大位置。</p><p>通过检查之后，它继续判断插入的位置是不是链表的末尾，如果是末尾的话，就直接调用 <code>linkLast(E)</code> 在链表尾部新增一个元素，否则它会先取出现在位于插入位置的节点，然后调用 <code>linkBefore(E, Node)</code> 在链表中间插入元素。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) {</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>{</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>node(int)</code> 方法巧妙的利用了二分法，根据元素所在的位置来决定是从链表头部还是从尾部开始查找节点。</p><p><code>linkBefore(E, Node)</code> 方法进行的操作，就像我们在书中学习到的一样，先让新节点建立起到左右两个节点的连接，然后让右边的节点连接到新插入的节点，最后更新链表的大小。</p><h3 id="用集合批量增加节点"><a href="#用集合批量增加节点" class="headerlink" title="用集合批量增加节点"></a>用集合批量增加节点</h3><p>之前我们在 <code>LinkedList</code> 的构造方法中看到了一个 <code>addAll(Collection)</code> 方法，现在就来看看它干了什么。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the specified</span></span><br><span class="line"><span class="comment"> * collection's iterator.  The behavior of this operation is undefined if</span></span><br><span class="line"><span class="comment"> * the specified collection is modified while the operation is in</span></span><br><span class="line"><span class="comment"> * progress.  (Note that this will occur if the specified collection is</span></span><br><span class="line"><span class="comment"> * this list, and it's nonempty.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element</span></span><br><span class="line"><span class="comment"> *              from the specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) {</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) {</span><br><span class="line">        <span class="meta">@SuppressWarnings("unchecked")</span> E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) {</span><br><span class="line">        last = pred;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的重头戏是 <code>addAll(int, Collection)</code> 方法，它实现了在链表中间批量插入节点的功能。<code>addAll(Collection)</code> 实际上就是调用它在链表末尾批量插入节点。</p><p>首先 <code>addAll</code> 方法会检查插入的位置是否合法，如果不合法就会抛出 <code>IndexOutOfBoundsException</code> 异常。然后它将传入的集合转换成一个对象数组，并检查数组长度，如果长度是 0，则说明链表内容未被改变，直接返回 <code>false</code>。</p><p>然后它会检查插入的位置，并且记录下插入位置的上一个节点和下一个节点。</p><p>接下来这个方法开始遍历传入的集合，并将集合中的数据逐个插入到链表中。插入的逻辑与前面讲的类似，所以就不再赘述了。</p><p>最后它会完成一系列收尾工作，包括设定链表尾部的节点，和更新链表的长度，然后返回 <code>true</code>，代表链表成功被更新了。</p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>因为 <code>LinkedList</code> 也是一个双向队列，所以它既允许从两端开始获取数据，又可以根据下标从指定位置获取数据。</p><h3 id="取出头部的节点"><a href="#取出头部的节点" class="headerlink" title="取出头部的节点"></a>取出头部的节点</h3><p><code>LinkedList</code> 提供了多个方法来允许用户从链表头部取出数据，分别有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or {<span class="doctag">@code</span> null} if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or {<span class="doctag">@code</span> null} if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从头部取出节点的操作都大同小异，区别只是在于取出空值之后是抛异常还是返回 null，以及会不会同时删除头部元素。逻辑很简单，这里就不多赘述了。</p><p>除了上面列出的几个方法外，还有 <code>pop()</code>、<code>pollFirst()</code> 等方法也提供了相同的功能，但是代码内容大同小异，所以也不放上来了，以免浪费篇幅。</p><h3 id="取出尾部的节点"><a href="#取出尾部的节点" class="headerlink" title="取出尾部的节点"></a>取出尾部的节点</h3><p><code>LinkedList</code> 同样提供了数个方法用于从尾部取出节点，它们的逻辑也基本相同，这里同上文一样，仅展示部分代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the last element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the last element of this list,</span></span><br><span class="line"><span class="comment"> * or returns {<span class="doctag">@code</span> null} if this list is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element of this list, or {<span class="doctag">@code</span> null}</span></span><br><span class="line"><span class="comment"> *         if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the last element of this list,</span></span><br><span class="line"><span class="comment"> * or returns {<span class="doctag">@code</span> null} if this list is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element of this list, or {<span class="doctag">@code</span> null} if</span></span><br><span class="line"><span class="comment"> *     this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="取出中间的节点"><a href="#取出中间的节点" class="headerlink" title="取出中间的节点"></a>取出中间的节点</h3><p>要从链表中的某个位置取出节点，可以使用 <code>get(int)</code> 方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它首先还是检查了传入的下标是否合法，如果合法就调用 <code>node(int)</code> 方法取得该节点，并返回其数据。<code>node(int)</code> 方法在上面已经介绍过，这里就不重复介绍了。</p><h3 id="查询链表是否包含某个数据"><a href="#查询链表是否包含某个数据" class="headerlink" title="查询链表是否包含某个数据"></a>查询链表是否包含某个数据</h3><p><code>LinkedList</code> 提供了 <code>contains(Object)</code> 方法用来查询该链表是否包含某个数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if this list contains the specified element.</span></span><br><span class="line"><span class="comment"> * More formally, returns {<span class="doctag">@code</span> true} if and only if this list contains</span></span><br><span class="line"><span class="comment"> * at least one element {<span class="doctag">@code</span> e} such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this list is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this list contains the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index {<span class="doctag">@code</span> i} such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to search for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the first occurrence of the specified element in</span></span><br><span class="line"><span class="comment"> *         this list, or -1 if this list does not contain the element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) {</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) {</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>contains(Object)</code> 方法实际上是调用了 <code>indexOf(Object)</code> 方法，并检查其返回是否为 <code>-1</code>，来判断这个值是否存在于该链表中。</p><p><code>indexOf(Object)</code> 方法的逻辑就是，从链表的头部开始，逐个检查其节点的值是否为传入的值。如果链表为空则直接返回 <code>-1</code>。</p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p><code>LinkedList</code> 提供了一个 <code>set(int, E)</code> 的方法用于修改某个节点的数据。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>{</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该方法首先检查传入的下标是否合法，检查通过后，它会为指定位置的节点设定新的数据，并返回该节点原有的数据。</p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p><code>LinkedList</code> 提供了多个方法来从链表中删除节点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the first element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the last element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>removeFirst()</code> 和 <code>removeLast()</code> 方法分别可以从链表的头部和尾部取出一个节点，并将其删除。如果链表是空的，则会抛出 <code>NoSuchElementException</code> 异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.  Shifts any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the left (subtracts one from their indices).</span></span><br><span class="line"><span class="comment"> * Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>remove(int)</code> 方法可以用来取出并删除指定位置下的一个节点，同时所有处于其后方的节点都将向前移动一个位置。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If this list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> i} such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns {<span class="doctag">@code</span> true} if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) {</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) {</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) {</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) {</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element in this</span></span><br><span class="line"><span class="comment"> * list (when traversing the list from head to tail).  If the list</span></span><br><span class="line"><span class="comment"> * does not contain the element, it is unchanged.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if the list contained the specified element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the last occurrence of the specified element in this</span></span><br><span class="line"><span class="comment"> * list (when traversing the list from head to tail).  If the list</span></span><br><span class="line"><span class="comment"> * does not contain the element, it is unchanged.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if the list contained the specified element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) {</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) {</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) {</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) {</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>remove(Object)</code> 方法和 <code>removeFirstOccurrence(Object)</code> 方法会从头部遍历整个链表，并检查各个节点是否与传入的参数匹配。一旦找到一个匹配的节点就将其删除，并结束操作。<code>removeLastOccurrence(Object)</code> 方法则是从链表尾部开始查找匹配的节点，并删除第一个匹配到的节点。</p><h2 id="将LinkedList当作栈来操作"><a href="#将LinkedList当作栈来操作" class="headerlink" title="将LinkedList当作栈来操作"></a>将 <code>LinkedList</code> 当作栈来操作</h2><p>上面说过，<code>LinkedList</code> 可以被当成一个双向队列来操作。那么，如果我们把这个队列的底部 “封死”，只操作头部，它是不是就变成了一个栈呢？没错，它是可以这样用的，而且也已经有方法来允许我们这样操作了。实际上，<code>push</code> 和 <code>pop</code> 的操作，就是直接调用了 <code>addFirst(E)</code> 和 <code>removeFirst()</code> 方法来实现入栈和出栈操作的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to {<span class="doctag">@link</span> #addFirst}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to push</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    addFirst(e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops an element from the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, removes and returns the first element of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to {<span class="doctag">@link</span> #removeFirst()}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the front of this list (which is the top</span></span><br><span class="line"><span class="comment"> *         of the stack represented by this list)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><code>LinkedList</code> 提供了 <code>iterator()</code> 和 <code>listIterator(int)</code> 方法来获取迭代器。实际上这两个方法都将返回一个 <code>ListItr</code> 实例，区别在于 <code>iterator()</code> 是从链表头部开始迭代，而 <code>listIterator(int)</code> 方法则是从指定位置开始迭代。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 上次迭代时返回的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一次迭代即将返回的节点</span></span><br><span class="line">    <span class="comment">// 其实也是当前指向但仍未取值的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个被迭代节点的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) {</span><br><span class="line">        <span class="comment">// 判断开始迭代的位置是否为链表末尾</span></span><br><span class="line">        <span class="comment">// 如果不是末尾就取出开始迭代位置的节点，否则取出null</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将nextIndex指向初始迭代位置</span></span><br><span class="line">        nextIndex = index;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查有无下一个节点可供迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 如果下一个迭代位置的下标小于链表长度</span></span><br><span class="line">        <span class="comment">// 就认为还有元素可供迭代</span></span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 检查链表的结构有没有被修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经没有节点可供迭代</span></span><br><span class="line">        <span class="comment">// 则抛出NoSuchElementException</span></span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出下一个被迭代的节点</span></span><br><span class="line">        lastReturned = next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next指针像下一个节点移动</span></span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出当前被迭代的节点的值</span></span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextIndex的初始值为0</span></span><br><span class="line">    <span class="comment">// 当它大于0时，就认定该位置的前面仍有节点可供迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 检查链表的结构有没有被修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查前面有无节点可供迭代</span></span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前节点是否为null，如果是，就说明当前已经处于链表的末尾，那么就返回链表最后一个节点；</span></span><br><span class="line">        <span class="comment">// 如果不是，就返回当前位置的上一个节点</span></span><br><span class="line">        <span class="comment">// 然后设定当前位置和上一次返回位置为上一个节点</span></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个被迭代节点的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一次被迭代节点的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除上一次被迭代的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 检查链表的结构有没有被修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有上一次被迭代的节点</span></span><br><span class="line">        <span class="comment">// 则抛出IllegalStateException</span></span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出将被删除节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后删掉它</span></span><br><span class="line">        unlink(lastReturned);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextIndex--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置上一次被迭代的位置</span></span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为unlink会使modCound加一</span></span><br><span class="line">        <span class="comment">// 所以这里要同步把expectedModCount加一</span></span><br><span class="line">        expectedModCount++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改上次迭代到的节点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为lastReturned是某个节点的引用</span></span><br><span class="line">        <span class="comment">// 所以可以直接修改它的值</span></span><br><span class="line">        lastReturned.item = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在下一个被迭代的节点前插入一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果已经迭代到链表的末尾，那么就在末尾新增一个节点</span></span><br><span class="line">            linkLast(e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则就在下个被迭代的节点前插入一个节点</span></span><br><span class="line">            linkBefore(e, next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 游标向后移一位</span></span><br><span class="line">        nextIndex++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步expectedModCount</span></span><br><span class="line">        expectedModCount++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>{</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) {</span><br><span class="line">            action.accept(next.item);</span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">        }</span><br><span class="line">        checkForComodification();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java-read-src-linkedlist.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 Spring Boot 应用中配置统一的请求响应</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/generify-response-format-in-spring-boot-applications.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/generify-response-format-in-spring-boot-applications.html</guid>
      <pubDate>Sat, 21 Dec 2019 07:46:42 GMT</pubDate>
      <description>
      
        &lt;p&gt;在前后端分离的架构下，后端通常是一个 RESTFul 的接口，而因为 HTTP 的响应码数量有限，无法灵活的反映出接口执行的各种结果，在这种情况下，就需要通过自定义的结构来表达接口最终的状态和返回的信息。而我正好最近在一个项目中实现了一个基于 &lt;code&gt;ControllerAdvice&lt;/code&gt; 的统一请求响应的功能，在这里记录一下实现的方式。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在前后端分离的架构下，后端通常是一个 RESTFul 的接口，而因为 HTTP 的响应码数量有限，无法灵活的反映出接口执行的各种结果，在这种情况下，就需要通过自定义的结构来表达接口最终的状态和返回的信息。而我正好最近在一个项目中实现了一个基于 <code>ControllerAdvice</code> 的统一请求响应的功能，在这里记录一下实现的方式。</p><a id="more"></a><h2 id="创建common模块"><a href="#创建common模块" class="headerlink" title="创建common模块"></a>创建 common 模块</h2><p>因为这是一个公共的功能，所以需要创建一个新的 Maven 模块，并被所有项目引用为依赖。具体操作这里不再赘述。以下的所有代码，如无特殊说明，都将存在于这个 common 模块中。</p><h2 id="定义全局的错误码"><a href="#定义全局的错误码" class="headerlink" title="定义全局的错误码"></a>定义全局的错误码</h2><p>首先我们需要定义一个全局的错误码，使得项目中的所有模块都可以使用统一的一套返回码来表达自己接口的状态。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口返回码和描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ReturnCode</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OK(<span class="string">"0000"</span>, <span class="string">"成功"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端异常，当发生未知异常时使用该错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FAIL(<span class="string">"9999"</span>, <span class="string">"失败"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数中包含无效参数或请求体为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INVALID_REQUEST_PARAM(<span class="string">"0001"</span>, <span class="string">"请求参数中包含无效参数或请求体为空"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新数据的主键与已有数据重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DUPLICATED_RECORD(<span class="string">"0002"</span>, <span class="string">"新数据的主键与已有数据重复"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未找到对应记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NON_EXISTENT_RECORD(<span class="string">"0003"</span>, <span class="string">"未找到对应记录，请检查主键或操作流水号"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名校验失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SIGNATURE_VERIFICATION_FAIL(<span class="string">"0004"</span>, <span class="string">"签名校验失败"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为各模块自定义的错误码</span></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    ReturnCode(<span class="keyword">final</span> String code, <span class="keyword">final</span> String message) {</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据状态码获取其错误信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 状态码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 错误码对应的错误信息。如果没有找到则返回{<span class="doctag">@code</span> null}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessageByCode</span><span class="params">(String code)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (ReturnCode item : values()) {</span><br><span class="line">            <span class="keyword">if</span> (item.code.equals(code)) {</span><br><span class="line">                <span class="keyword">return</span> item.message;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定义统一响应结构"><a href="#定义统一响应结构" class="headerlink" title="定义统一响应结构"></a>定义统一响应结构</h2><p>在这个项目中，我选择在这个结构中定义三个字段：错误码 <code>errCode</code>，错误信息 <code>errMessage</code>，和返回的数据 <code>data</code>。</p><p>同时，用于构造响应体的类应该同时兼顾数据合法性和灵活性，所以我决定不允许通过构造方法或者 setter 来填充信息，而是使用定义好了的静态方法来完成构造。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公共响应参数&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 成功的返回通过{<span class="doctag">@link</span> CommonResponseParams#ofSuccessful()}或{<span class="doctag">@link</span> CommonResponseParams#ofSuccessful(Object)}生成&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 失败的返回通过{<span class="doctag">@link</span> CommonResponseParams#ofFailure()}或{<span class="doctag">@link</span> CommonResponseParams#ofFailure(ReturnCode)}生成</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonResponseParams</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回码 - 必填</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String errCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回描述 - 必填</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String errMessage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务数据 - 必填</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个{<span class="doctag">@link</span> CommonResponseParams}对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errCode    返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errMessage 返回描述</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data    业务数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CommonResponseParams</span><span class="params">(<span class="keyword">final</span> String errCode, <span class="keyword">final</span> String errMessage, <span class="keyword">final</span> Object data)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.errCode = errCode;</span><br><span class="line">        <span class="keyword">this</span>.errMessage = errMessage;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回成功结果，没有响应数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title">ofSuccessful</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ofSuccessful(<span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回成功结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 返回的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;     返回的数据的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">CommonResponseParams <span class="title">ofSuccessful</span><span class="params">(<span class="keyword">final</span> T content)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResponseParams(</span><br><span class="line">                ReturnCode.OK.getCode(),</span><br><span class="line">                ReturnCode.OK.getMessage(),</span><br><span class="line">                JSONArray.toJSON(content));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回失败结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title">ofFailure</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResponseParams(</span><br><span class="line">                ReturnCode.FAIL.getCode(),</span><br><span class="line">                ReturnCode.FAIL.getMessage(),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title">ofFailure</span><span class="params">(String errMessage)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResponseParams(</span><br><span class="line">                ReturnCode.FAIL.getCode(),</span><br><span class="line">                errMessage,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回失败结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnCode 错误的返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title">ofFailure</span><span class="params">(ReturnCode returnCode)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResponseParams(</span><br><span class="line">                returnCode.getCode(),</span><br><span class="line">                returnCode.getMessage(),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回带有自定义错误信息的失败结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnCode 错误相关的返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errMessage 自定义的错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title">ofFailure</span><span class="params">(ReturnCode returnCode, String errMessage)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResponseParams(</span><br><span class="line">                returnCode.getCode(),</span><br><span class="line">                errMessage,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定义统一的业务异常基类"><a href="#定义统一的业务异常基类" class="headerlink" title="定义统一的业务异常基类"></a>定义统一的业务异常基类</h2><p>为了减少不必要的 <code>try-catch</code> 模版代码，业务异常必须不能为受检异常；而为了与其它的运行时异常区分开来，业务异常类就不能直接继承 <code>RuntimeException</code>，而是需要继承于一个自定义的基类。同时，这个业务异常基类不能被直接使用，所以必须是一个抽象类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务异常基类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBizException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>{</span><br><span class="line">    <span class="keyword">protected</span> ReturnCode returnCode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseBizException</span><span class="params">(String message)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseBizException</span><span class="params">(ReturnCode returnCode)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(returnCode.getMessage());</span><br><span class="line">        <span class="keyword">this</span>.returnCode = returnCode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务异常不记录stack trace</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定义统一的异常处理方法"><a href="#定义统一的异常处理方法" class="headerlink" title="定义统一的异常处理方法"></a>定义统一的异常处理方法</h2><p>在上面的准备工作全部完成后，就可以开始着手配置统一的异常处理方法。之所以选择不使用 <code>AOP</code> 实现，是因为在这个情况下，业务接口必须返回 <code>Object</code> 类型，而这样一来，会降低代码层面的可读性。使用 <code>ControllerAdvice</code> 注解实现则没有这个限制，业务接口可以自由选择自己合适的数据类型。</p><p>需要注意的是，因为我们所有的 controller 类都会带有 <code>RestController</code> 注解，所以在 <code>ControllerAdvice</code> 注解中，我们使用 <code>annotations</code> 参数指定了这个配置类仅针对带有 <code>RestController</code> 的类启用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一异常处理配置类&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 包装格式见{<span class="doctag">@link</span> CommonResponseParams}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnifiedExceptionHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理数据库连接失败抛出的异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 带有数据库连接失败信息的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(CannotCreateTransactionException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResponseParams <span class="title">handleCannotCreateTransactionException</span><span class="params">(CannotCreateTransactionException e)</span> </span>{</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(<span class="string">"数据库连接失败"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理未知的运行时错误</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResponseParams <span class="title">handleUnknownRuntimeExceptions</span><span class="params">(RuntimeException e)</span> </span>{</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(e.getMessage());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理公共请求参数校验失败异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 参数校验失败抛出的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 带有校验失败原因提示信息的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResponseParams <span class="title">handleRequestParamValidationExceptions</span><span class="params">(MethodArgumentNotValidException e)</span> </span>{</span><br><span class="line">        String errMessage = Optional.ofNullable(e.getBindingResult().getFieldError())</span><br><span class="line">                .map(FieldError::getDefaultMessage)</span><br><span class="line">                .orElse(ReturnCode.INVALID_REQUEST_PARAM.getMessage());</span><br><span class="line"></span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(ReturnCode.INVALID_REQUEST_PARAM, errMessage);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求body为空的异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 带有请求体无效错误的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResponseParams <span class="title">handleHttpMessageNotReadableException</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(ReturnCode.INVALID_REQUEST_PARAM);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理新增数据主键重复异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 带有主键重复错误的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(DuplicateKeyException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResponseParams <span class="title">handleDuplicateKeyException</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(ReturnCode.DUPLICATED_RECORD);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理业务异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 业务异常对应的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseBizException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResponseParams <span class="title">handleBizExceptions</span><span class="params">(BaseBizException e)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (e.getReturnCode() != <span class="keyword">null</span>) {</span><br><span class="line">            ReturnCode returnCode = e.getReturnCode();</span><br><span class="line">            log.error(returnCode.getMessage());</span><br><span class="line">            <span class="keyword">return</span> CommonResponseParams.ofFailure(returnCode);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isNotBlank(e.getMessage())) {</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> CommonResponseParams.ofFailure(e.getMessage());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> CommonResponseParams.ofFailure();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里详细说一下各个方法的作用。</p><p>第一个方法用于处理 <code>CannotCreateTransactionException</code> 异常类，这个异常会在应用无法成功连接数据库时被抛出。处理方式就是返回一个错误信息为 “数据库连接失败” 的失败结果。</p><p>第二个方法用于处理 <code>RuntimeException</code> 异常，这个方法的意义在于，我们无法预见所有可能出现的异常，所以使用这个方法作为一个兜底的处理方法。</p><p>第三个方法用于处理 <code>MethodArgumentNotValidException</code> 异常。因为这个项目中我们选择使用 <code>javax.validation.constraints</code> 包中的注解实现输入参数合法性的校验，而当校验失败时会抛出 <code>MethodArgumentNotValidException</code> 异常，并且在异常中会包含具体的校验失败的原因。同时为了保证方法的健壮性，在代码中也保证了如果无法获取到校验失败信息，就会选择 <code>INVALID_REQUEST_PARAM</code> 这个错误码作为兜底的错误信息。</p><p>第四个方法用于处理 <code>HttpMessageNotReadableException</code> 异常。如果一个接口方法的参数中存在被 <code>@RequestBody</code> 标记的参数，但是在请求该接口时 body 为空时，就会抛出这个异常。在出现了这个异常后，就会返回带有 <code>INVALID_REQUEST_PARAM</code> 错误信息的失败结果。</p><p>第五个方法用于处理 <code>DuplicateKeyException</code> 异常。因为这个项目中一部分数据的主键是由请求发起方生成的，同时数据库中也会将这一列定为主键来实现插入接口的幂等性。一旦出现网络状况不佳的情况时，发起方会尝试再次调用接口。而在重发请求时，可能数据已经在上一个请求中就已经成功插入了，只是因为网络不佳导致发起方没能接收到返回，在第二次请求中重复插入相同主键的数据，就会抛出这个异常。为了最终接口返回信息的可读性，我们选择在这里返回一个用户友好的信息。</p><p>最后一个方法就是这里的主角了，它用于处理所有继承了 <code>BaseBizException</code> 的业务异常。这个方法中，我们对应着 <code>CommonResponseParams</code> 中不同的静态方法，实现了对应的错误处理逻辑。</p><h2 id="定义统一的成功响应处理方法"><a href="#定义统一的成功响应处理方法" class="headerlink" title="定义统一的成功响应处理方法"></a>定义统一的成功响应处理方法</h2><p>上面洋洋洒洒写了一堆针对异常的处理逻辑，但是接口成功执行的处理逻辑也不能落下。这里我们使用 <code>RestControllerAdvice</code> 表示这是一个接口增强类，同时实现了 <code>ResponseBodyAdvice</code> 接口，用于实现实际的处理逻辑。</p><p>在这个配置类上，我们也指定了该配置类仅针对被 <code>RestController</code> 标记的类生效。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一响应格式配置类&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 包装格式见{<span class="doctag">@link</span> CommonResponseParams}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnifiedReturnConfig</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MediaType selectedContentType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpResponse response)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> CommonResponseParams) {</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofSuccessful(body);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码的重点是在 <code>beforeBodyWrite</code> 方法中。这个方法会在 <code>HttpMessageConverter#write()</code> 方法执行前，也就是返回被发出去之前被调用。借助这个功能，我们就可以实现在业务接口返回之后，将返回信息重新包装。</p><p>实现逻辑很简单，如果返回信息是一个 <code>CommonResponseParams</code> 对象，那么就认为这个返回信息已经被包装好了，所以不再进行二次包装，直接返回；否则就通过 <code>CommonResponseParams#ofSuccessful()</code> 方法，将返回信息包装为一个成功响应的格式，再返回到客户端。</p><h2 id="最后的一点配置"><a href="#最后的一点配置" class="headerlink" title="最后的一点配置"></a>最后的一点配置</h2><p>在上文中，统一返回格式的配置已经完成了。但是有的人可能会发现，虽然在自己的项目中引用了这个模块，但是实际上却没有生效，这是因为上面的配置类都存在于另一个 jar 包中，导致在应用启动时这些请求并没有被自动发现。解决方法也很简单，在项目的启动类 (即 <code>xxxApplication</code>) 中加上 <code>@ComponentScan</code> 注解，并在注解参数中加上 <code>UnifiedReturnConfig</code> 和 <code>UnifiedExceptionHandler</code> 所在的包名即可。</p>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/generify-response-format-in-spring-boot-applications.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 Spring Boot 应用中启用 HTTPS</title>
      <link>https://www.boris1993.com/projects/java/coding-tips/spring-boot-enable-https.html</link>
      <guid>https://www.boris1993.com/projects/java/coding-tips/spring-boot-enable-https.html</guid>
      <pubDate>Tue, 17 Dec 2019 06:45:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;在 &lt;code&gt;application.yml&lt;/code&gt; 中添加如下配置，即可在 Spring Boot 项目中开启 HTTPS。&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;server:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;# 如果有需要的话，配置应用监听HTTPS的默认端口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;port:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;443&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;ssl:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 我把证书放在了 resources/cert/certificate.pfx下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 使用时需要按照实际情况修改下面的路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;key-store:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;classpath:cert/certificate.pfx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;key-store-password:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;pA55w0Rd&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 证书类型需要按照实际类型填写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 本例使用PKCS12格式，所以写PKCS12。如果是JKS格式，那么需要填写JKS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 因为PKCS12比JKS有更好的通用型，所以个人建议使用PKCS12格式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;key-store-type:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;PKCS12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;enabled:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 <code>application.yml</code> 中添加如下配置，即可在 Spring Boot 项目中开启 HTTPS。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 如果有需要的话，配置应用监听HTTPS的默认端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="comment"># 我把证书放在了 resources/cert/certificate.pfx下</span></span><br><span class="line">    <span class="comment"># 使用时需要按照实际情况修改下面的路径</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:cert/certificate.pfx</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">pA55w0Rd</span></span><br><span class="line">    <span class="comment"># 证书类型需要按照实际类型填写</span></span><br><span class="line">    <span class="comment"># 本例使用PKCS12格式，所以写PKCS12。如果是JKS格式，那么需要填写JKS</span></span><br><span class="line">    <span class="comment"># 因为PKCS12比JKS有更好的通用型，所以个人建议使用PKCS12格式</span></span><br><span class="line">    <span class="attr">key-store-type:</span> <span class="string">PKCS12</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>使用如下命令即可将 JKS 证书转换为 PKCS12 证书：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore keystore.jks -destkeystore keystore.pfx -deststoretype pkcs12</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly93d3cudGhvbWFzdml0YWxlLmNvbS9odHRwcy1zcHJpbmctYm9vdC1zc2wtY2VydGlmaWNhdGUv">How to enable HTTPS in a Spring Boot Java application<i class="fa fa-external-link-alt"></i></span><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctYm9vdC9kb2NzLzIuMi4yLlJFTEVBU0UvcmVmZXJlbmNlL2h0bWwvaG93dG8uaHRtbCNob3d0by1jb25maWd1cmUtc3Ns">Spring Boot Docs - Configure SSL<i class="fa fa-external-link-alt"></i></span><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content:encoded>
      
      <comments>https://www.boris1993.com/projects/java/coding-tips/spring-boot-enable-https.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
