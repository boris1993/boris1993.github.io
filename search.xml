<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用 Docker 配置 Redis 哨兵</title>
    <url>/redis-sentinel-in-docker.html</url>
    <content><![CDATA[<p>接上文<a href="/database/Redis/redis-replication-in-docker.html">使用 Docker 配置 Redis 主从复制</a>完成之后，这篇文章主要介绍如何使用 Docker 在本机搭建 Redis 的哨兵，内容包括涉及的目录结构、<code>docker-compose.yml</code> 的编写。</p>
<span id="more"></span>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>本文将采用如下的目录结构，其中 <code>data</code> 目录将用于存放各个容器的数据，<code>server</code> 目录存放 <code>docker-compose.yml</code> 以及针对 <code>master</code> 和 <code>slave</code> 节点的配置文件，<code>sentinel</code> 目录存放哨兵的配置文件和 <code>docker-compose.yml</code>。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│&nbsp;&nbsp; ├── redis-master</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── dump.rdb</span><br><span class="line">│&nbsp;&nbsp; ├── redis-slave-1</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── dump.rdb</span><br><span class="line">│&nbsp;&nbsp; └── redis-slave-2</span><br><span class="line">│&nbsp;&nbsp;     └── dump.rdb</span><br><span class="line">├── sentinel</span><br><span class="line">│&nbsp;&nbsp; ├── docker-compose.yml</span><br><span class="line">│&nbsp;&nbsp; └── redis-sentinel.conf</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    └── redis-slave.conf</span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h2><h3 id="节点配置示意图"><a href="#节点配置示意图" class="headerlink" title="节点配置示意图"></a>节点配置示意图</h3><p>下面的示意图中，将采用 Redis 官方文档所使用的表示方法，<code>M</code> 代表一个 Master 节点，<code>R</code> 代表一个 Replica 节点，<code>S</code> 代表一个 Sentinel 节点。</p>
<p>从整个集群的稳定性角度考虑，首先 Master 节点和各个 Replica 节点不应同时处于同一台服务器上，以避免单台虚拟机或物理机不可用造成整个集群失效。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br><span class="line"></span><br><span class="line">配置最少投票节点为2，即有2个哨兵节点投票选举出新的Master即可完成切换。</span><br></pre></td></tr></tbody></table></figure>

<p>在本示例中，我将使用如下的节点配置，各个节点运行在不同的 Docker 容器中，来模拟运行在不同服务器中的效果：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">+----+   +----+   +----+</span><br><span class="line">| M1 |   | R1 |   | R2 |</span><br><span class="line">+----+   +----+   +----+</span><br><span class="line">  |        |        |</span><br><span class="line">  +--------+--------+</span><br><span class="line">  |        |        |</span><br><span class="line">+----+   +----+   +----+</span><br><span class="line">| S1 |   | S2 |   | S3 |</span><br><span class="line">+----+   +----+   +----+</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>编辑 <code>redis-sentinel-1.conf</code>，修改下列配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 哨兵的端口号</span><br><span class="line"># 因为各个哨兵节点会运行在单独的Docker容器中</span><br><span class="line"># 所以无需担心端口重复使用</span><br><span class="line"># 如果需要在单机</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 配置哨兵的监控参数</span><br><span class="line"># 格式：sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># master-name是为这个被监控的master起的名字</span><br><span class="line"># ip是被监控的master的IP或主机名。因为Docker容器之间可以使用容器名访问，所以这里写master节点的容器名</span><br><span class="line"># redis-port是被监控节点所监听的端口号</span><br><span class="line"># quorom设定了当几个哨兵判定这个节点失效后，才认为这个节点真的失效了</span><br><span class="line">sentinel monitor local-master 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"># 连接主节点的密码</span><br><span class="line"># 格式：sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass local-master redis</span><br><span class="line"></span><br><span class="line"># master在连续多长时间无法响应PING指令后，就会主观判定节点下线，默认是30秒</span><br><span class="line"># 格式：sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds local-master 30000</span><br></pre></td></tr></tbody></table></figure>

<p>编辑 <code>redis-sentinel-2.conf</code> 和 <code>redis-sentinel-3.conf</code>，分别修改监听端口号为 <code>26380</code> 和 <code>26381</code>，其余部分不变。</p>
<h2 id="配置及启动容器"><a href="#配置及启动容器" class="headerlink" title="配置及启动容器"></a>配置及启动容器</h2><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写 <code>docker-compose.yml</code></h3><p>这里继续使用 <code>docker-compose</code> 管理容器。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis-sentinel-1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-sentinel-1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="comment"># 为了规避Docker中端口映射可能带来的问题</span></span><br><span class="line">    <span class="comment"># 这里选择使用host网络</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-sentinel-1.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line">    <span class="comment"># 指定时区，保证容器内时间正确</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    <span class="attr">sysctls:</span></span><br><span class="line">      <span class="attr">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"redis-sentinel"</span>, <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span>]</span><br><span class="line">  <span class="attr">redis-sentinel-2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-sentinel-2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-sentinel-2.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    <span class="attr">sysctls:</span></span><br><span class="line">      <span class="attr">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"redis-sentinel"</span>, <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span>]</span><br><span class="line">  <span class="attr">redis-sentinel-3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-sentinel-3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-sentinel-3.conf:/usr/local/etc/redis/redis-sentinel.conf</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    <span class="attr">sysctls:</span></span><br><span class="line">      <span class="attr">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"redis-sentinel"</span>, <span class="string">"/usr/local/etc/redis/redis-sentinel.conf"</span>]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>这里同样使用 <code>docker-compose up -d</code> 启动容器，启动日志中可以看到哨兵开始监控 Master 节点，以及哨兵完成互相发现。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:33:06.871 # +monitor master local-master 127.0.0.1 6379 quorum 2</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:33:08.996 * +sentinel sentinel 3dc4e0bff631b994a492d51e99a7ebc48e35a054 127.0.0.1 26381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:06.990 # +monitor master local-master 127.0.0.1 6379 quorum 2</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:07.001 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:07.010 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:08.876 * +sentinel sentinel 6f646433feb264b582ffa73b5d6bed6626b97966 127.0.0.1 26380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:33:08.968 * +sentinel sentinel c3b07d8c4ac3686511e436e71043a615e9b1d420 127.0.0.1 26379 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:33:06.948 # +monitor master local-master 127.0.0.1 6379 quorum 2</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:33:08.997 * +sentinel sentinel 3dc4e0bff631b994a492d51e99a7ebc48e35a054 127.0.0.1 26381 @ local-master 127.0.0.1 6379</span><br></pre></td></tr></tbody></table></figure>

<p>然后使用 <code>redis-cli</code> 连接到哨兵节点，连接成功后，可以使用 <code>info sentinel</code> 检查哨兵的信息。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1:26379&gt; info sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=local-master,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3</span><br></pre></td></tr></tbody></table></figure>

<p>其中，<code>sentinel_masters:1</code> 说明这个哨兵在监控一个 master，最后一行中写明了 <code>master0</code> 这个节点别名为 <code>local-master</code>，状态为 <code>OK</code>，地址是 <code>10.1.0.2:6379</code>，有 2 个从节点，并有 3 个哨兵在监控。</p>
<h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>哨兵光是启动了还是不够的，还需要测试一下当被监控节点下线之后，哨兵是否能作出反应。</p>
<p>我先停掉一个从节点，redis-server-slave-2，等了 30 秒后，三个哨兵主观认为 redis-server-slave-2 下线。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:37:42.232 # +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:37:42.290 # +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:37:42.291 # +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br></pre></td></tr></tbody></table></figure>

<p>重新启动 redis-server-slave-2 后，三个哨兵节点都宣布不再主观认为该节点下线。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:40:19.160 * +reboot slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:40:19.243 # -sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:40:19.403 * +reboot slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:40:19.161 * +reboot slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:40:19.242 # -sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:40:19.502 # -sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br></pre></td></tr></tbody></table></figure>

<p>这次我停掉主节点，并经过 30 秒后，哨兵输出了一大堆日志，不要紧，我们一边看一边解读：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:11.639 # +sdown master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.695 # +sdown master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.752 # +new-epoch 1</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.755 # +vote-for-leader 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.758 # +odown master local-master 127.0.0.1 6379 #quorum 3/2</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:11.759 # Next failover delay: I will not start a failover before Mon Nov 11 14:50:11 2019</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.661 # +sdown master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.746 # +odown master local-master 127.0.0.1 6379 #quorum 2/2</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.746 # +new-epoch 1</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.747 # +try-failover master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.749 # +vote-for-leader 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.755 # c3b07d8c4ac3686511e436e71043a615e9b1d420 voted for 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.756 # 6f646433feb264b582ffa73b5d6bed6626b97966 voted for 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:11.753 # +new-epoch 1</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:11.754 # +vote-for-leader 3dc4e0bff631b994a492d51e99a7ebc48e35a054 1</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.826 # +elected-leader master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.832 # +failover-state-select-slave master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.894 # +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.895 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:11.971 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:12.436 # +config-update-from sentinel 3dc4e0bff631b994a492d51e99a7ebc48e35a054 127.0.0.1 26381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:12.436 # +switch-master local-master 127.0.0.1 6379 127.0.0.1 6380</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:12.437 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:12.439 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:12.434 # +config-update-from sentinel 3dc4e0bff631b994a492d51e99a7ebc48e35a054 127.0.0.1 26381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:12.435 # +switch-master local-master 127.0.0.1 6379 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:12.435 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:12.437 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.372 # +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.373 # +failover-state-reconf-slaves master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.433 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.753 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:12.920 # -odown master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.825 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.883 # +failover-end master local-master 127.0.0.1 6379</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.883 # +switch-master local-master 127.0.0.1 6379 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.884 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:13.885 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:44:42.446 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:44:42.465 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:44:43.887 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br></pre></td></tr></tbody></table></figure>

<p>首先，三台哨兵都宣布 Master 节点主观下线。</p>
<p>因为在配置文件中，我们指定了当最少 2 个哨兵认为 Master 节点失效后就会开始选举 (就是 quorom)，所以哨兵 2 提出选举新的 Master 节点。</p>
<p>接下来，哨兵将开始投票，从 Slave 节点中选举出新的 Master 节点。在达成一致后，被选举的 Slave 节点将成为新的 Master 节点，其配置文件将会被改写，来让这个变动永久生效。</p>
<p>然后，哨兵会通知这个集群的其他节点来加入新的 Master，包括挂掉的那个之前的 Master。</p>
<p>这样就完成了一次 failover 切换。</p>
<p>此时，如果重启之前的 Master 节点，哨兵会发现节点上线，并不再主观认为该节点下线。但是，现在这个节点已经变成了一个 Slave 节点。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">redis-sentinel-1    | 1:X 11 Nov 2019 14:56:32.936 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-2    | 1:X 11 Nov 2019 14:56:33.202 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br><span class="line">redis-sentinel-3    | 1:X 11 Nov 2019 14:56:33.707 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ local-master 127.0.0.1 6380</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby90b3BpY3Mvc2VudGluZWwjc2VudGluZWwtZG9ja2VyLW5hdC1hbmQtcG9zc2libGUtaXNzdWVz">Sentinel, Docker, NAT, and possible issues - Redis Sentinel Documentation<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h2><ul>
<li><a href="/database/Redis/redis-replication-in-docker.html">使用 Docker 配置 Redis 主从复制</a></li>
<li><a href="/database/Redis/redis-sentinel-in-docker.html">使用 Docker 配置 Redis 哨兵</a></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次抢救被 force push 的 GitHub 仓库</title>
    <url>/rescuing-my-github-repo-from-force-push.html</url>
    <content><![CDATA[<p>就在刚刚，我一个误操作，在没有本地备份的前提下，force push 了一个 GitHub 上的仓库。万幸最后恢复成功，数据拿回来了。惊魂未定之余，在此记录我的抢救过程以供参考。</p>
<span id="more"></span>

<h2 id="前景提要"><a href="#前景提要" class="headerlink" title="前景提要"></a>前景提要</h2><p>在闲逛 GitHub 的时候，发现了一个叫<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BsYXRhbmUvc25r"> snk<i class="fa fa-external-link-alt"></i></span>的项目，可以在我的 profile readme 里面放个贪吃蛇，遂照着它的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BsYXRhbmUvUGxhdGFuZS9ibG9iL21hc3Rlci8uZ2l0aHViL3dvcmtmbG93cy9tYWluLnltbA=="> example with cron job<i class="fa fa-external-link-alt"></i></span>抄了一个 workflow 过来。但是这里我自作聪明地想着把东西全放在 <code>master</code> 上，就把 38 行的 <code>target_branch</code> 改成了 <code>master</code>。结果一运行吓一跳，我的 <code>README.md</code> 没了，仓库只剩下 <code>snk</code> 生成的 svg 文件。这不行啊，我花了好久的时间才整出来的东西，不能说没就没啊！于是赶紧开始网上冲浪，看怎么抢救被 force push 的 repo。</p>
<h2 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h2><p>首先我要大力感谢<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYWdhcndhbHBhcmFzL2QzNTVhOTUwMTQ4NzAyY2M3YmE4MmFiYzRkMTk0M2Jm">这个 Gist<i class="fa fa-external-link-alt"></i></span>，我就是参考这里的做法成功恢复了这个 repo 的。</p>
<h3 id="找到上一次commit的记录"><a href="#找到上一次commit的记录" class="headerlink" title="找到上一次commit的记录"></a>找到上一次 commit 的记录</h3><p>首先，要通过 <code>https://api.github.com/repos/:owner/:repo/events</code> 这个 API 找到上次提交的 sha。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">-&gt; % curl -u boris1993 https://api.github.com/repos/boris1993/boris1993/events</span><br><span class="line">Enter host password <span class="keyword">for</span> user <span class="string">'boris1993'</span>:</span><br><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"24633558565"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"PushEvent"</span>,</span><br><span class="line">    <span class="string">"actor"</span>: {</span><br><span class="line">      <span class="string">"id"</span>: 4367313,</span><br><span class="line">      <span class="string">"login"</span>: <span class="string">"boris1993"</span>,</span><br><span class="line">      <span class="string">"display_login"</span>: <span class="string">"boris1993"</span>,</span><br><span class="line">      <span class="string">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"url"</span>: <span class="string">"https://api.github.com/users/boris1993"</span>,</span><br><span class="line">      <span class="string">"avatar_url"</span>: <span class="string">"https://avatars.githubusercontent.com/u/4367313?"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">"repo"</span>: {</span><br><span class="line">      <span class="string">"id"</span>: 297097347,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"boris1993/boris1993"</span>,</span><br><span class="line">      <span class="string">"url"</span>: <span class="string">"https://api.github.com/repos/boris1993/boris1993"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">"payload"</span>: {</span><br><span class="line">      <span class="string">"push_id"</span>: 11349267173,</span><br><span class="line">      <span class="string">"size"</span>: 1,</span><br><span class="line">      <span class="string">"distinct_size"</span>: 1,</span><br><span class="line">      <span class="string">"ref"</span>: <span class="string">"refs/heads/master"</span>,</span><br><span class="line">      <span class="string">"head"</span>: <span class="string">"98364ce80ec5bbcdb6dc6f8d2239de2256ede487"</span>,</span><br><span class="line">      <span class="string">"before"</span>: <span class="string">"32276fc643c6b34fee48f46363cfb6a44327cbe4"</span>,</span><br><span class="line">      <span class="string">"commits"</span>: [</span><br><span class="line">        {</span><br><span class="line">          <span class="string">"sha"</span>: <span class="string">"98364ce80ec5bbcdb6dc6f8d2239de2256ede487"</span>,</span><br><span class="line">          <span class="string">"author"</span>: {</span><br><span class="line">            <span class="string">"email"</span>: <span class="string">"41898282+github-actions[bot]@users.noreply.github.com"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"github-actions[bot]"</span></span><br><span class="line">          },</span><br><span class="line">          <span class="string">"message"</span>: <span class="string">"Deploy to GitHub pages"</span>,</span><br><span class="line">          <span class="string">"distinct"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="string">"url"</span>: <span class="string">"https://api.github.com/repos/boris1993/boris1993/commits/98364ce80ec5bbcdb6dc6f8d2239de2256ede487"</span></span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    },</span><br><span class="line">    <span class="string">"public"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"created_at"</span>: <span class="string">"2022-10-17T05:44:11Z"</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"24633554175"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"PushEvent"</span>,</span><br><span class="line">    <span class="string">"actor"</span>: {</span><br><span class="line">      <span class="string">"id"</span>: 4367313,</span><br><span class="line">      <span class="string">"login"</span>: <span class="string">"boris1993"</span>,</span><br><span class="line">      <span class="string">"display_login"</span>: <span class="string">"boris1993"</span>,</span><br><span class="line">      <span class="string">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"url"</span>: <span class="string">"https://api.github.com/users/boris1993"</span>,</span><br><span class="line">      <span class="string">"avatar_url"</span>: <span class="string">"https://avatars.githubusercontent.com/u/4367313?"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">"repo"</span>: {</span><br><span class="line">      <span class="string">"id"</span>: 297097347,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"boris1993/boris1993"</span>,</span><br><span class="line">      <span class="string">"url"</span>: <span class="string">"https://api.github.com/repos/boris1993/boris1993"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">"payload"</span>: {</span><br><span class="line">      <span class="string">"push_id"</span>: 11349264873,</span><br><span class="line">      <span class="string">"size"</span>: 1,</span><br><span class="line">      <span class="string">"distinct_size"</span>: 1,</span><br><span class="line">      <span class="string">"ref"</span>: <span class="string">"refs/heads/master"</span>,</span><br><span class="line">      <span class="string">"head"</span>: <span class="string">"32276fc643c6b34fee48f46363cfb6a44327cbe4"</span>,</span><br><span class="line">      <span class="string">"before"</span>: <span class="string">"b0ab0263c0693122ae8069c95526e13b7336483f"</span>,</span><br><span class="line">      <span class="string">"commits"</span>: [</span><br><span class="line">        {</span><br><span class="line">          <span class="string">"sha"</span>: <span class="string">"32276fc643c6b34fee48f46363cfb6a44327cbe4"</span>,</span><br><span class="line">          <span class="string">"author"</span>: {</span><br><span class="line">            <span class="string">"email"</span>: <span class="string">"boris1993@live.cn"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Boris Zhao"</span></span><br><span class="line">          },</span><br><span class="line">          <span class="string">"message"</span>: <span class="string">"Create generate_snake_animation.yml"</span>,</span><br><span class="line">          <span class="string">"distinct"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="string">"url"</span>: <span class="string">"https://api.github.com/repos/boris1993/boris1993/commits/32276fc643c6b34fee48f46363cfb6a44327cbe4"</span></span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    },</span><br><span class="line">    <span class="string">"public"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"created_at"</span>: <span class="string">"2022-10-17T05:43:50Z"</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"23024411036"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"PushEvent"</span>,</span><br><span class="line">    <span class="string">"actor"</span>: {</span><br><span class="line">      <span class="string">"id"</span>: 4367313,</span><br><span class="line">      <span class="string">"login"</span>: <span class="string">"boris1993"</span>,</span><br><span class="line">      <span class="string">"display_login"</span>: <span class="string">"boris1993"</span>,</span><br><span class="line">      <span class="string">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"url"</span>: <span class="string">"https://api.github.com/users/boris1993"</span>,</span><br><span class="line">      <span class="string">"avatar_url"</span>: <span class="string">"https://avatars.githubusercontent.com/u/4367313?"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">"repo"</span>: {</span><br><span class="line">      <span class="string">"id"</span>: 297097347,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"boris1993/boris1993"</span>,</span><br><span class="line">      <span class="string">"url"</span>: <span class="string">"https://api.github.com/repos/boris1993/boris1993"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">"payload"</span>: {</span><br><span class="line">      <span class="string">"push_id"</span>: 10514884570,</span><br><span class="line">      <span class="string">"size"</span>: 1,</span><br><span class="line">      <span class="string">"distinct_size"</span>: 1,</span><br><span class="line">      <span class="string">"ref"</span>: <span class="string">"refs/heads/master"</span>,</span><br><span class="line">      <span class="string">"head"</span>: <span class="string">"b0ab0263c0693122ae8069c95526e13b7336483f"</span>,</span><br><span class="line">      <span class="string">"before"</span>: <span class="string">"660e4d3896eb523d703464f89112a2eea07ee309"</span>,</span><br><span class="line">      <span class="string">"commits"</span>: [</span><br><span class="line">        {</span><br><span class="line">          <span class="string">"sha"</span>: <span class="string">"b0ab0263c0693122ae8069c95526e13b7336483f"</span>,</span><br><span class="line">          <span class="string">"author"</span>: {</span><br><span class="line">            <span class="string">"email"</span>: <span class="string">"boris1993@live.cn"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Boris Zhao"</span></span><br><span class="line">          },</span><br><span class="line">          <span class="string">"message"</span>: <span class="string">"Update README.md"</span>,</span><br><span class="line">          <span class="string">"distinct"</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="string">"url"</span>: <span class="string">"https://api.github.com/repos/boris1993/boris1993/commits/b0ab0263c0693122ae8069c95526e13b7336483f"</span></span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    },</span><br><span class="line">    <span class="string">"public"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"created_at"</span>: <span class="string">"2022-07-22T08:05:06Z"</span></span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>从接口的返回可以看到，截至现在一共有三次 push，仓库被覆盖就是发生在最上面的一次 push 中，而接下来的一个就是我添加 workflow 的那一次 push。</p>
<h3 id="从上一次的push记录中找回数据"><a href="#从上一次的push记录中找回数据" class="headerlink" title="从上一次的push记录中找回数据"></a>从上一次的 push 记录中找回数据</h3><p>找到 push 记录，那么就好办了。点击添加 workflow 那次 push 中的 <code>url</code>，在浏览器中会打开一个新页面，返回的 JSON 中是这次 push 的详细信息。这里我们要找的是 <code>html_url</code> 这个字段。点开这个字段里面的链接，会进入 GitHub 里面，看到这次 commit 的 diff。然后点击 <code>Browse files</code> 按钮，就能看到当时的文件了。这时候还等什么？赶紧下载啊！文件少的话复制内容回来就行，文件多的话，点开 <code>Code</code> 按钮，<code>Download ZIP</code> 就好啦。</p>
<p><img data-src="https://blog-static.boris1993.com/rescuing-my-github-repo-from-force-push/files_at_that_commit.png" alt="Files at that commit"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>一定要做备份啊！</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>GitHub</tag>
        <tag>force push</tag>
        <tag>恢复GitHub仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次修复生产环境中 nginx 出现的 SNI 相关的问题</title>
    <url>/resolving-nginx-sni-issue.html</url>
    <content><![CDATA[<p>前段时间，我司出现了一次生产事故，调查后发现是当时的 OpenResty 配置不兼容 SNI 导致的。在这里我也记录一下整件事的排查过程，以及解决方法，供遇到类似问题的同志们参考。</p>
<span id="more"></span>

<h1 id="事故症状"><a href="#事故症状" class="headerlink" title="事故症状"></a>事故症状</h1><p>某天开始，我司的 OpenResty 日志中大量出现 SSL 握手失败的错误，并影响了正常的业务。查看 OpenResty 日志，看到有大量这样子的报错：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2021/10/19 20:51:30 [warn] 16776#16776: *1110324 upstream server temporarily disabled while SSL handshaking to upstream, client: [MASKED], server: localhost, request: "GET /endpoint/to/the/api?query=param HTTP/1.1", upstream: "https://MASKED:443/endpoint/to/the/api?query=param", host: "MASKED"</span><br><span class="line"></span><br><span class="line">2021/10/19 20:51:30 [error] 16776#16776: *1110324 SSL_do_handshake() failed (SSL: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error:SSL alert number 80) while SSL handshaking to upstream, client: MASKED, server: localhost, request: "GET /endpoint/to/the/api?query=param HTTP/1.1", upstream: "https://MASKED:443/endpoint/to/the/api?query=param", host: "MASKED"</span><br></pre></td></tr></tbody></table></figure>

<h1 id="调查中的弯路"><a href="#调查中的弯路" class="headerlink" title="调查中的弯路"></a>调查中的弯路</h1><p>知道了是 SSL 握手失败导致的问题，那么当然接下来就开始调查为什么会握手失败。是解析配置出错？还是证书出现问题？</p>
<p>按照一直的经验，我决定先用 <code>nslookup</code> 检查一下 DNS 解析。因为保密和时间问题，我就不把 <code>nslookup</code> 的输出放在这里了。简而言之，再出现问题之前，我司的域名都是通过 <code>CNAME</code> 记录解析到 Akamai 的 Edge 节点上的，但现在，却直接用 <code>A</code> 记录解析到了一个 IP 上，这让我感觉很奇怪。同时，我为了确认，又用 <code>openssl</code> 命令连接了一下解析出来的 IP，看它会返回什么证书信息，可出乎意料，啥也没有。</p>
<p>我感觉不对劲，于是联系了 NetOps 组。这时候，NetOps 点出了这篇博文的主题，SNI。</p>
<p>他说，给 <code>openssl</code> 命令加一个 <code>-servername</code> 参数，把目标服务器的域名放上去。我一试，好使了，Akamai 返回了正确的证书信息。</p>
<p>那么问题来了，解析没问题，那就是我有问题了。但问题出在哪呢？</p>
<h1 id="SNI是什么"><a href="#SNI是什么" class="headerlink" title="SNI是什么"></a>SNI 是什么</h1><p>在继续之前，我想先简单介绍一下，什么是 SNI。</p>
<p>根据维基百科 <a href="%5B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E7%A7%B0%E6%8C%87%E7%A4%BA%5D(https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E7%A7%B0%E6%8C%87%E7%A4%BA)">^1</a> 中的说法：</p>
<blockquote>
<p>基于名称的虚拟主机允许多个 DNS 主机名由同一 IP 地址上的单个服务器（通常为 Web 服务器）托管。为了实现这一点，服务器使用客户端提供的主机名作为协议的一部分（对于 HTTP，名称显示在主机头中）。但是，当使用 HTTPS 时，TLS 握手发生在服务器看到任何 HTTP 头之前。因此，服务器不可能使用 HTTP 主机头中的信息来决定呈现哪个证书，并且因此只有由同一证书覆盖的名称才能由同一 IP 地址提供。<br>……<br>实际上，这意味着对于安全浏览来说，HTTPS 服务器只能是每个 IP 地址服务一个域名（或一组域名）。为每个站点分配单独的 IP 地址会增加托管成本，因为对 IP 地址的请求必须为区域互联网注册机构提供证据而且现在 IPv4 地址已用尽。<br>……<br>客户端在 SNI 扩展中发送要连接的主机名称，作为 TLS 协商的一部分。这使服务器能够提前选择正确的主机名称，并向浏览器提供相应 TLS 证书。从而，具有单个 IP 地址的服务器可以在获取公共证书不现实的情况下提供一组域名的 TLS 连接。</p>
</blockquote>
<p>也就是说，在握手的时候，我需要预先提供我要访问的网站的域名，这样服务器才会把正确的证书返回给我。而上面说的 <code>openssl</code> 命令中的 <code>-servername</code> 参数就是做了这件事。</p>
<h1 id="无心插柳，柳暗花明"><a href="#无心插柳，柳暗花明" class="headerlink" title="无心插柳，柳暗花明"></a>无心插柳，柳暗花明</h1><p>就在我拿着各种关键词 Google 的时候，一篇文章 [^2] 引起了我的注意。</p>
<p>文章里描述的问题也是在 OpenResty 中出现了 SSL 握手失败，同样作者也在 <code>proxy_pass</code> 中用了 <code>upstream</code>。作者做了一个测试，如果在 <code>proxy_pass</code> 中直接写上游的域名，就没有问题，但是一旦用 <code>upstream</code>，就会出现握手失败。那么问题一定出现在 <code>upstream</code> 导致的某种行为变化。</p>
<p>然后作者发现，在用域名的时候，OpenResty 的变量 <code>$proxy_host</code> 存放的就是域名，可在用 <code>upstream</code> 的时候，这里面就变成了那个 <code>upstream</code> 的名字。</p>
<p>看到这，我知道了，这应该就是我这个问题的解决方案。</p>
<h1 id="动手解决问题"><a href="#动手解决问题" class="headerlink" title="动手解决问题"></a>动手解决问题</h1><p>首先我先展示一下修复前的 OpenResty 的一部分配置：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">location</span> /path/to/endpoint {</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/proxy.common;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host api.<span class="variable">$DOMAIN_FOR_GCP</span>.com;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://gcp-https/path/to/the/endpoint/on/server;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可见，如果按照这个配置，那么我发给 Akamai 的域名就是 <code>gcp-https</code>，而不是正确的 <code>api.mycompany.com</code>。</p>
<p>所以，根据那篇文章，以及参照 OpenResty 的手册 [^3]，我在配置中增加了一条 <code>proxy_ssl_name</code> 指令，并将其配置为实际的后端服务的域名。</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">location</span> /path/to/endpoint {</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/proxy.common;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host api.<span class="variable">$DOMAIN_FOR_GCP</span>.com;</span><br><span class="line">    <span class="comment"># THIS ONE</span></span><br><span class="line">    <span class="attribute">proxy_ssl_name</span> api.<span class="variable">$DOMAIN_FOR_GCP</span>.com;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://gcp-https/path/to/the/endpoint/on/server;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可部署新配置之后，问题并未解决，SSL 握手失败的问题依旧存在。</p>
<p>然后我注意到，那篇文章中还出现了一个指令 <code>proxy_ssl_server_name on;</code>。莫非，我们的 OpenResty 里面干脆没启用 SNI 支持？</p>
<p>在终端里 dump 了一下当前的配置，果然没有显式指定 <code>proxy_ssl_server_name</code> 的值，而默认情况下这个是被关闭的 [^4]。那好办，我在 OpenResty 的全局配置中把它打开就好了。</p>
<p>然后再次部署测试，发现再没有 SSL 握手失败的问题，测试环境中业务也恢复了正常。火速打包上线生产环境，事故解决。</p>
<p>[^2]: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZGFpbHl0YXNrLmNvL3Rhc2svc3NsLWVycm9yMTQwOTQ0Mzhzc2wtcm91dGluZXNzc2wzcmVhZGJ5dGVzdGxzdjEtYWxlcnQtaW50ZXJuYWwtZXJyb3Jzc2wtYWxlcnQtbnVtYmVyLTgwLWFobWVkLXppZGFu">SSL: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error:SSL alert number 80<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfcHJveHlfbW9kdWxlLmh0bWwjcHJveHlfc3NsX25hbWU=">proxy_ssl_name - Module ngx_http_proxy_module<i class="fa fa-external-link-alt"></i></span><br>[^4]: <span class="exturl" data-url="aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfcHJveHlfbW9kdWxlLmh0bWwjcHJveHlfc3NsX3NlcnZlcl9uYW1l">proxy_ssl_server_name - Module ngx_http_proxy_module<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>OpenResty</tag>
        <tag>SNI</tag>
      </tags>
  </entry>
  <entry>
    <title>在 RouterOS 中配置 MSS Clamping 解决部分网站图片无法加载的问题</title>
    <url>/routeros-mss-clamping.html</url>
    <content><![CDATA[<p>换成自己用 RouterOS 拨号之后，经常发现有的图片加载不出来，网上一顿冲浪之后发现可能是在 RouterOS 中没有正确配置 MTU 及 MSS，导致部分包被丢弃，也就是传说中的 PMTU 黑洞。</p>
<span id="more"></span>

<h2 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h2><p>最常见的就是微信公众号的图片始终加载不出来，就像这样（自己当时没截图，借用知乎文章的图）：</p>
<p><img data-src="https://blog-static.boris1993.com/routeros-mss-clamping/symptom.jpg"></p>
<p>说来也很奇怪，我在 iOS 的微信上是能正常加载的，但是换到我妈的 Android 微信就会出现这样的情况，之前一直以为是我妈的手机出毛病了……</p>
<h2 id="PMTU黑洞"><a href="#PMTU黑洞" class="headerlink" title="PMTU黑洞"></a>PMTU 黑洞</h2><p>所谓 MTU，指的是一条链路上可以通过的三层数据包的最大尺寸（包含 IP 包头）。以太网默认的 MTU 是 1500 字节。但是从我的设备到目标服务器之间的路径上可能存在 MTU 小于 1500 的链路，那么这条路径上最小的 MTU，就是整条链路的 <code>Path MTU</code>（PMTU）。</p>
<p>路由器在转发包的时候，如果包的大小超过了 MTU，那么这个包会被分片（fragmentation）。而终端设备在发包时，也可以设置 DF 标志位（Don’t Fragment）来告诉路由器不要对这个包分片，此时如果这个包大小超过了 MTU，那么路由器就会丢掉这个包，并回复一条 <code>ICMP Fragmentation Needed</code> 消息。发送者收到这个消息后，下次就会发送小一点的包。这个过程叫做 PMTU 发现（PMTU Discovery）。</p>
<p>但是互联网中有大量的设备因为各种原因，会配置为不回应 <code>ICMP Fragmentation Needed</code> 消息，这使得大小超过 MTU 的包会被无声地丢掉，直到 TCP 协议发现超时丢包并进行重传。这种情况就是 <code>PMTU黑洞</code>。</p>
<p>此外，IPv6 包不支持分片，换句话说就是所有 IPv6 数据包全都带有 DF 标记。中间的路由器在遇到尺寸大于 MTU 的包的时候，应该回应 <code>ICMPv6 Packet Too Big</code> 消息，而同样的，由于各种原因，某些中间设备可能会直接丢掉这个包而不返回这条消息，直到 TCP 协议发现超时而进行重传。</p>
<h2 id="为什么用光猫或者硬路由拨号就没有这个问题"><a href="#为什么用光猫或者硬路由拨号就没有这个问题" class="headerlink" title="为什么用光猫或者硬路由拨号就没有这个问题"></a>为什么用光猫或者硬路由拨号就没有这个问题</h2><p>这是因为，多数家用路由器默认开启了一个叫 <code>MSS Clamping</code> 的功能。这是针对 PMTU 黑洞的一个 workaround，简单来说就是在 TCP 握手时，服务器会通过一个字段告知客户端它愿意接收的 TCP 包的最大尺寸，这样客户端就可以限制自己发送的包的大小，保证不会超出服务端要求的尺寸。</p>
<h2 id="在RouterOS中配置MSS-Clamping"><a href="#在RouterOS中配置MSS-Clamping" class="headerlink" title="在RouterOS中配置MSS Clamping"></a>在 RouterOS 中配置 MSS Clamping</h2><p>配置非常简单，分别对 IPv4 和 IPv6 的防火墙 Mangle 表添加如下配置即可。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将命令中 out-interface 参数的值替换成你的PPPoE接口的名字</span></span><br><span class="line">/ip/firewall<span class="built_in">/mangle</span></span><br><span class="line"><span class="built_in"></span><span class="built_in">add</span> <span class="attribute">action</span>=change-mss <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"IPv4 MSS clamp to PMTU"</span> \</span><br><span class="line">    <span class="attribute">new-mss</span>=clamp-to-pmtu <span class="attribute">out-interface</span>=<span class="string">"China Telecom"</span> <span class="attribute">passthrough</span>=<span class="literal">yes</span> \</span><br><span class="line">    <span class="attribute">protocol</span>=tcp <span class="attribute">tcp-flags</span>=syn</span><br><span class="line"></span><br><span class="line">/ipv6/firewall<span class="built_in">/mangle</span></span><br><span class="line"><span class="built_in"></span><span class="built_in">add</span> <span class="attribute">action</span>=change-mss <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"IPv6 MSS clamp to PMTU"</span> \</span><br><span class="line">    <span class="attribute">new-mss</span>=clamp-to-pmtu <span class="attribute">out-interface</span>=<span class="string">"China Telecom"</span> <span class="attribute">passthrough</span>=<span class="literal">yes</span> \</span><br><span class="line">    <span class="attribute">protocol</span>=tcp <span class="attribute">tcp-flags</span>=syn</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudjJleC5jb20vdC84MDAwMjQ=">开启 IPv6 后网速变得很慢？可能是 PMTU 黑洞的问题 - V2EX<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MzUzOTI4OTY=">ROS 修改 MTU 和 MSS 解决上网慢和页面显示不全问题<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vemgtY24vbGVhcm5pbmcvbmV0d29yay1sYXllci93aGF0LWlzLW1zcy8=">什么是最大分段大小 (MSS)？ - CloudFlare<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>二手MicroServer Gen8折腾记</tag>
        <tag>Gen8</tag>
        <tag>软路由</tag>
        <tag>RouterOS</tag>
      </tags>
  </entry>
  <entry>
    <title>RouterOS 配置 Wireguard 与阿里云 ECS 组网</title>
    <url>/routeros-setup-wireguard.html</url>
    <content><![CDATA[<p>前两天赶上阿里云搞活动，薅了一个 99 一年的 ECS。因为要接进咱的<span class="exturl" data-url="aHR0cHM6Ly9uZXpoYS5ib3JpczE5OTMuY29tLw==">探针<i class="fa fa-external-link-alt"></i></span>，就得跟我的服务器组个网。之前都是用 NAS 上装的 <code>wgeasy</code>，这回想想，咱的 RouterOS 也有 Wireguard，那干脆吃个螃蟹，看看能不能直接在软路由上组，慢慢的逐步把 <code>wgeasy</code> 淘汰掉，顺便正经的学学 Wireguard 组网。</p>
<span id="more"></span>

<h2 id="网络规划"><a href="#网络规划" class="headerlink" title="网络规划"></a>网络规划</h2><p>我的 LAN 网段：<code>192.168.1.0/24</code><br>Wireguard 网段：<code>10.10.0.0/24</code><br>分配给 ECS 的 Wireguard 地址：<code>10.10.0.100/32</code></p>
<h2 id="RouterOS端的准备"><a href="#RouterOS端的准备" class="headerlink" title="RouterOS端的准备"></a>RouterOS 端的准备</h2><p>首先添加一个 <code>Wireguard</code> 接口：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/interface/wireguard/<span class="built_in">add</span> <span class="attribute">disabled</span>=<span class="literal">no</span> <span class="attribute">listen-port</span>=13231 <span class="attribute">mtu</span>=1420 <span class="attribute">name</span>=wireguard1</span><br></pre></td></tr></tbody></table></figure>

<p>然后添加防火墙规则，允许 <code>13231/udp</code> 端口：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># in-interface更换成你的WAN接口的名字</span></span><br><span class="line">/ip/firewall<span class="built_in">/filter </span><span class="built_in">add</span> <span class="attribute">chain</span>=input <span class="attribute">in-interface</span>=<span class="string">"China Telecom"</span> <span class="attribute">dst-port</span>=13231 <span class="attribute">protocol</span>=udp <span class="attribute">action</span>=accept <span class="attribute">comment</span>=<span class="string">"Allow Wireguard"</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后为 Wireguard 分配一个网段：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ip<span class="built_in">/address </span><span class="built_in">add</span> <span class="attribute">address</span>=10.10.0.0/24 <span class="attribute">network</span>=10.10.0.0 <span class="attribute">interface</span>=wireguard1 <span class="attribute">comment</span>=Wireguard</span><br></pre></td></tr></tbody></table></figure>

<p>接下来配置转发规则，允许 LAN 和 Wireguard 网段互通：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ip/firewall<span class="built_in">/filter </span><span class="built_in">add</span> <span class="attribute">chain</span>=forward <span class="attribute">src-address</span>=192.168.1.0/24 <span class="attribute">dst-address</span>=10.10.0.0/24 <span class="attribute">action</span>=accept <span class="attribute">comment</span>=<span class="string">"Forward Wireguard to LAN"</span></span><br><span class="line">/ip/firewall<span class="built_in">/filter </span><span class="built_in">add</span> <span class="attribute">chain</span>=forward <span class="attribute">src-address</span>=10.10.0.0/24 <span class="attribute">dst-address</span>=192.168.1.0/24 <span class="attribute">action</span>=accept <span class="attribute">comment</span>=<span class="string">"Forward LAN to Wireguard"</span></span><br></pre></td></tr></tbody></table></figure>

<p>至此，RouterOS 上的 Wireguard 接口配置完毕。接下来需要取得 RouterOS 端 Wireguard 的公钥备用。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 记下输出中的 public-key 备用</span></span><br><span class="line">&gt; /interface/wireguard/<span class="built_in">print</span></span><br><span class="line">Flags: X - disabled; R - running </span><br><span class="line"> 0  R <span class="attribute">name</span>=<span class="string">"wireguard1"</span> <span class="attribute">mtu</span>=1420 <span class="attribute">listen-port</span>=13231 <span class="attribute">private-key</span>=<span class="string">"routeros-private-key"</span> <span class="attribute">public-key</span>=<span class="string">"routeros-public-key"</span> </span><br></pre></td></tr></tbody></table></figure>

<h2 id="ECS端的准备"><a href="#ECS端的准备" class="headerlink" title="ECS端的准备"></a>ECS 端的准备</h2><p>接下来登陆到 ECS，安装 Wireguard。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 安装Wireguard</span></span><br><span class="line">sudo apt install wireguard-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line"><span class="built_in">mkdir</span> wireguard &amp;&amp; <span class="built_in">cd</span> wireguard</span><br><span class="line">wg genkey | <span class="built_in">tee</span> privatekey | wg pubkey &gt; publickey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看公钥和私钥，备用</span></span><br><span class="line"><span class="built_in">cat</span> privatekey</span><br><span class="line"><span class="built_in">cat</span> publickey</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开始组网"><a href="#开始组网" class="headerlink" title="开始组网"></a>开始组网</h2><p>先回到 RouterOS，为 Wireguard 添加一个 Peer：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># allowed-address为我们要分配给这个节点的地址</span></span><br><span class="line"><span class="comment"># public-key要填写上面在ECS上得到的publickey</span></span><br><span class="line"><span class="comment"># preshared-key相当于密码，用来保护这个peer不会被陌生的节点连接</span></span><br><span class="line"><span class="comment"># comment按需填写，用来标识这个节点</span></span><br><span class="line">/interface/wireguard/peers <span class="built_in">add</span> <span class="attribute">allowed-address</span>=10.10.0.100/32 <span class="attribute">interface</span>=wireguard1 <span class="attribute">public-key</span>=<span class="string">"ECS-PUBLIC-KEY"</span> <span class="attribute">preshared-key</span>=<span class="string">"the-preshared-key"</span> <span class="attribute">comment</span>=ECS-SH-1</span><br></pre></td></tr></tbody></table></figure>

<p>接下来到 ECS，在 <code>/etc/wireguard</code> 目录下创建配置文件 <code>wg0.conf</code>，填写如下内容：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[Interface]</span></span><br><span class="line"><span class="attr">PrivateKey</span> = &lt;填写上面生成的私钥&gt;</span><br><span class="line"><span class="attr">Address</span> = <span class="number">10.10</span>.<span class="number">0.100</span>/<span class="number">32</span></span><br><span class="line"><span class="attr">DNS</span> = <span class="number">119.29</span>.<span class="number">29.29</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Peer]</span></span><br><span class="line"><span class="attr">PublicKey</span> = &lt;填写RouterOS的公钥&gt;</span><br><span class="line"><span class="attr">PresharedKey</span> = &lt;填写在RouterOS中Peer的preshared-key&gt;</span><br><span class="line"><span class="attr">AllowedIPs</span> = <span class="number">192.168</span>.<span class="number">1.0</span>/<span class="number">24</span></span><br><span class="line"><span class="attr">PersistentKeepalive</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">Endpoint</span> = &lt;你的公网IP或DDNS域名&gt;:<span class="number">13231</span></span><br></pre></td></tr></tbody></table></figure>

<p>保存后就可以启动 <code>wg0</code> 这个接口并测试组网是否成功。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 启动wg0</span></span><br><span class="line">$ sudo systemctl start wg-quick@wg0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping一个内网地址看有没有响应</span></span><br><span class="line">$ ping 192.168.1.20</span><br><span class="line">PING 192.168.1.20 (192.168.1.20) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.1.20: icmp_seq=1 ttl=63 time=6.07 ms</span><br><span class="line">64 bytes from 192.168.1.20: icmp_seq=2 ttl=63 time=4.72 ms</span><br><span class="line">64 bytes from 192.168.1.20: icmp_seq=3 ttl=63 time=5.25 ms</span><br><span class="line">64 bytes from 192.168.1.20: icmp_seq=4 ttl=63 time=6.07 ms</span><br></pre></td></tr></tbody></table></figure>

<p>如果能从 ECS 上 ping 通 LAN 侧的主机，那就说明组网成功了。接下来可以让 <code>wg0</code> 接口在开机后自动启动：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> wg-quick@wg0</span><br></pre></td></tr></tbody></table></figure>

<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>文章发布之后没两天，我的软路由突然内核崩溃重启，导致我的公网 IPv4 地址变了，而 Wireguard 在建立连接后，并不会检查对端的地址是否有变化，一旦变化，就会导致 Wireguard 隧道不通。于是我写了一段小脚本放在 crontab 里，每分钟 ping 一次对端的 Wireguard 接口地址，如果不通，就重启 Wireguard 服务。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ping对端Wireguard地址，仅ping一次，超时1秒</span></span><br><span class="line">ping 10.10.0.1 -qc 1 -w 1 &gt; /dev/null</span><br><span class="line"><span class="comment"># 如果ping不成功，那么返回码是1</span></span><br><span class="line">RESULT=$?</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要返回码不是0，就重启Wireguard连接</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$RESULT</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">  systemctl restart wg-quick@wg0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>RouterOS</tag>
        <tag>Wireguard</tag>
      </tags>
  </entry>
  <entry>
    <title>在群晖的 Docker 环境中运行甜糖星愿服务</title>
    <url>/run-tiantang-on-synology-docker.html</url>
    <content><![CDATA[<p>前段时间在网上看到了一个叫 “甜糖星愿计划” 的东西，声称可以通过贡献闲置带宽来获得积分。正好我有个 NAS，正好我的宽带一天从白天闲到黑夜，不如利用起来，少少挣一些零花钱。</p>
<p>需要注意的一点是，本文提到的镜像仅在我的<code>群晖DS218+</code> 上测试过，虽然镜像中未使用任何群晖限定的依赖，理论上适用于任何 x86 架构的平台，但并不保证运行效果。而且本文目标平台是 x86，如果你拥有 ARM 平台的机器，那根本不需要废这个劲，你可以直接运行甜糖星愿的可执行程序。</p>
<p>本文提到的操作全部基于 Docker，故在按照本文操作前，请先确保你已经拥有足够的知识来使用 <code>Docker</code> 和 <code>docker-compose</code>。</p>
<span id="more"></span>

<h2 id="我的网络环境"><a href="#我的网络环境" class="headerlink" title="我的网络环境"></a>我的网络环境</h2><p>因为这个镜像相关的一些配置是以我的网络结构为基础的，所以我觉得有必要简单说一下我的网络结构是什么样的。</p>
<p>简单来说，我的网络就是这样子的。虽然网络里还有别的设备，但是因为与本文无关，我就略掉了。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">[公网] -- [光猫] -- [群晖]</span><br></pre></td></tr></tbody></table></figure>

<p>其中光猫负责拨号，所以它也是最外层的一个路由器，光猫的 IP 地址是 <code>192.168.1.1</code>，它下面有一个 <code>192.168.1.0/24</code> 的子网，群晖与光猫直连，有一个 <code>192.168.1.0/24</code> 子网下的 IP 地址。在群晖的 Docker 中，会有一个 <code>macvlan</code> 驱动的网络，与物理网卡共享同一个子网。甜糖星愿的容器将会接入到这个 <code>macvlan</code> 网络，在接入时我会手动为其分配一个 IP 地址。</p>
<h2 id="安装Docker及配置网络"><a href="#安装Docker及配置网络" class="headerlink" title="安装Docker及配置网络"></a>安装 Docker 及配置网络</h2><p>因为本文是通过 Docker 来实现的，所以第一步当然是安装 Docker。群晖嘛就从套件商店安装，其他平台就用自己平台的方法安装，总之装上 Docker 就行。安装好 Docker 之后，进入<code>控制面板 -- 网络 -- 网络界面</code>，选择连接公网的接口，如<code>局域网1</code>，点击<code>管理 -- Open vSwitch设置</code>，勾选<code>启用 Open vSwitch</code>。</p>
<p>然后我们需要在 Docker 里面创建一个 <code>macvlan</code> 驱动的网络，命令如：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo docker network create \</span><br><span class="line">    -d macvlan \</span><br><span class="line">    --subnet=192.168.1.0/24 \</span><br><span class="line">    --gateway=192.168.1.1 \</span><br><span class="line">    -o parent=ovs_eth0 \</span><br><span class="line">    macvlan</span><br></pre></td></tr></tbody></table></figure>

<p>上面命令中 <code>subnet</code> 的值替换成群晖所在网络的子网，<code>gateway</code> 指向该子网的网关，<code>parent</code> 指向要绑定的物理网卡，最后面的 <code>macvlan</code> 是网络名，可以按需修改。</p>
<h2 id="准备二进制翻译器"><a href="#准备二进制翻译器" class="headerlink" title="准备二进制翻译器"></a>准备二进制翻译器</h2><p>接下来，我们要借助 QEMU 的力量，放一个幻术。毕竟，甜糖星愿只给了 ARM 平台的可执行程序，直接在 x86 平台跑肯定是跑不起来的，所以我们要向内核注册一个翻译器，这样 Docker 在执行其他平台的机器码时就可以通过这个翻译器将其翻译成 x86 指令来执行了。是的，我知道这玩意效率不高，我已经体验过了。</p>
<p>首先，克隆这个镜像的源码仓库 [^2]，找到 <code>resources/qemu-aarch64-static</code>，或者你直接<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL211bHRpYXJjaC9xZW11LXVzZXItc3RhdGljL3JlbGVhc2VzL2Rvd25sb2FkL3Y1LjIuMC0yL3FlbXUtYWFyY2g2NC1zdGF0aWM=">从 GitHub 下载 qemu-aarch64-static<i class="fa fa-external-link-alt"></i></span>也行，把这个文件放到 <code>$PATH</code> 指定的目录，赋予执行权限。</p>
<p>然后施法吟唱，很简单，就一句话：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo docker run --<span class="built_in">rm</span> --privileged multiarch/qemu-user-static:register</span><br></pre></td></tr></tbody></table></figure>

<p>但是，这个幻术在群晖重启之后就会消失，幻术没了，甜糖星愿就起不来。所以我们还得配一个开机后的自启动任务，让群晖帮我们自动吟唱。操作也很简单，首先将本仓库的 <code>set_qemu_user_static.sh</code> 放到一个合适的位置，比如我放到了 <code>/var/services/homes/boris1993/scripts</code>，然后前往<code>控制面板 -- 任务计划</code>，然后按照如下说明新增一个任务计划：</p>
<ul>
<li>任务名称：可自选</li>
<li>用户账号：root</li>
<li> 事件：开机</li>
<li>任务设置页面的运行命令：<br><code>/var/services/homes/boris1993/scripts/set_qemu_user_static.sh</code></li>
</ul>
<p>如果要看这个脚本的日志的话，在<code>运行命令</code>里面把脚本输出重定向到一个文件就可以了。</p>
<h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>进入本仓库所在目录，或者下载<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2JvcmlzMTk5My90aWFudGFuZy14ODYtZG9ja2VyL21hc3Rlci9kb2NrZXItY29tcG9zZS55bWw="> docker-compose.yml<i class="fa fa-external-link-alt"></i></span>到一个合适的目录下，然后稍微编辑一下，以符合你的网络状况。主要要检查的就是 <code>networks.macvlan.ipv4_address</code> 的值，要确保它处在上面创建的那个 <code>macvlan</code> 网络的子网中。</p>
<p>确认无误后，执行 <code>sudo docker-compose up -d</code>，Docker 就会自动拉取镜像，并启动一个名为 <code>tiantang</code> 的容器。</p>
<p>容器内的甜糖星愿在首次启动时会自动退出，这是因为它在自我更新（我就不说这个操作一开始给了我多大的困扰了）。不要怕，容器里面有一个每分钟执行一次的定时任务，在没有发现甜糖星愿的进程时会自动将它启动。</p>
<p>除此之外，我会在容器启动两分钟后，检测甜糖星愿监听了哪些端口，然后通过脚本自动设置路由器上的 UPnP 规则，这样你就不需要将甜糖星愿容器的 IP 放到 DMZ 里，也不需要手动配置端口转发了。当然这个操作的前提是，你的路由器支持 UPnP，并且你启用了 UPnP，如果没有的话，那你只能手动操作了。或者，如果你不想让脚本自动配置 UPnP，或者客观条件下不允许你这么做，那么你可以把 <code>docker-compose.yml</code> 中 <code>SKIP_UPNP_AUTOCONFIG</code> 这一环境变量置为 <code>true</code>，这样脚本就不会执行了。</p>
<p>在甜糖星愿稳定运行，且端口转发规则也配置成功后，就可以通过手机客户端绑定这个节点了。但是这里有个问题，就是手机与甜糖星愿必须处在同一个子网里才能自动发现，如果因为各种原因没能自动发现，那么你可以在 <code>tiantang</code> 这个容器中打开一个 <code>bash</code> 终端，执行 <code>ttnode_168 -p /data</code>，在输出中会打印出这个节点的 UID，将其复制到任意二维码生成工具中生成一个二维码，然后用手机端扫描这个二维码，即可完成绑定。</p>
<p>在这之后，就没什么我们能做的了。我们就慢慢等着甜糖星愿给你分配任务吧。我是等了大概有两三天才开始跑流量的。如果在配置好 UPnP 后，手机端仍提示 “未配置网络”，那有可能是在配置 UPnP 的脚本启动时，甜糖星愿尚未打开所有端口，导致 UPnP 规则不完整。你可以前往路由器的 UPnP 页面，将页面显示结果与 <code>netstat -nlp | grep qemu</code> 命令的输出做对比，如果不一致的话，重新手动运行 <code>set-port-forwarding.sh</code> 脚本即可。</p>
<h2 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h2><p>如果你不止满足于把它跑起来，还想要了解这个镜像背后的运作方式，那么你可以前往这个镜像的 GitHub 仓库 [^3] 阅读该镜像相关的源码。在源码中我也写了注释，可以方便你理解我的想法。</p>
<h2 id="我的邀请码"><a href="#我的邀请码" class="headerlink" title="我的邀请码"></a>我的邀请码</h2><p>如果我的镜像帮到了你，或者我的这篇文章帮到了你，那么如果你愿意的话，你可以在手机客户端的<code>填写邀请码</code>处，填上我的邀请码 **<code>804744</code>**，这样你可以获得 15 张加成卡，当然我也会得到一些加成。反正互利互惠，我的加成不会从你的身上扣掉，何乐而不为呢？</p>
<p>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yZXBvc2l0b3J5L2RvY2tlci9ib3JpczE5OTMvdGlhbnRhbmcteDg2LWRvY2tlcg==">tiantang-x86-docker - Docker Hub<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My90aWFudGFuZy14ODYtZG9ja2Vy">tiantang-x86-docker - GitHub<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>甜糖星愿</tag>
        <tag>甜糖</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序 scroll-view 填满剩余可用高度</title>
    <url>/scroll-view-auto-fit-height.html</url>
    <content><![CDATA[<p>根据<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2NvbXBvbmVudC9zY3JvbGwtdmlldy5odG1s">微信小程序 scroll-view 文档<i class="fa fa-external-link-alt"></i></span>所述，<code>scroll-view</code> 必须给定一个固定高度。那么如果我们想要让它自动填充剩余高度，该怎么办呢？</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在说出我的解决方案之前，先来看一下我的页面设计，以便于理解。</p>
<p><img data-src="https://blog-static.boris1993.com/scroll-view/page-design.png" alt="Page Design"></p>
<p>如图所示，我将这个页面分成了三部分：最顶部的导航栏 <code>navbar</code>，用于显示概要信息的 <code>header</code>，以及本文的主角 <code>scroll-view</code>。可见，<code>scroll-view</code> 位于页面的最下方，如果我直接给它设定一个固定的高度，那么在不同尺寸的屏幕上，就可能会有高度过小而在下方留白，或者高度过大超出屏幕下边界的可能。那么，自动计算 <code>scroll-view</code> 的高度，看起来是一个可行的办法。</p>
<p>思路有了，接下来就开始挑趁手的工具吧！</p>
<h1 id="需要的API"><a href="#需要的API" class="headerlink" title="需要的API"></a>需要的 API</h1><p>首先，在计算过程中，整个页面的高度是必须要有的。而小程序的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS9zeXN0ZW1pbmZvLmh0bWwjd3hnZXRzeXN0ZW1pbmZvb2JqZWN0"> wx.getSystemInfo API<i class="fa fa-external-link-alt"></i></span>正好可以提供这样的功能。</p>
<p>其次，我们还得想办法拿到 <code>scroll-view</code> 上面各个组件的高度。小程序虽然没有 DOM 操作，但也提供<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vbWluaXByb2dyYW0vZGV2L2FwaS93eG1sLW5vZGVzLWluZm8uaHRtbA=="> WXML 节点信息<i class="fa fa-external-link-alt"></i></span>的 API。</p>
<h1 id="撸起袖子开始干"><a href="#撸起袖子开始干" class="headerlink" title="撸起袖子开始干"></a>撸起袖子开始干</h1><p>既然工具有了，那么，talk is cheap, I’ll show you the code!</p>
<p>当然，简洁起见，我只会写出相关的代码，其余的代码我将直接略掉。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>({</span><br><span class="line">    <span class="attr">data</span>: {</span><br><span class="line">        <span class="comment">// 页面总高度将会放在这里</span></span><br><span class="line">        <span class="attr">windowHeight</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// navbar的高度</span></span><br><span class="line">        <span class="attr">navbarHeight</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// header的高度</span></span><br><span class="line">        <span class="attr">headerHeight</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// scroll-view的高度</span></span><br><span class="line">        <span class="attr">scrollViewHeight</span>: <span class="number">0</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">onLoad</span>: <span class="keyword">function</span>(<span class="params">option</span>) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先取出页面高度 windowHeight</span></span><br><span class="line">        wx.<span class="title function_">getSystemInfo</span>({</span><br><span class="line">            <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>) {</span><br><span class="line">                that.<span class="title function_">setData</span>({</span><br><span class="line">                    <span class="attr">windowHeight</span>: res.<span class="property">windowHeight</span></span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后取出navbar和header的高度</span></span><br><span class="line">        <span class="comment">// 根据文档，先创建一个SelectorQuery对象实例</span></span><br><span class="line">        <span class="keyword">let</span> query = wx.<span class="title function_">createSelectorQuery</span>().<span class="title function_">in</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="comment">// 然后逐个取出navbar和header的节点信息</span></span><br><span class="line">        <span class="comment">// 选择器的语法与jQuery语法相同</span></span><br><span class="line">        query.<span class="title function_">select</span>(<span class="string">'#navbar'</span>).<span class="title function_">boundingClientRect</span>();</span><br><span class="line">        query.<span class="title function_">select</span>(<span class="string">'#header'</span>).<span class="title function_">boundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行上面所指定的请求，结果会按照顺序存放于一个数组中，在callback的第一个参数中返回</span></span><br><span class="line">        query.<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">            <span class="comment">// 分别取出navbar和header的高度</span></span><br><span class="line">            <span class="keyword">let</span> navbarHeight = res[<span class="number">0</span>].<span class="property">height</span>;</span><br><span class="line">            <span class="keyword">let</span> headerHeight = res[<span class="number">1</span>].<span class="property">height</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后就是做个减法</span></span><br><span class="line">            <span class="keyword">let</span> scrollViewHeight = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">windowHeight</span> - navbarHeight - headerHeight;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 算出来之后存到data对象里面</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setData</span>({</span><br><span class="line">                <span class="attr">scrollViewHeight</span>: scrollViewHeight</span><br><span class="line">            });</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>至于 WXML 里面，就还是使用双大括号来将 <code>data</code> 部分的 <code>scrollViewHeight</code> 的值绑定到 <code>height</code> 属性上面就是了。</p>
<p>需要注意的是，上面计算出来的值，单位是 <code>px</code> 而不是 <code>rpx</code>。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">style</span>=<span class="string">"height: {{scrollViewHeight}}px"</span> <span class="attr">scroll-y</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- scroll-view里面的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样，我们就得到了一个可以自动填满屏幕最下方剩余空间的 <code>scroll-view</code> 啦～</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>scroll-view</tag>
      </tags>
  </entry>
  <entry>
    <title>自建 Tailscale 的 DERP 节点</title>
    <url>/self-hosting-tailscale-derp.html</url>
    <content><![CDATA[<p>迫于 Tailscale 官方的中继节点在国内几乎没法用，于是在轻量云香港区自建了一个 DERP 服务。</p>
<span id="more"></span>

<h2 id="安装derper"><a href="#安装derper" class="headerlink" title="安装derper"></a>安装 derper</h2><p>因为 derper 是依赖 <code>go install</code> 实现分发，所以要先安装 Go 语言 SDK。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wget https://go.dev/dl/go1.20.linux-amd64.tar.gz</span><br><span class="line">$ sudo <span class="built_in">rm</span> -rf /usr/local/go &amp;&amp; sudo tar -C /usr/local -xzf go1.20.linux-amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure>

<p>安装成功后，需要配置环境变量，把 Go 的可执行文件，和 <code>~/go/bin</code> 目录加入 <code>PATH</code>。在<code>.bashrc</code>（如果你用 <code>zsh</code>，那就是<code>.zshrc</code>）中添加如下命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin:~/go/bin</span><br></pre></td></tr></tbody></table></figure>

<p>重新载入<code>.bashrc</code> 后，执行 <code>go install tailscale.com/cmd/derper@main</code>，安装 <code>derper</code>。</p>
<p>此外，因为 derper 不能自动更新，所以需要设定一个定时任务来定期重新运行 <code>go install</code> 命令，如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0 0 * * * go install tailscale.com/cmd/derper@main</span><br></pre></td></tr></tbody></table></figure>

<h2 id="测试derper"><a href="#测试derper" class="headerlink" title="测试derper"></a>测试 derper</h2><p>在运行 derper 之前，你需要给这个服务器绑定一个域名，derper 会用这个域名来申请 Let’s Encrypt 的 SSL 证书。申请和购买域名我就不在这废话了，网上有很多相关文章。</p>
<p>此外，因为 derper 需要监听 443 端口，而我又不想以 root 身份运行它，所以我选择给它分配 <code>CAP_NET_BIND_SERVICE</code> 这个 capability，来让它有监听低位端口的权限。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo <span class="built_in">setcap</span> CAP_NET_BIND_SERVICE=+eip ~/go/bin/derper</span><br></pre></td></tr></tbody></table></figure>

<p>然后就可以手动运行 <code>derper</code> 来测试了。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># derper.conf它会自动创建，你给它指定一个位置就行</span></span><br><span class="line">$ go/bin/derper -c derper/derper.conf -hostname derp.mydomain.com</span><br><span class="line">2023/02/08 13:35:11 derper: serving on :443 with TLS</span><br><span class="line">2023/02/08 13:35:11 running STUN server on [::]:3478</span><br></pre></td></tr></tbody></table></figure>

<p>这时候 derper 就会开始监听 443 端口。</p>
<p>如果 443 端口被占用，那么就需要手动指定监听的端口（比如 4443），SSL 证书也要自己通过 <code>acme.sh</code> 之类的工具生成，而且证书的名字必须符合<code>域名.crt</code>（即 <code>derp.mydomain.com.crt</code>）这种格式。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">derper -c=derper/derper.conf -hostname derp.mydomain.com -a :4443 -certmode manual -certdir /home/admin/certs</span><br></pre></td></tr></tbody></table></figure>

<p>此时用浏览器访问 <code>https://derp.mydomain.com</code>，会得到一个这样的网页：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>DERP<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This is a</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://tailscale.com/"</span>&gt;</span>Tailscale<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://pkg.go.dev/tailscale.com/derp"</span>&gt;</span>DERP<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  server.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置服务和防火墙"><a href="#配置服务和防火墙" class="headerlink" title="配置服务和防火墙"></a>配置服务和防火墙</h2><p>每次手动执行 derper 命令肯定不现实，所以这时候就要 <code>systemd</code> 出马了。进入 <code>/etc/systemd/system</code>，新建一个名为 <code>derper.service</code> 的文件，输入如下内容：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="comment"># 服务名字</span></span><br><span class="line"><span class="attr">Description</span>=Tailscale DERP Server</span><br><span class="line"><span class="comment"># 在网络服务启动后启动这个服务</span></span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="comment"># 改成你的用户名</span></span><br><span class="line"><span class="attr">User</span>=admin</span><br><span class="line"><span class="comment"># 总是自动重新启动</span></span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="comment"># 重启前等待5秒</span></span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">5</span></span><br><span class="line"><span class="comment"># 启动derper的命令，跟上面测试用的命令一样</span></span><br><span class="line"><span class="attr">ExecStart</span>=/home/admin/go/bin/derper -c=/home/admin/derper/derper.conf -hostname derp.mydomain.com</span><br><span class="line"><span class="comment"># 停止derper的命令</span></span><br><span class="line"><span class="attr">ExecStop</span>=/bin/kill <span class="variable">$MAINPID</span></span><br><span class="line"><span class="comment"># 赋予CAP_NET_BIND_SERVICE这个capability</span></span><br><span class="line"><span class="attr">AmbientCapabilities</span>=CAP_NET_BIND_SERVICE</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></tbody></table></figure>

<p>然后分别执行如下命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 载入service文件的变更</span></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动derper</span></span><br><span class="line">$ sudo systemctl start derper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查状态</span></span><br><span class="line">$ sudo systemctl status derper</span><br><span class="line">● derper.service - Tailscale DERP Server</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/derper.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Wed 2023-02-08 14:27:13 CST; 2s ago</span><br><span class="line">   Main PID: 4944 (derper)</span><br><span class="line">      Tasks: 6 (<span class="built_in">limit</span>: 1006)</span><br><span class="line">     Memory: 2.6M</span><br><span class="line">        CPU: 16ms</span><br><span class="line">     CGroup: /system.slice/derper.service</span><br><span class="line">             └─4944 /home/admin/go/bin/derper -c=/home/admin/derper/derper.conf -hostname derp.mydomain.com</span><br><span class="line"></span><br><span class="line">Feb 08 14:27:13 iZj6caykwpo11gr659a9avZ systemd[1]: Started Tailscale DERP Server.</span><br><span class="line">Feb 08 14:27:13 iZj6caykwpo11gr659a9avZ derper[4944]: 2023/02/08 14:27:13 derper: serving on :443 with TLS</span><br><span class="line">Feb 08 14:27:13 iZj6caykwpo11gr659a9avZ derper[4944]: 2023/02/08 14:27:13 running STUN server on [::]:3478</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> derper</span><br><span class="line">Created symlink /etc/systemd/system/multiuser.target.wants/derper.service → /etc/systemd/system/derper.service.</span><br><span class="line">Unit /etc/systemd/system/derper.service is added as a dependency to a non-existent unit multiuser.target.</span><br></pre></td></tr></tbody></table></figure>

<p>因为 derper 依赖 HTTP、HTTPS 和 STUN 协议，所以需要配置防火墙或安全组，开放 <code>80/tcp</code>，<code>443/tcp</code>，和 <code>3478/udp</code> 端口。</p>
<h2 id="配置Tailscale"><a href="#配置Tailscale" class="headerlink" title="配置Tailscale"></a>配置 Tailscale</h2><p>现在自建的 DERP 节点就成功启动了，接下来我们就需要让 Tailscale 知道这个节点的信息。进入 Tailscale 的 Admin console，进入 <code>Access controls</code>，在 JSON 中增加如下配置：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="comment">// 前略</span></span><br><span class="line">    <span class="attr">"derpMap"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="comment">// 如果想要所有节点只使用自建中继的话，就启用这条配置</span></span><br><span class="line">        <span class="comment">// "OmitDefaultRegions": true,</span></span><br><span class="line">        <span class="attr">"Regions"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"900"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"RegionID"</span><span class="punctuation">:</span>   <span class="number">900</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">"RegionCode"</span><span class="punctuation">:</span> <span class="string">"Aliyun-HKG"</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">"Nodes"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">{</span></span><br><span class="line">                        <span class="attr">"Name"</span><span class="punctuation">:</span> <span class="string">"Aliyun-HKG-1"</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"RegionID"</span><span class="punctuation">:</span> <span class="number">900</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"HostName"</span><span class="punctuation">:</span> <span class="string">"derp.mydomain.com"</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 如果有多个区域、多个节点，或者使用了自定义端口，那么可以参考这部分</span></span><br><span class="line">            <span class="attr">"901"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"RegionID"</span><span class="punctuation">:</span> <span class="number">901</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">"RegionCode"</span><span class="punctuation">:</span> <span class="string">"Oracle-OSAKA"</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">"Nodes"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">{</span></span><br><span class="line">                        <span class="attr">"Name"</span><span class="punctuation">:</span> <span class="string">"Oracle-OSAKA-1"</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"RegionID"</span><span class="punctuation">:</span> <span class="number">901</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"HostName"</span><span class="punctuation">:</span> <span class="string">"osaka1.derp.mydomain.com"</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"DERPPort"</span><span class="punctuation">:</span> <span class="number">4443</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">{</span></span><br><span class="line">                        <span class="attr">"Name"</span><span class="punctuation">:</span> <span class="string">"Oracle-OSAKA-1"</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"RegionID"</span><span class="punctuation">:</span> <span class="number">901</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"HostName"</span><span class="punctuation">:</span> <span class="string">"osaka2.derp.mydomain.com"</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">"DERPPort"</span><span class="punctuation">:</span> <span class="number">4443</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">}</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>最后不要忘了点击 <code>Save</code> 保存。保存成功后，可以在 <code>Machines</code> 中随便点进一台机器，看 <code>Relays</code> 里面有没有出现刚刚添加的 DERP 服务器。</p>
<p><img data-src="https://blog-static.boris1993.com/self-hosting-tailscale-derp/relays.png"></p>
<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90YWlsc2NhbGUuY29tL2tiLzExMTgvY3VzdG9tLWRlcnAtc2VydmVycy8=">Custom DERP Servers<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Tailscale</tag>
        <tag>DERP</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>配置 Caddy 作为静态网站服务器和前置代理</title>
    <url>/set-up-caddy-server.html</url>
    <content><![CDATA[<p>之前听闻有个新的 Web Server，名曰 Caddy，其配置简单，还默认启用 HTTP/2，并且可以自动申请 Let’s Encrypt 的 HTTPS 证书。试用了一番，觉得不错，便把这个博客的服务程序换成了 Caddy。在这里呢，记录一下安装和配置的过程。</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>万事第一步，先安装。</p>
<h2 id="下载页面概览"><a href="#下载页面概览" class="headerlink" title="下载页面概览"></a>下载页面概览</h2><p>打开<span class="exturl" data-url="aHR0cHM6Ly9jYWRkeXNlcnZlci5jb20vZG93bmxvYWQ="> Caddy<i class="fa fa-external-link-alt"></i></span>的下载页面，页面的内容简洁明了，左侧是 4 个要配置的项，右侧是每个配置项实际的内容。</p>
<p><img data-src="https://blog-static.boris1993.com/caddy/caddy-download-overview.png" alt="Download Page Overview"></p>
<h2 id="选择运行平台"><a href="#选择运行平台" class="headerlink" title="选择运行平台"></a>选择运行平台</h2><p>首先，选择好 Caddy 要在哪个操作系统下运行。Caddy 支持的平台还是足够多的，而且覆盖到了主流的操作系统，所以甭管您是 Windows，还是 Linux，抑或是 BSD，都可以运行 Caddy。因为我的服务器运行的是 64 位 Ubuntu，所以选择 <code>Linux 64-bit</code>。</p>
<p>实话说，看到 Plan 9 的时候，心里还是被惊到了。</p>
<p><img data-src="https://blog-static.boris1993.com/caddy/caddy-download-choose-platform.png" alt="Choosing Platform"></p>
<h2 id="选择插件"><a href="#选择插件" class="headerlink" title="选择插件"></a>选择插件</h2><p>接下来是选择要安装哪些插件，通常来说，根据自己的需要来选择就可以了。如果后期要安装更多的插件的话，重新来下载页面勾选需要的插件并重新安装就可以了。毕竟是用 Go 写的，最后就一个可执行文件，替换掉原来的，就算重装好了。</p>
<p>我的需求有这么几点：</p>
<ol>
<li>我需要 Caddy 可以作为一个反向代理，所以选择了 <code>http.forwardproxy</code> 插件</li>
<li>我的博客的源文件放置于我的 GitHub 中，我希望 Caddy 可以直接 clone 这个仓库，并且能通过 WebHook 监听这个仓库的更新事件，所以选择了 <code>http.git</code> 插件</li>
<li>我在使用 Cloudflare 的 DNS 服务，并且 Caddy 可以通过 DNS 验证的方式申请 HTTPS 证书，所以需要 <code>tls.dns.cloudflare</code> 插件</li>
<li>我想要 Caddy 作为一个系统服务，并且可以随系统自动启动，但是我又懒得自己写配置文件，所以使用 <code>hook.service</code> 插件来为我提供已经写好并经过了测试的配置文件</li>
</ol>
<p><img data-src="https://blog-static.boris1993.com/caddy/caddy-download-choose-plugins.png" alt="Choosing Plugins"></p>
<h2 id="选择是否开启遥测功能"><a href="#选择是否开启遥测功能" class="headerlink" title="选择是否开启遥测功能"></a>选择是否开启遥测功能</h2><p>Caddy 提供了一个叫做 “遥测” 的功能，可以监控您的 Caddy 实例的状态。具体针对该功能的描述，可以到其文档页面<span class="exturl" data-url="aHR0cHM6Ly9jYWRkeXNlcnZlci5jb20vZG9jcy90ZWxlbWV0cnk="> Telemetry<i class="fa fa-external-link-alt"></i></span>阅读。这个功能开启与否与功能无关，开不开看您心情。</p>
<h2 id="选择适合您的许可证"><a href="#选择适合您的许可证" class="headerlink" title="选择适合您的许可证"></a>选择适合您的许可证</h2><p>接下来，就是选择您要使用哪一种许可证来运行 Caddy。像在下的博客是个人项目，不涉及商业应用，所以当然选择个人许可证。</p>
<p><img data-src="https://blog-static.boris1993.com/caddy/caddy-download-choose-license.png" alt="Choosing License"></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>终于，到了下载这一步了。Caddy 提供了多种下载的方式，您可以在浏览器中将可执行文件下载到本地，或者通过命令行来下载，还可以直接使用一句话脚本来安装。</p>
<p><img data-src="https://blog-static.boris1993.com/caddy/caddy-download-methods.png" alt="Install Methods"></p>
<p>如果使用自动安装脚本的话，Caddy 会被安装到 <code>/usr/local/bin/caddy</code> 中。如果选择手动安装，那么需要将 Caddy 的可执行文件放到 <code>PATH</code> 所包含的目录中，或者将 Caddy 所在的位置加入到 <code>PATH</code> 中。</p>
<h2 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h2><p>完成安装后，可以直接使用 <code>caddy</code> 命令启动一个 Caddy 服务器，它会开始监听本机的 <code>2015</code> 端口，并列出当前工作目录的内容。使用 <code>http://localhost:2015</code> 即可访问。如果能成功打开，或者可以看到一个 <code>404</code> 页面，那么说明 Caddy 安装成功了。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Caddy 的所有配置都将被写到一个名为 <code>Caddyfile</code> 的文件中。<span class="exturl" data-url="aHR0cHM6Ly9jYWRkeXNlcnZlci5jb20vdHV0b3JpYWwvY2FkZHlmaWxl">点击这里阅读 Caddy 官方提供的入门指导<i class="fa fa-external-link-alt"></i></span>，以及<span class="exturl" data-url="aHR0cHM6Ly9jYWRkeXNlcnZlci5jb20vZG9jcw=="> Caddy 官方文档<i class="fa fa-external-link-alt"></i></span>。</p>
<p>在以下实例中，我们假定 <code>Caddyfile</code> 的位置是 <code>/etc/caddy/Caddyfile</code>，并且所有与 Caddy 相关的文件、目录，都存放于 <code>/etc/caddy</code> 下。</p>
<h2 id="配置网站的地址"><a href="#配置网站的地址" class="headerlink" title="配置网站的地址"></a>配置网站的地址</h2><p>首先要配置 Caddy 所服务的网站的地址，如果只有一个地址的话，那么可以将地址写到 <code>Caddyfile</code> 的第一行，同时 <code>Caddyfile</code> 的第一行也必须是网站的地址。比如下面这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">www.boris1993.tk</span><br></pre></td></tr></tbody></table></figure>

<p>这样 Caddy 就会监听 <code>www.boris1993.tk</code> 所绑定的地址，并监听 80 端口提供 HTTP 服务，以及 443 端口提供 HTTPS 服务。在默认情况下，Caddy 会自动将 HTTP 请求使用 HTTP 301 返回码重定向到 HTTPS，除非显式配置禁用 HTTPS 服务。</p>
<p>如果需要指定端口号，那么可以在地址后面跟上端口号，比如 <code>www.boris1993.tk:8080</code>。因为我没有用到这项功能，所以没有测试过这样配置的效果。如果您有需要还请自行测试。</p>
<p>如果要同时开启多个网站，那么各个网站的配置需要以大括号包围起来，比如下面这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">www.boris1993.tk {</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">www2.boris1993.tk {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们这里就只演示仅有一个地址的情况。多个地址的配置与单个地址的配置方式相同，故不再赘述。</p>
<h2 id="配置静态文件所在的位置并启用gzip压缩"><a href="#配置静态文件所在的位置并启用gzip压缩" class="headerlink" title="配置静态文件所在的位置并启用gzip压缩"></a>配置静态文件所在的位置并启用 gzip 压缩</h2><p>有了地址之后，我们需要告诉 Caddy 要提供的静态文件在什么位置，这个可以使用 <code>root</code> 指令来制定，如下面这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">www.boris1993.tk {</span><br><span class="line">    root    /var/www</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后 Caddy 就会到 <code>/var/www</code> 目录寻找 <code>index.html</code> 等默认的主页文件。</p>
<p>启用 gzip 压缩，可以使我们的网站打开的更快。在 Caddy 中启用 gzip，也只需要一条指令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">www.boris1993.tk {</span><br><span class="line">    root    /var/www</span><br><span class="line">    gzip</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="提供申请HTTPS证书的信息"><a href="#提供申请HTTPS证书的信息" class="headerlink" title="提供申请HTTPS证书的信息"></a>提供申请 HTTPS 证书的信息</h2><p>在默认情况下，Caddy 会自动搞定申请 HTTPS 证书的事情，不需要用户进行干预。如果需要覆盖默认的配置，可以参考<span class="exturl" data-url="aHR0cHM6Ly9jYWRkeXNlcnZlci5jb20vZG9jcy90bHM="> Caddy 文档的 TLS 部分<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h2><h3 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h3><p>网站的访问日志可以使用 <code>log</code> 指令来配置，该指令的文档可以参考<span class="exturl" data-url="aHR0cHM6Ly9jYWRkeXNlcnZlci5jb20vZG9jcy9sb2c=">这里<i class="fa fa-external-link-alt"></i></span>。</p>
<p>在这里我先放出我的配置，然后再逐行来解释。简明起见，我就只写出日志的部分，其余无关内容就不在这里写出来了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">log /   /var/log/caddy/access.log   "{combined}" {</span><br><span class="line">    rotate_size 1</span><br><span class="line">    rotate_age  7</span><br><span class="line">    rotate_keep 2</span><br><span class="line">    rotate_compress</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第一行中，我指定要记录所有对网站根目录 <code>/</code> 的访问，将日志写到 <code>/var/log/caddy/access.log</code> 中，记录的方式是 <code>combined</code>。</p>
<p>Caddy 提供了两种日志格式，<code>common</code> 和 <code>combined</code>，<code>common</code> 是默认的记录格式。</p>
<p><code>common</code> 的格式是这样子的：</p>
<p><code>{客户端IP地址} - {HTTP基础验证的用户名} [{访问时间}] \"{HTTP方式} {请求的URI} {协议版本}\" {HTTP状态码} {响应体的大小}</code></p>
<p>而 <code>combined</code> 格式，则是在 <code>common</code> 格式的末尾，追加如下内容：</p>
<p><code>\"{&gt;Referer}\" \"{&gt;User-Agent}\"</code></p>
<p>第二行 <code>rotate_size</code> 指定了在日志到达 1MB 大小之前不进行日志翻转，这个指令的单位是 <code>MB</code>。</p>
<p>第三行 <code>rotate_age</code> 指定了保留 7 天的翻转日志。</p>
<p>第四行 <code>rotate_keep</code> 指定了只保留最近 2 个翻转日志，之前的版本将被删除。</p>
<p>第五行 <code>rotate_compress</code> 指定使用 gzip 压缩翻转日志。</p>
<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志可以使用 <code>errors</code> 指令来配置，该指令的文档可以参考<span class="exturl" data-url="aHR0cHM6Ly9jYWRkeXNlcnZlci5jb20vZG9jcy9lcnJvcnM=">这里<i class="fa fa-external-link-alt"></i></span>。</p>
<p>同样，我将以我的配置作为范例来解释，如果需要其他的配置可以参考官方文档。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">errors  /var/log/Caddy/error.log {</span><br><span class="line">    404         /var/www/error/HTTP404.html</span><br><span class="line">    rotate_age  7</span><br><span class="line">    rotate_keep 2</span><br><span class="line">    rotate_compress</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第一行配置了错误日志将被写入到 <code>/var/log/Caddy/error.log</code> 中。</p>
<p>第二行配置了当发生 <code>404</code> 错误后显示的页面，这里还可以为其他错误码指定错误页面，语法参见官方文档。</p>
<p>其余三行的含义与上文 <code>log</code> 指令中对应参数的含义一致，不再赘述。</p>
<h2 id="配置自动从Git拉取页面内容"><a href="#配置自动从Git拉取页面内容" class="headerlink" title="配置自动从Git拉取页面内容"></a>配置自动从 Git 拉取页面内容</h2><p>Caddy 支持从一个指定的 Git 仓库克隆以及更新页面的内容到某个目录，并可以通过 WebHook 来监视仓库的更新，参考配置如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git https://github.com/boris1993/boris1993.github.io.git {</span><br><span class="line">    path        /var/www</span><br><span class="line">    hook        /hook       hook.password</span><br><span class="line">    hook_type   github</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里我配置 Caddy 从 <code>https://github.com/boris1993/boris1993.github.io.git</code> 这个仓库拉取静态页面文件，这就是本博客所在的 GitHub 仓库，拉去之后文件将被放到 <code>/var/www</code> 目录下。因为我要实现博客文件自动更新，所以这里的地址需要与 <code>root</code> 指令配置的位置相同。</p>
<p><code>hook</code> 参数配置 Caddy 使用 <code>www.boris1993.tk/hook</code> 作为 WebHook 的监听地址，这个 hook 的访问密码是 <code>hook.password</code>，并且使用下一行中的 <code>hook_type</code> 指令显式指定 Hook 的类型是 <code>github</code>，也就是来自 GitHub 的 hook。</p>
<p>这样配置完毕后，还需要为远程 Git 仓库配置 hook，然后才可以实现自动更新。具体配置方式请参考 Git 仓库服务商的文档。</p>
<h2 id="配置Caddy作为前置代理"><a href="#配置Caddy作为前置代理" class="headerlink" title="配置Caddy作为前置代理"></a>配置 Caddy 作为前置代理</h2><p>一部分代理工具，比如 v2ray，支持使用一个 HTTP 服务器作为其前置代理，Caddy 就可以实现这样的功能。本示例中我配置 Caddy 作为 v2ray 的 WebSocket 代理，配置文件片段如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">proxy /v2ray localhost:12345 {</span><br><span class="line">    websocket</span><br><span class="line">    header_upstream -Origin</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段配置指定了将 <code>/v2ray</code> 这个路径作为 <code>localhost:12345</code> 这个地址的前置代理，代理协议为 <code>websocket</code>。具体的配置方法请参考被代理程序的文档。</p>
<h2 id="配置开机自启动"><a href="#配置开机自启动" class="headerlink" title="配置开机自启动"></a>配置开机自启动</h2><p><code>hook.service</code> 插件可以一键生成 <code>systemd</code> 格式的自启动配置文件，只需要如下命令即可完成配置：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">caddy -service install -conf /etc/caddy/Caddyfile</span><br></pre></td></tr></tbody></table></figure>

<p>注意将 <code>-conf</code> 参数的值指向实际的 <code>Caddyfile</code> 的路径。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，一个可以正常提供服务的 Caddy 服务器就配置完成了，现在 Caddy 可以提供正常的 HTTP 和 HTTPS 访问，并且会自动申请和续订 HTTPS 证书，在远端 Git 仓库有更新之后，Caddy 也会自动更新本地的文件，一切都变成了自动化操作，正常情况下完全可以实现无人值守运行。怎么样，是不是很方便？</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>WebServer</tag>
        <tag>Caddy</tag>
      </tags>
  </entry>
  <entry>
    <title>二手 MicroServer Gen8 折腾记 (2/n) - 配置 RouterOS 软路由</title>
    <url>/setting-up-microserver-gen8-routeros.html</url>
    <content><![CDATA[<p>我之前宽带一直都是光猫拨号，电脑和 NAS 直连光猫，光猫下挂个二级无线路由器来给其他设备联网，但我早就对这个拓扑不爽了，主要原因是自己花大钱买的 AC86U 派不上用场，只能干点边缘的杂活，而且搞两套局域网怎么看都挺恶心的。之前也试过把路由器改成 AP 模式，让所有设备都直连光猫，但是万恶的电信光猫限制了设备数，只有前 5 台机器能上网，其它的机器虽然能拿到地址，但是上网必定超时。那现在既然有了台服务器，那干脆装个软路由。</p>
<p>软路由系统我打算玩玩 <code>RouterOS</code>，毕竟 <code>iKuai</code> 听说过没用过，据说还出过劫持流量这种问题，不敢用也不想用；<code>OpenWRT</code> 以前玩过，没啥新鲜感，而 <code>RouterOS</code>，之前装着玩的时候就觉得倍有逼格，早就想搞搞它玩玩了。</p>
<p>本篇为<a href="/tags/%E4%BA%8C%E6%89%8BMicroServer-Gen8%E6%8A%98%E8%85%BE%E8%AE%B0/">二手 MicroServer Gen8 折腾记</a>的第二篇，记录配置猫棒和搭建 RouterOS 软路由的过程。</p>
<span id="more"></span>

<h2 id="获取光猫中的配置"><a href="#获取光猫中的配置" class="headerlink" title="获取光猫中的配置"></a>获取光猫中的配置</h2><p>我找装维师傅说要玩猫棒，需要进后台看参数，师傅就把密码查给我了。</p>
<p>用超级密码登录光猫后台，把 LOID、PPPoE 的用户名和密码（密码需要 base64 解码才能得到真实的密码）、IPv6 前缀长度记在一个文档里备查。</p>
<h2 id="准备猫棒"><a href="#准备猫棒" class="headerlink" title="准备猫棒"></a>准备猫棒</h2><p>因为我懒得找运营商的装维师傅给我改桥接（之前沟通过，师傅说要先换光猫，新光猫又得等），也考虑到留着原来的光猫配置不变的话，在我折腾翻车的时候也不需要再找装维师傅改回路由模式，直接把光纤接回去就能恢复网络，所以我直接在淘宝上买了根 ODI 的猫棒。又因为服务器上没有 SFP 口，我也不想再买个网卡，就顺便一起买了个光电转换器。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/converter-picture-on-taobao.png"></p>
<p>之前了解到，光纤的端面接口有 PC、UPC、APC 三种，之所以选择 ODI 的光猫，就是因为我们一般宽带光纤的端面是 UPC 的，而诺基亚和阿尔卡特之类的猫棒是 APC 接口，还要套个转换器才行，硬插进去可能会损坏光纤，但 ODI 这款采用的就是 UPC 接口，不用再买转换器。<strong>但是我无法保证覆盖所有情况，如果你也想用猫棒，请一定提前跟店家和装维师傅确认好，如果顶坏了光纤端面，你只能喊装维师傅来给你重新做接头，别无他法！</strong></p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/types-of-fiber-connector.jpg"></p>
<p>抓住光纤的蓝色滑套，往后抽，就可以把光纤从光猫上拔出来，然后对准接口插进猫棒，再把猫棒插进光电转换器，然后接上网线和电源，就可以了。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/ponstick-and-converter.jpg"></p>
<p>稍等几分钟等猫棒开机，开机之后，转换器在猫棒方向的灯会亮起来。这时候先把网线跟电脑连起来，给电脑分配一个 <code>192.168.1.0/24</code> 范围的地址（当然别用 <code>192.168.1.1</code>，那是猫棒后台的地址），然后用浏览器打开 <code>192.168.1.1</code>，就能看见猫棒后台的登陆页面了。账号和密码找商家要，我这款是 <code>admin/admin</code>，但不保证所有 ODI 猫棒都是这一对账号密码。登陆进去后，进入 <code>Settings</code> 页面，填入 <code>LOID</code>，点 <code>Apply Changes</code>，然后进入 <code>Commit/Reboot</code> 页面，点 <code>Commit and Reboot</code> 按钮保存配置并重启，猫棒端就配置完成了。</p>
<p>不过电信、联通、移动的光猫注册方式各有不同，上面说的操作都是针对电信的。其他运营商可以参考猫棒商家发的文档，或参考网上其他人的成功案例。这里引用猫棒说明中的一部分内容：</p>
<blockquote>
<p>★注册 - 初级:（部分型号光猫没有 GPON SN，可不修改）<br>电信 &amp; 联通 GPON/XGPON/XGSPON：Loid<br>移动 GPON/XGPON/XGSPON：Ploam 密码<br>电信 &amp; 联通 &amp; 移动 EPON/10G EPON：Loid</p>
<p>★注册 - 中级:<br>电信 &amp; 联 &amp; 移动 GPON/XGPON/XGSPON：GPON SN<br>电信 &amp; 联通 &amp; 移动 EPON/10G EPON：MAC/PON MAC+MAC KEY</p>
<p>★注册 - 高级：（GPON/XGPON/XGSPON）<br>厂商 ID/Vendor ID：如 HWTC / 华为、FHTT / 烽火、ZTEG / 中兴、SCTY / 天邑、YHTC / 友华<br>设备型号<br>OUI：6 位<br>设备标号：一般为 17 位<br>软件版本号<br>ONT 版本 / 硬件版本号</p>
<p>★注册 - 高级：（EPON/10G EPON）<br>设备型号<br>ONT 版本 / 硬件版本号</p>
</blockquote>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/pon-stick-settings-loid.png"></p>
<p>本来重启之后，应该先看一下 ONU 状态是不是 <code>O5</code> 来着，但是当时我忘了看，直接电脑上拨号成功，间接也证明了 LOID 注册成功。不过还是放个文档里扒出来的图好了。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/ponstick-status-o5.png"></p>
<h2 id="安装RouterOS"><a href="#安装RouterOS" class="headerlink" title="安装RouterOS"></a>安装 RouterOS</h2><p>一开始我以为装这玩意跟装别的系统没啥区别，就 ISO 一挂，顺着向导装就行。可看了文档发现，RouterOS 有一个专门面向虚拟平台的版本，叫 <code>Cloud Hosted Router (CHR)</code>，在<span class="exturl" data-url="aHR0cHM6Ly9taWtyb3Rpay5jb20vZG93bmxvYWQ=">官网的下载页面<i class="fa fa-external-link-alt"></i></span>下载 <code>OVA Template</code>，然后导入 ESXi 就行。具体的安装方法可以看<span class="exturl" data-url="aHR0cHM6Ly93aWtpLm1pa3JvdGlrLmNvbS93aWtpL01hbnVhbDpDSFJfVk1XYXJlX2luc3RhbGxhdGlvbiNIb3dfdG9fSW5zdGFsbF9DbG91ZF9Ib3N0ZWRfUm91dGVyX29uX1ZNV2FyZV9FU1hpXzYuNQ=="> Mikrotik 的 Wiki<i class="fa fa-external-link-alt"></i></span>。</p>
<p><code>RouterOS CHR</code> 作为一个付费的系统，当然也需要买授权才能用。买授权的方法也可以跟着<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLm1pa3JvdGlrLmNvbS9kb2NzL3BhZ2VzL3ZpZXdwYWdlLmFjdGlvbj9wYWdlSWQ9MTgzNTAyMzQjQ2xvdWRIb3N0ZWRSb3V0ZXIoQ0hSKS1HZXR0aW5ndGhlTGljZW5zZQ=="> Mikrotik 的 Wiki<i class="fa fa-external-link-alt"></i></span>操作，就是注意别买成 <code>RouterOS</code> 的 Key，这两者是不通用的。</p>
<p>另外安装之后，如果你更改了 RouterOS 的 CPU 数量，那么内存大小也要跟着调整。<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLm1pa3JvdGlrLmNvbS9kb2NzL3BhZ2VzL3ZpZXdwYWdlLmFjdGlvbj9wYWdlSWQ9MTgzNTAyMzQjQ2xvdWRIb3N0ZWRSb3V0ZXIoQ0hSKS1TeXN0ZW1SZXF1aXJlbWVudHM=">官方文档<i class="fa fa-external-link-alt"></i></span>提供了如下公式：</p>
<blockquote>
<p>RouterOS 6：RAM = 128 + [8 * CPU 数量 * (网络接口数量 - 1)]<br>RouterOS 7：RAM = 256 + [8 * CPU 数量 * (网络接口数量 - 1)]<br>注：建议为 CHR 实例分配至少 1024MB 内存。</p>
</blockquote>
<p>我因为没注意到这个信息，只把 CPU 改成了 4 核心，但内存还是 160MB，导致几乎每 24 小时就会出一次 <code>kernel failure in previous boot</code> 错误，为这事我还给 MikroTik 开了个工单……</p>
<h2 id="配置ESXi的网络"><a href="#配置ESXi的网络" class="headerlink" title="配置ESXi的网络"></a>配置 ESXi 的网络</h2><p>如果我没记错的话，ESXi 一开始只给 Ethernet 1 口做了配置，我们得手动给 Ethernet 2 配置虚拟网络。</p>
<p>首先到<code>网络</code>的<code>虚拟交换机</code>页面，创建一个新的虚拟交换机，名字按自己喜好起就行，比如我就顺着已有的 <code>vSwitch0</code> 给它命名 <code>vSwitch1</code>。然后点进 <code>vSwitch1</code>，点<code>添加上行链路</code>，把 <code>vmnic1</code> 分配给它，这样在 ESXi 里面就可以用这个接口了。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/esxi-vswitch1.png"></p>
<p>然后到<code>端口组</code>页面，添加一个新的端口组 <code>VM Network 2</code>，虚拟交换机选择刚创建的 <code>vSwitch1</code>。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/vm-network-2.png"></p>
<p>接下来点进虚拟机 <code>RouterOS</code>，关机之后编辑设置，给它添加一个网络适配器，然后给<code>网络适配器1</code> 分配 <code>VM Network 2</code>，给<code>网络适配器2</code> 分配 <code>VM Network 1</code>，保存，开机。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/vm-routeros-settings.png"></p>
<h2 id="配置RouterOS"><a href="#配置RouterOS" class="headerlink" title="配置RouterOS"></a>配置 RouterOS</h2><p>如果猫棒的 ONU 状态是 O5，那就可以把转换器连到 Gen 8 的 Ethernet 2 口上了。你问为啥不是 Ethernet 1？因为 Ethernet 1 我改成了与 iLO 共享，所以只能拿 Ethernet 2 当 WAN 口。下面进入 RouterOS，开始配置软路由。</p>
<h3 id="首次登录"><a href="#首次登录" class="headerlink" title="首次登录"></a>首次登录</h3><p>第一次登录的时候，因为我并不知道路由器的地址，所以没办法用 IP 地址打开 RouterOS 的配置页面，但 MikroTik 很贴心的提供了用 MAC 地址连接的功能。在 WinBox 的 Neighbors 页面双击 RouterOS 的条目，用 <code>admin</code> 用户和空密码登录就可以。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/routeros-login-with-mac-address.png"></p>
<p>为了后面分的清楚，我先到 <code>Interfaces</code> 页面，把 LAN 口和 WAN 口对应接口的名字改了过来，毕竟默认的 <code>ether1</code> 和 <code>ether2</code> 不如 <code>LAN</code> 和 <code>WAN</code> 看的清楚。通常来说观察接口的 <code>Tx</code> 和 <code>Rx</code> 就能分清哪个是 LAN 口，因为这时候没配置拨号，WAN 口的流量通常只会是 0。如果分不清，那就先把 Gen 8 的 Ethernet 1 拔了。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/routeros-interfaces.png" alt="请暂时忽略China Telecom和wireguard1"></p>
<h3 id="规划地址范围，配置DHCP、DNS"><a href="#规划地址范围，配置DHCP、DNS" class="headerlink" title="规划地址范围，配置DHCP、DNS"></a>规划地址范围，配置 DHCP、DNS</h3><p>在配置 DHCP 服务器前，要先规划好自己的局域网的网段。地址范围可以从 IPv4 的三个私有地址范围 <code>10.0.0.0/8</code>、<code>172.16.0.0/12</code> 和 <code>192.168.0.0/16</code> 之间选，一定不要作死用公网网段（比如一些无能 IT 给路由器配了个 <code>1.1.1.1</code>），不然我很难说你的网络会出什么奇怪的问题。我干脆就遵循之前的网络，用了 <code>192.168.1.0/24</code> 段作为我的内网网段。</p>
<p>确定好地址范围之后，就可以用这条命令给 LAN 口指定一个静态 IP 地址：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ip/address/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">interface</span>=LAN \</span><br><span class="line">  <span class="attribute">address</span>=192.168.1.3/24 \</span><br><span class="line">  <span class="attribute">network</span>=192.168.1.0</span><br></pre></td></tr></tbody></table></figure>

<p>选择给 RouterOS 分配 <code>192.168.1.3</code> 的原因是，<code>192.168.1.1</code> 留给猫棒（虽然后来发现连不上），<code>192.168.1.2</code> 留给 AC86U 路由器，它本来就是这个地址，我懒得再动它。</p>
<p>然后先给 DHCP 服务器添加一个地址池：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ip/pool/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">name</span>=192.168.1.0/24 \</span><br><span class="line">  <span class="attribute">ranges</span>=192.168.1.2-192.168.1.254</span><br></pre></td></tr></tbody></table></figure>

<p>接下来配置 DHCP 服务器：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 添加DHCP服务器</span></span><br><span class="line">/ip/dhcp-server/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">name</span>=LAN \</span><br><span class="line">  <span class="attribute">address-pool</span>=192.168.1.0/24 \</span><br><span class="line">  <span class="attribute">interface</span>=LAN \</span><br><span class="line">  <span class="attribute">lease-time</span>=1d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置DHCP服务器下发的网络参数</span></span><br><span class="line">/ip/dhcp-server/network/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">address</span>=192.168.1.0/24 \</span><br><span class="line">  <span class="attribute">dns-server</span>=192.168.1.3 \</span><br><span class="line">  <span class="attribute">gateway</span>=192.168.1.3</span><br></pre></td></tr></tbody></table></figure>

<p>此外我还想要给 ESXi 之类的机器配置一个固定的地址，于是：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ip/dhcp-server/lease/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">address</span>=192.168.1.4 \</span><br><span class="line">  <span class="attribute">mac-address</span>=D0:BF:9C:46:94:D8 \</span><br><span class="line">  <span class="attribute">server</span>=LAN \</span><br><span class="line">  <span class="attribute">comment</span>=ESXi</span><br></pre></td></tr></tbody></table></figure>

<p>上面 DHCP 网络参数中的 <code>dns-server=192.168.1.3</code> 配置的是让 RouterOS 作为 DNS 服务器，但现在 RouterOS 还不能响应远程的 DNS 请求，所以要用下面这条命令更改 DNS 的配置：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ip/dns/<span class="built_in">set</span> <span class="attribute">allow-remote-requests</span>=<span class="literal">yes</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="创建本地管理员，禁用admin"><a href="#创建本地管理员，禁用admin" class="headerlink" title="创建本地管理员，禁用admin"></a>创建本地管理员，禁用 admin</h3><p>安全起见，我建议给 RouterOS 创建一个新的管理员账户，并禁用默认的 <code>admin</code> 账户。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的管理员用户，仅允许在192.168.1.0/24网络内登录</span></span><br><span class="line">/user/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">name</span>=新用户的用户名 \</span><br><span class="line">  <span class="attribute">password</span>=新用户的密码 \</span><br><span class="line">  <span class="attribute">group</span>=full \</span><br><span class="line">  <span class="attribute">address</span>=192.168.1.0/24</span><br><span class="line"><span class="comment"># 禁用admin</span></span><br><span class="line">/user/<span class="built_in">set</span> [ <span class="built_in">find</span> <span class="attribute">name</span>=<span class="string">"admin"</span> ] <span class="attribute">disabled</span>=<span class="literal">yes</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="配置PPPoE拨号和NAT规则"><a href="#配置PPPoE拨号和NAT规则" class="headerlink" title="配置PPPoE拨号和NAT规则"></a>配置 PPPoE 拨号和 NAT 规则</h3><p>首先创建一个 PPPoE 客户端来拨号：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/interface/pppoe-client/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">name</span>=<span class="string">"PPPoE客户端名字"</span> \</span><br><span class="line">  <span class="attribute">interface</span>=WAN \</span><br><span class="line">  <span class="attribute">user</span>=<span class="string">"宽带账号"</span> \</span><br><span class="line">  <span class="attribute">password</span>=<span class="string">"宽带密码"</span> \</span><br><span class="line">  <span class="attribute">profile</span>=default \</span><br><span class="line">  <span class="attribute">use-peer-dns</span>=<span class="literal">yes</span> \</span><br><span class="line">  <span class="attribute">add-default-route</span>=<span class="literal">yes</span></span><br></pre></td></tr></tbody></table></figure>

<p>添加成功后，RouterOS 会自动开始拨号，在终端也可以用 <code>monitor</code> 命令实时监控 PPPoE 拨号端口的状态：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/interface/pppoe-client/monitor [ <span class="built_in">find</span> running ]</span><br><span class="line">               status: connected</span><br><span class="line">               uptime: 13h59m53s</span><br><span class="line">         active-links: 1</span><br><span class="line">             encoding: </span><br><span class="line">         service-name: </span><br><span class="line">              ac-name: SH-SH-ML-MSE-2.MAN.NE40E</span><br><span class="line">               ac-mac: D0:D0:4B:06:EC:CC</span><br><span class="line">                  mtu: 1492</span><br><span class="line">                  mru: 1492</span><br><span class="line">        local-address: 124.78.123.123</span><br><span class="line">       remote-address: 124.78.123.1</span><br><span class="line">   local-ipv6-address: fe80::5</span><br><span class="line">  remote-ipv6-address: fe80::d2d0:4bff:fe06:eccc</span><br><span class="line">-- [Q quit|D dump|C-z pause]</span><br></pre></td></tr></tbody></table></figure>

<p>这时候 RouterOS 自己已经可以上网了，但是路由器下面的设备还不行，因为没有配置 NAT。在终端执行这条命令，来创建一条 NAT 规则：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ip/firewall/nat/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">chain</span>=srcnat \</span><br><span class="line">  <span class="attribute">action</span>=masquerade \</span><br><span class="line">  <span class="attribute">out-interface</span>=<span class="string">"PPPoE接口的名字"</span> \</span><br><span class="line">  <span class="attribute">comment</span>=NAT</span><br></pre></td></tr></tbody></table></figure>

<p>现在路由下的设备就可以上网了。</p>
<h3 id="配置IPv6"><a href="#配置IPv6" class="headerlink" title="配置IPv6"></a>配置 IPv6</h3><p>电信宽带已经支持了 IPv6，那既然有了，我不能不用。电信会给宽带分配一个前缀，下级设备通过前缀来分配自己的地址，就是 prefix delegation。所以我只需要在 RouterOS 中配置一个 IPv6 的 DHCP client 就行。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ipv6/dhcp-client/<span class="built_in">add</span> \</span><br><span class="line">  <span class="attribute">interface</span>=<span class="string">"PPPoE客户端名字"</span> \</span><br><span class="line">  <span class="attribute">add-default-route</span>=<span class="literal">yes</span> \</span><br><span class="line">  <span class="attribute">pool-name</span>=ipv6_pool \</span><br><span class="line">  <span class="attribute">pool-prefix-length</span>=60 \</span><br><span class="line">  <span class="attribute">prefix-hint</span>=::/56 \</span><br><span class="line">  <span class="attribute">request</span>=prefix \</span><br><span class="line">  <span class="attribute">use-interface-duid</span>=<span class="literal">yes</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后检查 DHCP client 的状态，是 <code>bound</code> 的话就说明已经成功获取到地址和前缀。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/ipv6/dhcp-client/<span class="built_in">print</span></span><br><span class="line">Columns: INTERFACE, STATUS, REQUEST,<span class="built_in"> PREFIX</span></span><br><span class="line"><span class="built_in"></span><span class="comment"># INTERFACE      STATUS  REQUEST  PREFIX                              </span></span><br><span class="line">0 China Telecom  bound  <span class="built_in"> prefix </span>  240e:38a:5d27:5c00::/56, 2d21h48m59s</span><br></pre></td></tr></tbody></table></figure>

<p>然后让电脑重新连接路由，就能看到电脑成功获取到 IPv6 地址了。</p>
<h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><p>毕竟路由器这种玩意不能在网上裸奔，该禁的端口就得禁。</p>
<p>首先创建两个 interface list，把公网接口和内网接口归类到各自的列表中，方便后面创建防火墙规则。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">/interface </span>list</span><br><span class="line"><span class="comment"># 给内网接口的list</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">name</span>=local</span><br><span class="line"><span class="comment"># 给公网接口的list</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">name</span>=internet</span><br><span class="line"></span><br><span class="line"><span class="built_in">/interface </span>list member</span><br><span class="line"><span class="comment"># LAN口归进local这个list</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">interface</span>=LAN <span class="attribute">list</span>=local</span><br><span class="line"><span class="comment"># WAN口和PPPoE口归进internet这个list</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">interface</span>=WAN <span class="attribute">list</span>=internet</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">interface</span>=<span class="string">"China Telecom"</span> <span class="attribute">list</span>=internet</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>然后添加 IPv4 的防火墙规则：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">/ip firewall filter</span></span><br><span class="line"><span class="built_in"></span><span class="comment"># 放行状态为established、related、untracked的数据包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"accept established,related,untracked"</span> <span class="attribute">connection-state</span>=established,related,untracked</span><br><span class="line"><span class="comment"># 允许外网ping，不想允许的话就不执行这条</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"accept ping"</span> <span class="attribute">protocol</span>=icmp</span><br><span class="line"><span class="comment"># 丢弃invalid状态的包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"drop invalid"</span> <span class="attribute">connection-state</span>=invalid</span><br><span class="line"><span class="comment"># 兜底规则，丢弃一切来自公网的包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"drop all from WAN"</span> <span class="attribute">in-interface-list</span>=internet</span><br><span class="line"><span class="comment"># RouterOS的快速跟踪功能，可以跟踪已建立的连接并让这些流量走快速通道，以降低设备的CPU负载</span></span><br><span class="line"><span class="comment"># 好像必须要专门的硬件才能发挥作用，但总之先加在这里</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=fasttrack-connection <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: fasttrack"</span> <span class="attribute">connection-state</span>=established,related <span class="attribute">hw-offload</span>=<span class="literal">yes</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"accept established,related, untracked"</span> <span class="attribute">connection-state</span>=established,related,untracked</span><br><span class="line"><span class="comment"># 在forward链上也丢弃掉invalid状态的包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"drop invalid"</span> <span class="attribute">connection-state</span>=invalid</span><br><span class="line"><span class="comment"># 丢弃所有来自公网，且无端口转发规则匹配的包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"drop all from WAN not DSTNATed"</span> <span class="attribute">connection-nat-state</span>=!dstnat <span class="attribute">connection-state</span>=new <span class="attribute">in-interface-list</span>=internet</span><br></pre></td></tr></tbody></table></figure>

<p>对于 IPv6，要先创建两份 address list，分别包含可以放行的地址和有问题的地址：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">/ipv6 firewall address-list</span></span><br><span class="line"><span class="built_in"></span><span class="built_in">add</span> <span class="attribute">address</span>=fe80::/16 <span class="attribute">list</span>=allowed</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=ff02::/16 <span class="attribute">comment</span>=multicast <span class="attribute">list</span>=allowed</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=::/128 <span class="attribute">comment</span>=<span class="string">"defconf: unspecified address"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=::1/128 <span class="attribute">comment</span>=<span class="string">"defconf: lo"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=fec0::/10 <span class="attribute">comment</span>=<span class="string">"defconf: site-local"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=::ffff:0.0.0.0/96 <span class="attribute">comment</span>=<span class="string">"defconf: ipv4-mapped"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=::/96 <span class="attribute">comment</span>=<span class="string">"defconf: ipv4 compat"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=100::/64 <span class="attribute">comment</span>=<span class="string">"defconf: discard only "</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=2001:db8::/32 <span class="attribute">comment</span>=<span class="string">"defconf: documentation"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=2001:10::/28 <span class="attribute">comment</span>=<span class="string">"defconf: ORCHID"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=3ffe::/16 <span class="attribute">comment</span>=<span class="string">"defconf: 6bone"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=::224.0.0.0/100 <span class="attribute">comment</span>=<span class="string">"defconf: other"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=::127.0.0.0/104 <span class="attribute">comment</span>=<span class="string">"defconf: other"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=::/104 <span class="attribute">comment</span>=<span class="string">"defconf: other"</span> <span class="attribute">list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=::255.0.0.0/104 <span class="attribute">comment</span>=<span class="string">"defconf: other"</span> <span class="attribute">list</span>=bad_ipv6</span><br></pre></td></tr></tbody></table></figure>

<p>然后配置防火墙规则（其中一些规则我也不明白是啥作用，但是既然包含在默认配置里，那配进去应该不会造成什么问题）：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">/ipv6 firewall filter</span></span><br><span class="line"><span class="built_in"></span><span class="comment"># 放行状态为established、related、untracked的数据包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: accept established,related,untracked"</span> <span class="attribute">connection-state</span>=established,related,untracked</span><br><span class="line"><span class="comment"># 丢弃invalid状态的包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: drop invalid"</span> <span class="attribute">connection-state</span>=invalid</span><br><span class="line"><span class="comment"># 允许IPv6 ping</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: accept ICMPv6"</span> <span class="attribute">protocol</span>=icmpv6</span><br><span class="line"><span class="comment"># 允许IPv6 traceroute</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: accept UDP traceroute"</span> <span class="attribute">port</span>=33434-33534 <span class="attribute">protocol</span>=udp</span><br><span class="line"><span class="comment"># 允许DHCPv6 prefix delegation的包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: accept DHCPv6-Client prefix delegation."</span> <span class="attribute">dst-port</span>=546 <span class="attribute">protocol</span>=udp <span class="attribute">src-address</span>=fe80::/16</span><br><span class="line"><span class="comment"># 允许IKE数据包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: accept IKE"</span> <span class="attribute">dst-port</span>=500,4500 <span class="attribute">protocol</span>=udp</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: accept ipsec AH"</span> <span class="attribute">protocol</span>=ipsec-ah</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: accept ipsec ESP"</span> <span class="attribute">protocol</span>=ipsec-esp</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: accept all that matches ipsec policy"</span> <span class="attribute">ipsec-policy</span>=in,ipsec</span><br><span class="line"><span class="comment"># 兜底规则，丢弃一切不是从local接口列表发出的包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=input <span class="attribute">comment</span>=<span class="string">"defconf: drop everything else not coming from LAN"</span> <span class="attribute">in-interface-list</span>=!local</span><br><span class="line"><span class="comment"># forward链上放行状态为established、related、untracked的数据包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: accept established,related,untracked"</span> <span class="attribute">connection-state</span>=established,related,untracked</span><br><span class="line"><span class="comment"># forward链上丢弃invalid状态的包</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: drop invalid"</span> <span class="attribute">connection-state</span>=invalid</span><br><span class="line"><span class="comment"># 禁止来自bad_ipv6这个地址列表里面的地址</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: drop packets with bad src ipv6"</span> <span class="attribute">src-address-list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: drop packets with bad dst ipv6"</span> <span class="attribute">dst-address-list</span>=bad_ipv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: rfc4890 drop hop-limit=1"</span> <span class="attribute">hop-limit</span>=equal:1 <span class="attribute">protocol</span>=icmpv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: accept ICMPv6"</span> <span class="attribute">protocol</span>=icmpv6</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: accept HIP"</span> <span class="attribute">protocol</span>=139</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: accept IKE"</span> <span class="attribute">dst-port</span>=500,4500 <span class="attribute">protocol</span>=udp</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: accept ipsec AH"</span> <span class="attribute">protocol</span>=ipsec-ah</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: accept ipsec ESP"</span> <span class="attribute">protocol</span>=ipsec-esp</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=accept <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: accept all that matches ipsec policy"</span> <span class="attribute">ipsec-policy</span>=in,ipsec</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">action</span>=drop <span class="attribute">chain</span>=forward <span class="attribute">comment</span>=<span class="string">"defconf: drop everything else not coming from LAN"</span> <span class="attribute">in-interface-list</span>=!local</span><br></pre></td></tr></tbody></table></figure>

<h2 id="RouterOS里一些其它的配置"><a href="#RouterOS里一些其它的配置" class="headerlink" title="RouterOS里一些其它的配置"></a>RouterOS 里一些其它的配置</h2><p>最后就是一些杂七杂八的配置，比如开启 NTP 客户端来自动同步时间：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">/system ntp client</span></span><br><span class="line"><span class="built_in"></span><span class="built_in">set</span> <span class="attribute">enabled</span>=<span class="literal">yes</span></span><br><span class="line"><span class="built_in">/system ntp client </span>servers</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=time.windows.com</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=time.nist.gov</span><br><span class="line"><span class="built_in">add</span> <span class="attribute">address</span>=time.apple.com</span><br></pre></td></tr></tbody></table></figure>

<p>禁用掉不需要的服务以减小攻击面：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">/ip service</span></span><br><span class="line"><span class="built_in"></span><span class="comment"># 禁用telnet</span></span><br><span class="line"><span class="built_in">set</span> telnet <span class="attribute">disabled</span>=<span class="literal">yes</span></span><br><span class="line"><span class="comment"># 禁用ftp</span></span><br><span class="line"><span class="built_in">set</span> ftp <span class="attribute">disabled</span>=<span class="literal">yes</span></span><br><span class="line"><span class="comment"># 限制www、ssh、winbox服务都只能从内网访问</span></span><br><span class="line"><span class="built_in">set</span> www <span class="attribute">address</span>=192.168.1.0/24</span><br><span class="line"><span class="built_in">set</span> ssh <span class="attribute">address</span>=192.168.1.0/24</span><br><span class="line"><span class="built_in">set</span> www-ssl <span class="attribute">address</span>=192.168.1.0/24 <span class="attribute">disabled</span>=<span class="literal">no</span></span><br><span class="line"><span class="built_in">set</span> winbox <span class="attribute">address</span>=192.168.1.0/24</span><br><span class="line"><span class="comment"># API用不到，所以禁用</span></span><br><span class="line"><span class="built_in">set</span> api <span class="attribute">disabled</span>=<span class="literal">yes</span></span><br><span class="line"><span class="built_in">set</span> api-ssl <span class="attribute">disabled</span>=<span class="literal">yes</span></span><br></pre></td></tr></tbody></table></figure>

<p>开启 UPnP，虽然说开这玩意会有安全隐患，但是开了这么多年也没因为它出过事，这玩意也没法从外网开端口转发，也就是说首先内网得有机器中毒，我自认为我的使用习惯还算是安全的，所以，开。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 启用UPnP</span></span><br><span class="line"><span class="built_in">/ip upnp</span></span><br><span class="line"><span class="built_in"></span><span class="built_in">set</span> <span class="attribute">enabled</span>=<span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">/ip upnp </span>interfaces</span><br><span class="line"><span class="comment"># 配置LAN口作为内网端</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">interface</span>=LAN <span class="attribute">type</span>=internal</span><br><span class="line"><span class="comment"># 配置PPPoE端口作为公网端</span></span><br><span class="line"><span class="built_in">add</span> <span class="attribute">interface</span>=<span class="string">"PPPoE接口的名字"</span> <span class="attribute">type</span>=external</span><br></pre></td></tr></tbody></table></figure>

<p>开启云服务，包括 DDNS 和自动备份：</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">/ip </span>cloud</span><br><span class="line"><span class="built_in">set</span> <span class="attribute">ddns-enabled</span>=<span class="literal">yes</span> <span class="attribute">ddns-update-interval</span>=1h <span class="attribute">update-time</span>=<span class="literal">yes</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>二手MicroServer Gen8折腾记</tag>
        <tag>Gen8</tag>
        <tag>软路由</tag>
        <tag>RouterOS</tag>
      </tags>
  </entry>
  <entry>
    <title>二手 MicroServer Gen8 折腾记 (1/n) - 初始化服务器</title>
    <url>/setting-up-microserver-gen8.html</url>
    <content><![CDATA[<p>上个月冲动消费，入手了一台 HPE ProLiant MicroServer Gen8。其实我早想搞一台正经的服务器来玩了，因为群晖的魔改 Linux 总是玩的不那么爽。现在心愿实现，开始折腾。</p>
<p>本篇为<a href="/tags/%E4%BA%8C%E6%89%8BMicroServer-Gen8%E6%8A%98%E8%85%BE%E8%AE%B0/">二手 MicroServer Gen8 折腾记</a>的第一篇，记录拿到服务器之后做的一些初始化的工作。</p>
<span id="more"></span>

<h2 id="重置iLO"><a href="#重置iLO" class="headerlink" title="重置iLO"></a>重置 iLO</h2><p>到手之后，我发现我把事想简单了，服务器一般只给一个 VGA 口，而这台也不例外，然而，我这里没有一个能接 VGA 口的设备。是的，你没看错。不止显示器没有 VGA 口，连电视也没有。遂果断下单了一个 VGA 到 HDMI 转接器。第二天收到快递，兴冲冲的接上，却发现只能显示 POST 画面，之后无论是正常继续启动，还是进 RBSU（ROM based setup utility），电视上都是无信号。事到如此，接显示器这条路算是堵死了。别问我为什么不买个支持 VGA 的显示器，你自己想想这成本划得来么？</p>
<p>虽然接显示器不行，但是天无绝人之路啊，地球人都知道，正经服务器上都有一个带外管理系统，Gen 8 也不例外，带有惠普的 iLO（Integrated Lights-out）带外管理模块。iLO 的地址在 POST 界面左下角有显示，</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/ilo_address.jpg"></p>
<p>但是这个地址跟我的网络不在一个网段啊？没办法，拎出来一台带网口的笔记本电脑，把电脑跟 iLO 直连，给电脑配置静态 IP 为 <code>10.132.190.34</code>，子网掩码 <code>255.0.0.0</code>，试一试，果然能 ping 通，问题解决。开玩笑，哥们可是网络工程专业的。</p>
<p>接下来就要重置 iLO，省得因为上任机主的配置引出什么别的麻烦。但是问题又出现了，不知道什么原因，iLO 的网页不是打不开，就是报错 <code>Connection with iLO cannot be established</code>。一顿上网冲浪之后，发现还可以用 SSH 连接，果断掏出 <code>putty</code>，好在上任没改 iLO 的默认管理员密码，不然我就真的抓瞎了。</p>
<p>登进去之后，反手就是一个 <code>Reset /map1</code> 来重置 iLO 的所有配置，过了一会 iLO 重启完毕，再次 SSH 登录，把 DHCP 打开，这样我就能给 iLO 分配一个我的内网的地址了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;/&gt;hpiLO-&gt; cd /map1/dhcpendpt1</span><br><span class="line"></span><br><span class="line">status=0</span><br><span class="line">status_tag=COMMAND COMPLETED</span><br><span class="line">Tue Dec 20 15:13:47 2022</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/map1/dhcpendpt1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/map1/dhcpendpt1&gt;hpiLO-&gt; set EnabledState=yes</span><br><span class="line"></span><br><span class="line">status=0</span><br><span class="line">status_tag=COMMAND COMPLETED</span><br><span class="line">Tue Dec 20 15:14:28 2022</span><br><span class="line"></span><br><span class="line">Network settings change applied.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Settings change applied, iLO 4 will now be reset.</span><br><span class="line">Logged Out: It may take several minutes before you can log back in.</span><br><span class="line"></span><br><span class="line">CLI session stopped</span><br></pre></td></tr></tbody></table></figure>

<p>然后 iLO 会自动重启，过几分钟重启完成之后，就能在路由器里面看到 iLO 分配的地址了。</p>
<h2 id="更新iLO固件"><a href="#更新iLO固件" class="headerlink" title="更新iLO固件"></a>更新 iLO 固件</h2><p>上面一顿操作重置 iLO 之后，很神奇地，iLO 的 web 端能正常打开了。那么接下来，我就要升级 iLO 固件的版本，因为自带的 iLO 版本太低，反正自己用着玩，用新不用旧。</p>
<p>到<span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LmhwZS5jb20vY29ubmVjdC9zL3Byb2R1Y3Q/bGFuZ3VhZ2U9ZW5fVVMma21wbW9pZD0xMDA5MTQzODUzJnRhYj1kcml2ZXJzQW5kU29mdHdhcmUjdD1Ecml2ZXJzYW5kU29mdHdhcmU="> HPE Integrated Lights-Out 4 (iLO 4)<i class="fa fa-external-link-alt"></i></span>这里进入 <code>Online ROM Flash Component for Windows x64 - HPE Integrated Lights-Out 4</code> 下载最新的 iLO 4 固件。目前最新版是 <code>2.81</code>。下载好安装程序之后，打开运行，选择 <code>Extract</code> 把安装包解压缩到一个地方。<code>Install</code> 是不能用的，因为只能在服务器上才能自动安装。解压后可以看到一个叫 <code>ilo4_281.bin</code> 的文件，这个就是 iLO 的固件。</p>
<p>进入 iLO 控制台的 <code>Administration -&gt; Firmware</code> 页面，<code>File</code> 里面选择 <code>ilo4_281.bin</code> 这个文件。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/upoad_ilo4_firmware.jpg"></p>
<p>然后点 <code>Upload</code>，静等固件上传和更新完成即可。期间不要刷新页面或者关掉页面内的进度条弹窗，地球人都知道，刷机期间手贱就是找事。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/upgrading_ilo4_firmware.jpg"></p>
<h2 id="修复iLO降级"><a href="#修复iLO降级" class="headerlink" title="修复iLO降级"></a>修复 iLO 降级</h2><p>iLO 重启之后，我看到一条报错说 <code>iLO Self-Test reports a problem with: Embedded Flash/SD-CARD</code>，在网上一顿冲浪之后，说可以尝试在 <code>Diagnostics</code> 页面里 Reset iLO 来修复。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/fixing-embedded-flash-error.png"></p>
<p>但是我在 Reset 之后，问题依旧存在，按照网上的说法来看，应该是硬件有问题，要更换板载 Flash 了。</p>
<p>更新：发现了另一篇博客<span class="exturl" data-url="aHR0cHM6Ly9zeXNhZG1pbmd1aWRlcy5vcmcvMjAxOC8wOC8yNi9maXgtaWxvLWhwLWVycm9yLWVtYmVkZGVkLWZsYXNoLXNkLWNhcmQtZW1iZWRkZWQtbWVkaWEtbWFuYWdlci1mYWlsZWQtaW5pdGlhbGl6YXRpb24v"> [Fix] ILO HP Error – Embedded Flash/SD-CARD: Embedded media manager failed initialization<i class="fa fa-external-link-alt"></i></span>，说强制格式化 NAND 可以修复，我试了下，格式化并重启之后，一开始虽然显示正常，但几分钟后依旧会报同样错误。</p>
<p>此外根据<span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LmhwZS5jb20vaHBlc2MvcHVibGljL2RvY0Rpc3BsYXk/ZG9jSWQ9YzA0OTk2MDk3"> HPE 官方的 advisory<i class="fa fa-external-link-alt"></i></span>：</p>
<blockquote>
<p>Step 1) Upgrade the iLO 4 firmware to version 2.61<br>Step 2) Perform a NAND format<br>Step 3) Check the iLO status If the iLO status is normal, then skip to Step 6 If the iLO status is still degraded, continue to Step 4<br>Step 4) Schedule downtime; AC power-cycle and repeat the NAND format<br>Step 5) Check the iLO status If the iLO status is normal, continue to<br>Step 6 If the iLO status is still degraded, then skip to Step 7<br>Step 6) Perform these final steps if the system board does not need to be replaced: Reboot the server; reinstall IP; and refresh the server in OneView (if server is managed by OneView)<br>Step 7) If steps 1-4 did not resolve the degraded iLO, replace the system board.</p>
</blockquote>
<p>确实走到了 <code>Step 7</code>，只能 <code>replace the system board</code>。╮(╯▽╰)╭</p>
<h2 id="配置RAID"><a href="#配置RAID" class="headerlink" title="配置RAID"></a>配置 RAID</h2><blockquote>
<p>这一部分因为不方便复现，故使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuZW9vbC5uZXQvP3A9NjU="> HP MicroServer Gen8 不疼使用教程 - Eddie’s Blog<i class="fa fa-external-link-alt"></i></span>的文章配图用作参考。向 Eddie 表示由衷的感谢！</p>
</blockquote>
<p>我在 3 和 4 盘位插了两块 1TB 的固态硬盘，1 和 2 盘位暂时空下来。这么做的原因是，1 和 2 盘位是 SATA-3，3 和 4 盘位是 SATA-2，所以我打算把更快的接口留给日后拓展更大容量的机械硬盘，而固态硬盘本身读写速度就很快，插在一个慢点的接口上也不会造成很大的性能问题。</p>
<p>插硬盘之前要先关机，因为 Gen 8 的硬盘位是不支持热插拔的。插好硬盘后开机，在 POST 界面出现 <code>HP Dynamic Smart Array B120i</code> 的初始化信息时敲 F5 来进入 RAID 配置页面。这里可以多敲几次来保证成功率，就像进 BIOS 敲 del 那样。如果进入成功，就会看到一个写着 HP 的大球，这时候系统正在加载 RAID 卡的配置界面。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/smart-storage-administrator-loading.png"></p>
<p>进来之后，就可以点 <code>Dynamic Smart Array B120i RAID</code> 页面的 <code>Configure</code> 按钮来配置 RAID 了。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/configure-raid.png"></p>
<h2 id="装ESXi"><a href="#装ESXi" class="headerlink" title="装ESXi"></a>装 ESXi</h2><p>前面洋洋洒洒整了一大堆，但那都是前置任务。到这一步开始主线，装系统。Gen 8 主板上带了一个 TF 卡槽和一个 USB 2.0 接口。起初我打算把 ESXi 装在 TF 卡里面的，但是试了一张之前用过的老卡，安装慢的令人发指，又试了一张几个月前买的卡，结果 ESXi 安装程序发现不了，怀疑是系统没识别。我懒得折腾卡了，遂拿出一个闲置的 U 盘，插在了主板的 USB 口上。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/usb_stick_inside.JPEG"></p>
<p>至于 ESXi 系统，我选择了惠普定制的版本，毕竟不知道 VMWare 官方版跟定制版差别在哪，还不如直接选厂商定制的版本来的方便。镜像可以到<span class="exturl" data-url="aHR0cHM6Ly9jdXN0b21lcmNvbm5lY3Qudm13YXJlLmNvbS9kb3dubG9hZHMvZGV0YWlscz9kb3dubG9hZEdyb3VwPU9FTS1FU1hJNjVVMi1IUEUmcHJvZHVjdElkPTYxNA==">这里<i class="fa fa-external-link-alt"></i></span>下载，记得要选 <code>Pre-Gen9 Custom Image</code>。下载好 Install CD 之后，进入 iLO 的远程控制台，HTML5 的就行，然后点击标题栏的光盘按钮，选 <code>CD/DVD - Local *.iso file</code>，就可以把 ESXi 的安装盘插进服务器的虚拟光驱。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/ilo_remote_dvd.png"></p>
<p>打开服务器电源之后，就会正常从光盘启动进入 ESXi 的安装程序。安装步骤很简单，这里就不再赘述了，唯一要注意的就是选对安装位置，因为安装程序会把一整块盘当作系统盘，所以我个人建议把它装在 TF 卡或者 U 盘里。也不用担心 TF 卡或者 U 盘会降低系统性能，我这里实测没有什么明显难忍的性能问题。</p>
<h2 id="换阵列卡驱动，更新系统"><a href="#换阵列卡驱动，更新系统" class="headerlink" title="换阵列卡驱动，更新系统"></a>换阵列卡驱动，更新系统</h2><blockquote>
<p>这里参考了<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3JlYWQvY3Y4ODU2NTY1">第三篇：虚拟化层 - MicroServer Gen8 + ESXi Server 6.5u3 部署踩坑记 - 天一先生的游牧生活<i class="fa fa-external-link-alt"></i></span>，这里向作者表示感谢！</p>
</blockquote>
<p>装好 ESXi 之后，我先装上了 <code>Ubuntu Server 22.10</code> 和 <code>Windows Server 2019 Datacenter</code>。用了一段时间，总感觉有点奇怪，尽管说这是好多年前的机器，性能不强我是有心理准备的，但也不至于点个开始菜单都要好几秒，打开资源管理器也要将近半分钟。今天等待程序载入的时候看了眼任务管理器，发现磁盘占用率竟然 100%，要知道我这是两块固态硬盘组的阵列诶！既然有问题，就上网搜一搜呗，这不冲浪不知道，一冲浪吓一跳，惠普给 <code>ESXi 6.x</code> 打包的 <code>B120i</code> 板载阵列卡驱动有性能问题，会导致磁盘读写异常缓慢。针对这个问题，网上最普遍的一个解决方案就是把阵列卡驱动退回到 <code>ESXi 5.x</code> 中的最后一个版本 <code>5.5.0-88</code>。</p>
<p>那话不多说，搞它！</p>
<p>首先，把所有虚拟机关机，全部关机后，在 ESXi 的<code>主机</code>页面里，点击<code>操作</code>菜单中的<code>进入维护模式</code>；在点击<code>操作</code>菜单，进入<code>服务</code>，选择<code>启用 Secure Shell(SSH)</code>，因为后面要 SSH 进 ESXi 里面安装驱动。</p>
<p>下载 <code>http://downloads.hpe.com/pub/softlib2/software1/pubsw-linux/p1749737361/v98767/hpvsa-5.5.0-88.zip</code>，完成后，解压这个 ZIP 包，得到驱动本体 <code>scsi-hpvsa-5.5.0-88OEM.550.0.0.1331820.x86_64.vib</code>。将这个 <code>vib</code> 文件上传到 ESXi 的 <code>/var/log/vmware</code> 目录下。上传成功后，SSH 进入 ESXi，执行如下命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 卸载当前版本的驱动</span></span><br><span class="line">esxcli software vib remove -n scsi-hpvsa -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装5.5.0-88版驱动</span></span><br><span class="line">esxcli software vib install -v file:scsi-hpvsa-5.5.0-88OEM.550.0.0.1331820.x86_64.vib --force --no-sig-check --maintenance-mode</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启ESXi</span></span><br><span class="line">reboot</span><br></pre></td></tr></tbody></table></figure>

<p>重启完了，进 ESXi 看了眼驱动，发现 RAID 也没认出来，驱动也变成 <code>vmw_achi</code> 了，这是没认出来阵列卡驱动啊。搜了一下，发现可以强制禁用 <code>vmw_ahci</code>，于是再进 SSH，执行 <code>esxcli system module set --enabled=false --module=vmw_ahci</code> 这条命令，再重启之后，RAID 回来了，驱动也变成 <code>hpvsa</code> 了。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/confirm-b120i-driver.png"></p>
<p>如果你在禁用 <code>vmw_ahci</code> 之后还不能成功加载 <code>hpvsa</code> 驱动，那么就得先执行 <code>esxcli software vib remove -n scsi-hpvsa -f</code> 来卸掉它，重启之后再重装。这时候千万不能操作硬盘，否则可能造成数据损毁。</p>
<p>换驱动的时候了解到，VMWare 也会给 ESXi 推出一些系统修正补丁，那有补丁当然要打啊。一开始我想着参照<span class="exturl" data-url="aHR0cHM6Ly9lc3hpLXBhdGNoZXMudi1mcm9udC5kZS9FU1hpLTYuNS4wLmh0bWw="> ESXi 6.5 - VMware ESXi Patch Tracker<i class="fa fa-external-link-alt"></i></span>这个网站给的命令在线更新，但是一直报 <code>Got no data from process</code> 这个错误，<span class="exturl" data-url="aHR0cHM6Ly9jb21tdW5pdGllcy52bXdhcmUuY29tL3Q1L0VTWGktRGlzY3Vzc2lvbnMvZXN4Y2xpLXNvZnR3YXJlLXByb2ZpbGUtdXBkYXRlLWZhaWxzLXdpdGgtcXVvdC1Hb3Qtbm8tZGF0YS1mcm9tL3RkLXAvMjg0NzQ3OA==">VMWare Communities<i class="fa fa-external-link-alt"></i></span>上面也有人遇到同样的错误，解决方法是下载补丁然后手动安装。</p>
<blockquote>
<p>关于 <code>Got no data from process</code> 这个错误，根据<span class="exturl" data-url="aHR0cHM6Ly93d3cubmFraXZvLmNvbS9ibG9nL2hvdy10by11cGdyYWRlLWZyb20tdm13YXJlLXZzcGhlcmUtZXN4aS02LTctdG8tNy0wLw=="> How to Upgrade from VMware vSphere ESXi 6.7 to 7.0<i class="fa fa-external-link-alt"></i></span>中的描述：</p>
<blockquote>
<p>If you see the error message:</p>
<p>Got no data from process: LANG=en_US.UTF-8 /usr/lib/vmware/esxcli-software profile.update  -d “<span class="exturl" data-url="aHR0cHM6Ly9ob3N0dXBkYXRlLnZtd2FyZS5jb20vc29mdHdhcmUvVlVNL1BST0RVQ1RJT04vbWFpbi92bXctZGVwb3QtaW5kZXgueG1s">https://hostupdate.vmware.com/software/VUM/PRODUCTION/main/vmw-depot-index.xml<i class="fa fa-external-link-alt"></i></span>“ -p “ESXi-7.0.0-15843807-standard”,</p>
<p>check whether there is a persistent scratch partition. There may not be a persistent scratch partition if you’re running ESXi from a USB flash drive. </p>
</blockquote>
<p>而根据<span class="exturl" data-url="aHR0cHM6Ly93d3cubmFraXZvLmNvbS9ibG9nL3J1bi1lc3hpLWZyb20tdXNiLWZsYXNoLWRyaXZlLWd1aWRlLw=="> How to Run ESXi from a USB Flash Drive<i class="fa fa-external-link-alt"></i></span>所说：</p>
<blockquote>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/esxi-partition-map-hard-drive.webp" alt="Installing ESXi on an 8-GB drive (or bigger)"><br>If ESXi is installed on a USB flash drive or SD card whose size is 8 GB or more, partitions #2 and #3 are not created. The Scratch directory used to store logs is linked to the /tmp/scratch directory that is located on the RAM drive. </p>
</blockquote>
<p>也就是说，如果把 ESXi 装在大于等于 8GB 的 TF 卡或者 U 盘里面的话，就会缺少一个 <code>scratch</code> 分区。</p>
<p>另外根据这个分区图，我还发现，如果把 ESXi 装在硬盘里的话，它会把剩余空间作为数据存储，而不是像网上一些文章说的只用来装系统，这个我后面有时间会再测试一下。</p>
</blockquote>
<p>那么，首先到<span class="exturl" data-url="aHR0cHM6Ly9jdXN0b21lcmNvbm5lY3Qudm13YXJlLmNvbS9wYXRjaA=="> Product Patches<i class="fa fa-external-link-alt"></i></span>这里，Product 选 <code>ESXi (Embeeded and Installable)</code>，Version 选 <code>6.5.0</code>（如果你装的不一样，以你为准），点 Search 后会列出一堆补丁，选最新那个，点 Download Now 来下载补丁的 ZIP 包。然后点 <code>View Details</code>，我们要在详细信息页面找到 Image Profile 的名字。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-microserver-gen8/vmware-product-patches.png"></p>
<blockquote>
<p>关于什么是 Image Profile：<br>VMWare 文档说：Image profiles define the set of VIBs that an ESXi installation or update process uses.<br>也就是说，Image Profile 定义了包里的哪些 VIB 会被安装。<br>每个补丁包中都会带有 2~4 个 Image Profile，根据<span class="exturl" data-url="aHR0cHM6Ly93d3cudmlydGVuLm5ldC92bXdhcmUvdm13YXJlLWVzeGktaW1hZ2UtcHJvZmlsZXMv"> VMware ESXi Image Profiles<i class="fa fa-external-link-alt"></i></span>的描述，各个 Image Profile 的含义是：</p>
<ol>
<li>ESXi-5.5.0-20140704001-standard - 包含全部补丁</li>
<li> ESXi-5.5.0-20140704001-no-tools - 包含除了 VMware Tools 之外的全部补丁</li>
<li> ESXi-5.5.0-20140701001s-standard - 只包含安全补丁</li>
<li> ESXi-5.5.0-20140701001s-no-tools - 只包含安全补丁，同时没有 VMware Tools</li>
</ol>
</blockquote>
<p>因为我要更新所有的 VIB，所以我将要用 <code>ESXi-6.5.0-20221004001-standard</code> 这个 Image Profile。SSH 进 ESXi，执行 <code>esxcli software profile update -p ESXi-6.5.0-20221004001-standard -d /vmfs/volumes/63a1b271-3340b157-711e-d0bf9c4694d8/ESXi650-202210001.zip</code> 开始安装（记得把 <code>-d</code> 参数指定的绝对路径改为你的机器上面的路径）。安装过程比较耗时间，这期间可以 <code>tail -f /var/log/esxupdate.log</code> 来看 ESXi 正在干什么，毕竟看着日志在跑，心里也有底，不然总害怕系统是不是死掉了。</p>
<p>更新成功后，<code>esxcli</code> 会打出来哪些包被更新了，但是实在是太多，我根本懒得看，直接重启。重启之后，ESXi 能正常进系统，存储和虚拟机都正常载入，说明没出啥毛病。这时候就可以退出维护模式，给虚拟机开机。有一说一，现在不管是开机还是打开什么东西，反应确实快了不少，看来驱动导致的硬盘性能问题已经成功解决。</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p><img data-src="https://blog-static.boris1993.com/to-be-continued.png"></p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>二手MicroServer Gen8折腾记</tag>
        <tag>Gen8</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Tailscale 部署虚拟局域网</title>
    <url>/setting-up-tailscale.html</url>
    <content><![CDATA[<p>最近折腾了下用 Tailscale 搭建虚拟局域网，在这里记录一下折腾的过程和一些心得。</p>
<span id="more"></span>

<h2 id="什么是Tailscale"><a href="#什么是Tailscale" class="headerlink" title="什么是Tailscale"></a>什么是 Tailscale</h2><p>说起 Tailscale，就不得不提到最近很火的 Mesh VPN 这个概念。</p>
<p>经典的 VPN 是作为一个网关，让外网用户通过它来访问内网。比如传统的 L2TP VPN：</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-tailscale/network-topology-with-l2tp-vpn.png"></p>
<p>但是 Mesh VPN 提出了一种全新的拓扑结构，这种结构中每个节点之间都相互连接，不再存在中心的 VPN 服务器。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-tailscale/mesh-vpn-with-wireguard.png"></p>
<p>上图提到的 <code>Wireguard</code> 就是一个 Mesh VPN 的实现，但是 <code>Wireguard</code> 配置比较繁琐，维护成本也比较高，所以 <code>Tailscale</code> 在基于 <code>Wireguard</code> 的基础上做了一些优化，比如用于 NAT 穿透的 <code>DERP</code> 协议、建立了公网 coordinator 服务器用于下发配置，以及集成了第三方 SSO 用于认证和权限管理。</p>
<h2 id="如何安装和使用Tailscale"><a href="#如何安装和使用Tailscale" class="headerlink" title="如何安装和使用Tailscale"></a>如何安装和使用 Tailscale</h2><p>安装 Tailscale 很简单（除了国内群晖），跟着官网的<span class="exturl" data-url="aHR0cHM6Ly90YWlsc2NhbGUuY29tL2tiLzEwMTcvaW5zdGFsbC8="> Quickstart<i class="fa fa-external-link-alt"></i></span>走就行了。简单来说就是先在官网注册账号，然后在电脑上安装 Tailscale 并使用相同账号登陆，然后这些机器就处于同一个虚拟局域网上了。</p>
<p>登陆的时候注意，千万不要用 GitHub 或者 Google 认证，原因我不用说，你懂的。就算电脑上你有办法，手机上也会很闹心。</p>
<p>在机器成功加入 Tailscale 虚拟局域网后，就可以在 Tailscale 控制面板里面看到这些机器的 IP 地址了。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-tailscale/tailscale-admin-portal.png"></p>
<p>这时候，就可以直接使用这些 IP 地址访问到对应的机器了。</p>
<h3 id="国内群晖安装Tailscale"><a href="#国内群晖安装Tailscale" class="headerlink" title="国内群晖安装Tailscale"></a>国内群晖安装 Tailscale</h3><p>因为国内群晖的套件商店下架了所有 VPN 相关的套件，所以只能到官网的<span class="exturl" data-url="aHR0cHM6Ly9wa2dzLnRhaWxzY2FsZS5jb20vc3RhYmxlLyNzcGtz"> Tailscale Packages - stable track<i class="fa fa-external-link-alt"></i></span>手动下载对应 DSM 版本的 spk，然后到套件中心手动安装。安装成功后就可以在主菜单中看到 Tailscale 的图标，点击启动并在新页面中使用相同账号登陆，然后就能用了。</p>
<h2 id="Tailnet和Magic-DNS"><a href="#Tailnet和Magic-DNS" class="headerlink" title="Tailnet和Magic DNS"></a>Tailnet 和 Magic DNS</h2><p>当然 Tailscale 并不仅支持通过 IP 地址访问机器，还可以通过域名访问。这里请放心，Tailnet 的域名解析是通过你本机的 Tailnet 客户端解析的。</p>
<p>要启用这个功能，首先你需要选择一个 Tailnet 域名。Tailscale 会给你一系列域名让你选，选好之后就会在控制面板的 DNS 页面出现。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-tailscale/tailscale-dns-tailnet.png"></p>
<p>然后，在 <code>Magic DNS</code> 栏目下面点 <code>Enable Magic DNS</code> 就可以了。</p>
<p><img data-src="https://blog-static.boris1993.com/setting-up-tailscale/tailscale-dns-magic-dns.png"></p>
<p>在这之后，就可以直接用控制面板中的设备名，或者<code>设备名.Tailnet域名</code>的方式访问你的设备了。比如我要 SSH 到 <code>ds218plus</code> 这台机器上，我就可以 <code>ssh ds218plus</code> 或 <code>ssh ds218plus.tailnet-a8cf.ts.net</code>。</p>
<h2 id="访问内网机器很慢"><a href="#访问内网机器很慢" class="headerlink" title="访问内网机器很慢"></a>访问内网机器很慢</h2><p>在我试用了几天之后，我发现了一个问题，如果节点双方都有 IPv6 的话，互联速度很快，但是如果节点一方没有 IPv6 的话，速度就出奇的慢。遂用 <code>tailscale status</code> 命令看了下连接情况，不出意外，看到了这样的返回：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ tailscale status</span><br><span class="line">100.98.89.5     macbook-pro          boris1993@   macOS   -</span><br><span class="line">100.88.234.12   boris-iphone         boris1993@   iOS     offline</span><br><span class="line">100.105.198.123 ds218plus            boris1993@   linux   active; relay "sfo", tx 1778904 rx 63968652</span><br></pre></td></tr></tbody></table></figure>

<p>划重点，<code>relay "sfo"</code>，这说明我连接到 <code>ds218plus</code> 的通信，是经过位于旧金山的 <code>DERP</code> 服务器中转的，所以会慢。</p>
<p>虽然在<span class="exturl" data-url="aHR0cHM6Ly90YWlsc2NhbGUuY29tL2tiLzEwODIvZmlyZXdhbGwtcG9ydHMv"> What firewall ports should I open to use Tailscale?<i class="fa fa-external-link-alt"></i></span>里面说，</p>
<blockquote>
<p>Nearly all of the time, you don’t need to open any firewall ports for Tailscale. Tailscale uses various NAT traversal techniques to safely connect to other Tailscale nodes without manual intervention—it “just works.”</p>
</blockquote>
<p>也没错，它确实 work，但是我真的没法说它 work 的 well。好在，文章下面提到，除了 <code>443/tcp</code> 之外，Tailscale 还用到 <code>41641/udp</code> 来让 Wireguard 节点互联，以及 <code>3478/udp</code> 用于 STUN 协议。</p>
<p>在我的这个使用场景中，<code>ds218plus</code> 作为服务器，那么我就在 <code>ds218plus</code> 所在的网络中做了两件事，给 <code>41641/udp</code> 配置端口转发，并在防火墙上放行这个端口。然后我在作为客户端的 <code>macbook-pro</code> 上执行 <code>tailscale down</code> 和 <code>tailscale up</code> 来重启 Tailscale 连接。这时候再用 <code>tailscale status</code> 命令检查连接情况，发现输出变成了这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ tailscale status</span><br><span class="line">100.98.89.5     macbook-pro          boris1993@   macOS   -</span><br><span class="line">100.88.234.12   boris-iphone         boris1993@   iOS     offline</span><br><span class="line">100.105.198.123 ds218plus            boris1993@   linux   active; direct 121.70.200.131:41641, tx 5884 rx 8500</span><br></pre></td></tr></tbody></table></figure>

<p>接着划重点，<code>direct</code>，说明现在节点之间已经是直连了，随便做点什么测试一下，果然快了很多。</p>
<p>不过端口转发只是权宜之计，毕竟没法同时让 <code>41641/udp</code> 转发给多个机器，只能解决一台机器不能直连的问题。要想彻底解决，还是得用 IPv6。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Tailscale</tag>
        <tag>内网穿透</tag>
        <tag>VPN</tag>
        <tag>Virtual LAN</tag>
        <tag>虚拟局域网</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 脚本中 set -ex 命令的作用</title>
    <url>/shell-set-ex.html</url>
    <content><![CDATA[<p>刚刚学会了一个很实用的 shell 命令 <code>set -ex</code>，在这里分享一下。</p>
<span id="more"></span>

<p>稍有常识的人都能看出，这是 <code>set</code> 命令加上了 <code>-e</code> 和 <code>-x</code> 两个参数 (废话么这不是)。那么，我就把这两个参数拆开，分别说一下它在脚本中的用处。</p>
<h1 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a><code>set -e</code></h1><p>先说说 <code>set -e</code>，这个参数的含义是，当命令发生错误的时候，停止脚本的执行。</p>
<p>通常来说，我们会习惯于使用 <code>&amp;&amp;</code> 来实现这样的功能，比如：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &amp;&amp; <span class="built_in">rm</span> non-existent-file &amp;&amp; <span class="built_in">echo</span> 2</span><br></pre></td></tr></tbody></table></figure>

<p>但是，写成一行呢，可读性有点差，分成多行的话，也得注意换行符 <code>\</code> 和 <code>&amp;&amp;</code> 号，我就有过好几次忘了加这俩东西，还是挺麻烦的是吧。</p>
<p>更麻烦的是，<code>&amp;&amp;</code> 连接的命令之间不能写注释，也就是说，下面这个示例是不能用的：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 \</span><br><span class="line">  &amp;&amp; <span class="built_in">rm</span> non-existent-file \ <span class="comment"># which will fail</span></span><br><span class="line">  &amp;&amp; <span class="built_in">echo</span> 2</span><br></pre></td></tr></tbody></table></figure>

<p>运行之后会是这个德行：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line">rm: non-existent-file: No such file or directory</span><br><span class="line">rm:  #: No such file or directory</span><br><span class="line">rm: which: No such file or directory</span><br><span class="line">rm: will: No such file or directory</span><br><span class="line">rm: fail: No such file or directory</span><br><span class="line">./test1.sh: line 5: syntax error near unexpected token `&amp;&amp;'</span><br><span class="line">./test1.sh: line 5: `  &amp;&amp; echo 2'</span><br></pre></td></tr></tbody></table></figure>

<p>现在，就可以写成下面这样了：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line"><span class="built_in">rm</span> non-existent-file <span class="comment"># which will fail</span></span><br><span class="line"><span class="built_in">echo</span> 2</span><br></pre></td></tr></tbody></table></figure>

<p>猜猜最后输出里面会不会把 <code>2</code> 打印出来？</p>
<h1 id="set-x"><a href="#set-x" class="headerlink" title="set -x"></a><code>set -x</code></h1><p>说完了 <code>-e</code>，继续说说 <code>-x</code>。<code>-x</code> 参数的作用，是把将要运行的命令用一个 <code>+</code> 标记之后显示出来。</p>
<p>还是拿上面这个脚本举个例子，这次加上 <code>-x</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -ex</span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line"><span class="built_in">rm</span> non-existent-file <span class="comment"># which will fail</span></span><br><span class="line"><span class="built_in">echo</span> 2</span><br></pre></td></tr></tbody></table></figure>

<p>然后它的输出就变成了：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">+ echo 1</span><br><span class="line">1</span><br><span class="line">+ rm non-existent-file</span><br><span class="line">rm: non-existent-file: No such file or directory</span><br></pre></td></tr></tbody></table></figure>

<p>注意第一行和第三行前面那个 <code>+</code>，这就是 <code>-x</code> 参数的作用。</p>
<h1 id="One-more-thing……"><a href="#One-more-thing……" class="headerlink" title="One more thing……"></a>One more thing……</h1><p>需要注意，这条命令需要放到整个 shell 脚本的开头，才会起作用。毕竟用脑子想想就知道，这是俩开关，不论放在中间还是结尾，都不会起到预期的作用。</p>
<h1 id="Credit"><a href="#Credit" class="headerlink" title="Credit"></a>Credit</h1><p>感谢这篇文章<span class="exturl" data-url="aHR0cHM6Ly93d3cucGV0ZXJiZS5jb20vcGxvZy9zZXQtZXg="> set -ex - The most useful bash trick of the year<i class="fa fa-external-link-alt"></i></span>为我提供了这条命令的解释，和写作的思路。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>分环境为 Git 指定单独的配置</title>
    <url>/specify-different-git-config-for-different-environments.html</url>
    <content><![CDATA[<p>有的小伙伴，在公司需要使用公司的 Git 来干活，同时自己也有些托管在 GitHub 等其他仓库的代码，在这种情况下会有一个烦恼，就是怎么样在多个仓库之间使用不同的配置。比如在公司仓库和个人仓库之间使用不同的身份信息，或者在公司仓库和个人仓库之间，使用不同的 GPG 签名。</p>
<p>在 <code>2.13</code> 版本之前，大概你就只能单独为每一个仓库单独设定这些信息了，但是，在 <code>2.13</code> 这个版本中，Git 引入了一个名为 “按条件引入”(Conditional includes) 的功能。这个功能允许用户通过指定一定的条件，来使 Git 从不同的配置文件中取得配置项。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>“按条件引入” 功能可以根据<strong>目录</strong>或者<strong>分支</strong>来决定使用哪个配置，显然根据分支无法区分工作环境和私人环境，所以首先需要分别为工作环境和私人环境创建各自的目录。比如将目录划分为这样：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">projects</span><br><span class="line">├── work     &lt;== 工作相关</span><br><span class="line">└── personal &lt;== 私人项目</span><br></pre></td></tr></tbody></table></figure>

<h2 id="拆分配置"><a href="#拆分配置" class="headerlink" title="拆分配置"></a>拆分配置</h2><p>接下来，需要为全局、工作、私人分别编写配置文件。本文中，全局配置文件<code>.gitconfig</code> 位于 <code>$HOME</code> 下，各环境的配置文件位于 <code>~/.config/git</code> 下。</p>
<h3 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h3><figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[core]</span></span><br><span class="line">  <span class="attr">excludesfile</span> = ~/.gitignore_global</span><br><span class="line">  <span class="attr">editor</span> = vim</span><br><span class="line"><span class="section">[includeIf "gitdir:~/projects/work/"]</span></span><br><span class="line">  <span class="attr">path</span> = ~/.config/git/gitconfig-work</span><br><span class="line"><span class="section">[includeIf "gitdir:~/projects/personal/"]</span></span><br><span class="line">  <span class="attr">path</span> = ~/.config/git/gitconfig-personal</span><br></pre></td></tr></tbody></table></figure>

<p>第 4 行和第 6 行的 <code>includeIf</code> 段，就是 “按条件引入” 的配置。在这里需要注意这几点：</p>
<ul>
<li><code>gitdir:</code> 参数用于匹配本地 Git 仓库的路径。<ul>
<li>如果文件系统是大小写不敏感的，并且路径同时包含大写和小写字母，那么需要使用 <code>gitdir/i:</code> 来匹配。</li>
<li>如果要匹配某个目录下面的所有子目录，那么在路径最后需要加上 <code>/</code> 或者 <code>/**</code>。（实际上，Git 会自动在末尾的 <code>/</code> 后面附加 <code>**</code>）</li>
<li>反之，如果只要匹配到某一个目录，而不递归包含其下面的所有子目录，那么路径末尾就不要有 <code>/</code>。</li>
</ul>
</li>
<li><code>path</code> 指定了在满足条件时要使用的配置文件</li>
</ul>
<p>综上所述，位于 <code>~/projects/work/</code> 下的所有 Git 仓库，都套用 <code>~/.config/git/gitconfig-work</code> 中的配置；位于 <code>~/projects/personal/</code> 下的所有 Git 仓库，都套用 <code>~/.config/git/gitconfig-personal</code> 中的配置。</p>
<h3 id="私人环境和工作环境的配置文件"><a href="#私人环境和工作环境的配置文件" class="headerlink" title="私人环境和工作环境的配置文件"></a>私人环境和工作环境的配置文件</h3><p>这两个环境各自的配置文件就没有什么新鲜的东西了，就只有面向各个环境的身份信息、GPG 签名信息等。</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">  <span class="attr">signingkey</span> = <span class="number">1122334455667788</span></span><br><span class="line">  <span class="attr">name</span> = Your Name</span><br><span class="line">  <span class="attr">email</span> = test@example.com</span><br><span class="line"><span class="section">[commit]</span></span><br><span class="line">  <span class="attr">gpgsign</span> = <span class="literal">true</span></span><br><span class="line">  <span class="attr">template</span> = ~/.stCommitMsg</span><br><span class="line"><span class="section">[gpg]</span></span><br><span class="line">  <span class="attr">program</span> = /usr/local/bin/gpg</span><br></pre></td></tr></tbody></table></figure>

<h2 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h2><p>写完了配置文件，还是要检查一下是不是生效了的。首先，在一个不包含任何 Git 仓库的位置执行 <code>git config -l</code>，返回的信息中就只有全局配置中的值。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">core.excludesfile=~/.gitignore_global</span><br><span class="line">core.editor=vim</span><br><span class="line">includeif.gitdir:~/projects/mininglamp/.path=~/.config/git/gitconfig-mininglamp</span><br><span class="line">includeif.gitdir:~/projects/personal/.path=~/.config/git/gitconfig-default</span><br></pre></td></tr></tbody></table></figure>

<p>然后，进入私人环境的某个 Git 仓库，再执行 <code>git config -l</code>，就可以看到私人环境相关的配置文件被引入了。（仓库自己的配置其实也会被显示出来，这里为了减小篇幅将其略掉了）</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">core.excludesfile=~/.gitignore_global</span><br><span class="line">core.editor=vim</span><br><span class="line">includeif.gitdir:~/projects/mininglamp/.path=~/.config/git/gitconfig-mininglamp</span><br><span class="line">includeif.gitdir:~/projects/personal/.path=~/.config/git/gitconfig-default</span><br><span class="line">user.signingkey=1122334455667788</span><br><span class="line">user.name=Your Name</span><br><span class="line">user.email=test@example.com</span><br><span class="line">commit.gpgsign=true</span><br><span class="line">commit.template=~/.stCommitMsg</span><br><span class="line">gpg.program=/usr/local/bin/gpg</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://git-scm.com/docs/git-config#_includes">Git 官方文档的 <code>Includes</code> 部分</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuYmxvZy8yMDE3LTA1LTEwLWdpdC0yLTEzLWhhcy1iZWVuLXJlbGVhc2VkLw=="> Git 2.13 有趣的新功能介绍 - GitHub<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubW90b3dpbGxpYW1zLmNvbS9jb25kaXRpb25hbC1pbmNsdWRlcy1mb3ItZ2l0LWNvbmZpZw==">Conditional Includes For Git Config<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Spring Boot 应用中启用 HTTPS</title>
    <url>/spring-boot-enable-https.html</url>
    <content><![CDATA[<p>在 <code>application.yml</code> 中添加如下配置，即可在 Spring Boot 项目中开启 HTTPS。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 如果有需要的话，配置应用监听HTTPS的默认端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="comment"># 我把证书放在了 resources/cert/certificate.pfx下</span></span><br><span class="line">    <span class="comment"># 使用时需要按照实际情况修改下面的路径</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:cert/certificate.pfx</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">pA55w0Rd</span></span><br><span class="line">    <span class="comment"># 证书类型需要按照实际类型填写</span></span><br><span class="line">    <span class="comment"># 本例使用PKCS12格式，所以写PKCS12。如果是JKS格式，那么需要填写JKS</span></span><br><span class="line">    <span class="comment"># 因为PKCS12比JKS有更好的通用型，所以个人建议使用PKCS12格式</span></span><br><span class="line">    <span class="attr">key-store-type:</span> <span class="string">PKCS12</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p>使用如下命令即可将 JKS 证书转换为 PKCS12 证书：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore keystore.jks -destkeystore keystore.pfx -deststoretype pkcs12</span><br></pre></td></tr></tbody></table></figure>

<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly93d3cudGhvbWFzdml0YWxlLmNvbS9odHRwcy1zcHJpbmctYm9vdC1zc2wtY2VydGlmaWNhdGUv">How to enable HTTPS in a Spring Boot Java application<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctYm9vdC9kb2NzLzIuMi4yLlJFTEVBU0UvcmVmZXJlbmNlL2h0bWwvaG93dG8uaHRtbCNob3d0by1jb25maWd1cmUtc3Ns">Spring Boot Docs - Configure SSL<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Spring 中通过配置类注入配置文件的值</title>
    <url>/spring-injecting-property-value-with-configuration-bean.html</url>
    <content><![CDATA[<p>我们在开发过程中，为了保证项目的灵活性，经常会选择将一些值放在配置文件中，并在代码中将它注入并使用。将值注入代码最常见的一种方法，则是使用 <code>@Value()</code> 注解搭配 SpEL 直接注入我们需要的属性。但是鲁迅先生有云：从来如此，便对吗？这里，我想介绍一个我个人认为更好的实践：通过配置类来注入属性的值。</p>
<span id="more"></span>

<h2 id="旧的做法有什么问题"><a href="#旧的做法有什么问题" class="headerlink" title="旧的做法有什么问题"></a>旧的做法有什么问题</h2><p>假设我们现在有这样一个 <code>application.yml</code>，其中 <code>credentials</code> 部分是我自定义的一个属性：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="attr">credentials:</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">A_VERY_SECRET_TOKEN</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后，我们会在用到它的地方，直接通过 <code>@Value</code> 注解把它注入进来，就像这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeService</span> {</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value("${credientials.token}")</span></span><br><span class="line">  <span class="keyword">private</span> String token;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>好像没什么问题对吧，直接用表达式把值拿进来，然后该怎么用就怎么用。但是我不知道你们有没有注意过，这种做法其实既不利于后期重构，也不利于为代码生成好的文档。</p>
<p>比如说，这个值在多个类中都有被引用，但某一天，我们觉得这个名字不够直观，我们想改成 <code>contactServiceAppToken</code>，那么我们就只能先改掉属性的名字，然后在代码里面全文替换，把 <code>credentials.token</code> 批量替换成 <code>credentials.contactServiceAppToken</code>。我不知道你们是怎么想的，我每次做这种文本批量替换都很慌，生怕一个没看见而改掉了不应该改的东西。</p>
<p>而对于生成文档，我们都知道，在 Java 代码上面我们可以使用 JavaDoc 来编写文档，阐明这个类的作用等等。而对于 YAML 文件，则没有类似的东西，我们只能在属性上面写普通的注释。可是，大篇幅的注释又有可能会影响 YAML 文件的可读性，更不用说有谁会在看代码的时候专程去看 YAML 文件？</p>
<p>所以，我会建议团队使用配置类，也就是本文下面要讲的这个东西，来管理和注入这些自定义的属性。</p>
<h2 id="来个示例"><a href="#来个示例" class="headerlink" title="来个示例"></a>来个示例</h2><p>首先，我们需要创建一个配置类，来给这些属性找一个家。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 这个注解是重点，说明我们要把配置文件的 credentials 部分映射到这里</span></span><br><span class="line"><span class="meta">@ConfigurationProperties("credentials")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Credentials</span> {</span><br><span class="line">  <span class="comment">// 属性名与变量名保持一致即可，Spring会自动处理两者的绑定关系</span></span><br><span class="line">  <span class="comment">// 同时，Spring会自动完成不同命名方式的转换，比如 kebab-case 变成 camelCase</span></span><br><span class="line">  <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，在要使用这些属性的地方，把这个配置类注入，然后直接 get 属性的值，就可以了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeService</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Credentials credentials;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SomeService</span><span class="params">(Credentials credentials)</span> {</span><br><span class="line">    <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> credentials.getToken();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>与直接取值的方法比较起来，使用配置类有这么几个优点：</p>
<ul>
<li>如果在重构的时候要改变属性名，那么我们只需要修改配置文件里面的属性名，和配置类里面的属性名。当然要记得使用 IDE 里面的重构功能改名，这样 IDE 会自动分析这个属性的引用，并自动改正过来。</li>
<li>使用配置类还可以方便我们生成文档。如果直接在配置文件里面写文档，一方面是不一定易读，另一方面，也不是所有人都会想到在配置文件里面还有文档。而使用配置类的话，我们只需要在类上面加上 JavaDoc 就好了。</li>
<li>而且，我们还不需要担心打错字，导致 <code>@Value</code> 注入失败而使得应用起不来。虽然这不是什么大问题，改正就行了，但毕竟还是麻烦。</li>
</ul>
<h2 id="多层属性怎么办"><a href="#多层属性怎么办" class="headerlink" title="多层属性怎么办"></a>多层属性怎么办</h2><p>上面只是演示了只有一级子属性的情况，如果下面包含了多层属性，那配置类应该怎么写呢？</p>
<p>假设现在配置文件变成了这样：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">credentials:</span></span><br><span class="line">  <span class="attr">token:</span></span><br><span class="line">    <span class="attr">contact:</span> <span class="string">TOKEN_FOR_CONTACT_API</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">TOKEN_FOR_USER_API</span></span><br><span class="line">  <span class="attr">oauth:</span></span><br><span class="line">    <span class="attr">client-id:</span> <span class="string">CLIENT_ID</span></span><br><span class="line">    <span class="attr">client-secret:</span> <span class="string">CLIENT_SECRET</span></span><br><span class="line"></span><br><span class="line"><span class="attr">endpoint:</span></span><br><span class="line">  <span class="attr">contact:</span></span><br><span class="line">    <span class="attr">v1:</span> <span class="string">URL_FOR_CONTACT_API_VERSION_1</span></span><br><span class="line">    <span class="attr">v2:</span> <span class="string">URL_FOR_CONTACT_API_VERSION_2</span></span><br></pre></td></tr></tbody></table></figure>

<p>对于 <code>credentials</code> 部分，因为里面子属性的名字大致是确定的，我们用一个内部类就可以搞定（其实写在单独的类里面也可以，只是我不喜欢那么做）。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties("credentials")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Credentials</span> {</span><br><span class="line">  <span class="keyword">private</span> Token token;</span><br><span class="line">  <span class="keyword">private</span> Oauth oauth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Token</span> {</span><br><span class="line">    <span class="keyword">private</span> String contact;</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Oauth</span> {</span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>取值的时候呢，逐层取到就好了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeService</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Credentials credentials;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SomeService</span><span class="params">(Credentials credentials)</span> {</span><br><span class="line">    <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">contactApiToken</span> <span class="operator">=</span> credentials.getToken().getContact();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是对于 <code>endpoint</code> 部分，因为里面的值是某个 API 各个版本的 URL，考虑到 API 还有可能会有新版本，每加一个版本都要再改配置类有点麻烦，所以我们可以直接用一个 Map 来存放。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties("endpoint")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Endpoint</span> {</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, String&gt; contact;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//getters and setters</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在取值的时候，就还是一样的套路，注入这个配置类，然后从 Map 中取值就行了。Map 的 key 就是属性名，比如 <code>v1</code>，值就是属性的值。当然这样做的话，就要处理一下取到 null 的情况。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeService</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Endpoint endpoint;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SomeService</span><span class="params">(Endpoint endpoint)</span> {</span><br><span class="line">    <span class="built_in">this</span>.endpoint = endpoint;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">contactV1Url</span> <span class="operator">=</span> endpoint.getContact().get(<span class="string">"v1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contactV1Url == <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// handle it here</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="给配置文件加上自动提示"><a href="#给配置文件加上自动提示" class="headerlink" title="给配置文件加上自动提示"></a>给配置文件加上自动提示</h2><p>其实，<code>Configuration properties</code> 配置类除了可以方便我们管理属性之外，他还可以搭配 <code>spring-boot-configuration-processor</code> 来实现配置文件的自动提示，当然这也需要 IDE 的支持。</p>
<p>在 <code>pom.xml</code> 中加入如下依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后在编写完配置类之后，执行一下 build 操作，或者 <code>mvn compile</code>，来让它帮我们生成一个 <code>additional-spring-configuration-metadata.json</code> 文件。有了这个文件之后，IDE 就会参照它在配置文件里面给我们提供自动提示。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>ConfigurationProperties</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 SSH config 简化 SSH 连接</title>
    <url>/ssh-config-file.html</url>
    <content><![CDATA[<p>如果你有很多的服务器要连接，如果对你来说记住那些服务器的地址、端口实在是一种痛苦，如果你一直在寻找一种能够简化在命令行下连接 SSH 服务器的办法，那么，本文将给你提供一种解决问题的思路，那就是，使用 SSH 的 config 文件。</p>
<span id="more"></span>

<h1 id="SSH-config文件是什么"><a href="#SSH-config文件是什么" class="headerlink" title="SSH config文件是什么"></a>SSH config 文件是什么</h1><p>Open SSH 客户端配置文件，允许你以配置项的形式，记录各个服务器的连接信息，并允许你使用一个定义好的别名来代替其对应的 ssh 命令参数。</p>
<h1 id="SSH-config文件该怎么用"><a href="#SSH-config文件该怎么用" class="headerlink" title="SSH config文件该怎么用"></a>SSH config 文件该怎么用</h1><h2 id="创建SSH-config文件"><a href="#创建SSH-config文件" class="headerlink" title="创建SSH config文件"></a>创建 SSH config 文件</h2><p>通常来说，该文件会出现在两个地方，一个是 <code>/etc/ssh/ssh_config</code>，一个是 <code>~/.ssh/config</code>。</p>
<p><code>/etc/ssh/ssh_config</code> 文件通常用来定义全局范围上的 SSH 客户端参数，而 <code>~/.ssh/config</code> 则被用来定义每个用户自己的 SSH 客户端的配置。我们将要修改的，就是位于用户目录下的 config 文件。</p>
<p>如果 <code>~/.ssh/config</code> 文件不存在，那么也不用着急，这是正常的，只需要执行如下命令，即可新建一个空白的 config 文件</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.ssh/config</span><br></pre></td></tr></tbody></table></figure>

<h2 id="编写config条目"><a href="#编写config条目" class="headerlink" title="编写config条目"></a>编写 config 条目</h2><p>假如说，我们想连接到一台服务器，它的地址是 example.server.com，端口号是 2222，以用户 admin 登陆，并使用～/.ssh/id_rsa 这个私钥验证身份。那么，我们需要在命令行里输入：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh admin@example.server.com -p 2222 -i ~/.ssh/id_rsa</span><br></pre></td></tr></tbody></table></figure>

<p>嗯好吧，-i 参数可以省略，但即使这样，命令还是很长，对吧？</p>
<p>那么我们把这个服务器的连接参数写到 config 文件里，就变成了这个样子：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"># 此处我为了美观起见，给每个子条目都缩进了一层，实际使用时缩进不影响文件的效果。</span><br><span class="line"></span><br><span class="line">Host sample</span><br><span class="line">    Hostname        example.server.com</span><br><span class="line">    Port            2222</span><br><span class="line">    User            admin</span><br><span class="line">    Identityfile    ~/.ssh/id_rsa</span><br></pre></td></tr></tbody></table></figure>

<p>嗯，在这里，它还有了一个新名字，叫 <code>sample</code>。</p>
<p>然后，我们只需要：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh sample</span><br></pre></td></tr></tbody></table></figure>

<p>就可以连接到这台主机了。</p>
<h2 id="创建通配符规则"><a href="#创建通配符规则" class="headerlink" title="创建通配符规则"></a>创建通配符规则</h2><p>有的时候，我们需要连接多台不同的主机，那难道我们需要针对每个主机都写一遍规则吗？</p>
<p>答案是不一定。如果你要连接的主机，它们的域名有一定规律可循，那么我们可以用通配符来匹配这一系列的主机。</p>
<p>比如，公司里针对开发和测试环境，各创建了一系列集群，同时各个集群中又根据负责的业务不同，有多台负载均衡的主机，那么我们可以这样写：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"># 首先匹配所有主机，在这里配置好我们的用户名、私钥等参数</span><br><span class="line">Host *</span><br><span class="line">    User            boris1993</span><br><span class="line">    IdentityFile    ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># 开发环境</span><br><span class="line">Host dev-*</span><br><span class="line">    HostName    %h.dev.mycompany.com</span><br><span class="line"></span><br><span class="line"># 测试环境</span><br><span class="line">Host staging-*</span><br><span class="line">    HostName    %h.staging.mycompany.com</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，我们只需要执行类似 <code>ssh dev-user</code>，就可以连接到开发环境的负责用户管理的服务器上了。</p>
<p>而实现这个操作的重点，我想你已经注意到了，一个是 <code>Host</code> 配置中的 <code>*</code>，另一个就是配置文件里面的 <code>%h</code>。星号我们都知道，是个通配符，放在这里就意味着它会匹配所有以 <code>dev-*</code> 开头的主机名；而 <code>%h</code> 是一个占位符，它会把你在 <code>SSH</code> 命令中 <code>destination</code> 部分的输入取出来放在这里，所以当我们执行 <code>ssh dev-user</code> 的时候，实际上命令会被展开成 <code>ssh dev-user.dev.mycompany.com</code>。</p>
<h2 id="配置通过跳板机连接"><a href="#配置通过跳板机连接" class="headerlink" title="配置通过跳板机连接"></a>配置通过跳板机连接</h2><p>如果公司规定所有服务器都需要先 <code>SSH</code> 到跳板机，然后才能连接到具体的服务器，那该怎么办？把 <code>ssh_config</code> 文件放在跳板机上吗？</p>
<p>确实这是一个解决方案，但不是唯一解。因为我们还有一个配置参数叫 <code>ProxyJump</code>。它，就是用来指定，在连接这个服务器之前，需要通过哪个跳板机。</p>
<p>写起来，是这样的：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"># 其他部分略</span><br><span class="line"></span><br><span class="line"># 跳板机</span><br><span class="line">Host bastion</span><br><span class="line">    HostName    bastion.mycompany.com</span><br><span class="line"></span><br><span class="line"># 服务器</span><br><span class="line">Host dev-*</span><br><span class="line">    HostName    %h.dev.mycompany.com </span><br><span class="line">    ProxyJump   bastion</span><br></pre></td></tr></tbody></table></figure>

<p>如果你的 <code>SSH</code> 版本早于 7.3，那么很可惜它是不支持 <code>ProxyJump</code> 这条配置的。但是不要灰心，它支持另一条配置，<code>ProxyCommand</code>。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"># 其他部分略</span><br><span class="line"></span><br><span class="line"># 跳板机</span><br><span class="line">Host bastion</span><br><span class="line">    HostName    bastion.mycompany.com</span><br><span class="line"></span><br><span class="line"># 服务器</span><br><span class="line">Host dev-*</span><br><span class="line">    HostName        %h.dev.mycompany.com </span><br><span class="line">    ProxyCommand    ssh -W %h:%p bastion </span><br></pre></td></tr></tbody></table></figure>

<p>然后，我们继续执行 <code>ssh dev-user</code> 就可以了，<code>SSH</code> 会自动先连接到跳板机，然后在跳板机中再连接到我们要去的服务器。</p>
<p>如果你们公司安全做的非常好，需要通过数个跳板机来连接服务器，那么只需要给每个跳板机都配置上更外层的跳板就好了，像这样：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"># 其他部分略</span><br><span class="line"></span><br><span class="line"># 最外层跳板机</span><br><span class="line">Host bastion-outer</span><br><span class="line">    HostName    bastion-outer.mycompany.com</span><br><span class="line"></span><br><span class="line"># 下一层跳板机</span><br><span class="line">Host bastion-inner</span><br><span class="line">    HostName    bastion-inner.mycompany.com</span><br><span class="line">    ProxyJump   bastion-outer</span><br><span class="line"></span><br><span class="line"># 服务器</span><br><span class="line">Host dev-*</span><br><span class="line">    HostName    %h.dev.mycompany.com </span><br><span class="line">    ProxyJump   bastion-inner</span><br></pre></td></tr></tbody></table></figure>

<p>这样，<code>SSH</code> 就会先连接到 <code>bastion-outer</code>，然后连到 <code>bastion-inner</code>，然后连到 <code>dev-user</code>。理论上，你可以在这里无限套娃（逃</p>
<h1 id="这玩意有意思，我还想了解更多！"><a href="#这玩意有意思，我还想了解更多！" class="headerlink" title="这玩意有意思，我还想了解更多！"></a>这玩意有意思，我还想了解更多！</h1><p>好吧，为了满足你的好奇心，我这里为你提供了 3 篇博客供你参考。当然，这三篇博客也是我编写本文时的参考文档。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuenlidWx1by5jb20veWFuZ2ZjaDMvbm90ZS8xNzIxMjA=">多个 SSH KEY 的管理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1jb25maWd1cmUtY3VzdG9tLWNvbm5lY3Rpb24tb3B0aW9ucy1mb3IteW91ci1zc2gtY2xpZW50">How To Configure Custom Connection Options for your SSH Client<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL25lcmRlcmF0aS5jb20vMjAxMS8wMy8xNy9zaW1wbGlmeS15b3VyLWxpZmUtd2l0aC1hbi1zc2gtY29uZmlnLWZpbGUv">Simplify Your Life With an SSH Config File<i class="fa fa-external-link-alt"></i></span></p>
<p>另外，您也可以阅读 ssh_config 的手册页，来获得最原始的信息，阅读该手册的命令是：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">man ssh_config</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>SSH</tag>
        <tag>ssh_config</tag>
        <tag>ProxyCommand</tag>
        <tag>ProxyJump</tag>
        <tag>跳板机</tag>
      </tags>
  </entry>
  <entry>
    <title>让 nohup 不输出 appending output to &#39;nohup.out&#39;</title>
    <url>/suppress-appending-to-nohup-out-message.html</url>
    <content><![CDATA[<p>在使用 <code>nohup</code> 的时候，它总会打印一条 <code>nohup: appending output to 'nohup.out'</code> 这样的信息，并且必须敲一下回车。</p>
<p>因为 <code>nohup: appending output to 'nohup.out'</code> 这条信息是打印到 <code>STDERR</code> 的，所以解决的方法很简单，把 <code>STDERR</code> 重定向至 <code>STDOUT</code> 就可以了，比如这样：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> doSomething &gt; nohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 学习记录 - 使用 Alamofire 加载 JSON 并初始化列表</title>
    <url>/swiftui-initialize-list-with-remote-data.html</url>
    <content><![CDATA[<p>这两天又捡起来了之前开的一个老坑，继续完成<span class="exturl" data-url="aHR0cHM6Ly93d3cubm1ieGQxLmNvbS9Gb3J1bQ=="> X 岛揭示板<i class="fa fa-external-link-alt"></i></span>的 iOS 客户端，而且刚刚完成了从 JSON 初始化版面列表的功能。<br>这部分感觉最难的还是上手 <code>Alamofire</code>，因为它返回结果不像我平时做 Web 开发那样通过方法返回（也有可能是我没学到位），而是要把反序列化得到的对象传给一个回调方法。而这个思路的差异也导致我刚开始学的时候非常的痛苦，因为怎么也找不到我想要的那种返回方式。<br>我相信应该不止我一个人会遇到这种情况，所以打算在这里把完整的实现过程记录在这里，并希望后面有类似情况的同志能因为这篇文章而少掉几根头发。</p>
<span id="more"></span>

<h2 id="定义JSON对应的结构体"><a href="#定义JSON对应的结构体" class="headerlink" title="定义JSON对应的结构体"></a>定义 JSON 对应的结构体</h2><p>X 岛揭示板的<code>版面列表</code> API 会返回一个类似这样的 JSON：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"4"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sort"</span><span class="punctuation">:</span> <span class="string">"1"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"综合"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"status"</span><span class="punctuation">:</span> <span class="string">"n"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"forums"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"-1"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"时间线"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"msg"</span><span class="punctuation">:</span> <span class="string">"这里是匿名版最新的串"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"23"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"fgroup"</span><span class="punctuation">:</span> <span class="string">"3"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"sort"</span><span class="punctuation">:</span> <span class="string">"12"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"暴雪游戏"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"showName"</span><span class="punctuation">:</span> <span class="string">"暴雪游戏"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"msg"</span><span class="punctuation">:</span> <span class="string">"•本版发文间隔为15秒。"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"interval"</span><span class="punctuation">:</span> <span class="string">"15"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"safe_mode"</span><span class="punctuation">:</span> <span class="string">"0"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"auto_delete"</span><span class="punctuation">:</span> <span class="string">"0"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"thread_count"</span><span class="punctuation">:</span> <span class="string">"72"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"permission_level"</span><span class="punctuation">:</span> <span class="string">"0"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"forum_fuse_id"</span><span class="punctuation">:</span> <span class="string">"0"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"createdAt"</span><span class="punctuation">:</span> <span class="string">"2012-05-25 21:21:21"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"updateAt"</span><span class="punctuation">:</span> <span class="string">"2015-04-21 12:30:39"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"status"</span><span class="punctuation">:</span> <span class="string">"n"</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure>

<p>所以，我们可以创建一个这样的结构体来用来反序列化它：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ForumGroup</span>: <span class="title class_">Codable</span>, <span class="title class_">Identifiable</span> {</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> sort: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> status: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> forums: [<span class="type">Forum</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_">String</span>, <span class="title class_">CodingKey</span> {</span><br><span class="line">        <span class="keyword">case</span> id</span><br><span class="line">        <span class="keyword">case</span> sort</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> status</span><br><span class="line">        <span class="keyword">case</span> forums</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Forum</span>: <span class="title class_">Codable</span>, <span class="title class_">Identifiable</span> {</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> fGroup: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> sort: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> showName: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> msg: <span class="type">String</span> <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> interval: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> threadCount: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> permissionLevel: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> forumFuseId: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> createdAt: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> updateAt: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> status: <span class="type">String</span>? <span class="operator">=</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_">String</span>, <span class="title class_">CodingKey</span> {</span><br><span class="line">        <span class="keyword">case</span> id</span><br><span class="line">        <span class="keyword">case</span> fGroup</span><br><span class="line">        <span class="keyword">case</span> sort</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> showName</span><br><span class="line">        <span class="keyword">case</span> msg</span><br><span class="line">        <span class="keyword">case</span> interval</span><br><span class="line">        <span class="comment">// 因为X岛揭示板的API存在CamelCase和snake_case混用的情况</span></span><br><span class="line">        <span class="comment">// 所以需要CodingKeys来配置正确的映射</span></span><br><span class="line">        <span class="keyword">case</span> threadCount <span class="operator">=</span> <span class="string">"thread_count"</span></span><br><span class="line">        <span class="keyword">case</span> permissionLevel <span class="operator">=</span> <span class="string">"permission_level"</span></span><br><span class="line">        <span class="keyword">case</span> forumFuseId <span class="operator">=</span> <span class="string">"forum_fuse_id"</span></span><br><span class="line">        <span class="keyword">case</span> createdAt</span><br><span class="line">        <span class="keyword">case</span> updateAt</span><br><span class="line">        <span class="keyword">case</span> status</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="编写网络请求"><a href="#编写网络请求" class="headerlink" title="编写网络请求"></a>编写网络请求</h2><p>创建一个新的 Swift 文件 <code>AnoBbsApiClient</code>，编写如下代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AnoBbsApiClient</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> logger <span class="operator">=</span> <span class="type">LoggerHelper</span>.getLoggerForNetworkRequest(name: <span class="string">"AnoBbsApiClient"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">loadForumGroups</span>(</span><br><span class="line">        <span class="params">completion</span>:<span class="keyword">@escaping</span> ([<span class="type">ForumGroup</span>]) -&gt; <span class="type">Void</span>,</span><br><span class="line">        <span class="params">failure</span>:<span class="keyword">@escaping</span> (<span class="type">String</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    ) {</span><br><span class="line">        <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="type">XdnmbAPI</span>.<span class="type">GET_FORUM_LIST</span>)<span class="operator">!</span></span><br><span class="line">        <span class="type">AF</span>.request(url, method: .get, interceptor: .retryPolicy) { <span class="variable">$0</span>.timeoutInterval <span class="operator">=</span> <span class="number">10</span> }</span><br><span class="line">            .cacheResponse(using: .cache)</span><br><span class="line">            .validate()</span><br><span class="line">            .responseDecodable(of: [<span class="type">ForumGroup</span>].<span class="keyword">self</span>) { response <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> response.result {</span><br><span class="line">                <span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">                    completion(data)</span><br><span class="line">                <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">                    failure(error.localizedDescription)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>是的，就这几行代码，花了我大概一整天时间来学明白，定稿之前不知道来来回回试了多少遍。前面都很好懂，重点就是 <code>responseDecodable</code> 这个方法调用，<code>of</code> 参数指明我希望把返回的 JSON 反序列化成一个 <code>ForumGroup</code> 列表，后面的方法块中根据成功反序列化和发生任何错误的情况，分别调用 <code>completion</code> 和 <code>failure</code> 这两个回调方法。</p>
<h2 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h2><p>现在回到展示版面的 <code>ForumsView</code>，在 <code>body</code> 里面做如下实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">    <span class="type">NavigationStack</span> {</span><br><span class="line">        <span class="type">List</span> {</span><br><span class="line">            <span class="type">ForEach</span>(<span class="variable">$forumGroups</span>) { <span class="variable">$forumGroup</span> <span class="keyword">in</span></span><br><span class="line">                <span class="type">Section</span> {</span><br><span class="line">                    <span class="type">ForEach</span>(forumGroup.forums) { forum <span class="keyword">in</span></span><br><span class="line">                        <span class="type">NavigationLink</span>(destination: <span class="type">CookieListView</span>(globalState: globalState)) {</span><br><span class="line">                            <span class="keyword">if</span> (forum.showName <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">||</span> forum.showName<span class="operator">!</span>.isEmpty) {</span><br><span class="line">                                <span class="type">Text</span>(forum.name)</span><br><span class="line">                            } <span class="keyword">else</span> {</span><br><span class="line">                                <span class="type">Text</span>(forum.showName<span class="operator">!</span>)</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                } header: {</span><br><span class="line">                    <span class="type">Text</span>(forumGroup.name)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    .onAppear {</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>isContentLoaded) {</span><br><span class="line">            globalState.loadingStatus <span class="operator">=</span> <span class="type">String</span>(localized: <span class="string">"msgLoadingForumList"</span>);</span><br><span class="line">            shouldDisplayProgressView <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">AnoBbsApiClient</span>.loadForumGroups { forumGroups <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.forumGroups <span class="operator">=</span> forumGroups</span><br><span class="line">                isContentLoaded <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                shouldDisplayProgressView <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            } failure: { error <span class="keyword">in</span></span><br><span class="line">                showErrorToast(message: error)</span><br><span class="line">                shouldDisplayProgressView <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    .toast(isPresenting: <span class="variable">$isErrorToastShowing</span>) {</span><br><span class="line">        <span class="type">AlertToast</span>(type: .regular, title: errorMessage)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个 View 展示时，如果版面列表没有被加载，那么就调用刚刚写的 <code>loadForumGroups</code> 方法获取版面列表，后面的第一个代码块就是 <code>completion</code> 这个回调的实现，负责把 <code>loadForumGroups</code> 方法得到的结果传给一个 <code>@State</code> 变量 <code>forumGroups</code>，以及标记内容已经成功载入，并隐藏载入提示的风火轮；第二个代码块是 <code>failure</code> 这个回调的实现，负责显示一个带有错误信息的 <code>Toast</code> 并隐藏风火轮。</p>
<p>在这个 <code>View</code> 的 <code>NavigationStack</code> 里面，就可以监听 <code>forumGroups</code> 这个 <code>@State</code> 变量，并用变量里面的内容来渲染整个列表了。最后，我们就可以得到这样一个结果：</p>
<p><img data-src="https://blog-static.boris1993.com/swiftui-initialize-list-with-remote-data/forum-list-view.jpeg"></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>List</tag>
        <tag>Alamofire</tag>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 学习记录 - 切换 TabView 的 tab 时触发震动反馈</title>
    <url>/swiftui-trigger-haptic-feedback-when-changing-tabs.html</url>
    <content><![CDATA[<p>最近在折腾 iOS 开发的时候，想实现在切换 <code>TabView</code> 的 tab 时触发震动反馈，因为一边写一边学嘛，基础不牢，只能在网上瞎搜，试了各种方法都不奏效。直到前两天看到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RpbWlsbGlhbi9JY2VDdWJlc0FwcC9ibG9iLzczMGU0NzE3MTgzODliNTRmMWM5MjgwNWM1NmY1YTQ3MjI1NjUwYTIvSWNlQ3ViZXNBcHAvQXBwL0ljZUN1YmVzQXBwLnN3aWZ0I0wxMzItTDE0NQ=="> Ice Cubes: for Mastodon 的这段代码<i class="fa fa-external-link-alt"></i></span>，豁然开朗。</p>
<span id="more"></span>

<p>之前写的时候，只知道给 <code>selection</code> 传一个绑定的对象，但是看完 <code>IceCubes</code> 的代码，再一看 <code>selection</code> 参数的文档，恍然大悟，这个参数要的其实是一个 <code>SelectionValue</code> 的绑定对象，所以我其实可以在这个对象的 <code>set</code> 方法上面做文章。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> {</span><br><span class="line">    <span class="meta">@State</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> selectedTab <span class="operator">=</span> <span class="type">Tab</span>.<span class="type">Timeline</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">TabView</span>(selection: .<span class="keyword">init</span>(</span><br><span class="line">            get: {</span><br><span class="line">                selectedTab</span><br><span class="line">            },</span><br><span class="line">            set: { newTab <span class="keyword">in</span> </span><br><span class="line">                selectedTab <span class="operator">=</span> newTab</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在TabView更新selection的时候触发震动反馈就行了</span></span><br><span class="line">                <span class="keyword">if</span> (globalState.isHapticFeedbackEnabled) {</span><br><span class="line">                    <span class="type">HapticsHelper</span>.playHapticFeedback()</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        )) {</span><br><span class="line">            <span class="comment">// Views</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>顺便提一嘴我之前走过的一个弯路，就是试图在 <code>TabView</code> 上用<code>.onTapGesture()</code> 方法，结果虽然能震了，但是 tab 不会切换，当时还花了好长时间找怎么调用原本的<code>.onTapGesture()</code> 来切 tab，当然最后一无所获，最后认输，把震动反馈这个功能忍痛砍了……</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>iOS开发</tag>
        <tag>TabView</tag>
        <tag>Haptic Feedback</tag>
        <tag>震动反馈</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将项目部署至 Tomcat 的根下</title>
    <url>/tomcat-deploy-to-root.html</url>
    <content><![CDATA[<p>有两种方法可以实现将项目部署到 Tomcat 的根下。</p>
<ol>
<li><p>删掉自带的 ROOT / 目录，然后将项目的 war 包重命名为 ROOT.war</p>
</li>
<li><p>将项目正常部署 (假设 war 包名为 your_project.war)，然后修改 <code>conf/server.xml</code> 中的<span class="exturl" data-url="aHR0cHM6Ly90b21jYXQuYXBhY2hlLm9yZy90b21jYXQtOC4wLWRvYy9jb25maWcvY29udGV4dC5odG1s"> Context Root<i class="fa fa-external-link-alt"></i></span>为如下内容：</p>
</li>
</ol>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"your_project"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>参考文献：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUzMjg2MzYvMzgzMzg1OA==">https://stackoverflow.com/questions/5328518/deploying-my-application-at-the-root-in-tomcat<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>配置 Tomcat 监控 class 和 lib 变更并自动重新加载</title>
    <url>/tomcat-monitor-classes-and-auto-reload.html</url>
    <content><![CDATA[<p>在 <code>context.xml</code> 的 <code>Context</code> 标签中，设定 <code>reloadable="true"</code> 即可。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">reloadable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Other configurations --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>配置完毕后重启 Tomcat 使配置生效，然后 Tomcat 在监控到项目的 class 或 lib 有变化后，就会自动重新加载这个 webapp。</p>
<p>但是这个功能会显著增加 Tomcat 的性能消耗，故不建议在生产环境中使用。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>监听 Tomcat 的启动、停止事件</title>
    <url>/tomcat-servlet-context-listener.html</url>
    <content><![CDATA[<p>当 <code>Servlet</code> 容器启动或终止 Web 应用时，会触发 <code>ServletContextEvent</code> 事件，该事件由 <code>ServletContextListener</code> 来处理。在 <code>Servlet API</code> 中有一个 <code>ServletContextListener</code> 接口，接口中定义了处理 <code>ServletContextEvent</code> 事件的两个方法，它能够监听 <code>ServletContext</code> 对象的生命周期，实际上就是监听 Web 应用的生命周期。我们可以通过实现这两个方法，来实现在 <code>Tomcat</code> 启动和停止时执行一定的操作。</p>
<span id="more"></span>

<h1 id="监听器类编写"><a href="#监听器类编写" class="headerlink" title="监听器类编写"></a>监听器类编写</h1><p>新建一个监听器类 <code>TomcatListener</code> 并实现 <code>ServletContextListener</code> 接口</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Tomcat Started"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Tomcat Destroyed"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置 web.xml</h1><p>在 <code>web.xml</code> 中添加 <code>listener</code> 条目</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.project.name.listener.DemoListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>将 WAR 包部署到 <code>Tomcat</code> 并启动，检查 <code>catalina.out</code></p>
<p>在 <code>Tomcat</code> 启动时看到如下日志：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">15-Aug-2018 15:58:44.632 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployWAR Deploying web application archive [/usr/local/Cellar/tomcat@8/8.5.28/libexec/webapps/tomcatlistener.war]</span><br><span class="line">Tomcat Started</span><br></pre></td></tr></tbody></table></figure>

<p>在 <code>Tomcat</code> 停止时看到如下日志：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">15-Aug-2018 16:02:22.582 INFO [main] org.apache.catalina.core.StandardService.stopInternal Stopping service [Catalina]</span><br><span class="line">Tomcat Destroyed</span><br></pre></td></tr></tbody></table></figure>

<p>输出内容与 <code>TomcatListener</code> 所写内容一致，Q.E.D.</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>简单理解 NTP v3 协议</title>
    <url>/understanding-ntp-protocol.html</url>
    <content><![CDATA[<p>前段时间瞎折腾，给自己的黑莓 Bold 9900 写了个通过 NTP 同步时间的小工具，顺便在这里记录一下我在实现一个 NTP 客户端时对这个协议的理解。</p>
<span id="more"></span>

<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>NTP 协议使用 UDP 作为传输层协议，服务器监听 UDP 端口 123，在收到有效的报文后，服务器会发送响应报文，否则服务器将直接忽略不做响应。</p>
<h2 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h2><p>NTP 协议使用三种时间格式。</p>
<h3 id="NTP短时间格式"><a href="#NTP短时间格式" class="headerlink" title="NTP短时间格式"></a>NTP 短时间格式</h3><p>短时间格式长度为 32 位，其中高 16 位代表从 NTP 时间戳 0 秒至现在的秒数，低 16 位代表 1 秒以内的分数部分。<br>这个格式只会在 NTP 报文的 delay 和 dispersion 字段中用到。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Seconds              |           Fraction            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NTP时间戳"><a href="#NTP时间戳" class="headerlink" title="NTP时间戳"></a>NTP 时间戳</h3><p>NTP 时间戳格式长度为 64 位，其中高 32 位代表从 NTP 时间戳 0 秒至现在的秒数，低 32 位代表 1 秒以内的分数部分。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            Seconds                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                            Fraction                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NTP日期格式"><a href="#NTP日期格式" class="headerlink" title="NTP日期格式"></a>NTP 日期格式</h3><p>NTP 日期格式长度为 128 位，其中高 32 位用来表示 NTP 时间纪元，然后用 32 位表示从当前纪元开始经过的秒数，最后用 64 位表示 1 秒以内的分数部分。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Era Number                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           Era Offset                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">|                           Fraction                            |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></tbody></table></figure>

<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>一个 NTP v3 的报文必须包含如下字段：</p>
<ul>
<li><code>LI</code> - Leap Indicator，2 bit 整型数，指示当月最后一分钟是否包含闰秒</li>
<li><code>VN</code> - Version Number，3 bit 整型数，指示 NTP 协议的版本号。如 NTP v3 就是 3。</li>
<li><code>MODE</code> - 3 bit 整型数，指示发包方的工作模式。通常来说客户端使用 3 (client) 请求时间，服务端使用 4 (server) 返回时间。</li>
<li><code>STRATUM</code> - 8 bit 整型数，代表 NTP 层数。0 代表时钟源，如装备有 GPS 接收机的主服务器；1-15 逐层作为下游服务器，16 被定义为 “无法同步”。</li>
<li><code>POLL</code> - 8 bit 有符号整型数，代表在间隔多少秒后再进行下一次同步。值由 <code>log2(second)</code> 计算得出。</li>
<li><code>PRECISION</code> - 8 bit 有符号整型数，代表系统时钟的精确度。</li>
<li><code>ROOT DELAY</code> - NTP 短时间格式，指示从客户端到根服务器 (stratum 1 的服务器) 的延迟。</li>
<li><code>ROOT DISPERSION</code> - NTP 短时间格式，指示数据从根服务器到客户端之间可能引入的误差。</li>
<li><code>REFERENCE ID</code> - 32 bit 代码，用于标识一个特定的服务器，或一个参考时钟。<ul>
<li>对于 stratum 0 的数据包，该字段为 4 个 ASCII 字符，称作 “kiss code”，用于调试和监控。</li>
<li>对于 stratum 1 的数据包，该字段为参考时钟的标识符。标识符由 IANA 维护，此外以 “X” 开头的标识符都被预留给未注册的试验和开发用途。</li>
<li>对于 stratum 2~15 的数据包，该字段为服务器的标识符。当服务器使用 IPv4 时，该字段为服务器的 IP 地址；当服务器使用 IPv6 时，该字段为 IPv6 地址的前四段。</li>
</ul>
</li>
<li><code>REFERENCE TIMESTAMP</code> - NTP 时间戳格式，内容为客户端最后同步的时间。</li>
<li><code>ORIGIN TIMESTAMP</code> - NTP 时间格式，内容为数据包离开客户端的时间。</li>
<li><code>RECEIVE TIMESTAMP</code> - NTP 时间格式，内容为数据包抵达服务器的时间。</li>
<li><code>TRANSMIT TIMESTAMP</code> - NTP 时间格式，内容为数据包离开服务器的时间。</li>
<li><code>DESTINATION TIMESTAMP</code> - NTP 时间格式，内容为数据包抵达客户端的时间。<ul>
<li>注：DESTINATION TIMESTAMP 并不会包含在数据包中，而是在客户端收到数据包之后，它的数值才会被确定。</li>
</ul>
</li>
</ul>
<p>那么全部组合起来，就是这个样子的：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|LI | VN  |Mode |    Stratum     |     Poll      |  Precision   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Root Delay                            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Root Dispersion                       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          Reference ID                         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                     Reference Timestamp (64)                  +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                      Origin Timestamp (64)                    +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                      Receive Timestamp (64)                   +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |</span><br><span class="line">+                      Transmit Timestamp (64)                  +</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></tbody></table></figure>

<p>然而上述字段并不需要全部填写数据，实际上除了 LI、VN、MODE、STRATUM 之外，剩下的所有字段都可以填零。如下就是一个我用来测试的数据包：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">HEX:</span><br><span class="line">DB 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></tbody></table></figure>

<p>拆开来看的话：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">BIN:</span><br><span class="line">LI = 0b11 = 3 unknown (clock unsyncronized)</span><br><span class="line">VN = 0b011 = 3</span><br><span class="line">MODE = 0b011 = 3 client</span><br><span class="line">STRATUM = 0b00010000 = 16</span><br><span class="line">POLL = 0b00000000 = 0</span><br><span class="line">PRECISION = 0b00000000 = 0</span><br><span class="line">ROOT DELAY = 0b00000000000000000000000000000000</span><br><span class="line">ROOT DISPERSION = 0b00000000000000000000000000000000</span><br><span class="line">REFERENCE ID = 00000000000000000000000000000000</span><br><span class="line">REFERENCE TIMESTAMP = 00000000000000000000000000000000 00000000000000000000000000000000</span><br><span class="line">ORIGIN TIMESTAMP = 00000000000000000000000000000000 00000000000000000000000000000000</span><br><span class="line">RECEIVE TIMESTAMP = 00000000000000000000000000000000 00000000000000000000000000000000</span><br><span class="line">TRANSMIT TIMESTAMP = 00000000000000000000000000000000 00000000000000000000000000000000</span><br></pre></td></tr></tbody></table></figure>

<h2 id="计算second和fraction"><a href="#计算second和fraction" class="headerlink" title="计算second和fraction"></a>计算 second 和 fraction</h2><p>计算 second 很简单，取出 timestamp 的高 32 位就可以了；但是从 fraction 计算毫秒数比较麻烦，需要通过 <code>fraction * 10^6 / 2^32</code> 计算得到毫秒数。</p>
<p>这里我给出一个 Java 的代码片段：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> (ntpTimestamp &gt;&gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">secondsInMilliseconds</span> <span class="operator">=</span> seconds * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">fractionInTimestamp</span> <span class="operator">=</span> (ntpTimestamp &amp; <span class="number">0xFFFFFFFFL</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">milliseconds</span> <span class="operator">=</span> fractionInTimestamp * Math.pow(<span class="number">10</span>, <span class="number">6</span>) / Math.pow(<span class="number">2</span>, <span class="number">32</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>然后计算 1900 年 1 月 1 日 00:00:00 的 UNIX 时间戳作为基准 UNIX 时间戳，再加上 <code>secondsInMilliseconds</code> 和 <code>milliseconds</code>，就可以得到 NTP 返回的当前时间了。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzU5MDU=">Network Time Protocol Version 4: Protocol and Algorithms Specification - RFC<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamFubmV0LmhrL25ldHdvcmstdGltZS1wcm90b2NvbC1udHAtemgtaGFucy8=">Network Time Protocol (NTP) 网络时间协定 - Jan Ho 的网络世界<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1laW5iZXJnZ2xvYmFsLmNvbS8yMDIxLzAyLzI1L3RoZS1yb290LW9mLWFsbC10aW1pbmctdW5kZXJzdGFuZGluZy1yb290LWRlbGF5LWFuZC1yb290LWRpc3BlcnNpb24taW4tbnRwLw==">The Root of All Timing: Understanding root delay and root dispersion in NTP<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3Rob21wc29ubmcuYmxvZ3Nwb3QuY29tLzIwMTAvMDQvbnRwLXRpbWVzdGFtcF8yMS5odG1s">NTP Timestamp - Thompson’s Technological Insight<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aWNrZWx0b24uZ2l0bGFiLmlvL2FydGljbGVzL250cC10aW1lc3RhbXBzLw==">A Very Short Introduction to NTP Timestamps<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My9ibGFja2JlcnJ5X3RpbWVfc3luY19udHAvYmxvYi9lYmMyMTE2YmM4ZGEzMDkwZTlhZGI2OGZlOTEzMmRjNDdmMzc1ODkzL3NyYy9jb20vYm9yaXMxOTkzL3RpbWVzeW5jbnRwL3V0aWxzL050cFBhY2tldFV0aWxzLmphdmEjTDMyLUw1Ng==">NtpPacketUtils#getNtpTimestampMilliseconds - blackberry_time_sync_ntp - GitHub<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>NTP</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 lsof 命令备忘</title>
    <url>/useful-lsof-commands.html</url>
    <content><![CDATA[<p>记录 lsof 命令常见用法备忘</p>
<span id="more"></span>

<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有网络连接</span></span><br><span class="line">lsof -i</span><br></pre></td></tr></tbody></table></figure>

<h2 id="根据协议类型筛选"><a href="#根据协议类型筛选" class="headerlink" title="根据协议类型筛选"></a>根据协议类型筛选</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 仅显示IPv4网络连接</span></span><br><span class="line">lsof -i 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅显示IPv6网络连接</span></span><br><span class="line">lsof -i 6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅显示TCP连接</span></span><br><span class="line">lsof -iTCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅显示UDP连接</span></span><br><span class="line">lsof -iUDP</span><br></pre></td></tr></tbody></table></figure>

<h2 id="根据目标地址和端口号筛选"><a href="#根据目标地址和端口号筛选" class="headerlink" title="根据目标地址和端口号筛选"></a>根据目标地址和端口号筛选</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 根据目标地址筛选</span></span><br><span class="line">lsof -i@<span class="variable">${HOSTNAME_OR_IP_ADDRESS}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据端口号筛选</span></span><br><span class="line">lsof -i :<span class="variable">${PORT_NUMBER}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合</span></span><br><span class="line">lsof -i@<span class="variable">${HOSTNAME_OR_IP_ADDRESS}</span>:<span class="variable">${PORT_NUMBER}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="根据端口状态筛选"><a href="#根据端口状态筛选" class="headerlink" title="根据端口状态筛选"></a>根据端口状态筛选</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">lsof -i -sTCP:<span class="variable">${STATE}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">lsof -i -sTCP:LISTEN</span><br><span class="line">lsof -i -sTCP:ESTABLISHED</span><br></pre></td></tr></tbody></table></figure>

<h2 id="查看某进程端口占用"><a href="#查看某进程端口占用" class="headerlink" title="查看某进程端口占用"></a>查看某进程端口占用</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">lsof -p <span class="variable">${PID}</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前用户打开的文件</span></span><br><span class="line">lsof -u <span class="variable">${USER}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示除当前用户以外的用户打开的文件</span></span><br><span class="line">lsof -u ^<span class="variable">${USER}</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 仅显示PID而不是所有输出信息</span></span><br><span class="line">lsof -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据程序名筛选</span></span><br><span class="line">lsof -c <span class="variable">${COMMAND}</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>lsof</tag>
      </tags>
  </entry>
  <entry>
    <title>为 UWP 的 TextBlock 实现鼠标悬浮时显示和隐藏内容</title>
    <url>/uwp-textblock-show-and-hide-content-on-hover.html</url>
    <content><![CDATA[<p>这两天给我的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My9Yb1c=">窗边岛<i class="fa fa-external-link-alt"></i></span>项目实现了<span class="exturl" data-url="aHR0cHM6Ly93d3cubm1ieGQxLmNvbS8="> X 岛揭示板<i class="fa fa-external-link-alt"></i></span>网页中的<code>防剧透</code>功能。这个功能本质上就是，当鼠标悬浮在文字上时显示原本的内容，当鼠标移出文字时则用黑块代替。即</p>
<table>
<thead>
<tr>
<th>X 岛揭示板</th>
<th>窗边岛</th>
</tr>
</thead>
<tbody><tr>
<td><img data-src="https://blog-static.boris1993.com/uwp-textblock-show-and-hide-content-on-hover/nmbxd-anti-spoiler.gif"></td>
<td><img data-src="https://blog-static.boris1993.com/uwp-textblock-show-and-hide-content-on-hover/xow-anti-spoiler.gif"></td>
</tr>
</tbody></table>
<p>虽然说起来很简单，但是好像网上并没有针对这个需求有什么相关的内容，所以在这里记录下我的实现，权当抛砖引玉。</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 <code>X岛揭示板</code>中，防剧透是通过 <code>[h][/h]</code> 这个自定义标签实现的，所以上面 GIF 图中的文字其实是<code>正常文字--[h]防剧透文字[/h]--正常文字--[h]防剧透文字[/h]--</code>。那么这里要做的就有两件事：解析这个自定义标签，以及在 <code>TextBlock</code> 控件中实现黑块和正常文字的互相替换。</p>
<h2 id="为TextBlock对象填充内容"><a href="#为TextBlock对象填充内容" class="headerlink" title="为TextBlock对象填充内容"></a>为 TextBlock 对象填充内容</h2><p><code>TextBlock</code> 对象有两种填充内容的方式：</p>
<ul>
<li><p>直接将内容放入 <code>TextBlock.Text</code> 属性中。这种方式适合不包含防剧透标签的内容。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> TextBlock</span><br><span class="line">{</span><br><span class="line">    VerticalAlignment = VerticalAlignment.Top,</span><br><span class="line">    HorizontalAlignment = HorizontalAlignment.Stretch,</span><br><span class="line">    Text = content,</span><br><span class="line">    TextWrapping = TextWrapping.Wrap,</span><br><span class="line">    IsTextSelectionEnabled = textSelectionEnabled,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>将内容分散到各个 <code>Run</code> 对象中，并将这些 <code>Run</code> 对象放在 <code>TextBlock.Inlines</code> 属性中。我就是搭配这种方式实现的防剧透功能。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> run1 = <span class="keyword">new</span> Run { Text = <span class="string">"Run 1"</span> };</span><br><span class="line"><span class="keyword">var</span> run2 = <span class="keyword">new</span> Run { Text = <span class="string">"Run 2"</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textBlock = <span class="keyword">new</span> TextBlock</span><br><span class="line">{</span><br><span class="line">    VerticalAlignment = VerticalAlignment.Top,</span><br><span class="line">    HorizontalAlignment = HorizontalAlignment.Stretch,</span><br><span class="line">    TextWrapping = TextWrapping.Wrap,</span><br><span class="line">    IsTextSelectionEnabled = textSelectionEnabled,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">textBlock.Inlines.Add(run1);</span><br><span class="line">textBlock.Inlines.Add(run2);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="保存黑块下的原本内容"><a href="#保存黑块下的原本内容" class="headerlink" title="保存黑块下的原本内容"></a>保存黑块下的原本内容</h2><p>因为防剧透本质就是，平时用黑块替换掉要遮挡的内容，仅在鼠标悬浮时再用真正的内容替换掉黑块，所以我们需要一个地方来保存原本的内容。本来我想直接在 <code>Run</code> 对象上下功夫，但是可惜 <code>Run</code> 不像 <code>TextBlock</code> 有一个 <code>DataContext</code> 属性可以放东西，所以最后我还是把目光放在了 <code>TextBlock</code> 上。</p>
<p><code>TextBlock.DataContext</code> 是一个 <code>object</code> 类型的属性，所以我们可以随意放任何我们想放的东西。</p>
<p>当然为了扩展性考虑，我们最好还是给它创建一个类。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TextBlockDataContext</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// key用来放应该被防剧透的Run在Inline里的下标</span></span><br><span class="line">    <span class="comment">// value是这个Run实际的内容</span></span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; IndexAndOriginalTextOfHiddenContent = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后我在给一个段落创建 <code>TextBlock</code> 时，就可以把这个 <code>TextBlockDataContext</code> 对象放在 <code>DataContext</code> 属性中备用。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">textBlock = <span class="keyword">new</span> TextBlock</span><br><span class="line">{</span><br><span class="line">    VerticalAlignment = VerticalAlignment.Top,</span><br><span class="line">    HorizontalAlignment = HorizontalAlignment.Stretch,</span><br><span class="line">    TextWrapping = TextWrapping.Wrap,</span><br><span class="line">    IsTextSelectionEnabled = textSelectionEnabled,</span><br><span class="line">    DataContext = <span class="keyword">new</span> TextBlockDataContext { },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解析标签并生成Run对象"><a href="#解析标签并生成Run对象" class="headerlink" title="解析标签并生成Run对象"></a>解析标签并生成 <code>Run</code> 对象</h2><p>这部分的思路就是，整行文字会被 <code>[h]</code> 和 <code>[/h]</code> 标签切割成各自的 <code>Run</code>，因为 <code>TextBlock.Inlines</code> 是一个有序的列表，所以在切割和生成 <code>Run</code> 对象时，我可以在 <code>TextBlockDataContext.IndexAndOriginalTextOfHiddenContent</code> 中记录下要防剧透的 <code>Run</code> 的下标和它实际的内容。同时，针对要防剧透的 <code>Run</code>，我先用黑块字符<code>█</code>填充它的 <code>Text</code> 属性。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> indexOfRun = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> totalLength = content.Length;</span><br><span class="line"><span class="keyword">var</span> enteredHiddenBlock = <span class="literal">false</span>;</span><br><span class="line">Run run;</span><br><span class="line"><span class="keyword">while</span> (content.Length &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> indexOfBeginHideMark = content.IndexOf(<span class="string">"[h]"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!enteredHiddenBlock &amp;&amp; indexOfBeginHideMark &gt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        run = <span class="keyword">new</span> Run</span><br><span class="line">        {</span><br><span class="line">            Text = content.Substring(<span class="number">0</span>, indexOfBeginHideMark),</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        textBlock.Inlines.Add(run);</span><br><span class="line">        content = content.Substring(indexOfBeginHideMark + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        enteredHiddenBlock = <span class="literal">true</span>;</span><br><span class="line">        indexOfRun++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indexOfEndHideMark = content.IndexOf(<span class="string">"[/h]"</span>);</span><br><span class="line">    <span class="keyword">if</span> (indexOfEndHideMark &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">var</span> text = content.Substring(<span class="number">0</span>, indexOfEndHideMark);</span><br><span class="line">        run = <span class="keyword">new</span> Run</span><br><span class="line">        {</span><br><span class="line">            Text = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">'█'</span>, text.Length),</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        textBlock.Inlines.Add(run);</span><br><span class="line">        content = content.Substring(indexOfEndHideMark + <span class="number">4</span>);</span><br><span class="line">        (textBlock.DataContext <span class="keyword">as</span> TextBlockDataContext).IndexAndOriginalTextOfHiddenContent.Add(indexOfRun, text);</span><br><span class="line"></span><br><span class="line">        enteredHiddenBlock = <span class="literal">false</span>;</span><br><span class="line">        indexOfRun++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    run = <span class="keyword">new</span> Run</span><br><span class="line">    {</span><br><span class="line">        Text = content,</span><br><span class="line">    };</span><br><span class="line">    textBlock.Inlines.Add(run);</span><br><span class="line">    indexOfRun++;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="实现鼠标悬浮时显示真实内容"><a href="#实现鼠标悬浮时显示真实内容" class="headerlink" title="实现鼠标悬浮时显示真实内容"></a>实现鼠标悬浮时显示真实内容</h2><p><code>TextBlock</code> 提供了两个事件 <code>PointerEntered</code> 和 <code>PointerExited</code>，分别对应鼠标指针进入和离开 <code>TextBlock</code> 范围。所以我们就可以给这两个事件分别绑定 <code>UnhidingContent</code> 方法和 <code>HidingContent</code> 方法来实现鼠标悬浮时显示真正内容。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HidingContent</span>(<span class="params"><span class="built_in">object</span> sender, PointerRoutedEventArgs pointerRoutedEventArgs</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> textBlock = sender <span class="keyword">as</span> TextBlock;</span><br><span class="line">    <span class="keyword">if</span> (textBlock.DataContext <span class="keyword">is</span> TextBlockDataContext dataContext)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> indexAndOriginalText <span class="keyword">in</span> dataContext.IndexAndOriginalTextOfHiddenContent)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">var</span> textLength = indexAndOriginalText.Value.Length;</span><br><span class="line">            (textBlock.Inlines.ElementAt(indexAndOriginalText.Key) <span class="keyword">as</span> Run).Text = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">'█'</span>, textLength);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnhidingContent</span>(<span class="params"><span class="built_in">object</span> sender, PointerRoutedEventArgs pointerRoutedEventArgs</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> textBlock = sender <span class="keyword">as</span> TextBlock;</span><br><span class="line">    <span class="keyword">if</span> (textBlock.DataContext <span class="keyword">is</span> TextBlockDataContext dataContext)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> indexAndOriginalText <span class="keyword">in</span> dataContext.IndexAndOriginalTextOfHiddenContent)</span><br><span class="line">        {</span><br><span class="line">            (textBlock.Inlines.ElementAt(indexAndOriginalText.Key) <span class="keyword">as</span> Run).Text = indexAndOriginalText.Value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此，与<span class="exturl" data-url="aHR0cHM6Ly93d3cubm1ieGQxLmNvbS8="> X 岛揭示板<i class="fa fa-external-link-alt"></i></span>网页端类似的防剧透功能就完成实现了。完整的代码可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My9Yb1cvY29tbWl0Lzg3MzE5NGJjNDZlYWUwNGFlMjNkMjVkZTg0MmM0NTc0YzU0YWRhYWQ=">对应的 GitHub commit<i class="fa fa-external-link-alt"></i></span>。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>UWP</tag>
        <tag>TextBlock</tag>
      </tags>
  </entry>
  <entry>
    <title>梦幻电子宠物 - 雪儿</title>
    <url>/virtual-pet-xue-er.html</url>
    <content><![CDATA[<p>突然想起来小时候玩过的一个电子宠物游戏《梦幻电子宠物》。</p>
<table>
<thead>
<tr>
<th>主窗口</th>
<th>宠物状态</th>
<th>关于</th>
</tr>
</thead>
<tbody><tr>
<td><img data-src="https://blog-static.boris1993.com/virtual-pet-xue-er/main_window.png"></td>
<td><img data-src="https://blog-static.boris1993.com/virtual-pet-xue-er/statistics.png"></td>
<td><img data-src="https://blog-static.boris1993.com/virtual-pet-xue-er/about.png"></td>
</tr>
</tbody></table>
<p>这个小游戏的存档机制很有意思，是在 C 盘根目录下创建一个 ini 文件，记录宠物的出生时间和各项指标，然后它会根据这个时间来计算宠物的状态。也就是说，即使你把游戏关掉，宠物也不会停止成长。所以玩家就必须经常打开游戏照顾这个宠物，不然很有可能下次打开的时候，宠物就已经变成一个墓碑了……</p>
<p>这个小游戏我上传到蓝奏云了，有兴趣的可以去下载来玩。不过因为 64 位的 Windows 已经不支持 16 位应用，所以你需要一个老版本系统的虚拟机，或者用 <a href="https://github.com/otya128/winevdm"><code>otvdm</code></a>来运行。<br>地址：<span class="exturl" data-url="aHR0cHM6Ly9ib3JpczE5OTMubGFuem91ai5jb20vYjAzcXVldTNj">https://boris1993.lanzouj.com/b03queu3c<i class="fa fa-external-link-alt"></i></span><br>密码：15l3</p>
<p>P.S.：在找原版的时候，我注意到关于页面里 “碧晓拱籍 设计”，以为这是原作者的名字，于是就拿它一顿找啊，但一无所获。突然灵光一现，这会不会是…… 乱码？鬼使神差把这四个字按照 <code>GBK</code> 编码保存，然后再用 <code>SHIFT-JIS</code> 编码打开，得到一串片假名<code>ｱﾌﾏ�ｹｰｼｮ</code>，定睛一看这不就是 <code>application</code> 的日语<code>アプリケション</code>嘛，虽然里面又掺了个乱码……</p>
]]></content>
      <categories>
        <category>忆往昔</category>
      </categories>
      <tags>
        <tag>电子宠物</tag>
        <tag>梦幻电子宠物</tag>
        <tag>雪儿</tag>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 TRANSMIT 和 RECEIVE 命令打包、解包文件</title>
    <url>/zos-xmit.html</url>
    <content><![CDATA[<p>当需要从 z/OS 中下载一个 PS 文件，或者下载一个 Member 时，我们可以简单地使用 FTP 或者 IND$FILE 将文件下载回来，但是如果想要下载一整个 PDS 呢？总不能一个个地去下载吧，此时，XMIT 命令就派上用场了。</p>
<span id="more"></span>

<hr>
<h1 id="TRANSMIT命令"><a href="#TRANSMIT命令" class="headerlink" title="TRANSMIT命令"></a>TRANSMIT 命令</h1><p>TRANSMIT 命令用于将指定文件打包成 XMIT 档案以方便传输。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>使用一条命令前，必须要知道这条命令的语法。那么 XMIT 命令的语法如下：<br><em>注：TRANSMIT 命令可以简写为 XMIT</em></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">XMIT (nodeid.username) DSNAME('input.dataset.name') [MEMBERS(member1, member2, ...)] OUTDSN('output.dataset.name')</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>(nodeid.username) 为目标机器的 JES2 Node 名，以及接收用户的 TSOID，不过亲测在这里写自己的 Node 名和 TSOID 也能正常使用。通常来说，本机的 Node name 为 N1</li>
<li>DSNAME 为要打包的数据集名字</li>
<li>如果只打包这个 PDS 中的一部分 member，则可以在 MEMBERS 参数中指定。因为目前还没有用过，所以不知道可不可以指定通配符</li>
<li> OUTDSN 为打包之后输出文件的数据集名字</li>
</ul>
<p>TRANSMIT 命令的官方手册在 <a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.ikjc500/transmi.htm"><strong>这里</strong></a> ，完整的 TRANSMIT 命令的语法在 <a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.ikjc500/transsyn.htm"><strong>这里</strong></a> ，参数的详细说明在 <a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.ikjc500/transmitcomop.htm"><strong>这里</strong></a> 。</p>
<p>另外，根据 IBM 员工 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jb21tdW5pdHkvcHJvZmlsZXMvaHRtbC9wcm9maWxlVmlldy5kbz91c2VyaWQ9MDYwMDAwQUVRMiZsYW5nPWVu">Isabel Arnold<i class="fa fa-external-link-alt"></i></span> 的建议，在打包之前最好先创建一个 <code>DSORG=FB,LRECL=80,BLKSIZE=3120</code> 的文件供 TRANSMIT 用作输出文件。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如果我想要打包 IBMUSER.COBOL.SRC 这个 PDS 中的所有 member，打包输出文件名为 IBMUSER.COBOL.SRC.XMIT 那么命令可以这样写：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">XMIT (N1.IBMUSER) DSN('IBMUSER.COBOL.SRC') OUTDSN('IBMUSER.COBOL.SRC.XMIT')</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="RECEIVE命令"><a href="#RECEIVE命令" class="headerlink" title="RECEIVE命令"></a>RECEIVE 命令</h1><p>RECEIVE 命令用于解包 XMIT 档案。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>同样，这里先展示 RECEIVE 命令的语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">RECEIVE INDSN('xmit.dataset.name')</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>INDSN</code> 为 XMIT 档案的文件名。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>如果现在我在另一台主机上接收到了这个 XMIT 档案，那么我可以使用如下命令解包这个文件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">RECEIVE INDSN('IBMUSER.COBOL.SRC.XMIT')</span><br></pre></td></tr></tbody></table></figure>

<p>在 RECEIVE 命令成功识别指定的 XMIT 档案之后，会输出如下信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">INMR901I Dataset IBMUSER.COBOL.SRC from IBMUSER on NODENAME</span><br><span class="line">INMR906A Enter restore parameters or 'DELETE' or 'END' +</span><br></pre></td></tr></tbody></table></figure>

<p>此时 RECEIVE 命令等待用户输入解包信息，我们可以回复如下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">DA('IBMUSER.COBOL.SRC')</span><br></pre></td></tr></tbody></table></figure>
<p>来将内容解包至 IBMUSER.COBOL.SRC 中。</p>
<p>此处需要注意的是，如果目标数据集不存在，则 RECEIVE 会自动创建一个同名数据集，但接下来的解包过程可能会因这个数据集的空间不够用于存放解包出来的文件而报出 <code>ABEND B37</code> 。为避免这种情况发生，建议在 RECEIVE 前预先创建好需要的数据集，并保证数据集的空间足够。</p>
<p>在输入 DA 命令后，RECEIVE 将会试图向指定位置解包，并且会将结果输出至终端。</p>
<h2 id="对INMR906A消息的回复"><a href="#对INMR906A消息的回复" class="headerlink" title="对INMR906A消息的回复"></a>对 INMR906A 消息的回复</h2><p>对 <code>INMR906A</code> 的消息，有如下三种回复：</p>
<ul>
<li>DATASET (‘output.dataset.name’) - 将 XMIT 档案解包至指定位置，可简写为 DA ()</li>
<li>DELETE - 删除该 XMIT 档案</li>
<li> END - 退出，不执行任何操作</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9zdXBwb3J0L2tub3dsZWRnZWNlbnRlci9lbi9TU0xUQldfMi4xLjAvY29tLmlibS56b3MudjJyMS5pa2pjNTAwL3RyYW5zbWkuaHRt">TRANSMIT command<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9zdXBwb3J0L2tub3dsZWRnZWNlbnRlci9lbi9TU0xUQldfMi4xLjAvY29tLmlibS56b3MudjJyMS5pa2pjNTAwL3RyYW5zc3luLmh0bQ==">TRANSMIT command syntax<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9zdXBwb3J0L2tub3dsZWRnZWNlbnRlci9lbi9TU0xUQldfMi4xLjAvY29tLmlibS56b3MudjJyMS5pa2pjNTAwL3RyYW5zbWl0Y29tb3AuaHRt">TRANSMIT command operands<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9zdXBwb3J0L2tub3dsZWRnZWNlbnRlci9lbi9TU0xUQldfMi4xLjAvY29tLmlibS56b3MudjJyMS5pa2pjNDAwL2lramM0MDAxMjMuaHRt">RECEIVE command<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9zdXBwb3J0L2tub3dsZWRnZWNlbnRlci9lbi9TU0xUQldfMi4xLjAvY29tLmlibS56b3MudjJyMS5pa2pjMjAwL2RzcmVjLmh0bQ==">Receiving Data Sets with the RECEIVE Command<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jb21tdW5pdHkvYmxvZ3MvY2ljc2FiZWwvZW50cnkvdHJhbnNmZXJpbmdfbG9hZF9tb2R1bGVzX2JldHdlZW5fbWFpbmZyYW1lc191c2luZ194bWl0X2FuZF9mdHAyMD9sYW5nPWVu">Transfering Load Modules between Mainframes using XMIT and ftp<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Mainframe</tag>
        <tag>z/OS</tag>
        <tag>TRANSMIT</tag>
        <tag>XMIT</tag>
        <tag>RECEIVE</tag>
      </tags>
  </entry>
  <entry>
    <title>如何允许非 root 进程绑定低位端口</title>
    <url>/allow-non-root-process-to-bind-low-numbered-ports.html</url>
    <content><![CDATA[<p>众所周知，在 Linux 中，要想绑定端口号在 1024 以下的低位端口，是需要 root 权限的。但是，如果我又想绑定低位端口，又不想以 root 身份运行程序，该怎么办？答案是，<code>setcap</code> 命令。</p>
<span id="more"></span>

<h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>TL;DR，使用如下命令给这个程序赋予 <code>CAP_NET_BIND_SERVICE</code> 能力即可。注意，这条命令需要以 root 身份执行。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo <span class="built_in">setcap</span> CAP_NET_BIND_SERVICE=+eip /path/to/binary</span><br></pre></td></tr></tbody></table></figure>

<h1 id="这到底在干嘛"><a href="#这到底在干嘛" class="headerlink" title="这到底在干嘛"></a>这到底在干嘛</h1><p>接下来，我就把上面这条命令一点点拆开，解释清楚它到底干了什么。</p>
<h2 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h2><p>首先介绍一下 <code>capabilities</code>(能力) 这个东西。</p>
<p>在 Linux 内核版本 2.2 开始，Linux 将一系列的超级管理员权限细分成了一个个可以单独开启关闭的单元，以提供更细粒度的权限控制，这些单元，就被称之为 <code>capabilities</code>。详细的 <code>capabilities</code> 列表可以参考 <a href="#ref_1">Man Page Capabilities(7)</a>。</p>
<h2 id="CAP-NET-BIND-SERVICE"><a href="#CAP-NET-BIND-SERVICE" class="headerlink" title="CAP_NET_BIND_SERVICE"></a>CAP_NET_BIND_SERVICE</h2><p>拥有这个 <code>capability</code> 的程序，就可以绑定端口号在 1024 以下的特权端口。</p>
<h2 id="setcap"><a href="#setcap" class="headerlink" title="setcap"></a>setcap</h2><p>那么，该如何控制每个 <code>capability</code> 呢？答案就是 <code>setcap</code> 命令。上文所提到的命令，就是给指定的这个二进制程序增加 <code>CAP_NET_BIND_SERVICE</code> 这个 <code>capability</code>。</p>
<p>在 <code>capability</code> 名后面，用加号相连接的，则是开启这个 <code>capability</code> 的模式。模式有如下三种：</p>
<ul>
<li>e: Effective，意为这个 <code>capability</code> 是启用的。</li>
<li>p: Permitted，意为这个 <code>capability</code> 是允许被使用的。</li>
<li>i: inherited，意为这个 <code>capability</code> 可以被其子进程继承。</li>
</ul>
<p>在 <code>setcap</code> 命令中，使用加号来开启这个模式，或者使用减号来关闭这个模式。</p>
<h1 id="有什么副作用"><a href="#有什么副作用" class="headerlink" title="有什么副作用"></a>有什么副作用</h1><p>这个方法确实有一些副作用，或者说是限制：</p>
<ol>
<li>这个方法对脚本无效。如果要使某个脚本拥有这个能力，则需要为其解释器赋予这个能力，而这明显是一个巨大的安全隐患。</li>
<li>Linux 会为使用了 <code>setcap</code> 或 <code>suid</code> 的程序禁用掉 <code>LD_LIBRARY_PATH</code>。</li>
</ol>
<h1 id="除了手动指定，还有没有其他办法"><a href="#除了手动指定，还有没有其他办法" class="headerlink" title="除了手动指定，还有没有其他办法"></a>除了手动指定，还有没有其他办法</h1><p><code>Systemd</code> 也支持在 <code>service</code> 的配置文件中指定 <code>capabilities</code>，其用法示例如下：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[Service]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该服务仅可以使用哪些capabilities</span></span><br><span class="line"><span class="attr">CapabilityBoundingSet</span>=CAP_NET_BIND_SERVICE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以非特权用户运行程序时需要设定此参数</span></span><br><span class="line"><span class="attr">AmbientCapabilities</span>=CAP_NET_BIND_SERVICE</span><br></pre></td></tr></tbody></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a id="ref_1"><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kaWUubmV0L21hbi83L2NhcGFiaWxpdGllcw==">Man Page Capabilities(7)<i class="fa fa-external-link-alt"></i></span></a></li><a id="ref_1">
</a><li><a id="ref_1"></a><a id="ref_2"><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kaWUubmV0L21hbi84L3NldGNhcA==">Man Page setcap(8)<i class="fa fa-external-link-alt"></i></span></a></li><a id="ref_2">
</a><li><a id="ref_2"></a><a id="ref_3"><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kaWUubmV0L21hbi8zL2NhcF9mcm9tX3RleHQ=">Man Page cap_from_text(3)<i class="fa fa-external-link-alt"></i></span></a></li><a id="ref_3">
</a><li><a id="ref_3"></a><a id="ref_4"><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5zZWN1cmUud3MvbGludXgvZ2V0Y2FwX3NldGNhcC5odG1s">getcap, setcap and file capabilities - insecure.ws<i class="fa fa-external-link-alt"></i></span></a></li><a id="ref_4">
</a><li><a id="ref_4"></a><a id="ref_5"><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQxNDI1OC8zODMzODU4">Is there a way for non-root processes to bind to “privileged” ports on Linux? - Stack Overflow<i class="fa fa-external-link-alt"></i></span></a></li><a id="ref_5">
</a><li><a id="ref_5"></a><a id="ref_6"><span class="exturl" data-url="aHR0cDovL3JrNzAwLmdpdGh1Yi5pby8yMDE2LzEwLzI2L2xpbnV4LWNhcGFiaWxpdGllcy8=">Linux 的 capabilities 机制<i class="fa fa-external-link-alt"></i></span></a></li><a id="ref_6">
</a></ol><a id="ref_6">
</a>]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>setcap</tag>
        <tag>low numbered ports</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet 和 Spring MVC 是不是线程安全的</title>
    <url>/are-servlet-and-spring-mvc-thread-safe.html</url>
    <content><![CDATA[<p>太长不看：默认情况下 <code>servlet</code> 不是线程安全的；<code>Spring bean</code> 是否线程安全取决于这个 bean 的 scope。</p>
<span id="more"></span>

<h2 id="Servlet为什么不是线程安全的"><a href="#Servlet为什么不是线程安全的" class="headerlink" title="Servlet为什么不是线程安全的"></a>Servlet 为什么不是线程安全的</h2><p>单个 servlet 实例中的方法会被多个线程同时调用很多次，而 servlet 类中的变量是引用传递，多个线程同时存取某个变量时，就会产生线程安全问题。</p>
<p>以下方法可以让 servlet 或其中的一部分代码块变成线程安全的：</p>
<ul>
<li>使用 <code>syncronized</code> 关键字。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span> <span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line">        <span class="comment">//pre-processing</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">            <span class="comment">//code in this block is thread-safe</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//other processing;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>使用 <code>SingleThreadModel</code> 类</li>
</ul>
<p>如果在 <code>Sun Java System Web Server 7.0</code> 中部署单线程 servlet 时，servlet 引擎会创建一个 servlet 实例池，并保持内存中有多个 servlet 实例的副本。要想调整实例池中的实例数量，可以调整 Web Server 中的 <code>singleThreadedServletPoolSize</code> 属性。这种情况下，服务器的性能可能会降低，如果池中的所有实例全部被占用，那么新到来的请求就必须要在队列中等待某个实例被释放。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> <span class="keyword">implements</span> <span class="title class_">SingleThreadModel</span> {</span><br><span class="line">    <span class="comment">//servlet methods...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Spring-Bean什么时候是线程安全的，什么时候不是"><a href="#Spring-Bean什么时候是线程安全的，什么时候不是" class="headerlink" title="Spring Bean什么时候是线程安全的，什么时候不是"></a>Spring Bean 什么时候是线程安全的，什么时候不是</h2><p>首先，<code>singleton</code> 的 bean 不是线程安全的。在不使用 <code>@Lazy</code> 注解时，框架会在启动时就初始化好 singleton bean。但是框架不会管理开发人员怎么用这些 singleton bean，换言之，开发人员要自己处理线程安全问题。</p>
<p>而被 <code>@RequestScope</code> 注解标记的 bean 是线程安全的，因为这些 bean 不会在线程之间共享，而是在每次请求到来时都会创建新的实例。</p>
<p>Session scope 的 bean 也不是线程安全的，因为这些 bean 会与用户的会话绑定，每有一个新用户发来请求，就会创建一个新的 bean。但是，用户发来的请求可能是并行的，所以也有可能产生线程安全问题。</p>
<p>Prototype bean 是不是线程安全取决于它与哪种 bean 绑定。如果它是被一个 singleton bean 所依赖，因为 singleton bean 不是线程安全的，这个 prototype bean 也将被多个线程访问，所以此时 prototype bean 不是线程安全的；如果它被一个 request scope 的 bean 所依赖，那么这个 prototype bean 就是线程安全的，因为它会随着 request scoped bean 消亡而消亡，同时不会被多个线程共享。</p>
<p>除此之外，如果一个 bean 是无状态的，那么无论是什么 scope，它都是线程安全的。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vY2QvRTE5MTQ2LTAxLzgxOS0yNjM0L2FieGJoL2luZGV4Lmh0bWw=">Handling Threading Issues<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2RvbHN6ZXdza2kuY29tL3NwcmluZy9zcHJpbmctYmVhbi10aHJlYWQtc2FmZXR5LWd1aWRlLw==">Spring bean thread safety guide<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 MySQL 中的校对规则 (collation)</title>
    <url>/brief-talk-about-mysql-collations.html</url>
    <content><![CDATA[<p>在我们开发过程中，最常见到的三种校对规则 (collation) 就是 <code>utf8mb4_general_ci</code>、<code>utf8mb4_unicode_ci</code>，和 <code>utf8mb4_bin</code>。那么这三种排序规则之间有什么区别，在开发过程中又该怎么选择？这里就简单说一下我所了解到的知识，和我的理解。</p>
<span id="more"></span>

<h2 id="校对规则不会导致乱码"><a href="#校对规则不会导致乱码" class="headerlink" title="校对规则不会导致乱码"></a>校对规则不会导致乱码</h2><p>之前听到一名同事说，“这个东西 (collation) 你再研究下，搞不好中文会乱码的”。显然这位同事没搞清楚字符编码 (encoding) 和校对规则 (collation) 的区别。</p>
<p>字符集是一套符号和编码，它实实在在决定了每个字符应当以怎样的规则被编码为二进制数据，以及在取出一系列二进制数据之后，又应当以怎样的规则还原为字符。比如我们喜闻乐见的 “锟斤拷” 就是因为 GBK 编码与 Unicode 编码之间转换出现问题导致的乱码。</p>
<p>而校对规则本身并不会参与字符的编码，所以它当然不会产生文字乱码的问题。当然，使用了不合适的校对规则，也会对数据产生一定的影响，具体有什么影响后面我们慢慢说。</p>
<h2 id="校对规则是什么"><a href="#校对规则是什么" class="headerlink" title="校对规则是什么"></a>校对规则是什么</h2><p>校对规则是一套规范，它指明了数据在数据库中应当以哪种方式被比较和排序，包括排序的规则、是否大小写敏感，以及是否对重音标记敏感。</p>
<p>在 <code>MySQL</code> 中，校对规则通常按照<code>字符集_语言或地区_字符敏感特性</code>的规则来命名。</p>
<h2 id="这三种校对规则有什么区别"><a href="#这三种校对规则有什么区别" class="headerlink" title="这三种校对规则有什么区别"></a>这三种校对规则有什么区别</h2><p>首先，根据它们的后缀<code>_ci</code> 可以知道，这三种校对规则都是对大小写不敏感 (Case Insensitive) 的。</p>
<p><code>utf8mb4_general_ci</code> 是对大小写和重音字符都不敏感的。比如，拉丁字符 <code>ÀÁÅåāă</code>是等同于字符 <code>a</code> 的。</p>
<p><code>utf8mb4_unicode_ci</code> 是大小写不敏感，但是对重音字符敏感的。即，拉丁字符 <code>Å</code> 和 <code>å</code> 是等同的，但是和 <code>a</code> 是不同的。</p>
<p><code>utf8mb4_bin</code> 则是直接比较每个字符的 Unicode 码点 (code point)。</p>
<p>从效率上来讲，<code>utf8mb4_bin</code> &gt; <code>utf8mb4_general_ci</code> &gt; <code>utf8mb4_unicode_ci</code>。</p>
<h2 id="校对规则会产生什么影响"><a href="#校对规则会产生什么影响" class="headerlink" title="校对规则会产生什么影响"></a>校对规则会产生什么影响</h2><p>不同的排序规则，不仅对大小写和重音字符的处理不同，对于一些语言中特有的字符的处理也是不同的。</p>
<p>比如一个斯洛伐克人，他向数据库中插入了两条数据，其主键分别是 <code>poistný</code> 和 <code>poistny</code>。但是因为他用了重音不敏感的 <code>utf8mb4_general_ci</code>，导致数据库判定这两个字符串是一样的，而抛出了重复主键的错误。[^3]</p>
<p>另一个例子是，对于德语中的 <code>ß</code>，如果使用 <code>utf8mb4_general_ci</code>，那么它等同于 <code>s</code>，而如果使用 <code>utf8mb4_unicode_ci</code>，它则等同于 <code>ss</code>。</p>
<p>所以，如果数据涉及的语言中包含有特殊的字符或者重音符号，而其比对结果的正确性又很重要时，那么就应当选择 <code>unicode_ci</code> 系列的校对规则，否则，<code>general_ci</code> 就够用了。当然，在必要的情况下，也可以选择这个语言对应的规则，比如 <code>utf8_swedish_ci</code>。</p>
<p>对于中文来说，我在网上并没有找到相关的文章，同时根据自己的开发经验，<code>general_ci</code> 和 <code>unicode_ci</code> 对于中文都没有什么明显的问题，所以两个都可以用。</p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9mb3J1bXMubXlzcWwuY29tL3JlYWQucGhwPzEwMywxODcwNDgsMTg4NzQ4">Re: utf8_unicode_ci vs utf8_general_ci - MySQL Forums<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cDovL2NvbGxhdGlvbi1jaGFydHMub3JnL215c3FsNjAv">MySQL collation charts<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM1NDgyNzA3LzM4MzM4NTg=">斯洛伐克人的例子<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>collation</tag>
      </tags>
  </entry>
  <entry>
    <title>在 macOS 中搭建自己的 DNS 服务器</title>
    <url>/build-dns-server-on-macos.html</url>
    <content><![CDATA[<p>最近实验了一下配置 nginx 多站点，顺便也给自己跑在本机上的几个服务上了个域名 (当然是直接用 Hosts 强行解析到 127.0.0.1 的……)。但是吧，用 Hosts 强行解析，总觉得有点别扭，所以试着在本机搭一个 DNS 服务器。</p>
<span id="more"></span>

<h1 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h1><ul>
<li>一台安装有 macOS 的电脑 (不过，本文使用的 dnsmasq 在任何一个 UNIX-like 操作系统上也可以使用，所以要说成” 一台安装有 UNIX-like 操作系统的电脑” 也可以。至于 Windows？抱歉我懒得去试。)</li>
<li>Homebrew 或类似的包管理工具 (或者您要是愿意，编译安装也不是不可以，只要您能解决一路上遇到的问题)</li>
<li> 一个终端模拟器</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装过程很简单，使用包管理工具安装即可</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">brew install dnsmasq</span><br></pre></td></tr></tbody></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装成功之后，编辑 <code>/usr/local/etc/dnsmasq.conf</code> 文件，修改如下内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Never forward plain names (without a dot or domain part)</span><br><span class="line">domain-needed</span><br><span class="line"># Never forward addresses in the non-routed address spaces.</span><br><span class="line">bogus-priv</span><br><span class="line"></span><br><span class="line"># 将所有.local的域名全部解析到本机回环地址</span><br><span class="line">address=/local/127.0.0.1</span><br><span class="line">address=/local/::1</span><br><span class="line"></span><br><span class="line"># 不读入/etc/hosts</span><br><span class="line">no-hosts</span><br><span class="line"></span><br><span class="line"># 如果不想dnsmasq载入/etc/resolv.conf，则解除该行注释</span><br><span class="line">#no-resolv</span><br></pre></td></tr></tbody></table></figure>

<p>然后我这里希望仍然使用路由器作为主要的 DNS 服务器，dnsmasq 仅用来解析.local 域名，所以还需要配置系统的 /etc/resolver。<br><strong>注意：这一步操作仅在 macOS 中测试通过，不保证其他操作系统下的可用性</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 首先创建/etc/resolver目录</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/resolver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后配置local域名使用127.0.0.1上的DNS解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 127.0.0.1"</span> &gt; <span class="built_in">local</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>在这之前，我已经在本机配置了 nginx 服务器，并将 Aria2 前端配置了域名 <code>aria.boris1993.local</code>，所以我使用浏览器直接访问这个域名，打开成功，Q.E.D.<br><strong>注意：nslookup 貌似不会读取 /etc/resolver 的配置，至少在我的电脑上，nslookup aria.boris1993.local 的结果是 NXDOMAIN</strong></p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>果然，没文化真可怕。现在得知，<code>macOS</code> 支持 <code>mDNS</code>，系统会取电脑的主机名，将其转为全小写，并使用横线替换空格，最后在其后面附加<code>.local</code>，来作为本机的域名。<br>比如我的主机名是 <code>Boris-MacBook Pro</code>，那么系统生成的本机域名就是 <code>boris-macbook-pro.local</code>，使用这个域名就可以访问本机的服务了。<br>上面这一顿操作猛如虎，白干了，23333</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>DNS Server</tag>
      </tags>
  </entry>
  <entry>
    <title>100 块自制短信转发器</title>
    <url>/building-a-sms-forwarder-with-air780e.html</url>
    <content><![CDATA[<p>迫于手上有张 KnowRoaming 的卡用来收短信，但是为了这玩意再照顾个手机又很烦，正好看到合宙有卖 4G 模块，还有人已经实现了短信转发功能。本着生命在于折腾的精神，果断下单了一张开始搞。</p>
<span id="more"></span>

<h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul>
<li>Air780E + ESP32S3 套餐 - ￥66.80</li>
</ul>
<p>因为 KnowRoaming 手机卡只能收短信，不能发短信，也没有数据流量，而 Air780e 正好不支持连接 Wi-Fi，所以需要搭配 ESP32S3。ESP32S3 用来连接 Wi-Fi，并作为主控板，通过 UART 来连接和驱动 Air780e。</p>
<p><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/air780e_purchase_history.png"></p>
<ul>
<li>16pin 排母 - ￥15</li>
</ul>
<p>合宙只给送了排针，没有排母（甚至不卖这玩意），但是直接把 ESP32S3 和 Air780e 焊死显然不合适，所以只能自己再买排母。￥15 一盒里面有 5 对，所以实际分摊下来只有￥3。</p>
<p><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/socket_header.jpg"></p>
<ul>
<li>USB Type-C 转 Type-B 双公头转接头 - ￥9.9</li>
</ul>
<p>开发过程中可以用线凑合，但是我最后打算直插在 UPS 的 USB 口上，所以转换头必不可少。</p>
<p><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/usb_c_to_b_converter.png"></p>
<ul>
<li>找师傅焊接的手工费 - ￥50</li>
</ul>
<p>这没啥说的，自己又没有电烙铁又没这技术，就找了个修手机的铺子，让老板帮忙焊的。老板一边焊，一边说他这含银焊锡用在这上面都浪费……</p>
<h2 id="焊接和组装"><a href="#焊接和组装" class="headerlink" title="焊接和组装"></a>焊接和组装</h2><p>先上个全家福～</p>
<p><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/parts.jpeg"></p>
<p>焊排针和排座没啥好说的，就照着下图的样子焊就行。</p>
<table>
<thead>
<tr>
<th>ESP32S3</th>
<th>Air780e</th>
</tr>
</thead>
<tbody><tr>
<td><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/esp32s3.jpeg"></td>
<td><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/air780e.jpeg"></td>
</tr>
</tbody></table>
<p>另外因为 Air780e 默认不会上电自动开机，所以还要把 PWR 键上方的焊盘短接来让它通电就自动开机。（暂且借<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hlbnh1YmxvZy5jb20vMjAyMi8xMC8yOC8xOS05LXNtcy1mb3J3YXJkaW5nLWFpcjc4MGUtZXNwMzJjMy5odG1s">晨旭的博客<i class="fa fa-external-link-alt"></i></span>中的图片，因为我焊的时候忘了这茬了……）</p>
<p><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/shorting_soldering_pad_for_power_key.jpg"></p>
<p>然后 SIM 卡芯片朝板子，缺口朝内，插进 Air780e 的 SIM 卡槽。</p>
<p><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/sim_card_direction.jpeg"></p>
<p>最后按照如图的方向把排针对其插上就组装好了。一定要注意方向，毕竟有 5V 供电的针脚，插反了把 5V 怼到 GND 上会发生什么就不好说了，或许可以参考伊朗电工 Mehdi Sadaghdar 的各种作死实战。</p>
<p><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/put_together.jpeg"></p>
<h2 id="刷机和测试"><a href="#刷机和测试" class="headerlink" title="刷机和测试"></a>刷机和测试</h2><p>ESP32S3 接上 USB 转换头，再插到电脑上，就可以愉快的刷机了。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My9zbXNfZm9yd2FyZGVyX2Fpcjc4MF9lc3AzMg==">代码我已经写好并发布在 GitHub 上面了<i class="fa fa-external-link-alt"></i></span>，下载下来，照着<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My9zbXNfZm9yd2FyZGVyX2Fpcjc4MF9lc3AzMi9ibG9iL21hc3Rlci9SRUFETUUubWQjJUU0JUJGJUFFJUU2JTk0JUI5JUU4JTg0JTlBJUU2JTlDJUFDJUU1JTg4JUI3JUU1JTg1JUE1ZXNwMzI="> README 里面刷机的部分<i class="fa fa-external-link-alt"></i></span>改好代码，用合宙的 <code>LuaTools</code> 刷进去，就可以了。注意板子的固件要用我的 repo 里面的，<code>LuaTools</code> 提供的固件刷进去之后可用内存不够，会发不出去 HTTP 请求。如果不会刷机，可以看看<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMU1xNHkxZTdFYi8/cD0zJnZkX3NvdXJjZT1lOTE3ZGMyYmIyZTI2MDZjYzQ5MTdkNTM1MTNhNmJlNg=="> ESP32C3 烧录教程<i class="fa fa-external-link-alt"></i></span>。</p>
<p>刷完机板子会自动重启，这时候可以观察板子上面指示灯的状态，或者直接在 <code>LuaTools</code> 里面看日志，来看板子的初始化状态。LED 灯各种状态的含义也可以看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My9zbXNfZm9yd2FyZGVyX2Fpcjc4MF9lc3AzMi9ibG9iL21hc3Rlci9SRUFETUUubWQjbGVkJUU3JTgxJUFGJUU3JThBJUI2JUU2JTgwJTgxJUU1JTkwJUFCJUU0JUI5JTg5"> README 里面的解释<i class="fa fa-external-link-alt"></i></span>。</p>
<p>等板子初始化完成之后，就可以给这个手机号发短信了，板子收到短信后就会把发信号码和短信内容发送到配置的通知通道。开发的时候我已经测试过普通短信、长短信、中文、英文、日语，都可以正常接收。</p>
<p><img data-src="https://blog-static.boris1993.com/forwarding-sms-by-air780/test_results.JPEG"></p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>LuatOS</tag>
        <tag>合宙</tag>
        <tag>短信转发</tag>
        <tag>Air780E</tag>
        <tag>ESP32S3</tag>
      </tags>
  </entry>
  <entry>
    <title>记一个 Caddy 和 GitHub 自定义域名的坑</title>
    <url>/caddy-and-github-custom-domain.html</url>
    <content><![CDATA[<p>最近心血来潮，想给这个博客在 GitHub 上面的页面绑个自定义域名，结果无意中发现了一个坑。</p>
<span id="more"></span>

<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>如关于页面所见，这个博客是同时放在 GitHub Pages 和我的服务器上面的。我的服务器上面呢，是用 Caddy 的 <code>git</code> 插件监听了一个 <code>WebHook</code> 来实现同步更新的。</p>
<p>在我绑定 Custom domain 之前，<code>Caddy</code> 的自动更新一直在默默正常工作着。但就在我绑了 Custom domain 之后，我发现，Caddy 没能成功拉取最新版本的仓库。</p>
<h1 id="追踪线索"><a href="#追踪线索" class="headerlink" title="追踪线索"></a>追踪线索</h1><p>首先使用排除法，肯定不是 GitHub 的问题。那就看一下 Caddy 的日志里面有没有什么线索吧。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Aug 09 14:44:42 vps caddy[4516]: 2018/08/09 14:44:42 Received pull notification for the tracking branch, updating...</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]: From https://github.com/boris1993/boris1993.github.io</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]:  * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]:  + 3d5ecea...204143b master     -&gt; origin/master  (forced update)</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]: *** Please tell me who you are.</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]: Run</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]:   git config --global user.email "you@example.com"</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]:   git config --global user.name "Your Name"</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]: to set your account's default identity.</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]: Omit --global to set the identity only in this repository.</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]: fatal: unable to auto-detect email address (got 'www-data@vps.(none)')</span><br><span class="line">Aug 09 14:44:43 vps caddy[4516]: 2018/08/09 14:44:43 exit status 128</span><br></pre></td></tr></tbody></table></figure>

<p>鞥？啥时候 <code>git pull</code> 也要提供用户名和邮箱了？</p>
<p>随手往上面翻了翻，看见了点更有意思的东西：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Aug 10 16:45:46 vps caddy[11022]: 2018/08/10 16:45:46 Received pull notification for the tracking branch, updating...</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]: From https://github.com/boris1993/boris1993.github.io</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]:  * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]:    3a305c6..b57b257  master     -&gt; origin/master</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]: Updating 3a305c6..b57b257</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]: Fast-forward</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]:  CNAME | 1 +</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]:  1 file changed, 1 insertion(+)</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]:  create mode 100644 CNAME</span><br><span class="line">Aug 10 16:45:47 vps caddy[11022]: 2018/08/10 16:45:47 https://github.com/boris1993/boris1993.github.io.git pulled.</span><br></pre></td></tr></tbody></table></figure>

<p>新增了个叫 <code>CNAME</code> 的文件？这是啥玩意？得，看看里面写了啥。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> CNAME</span><br><span class="line">blog2.boris1993.tk</span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>

<p>这…… 不是我刚绑的那个自定义域名么…… 原来是这么实现的……</p>
<p>好吧，这样一来，问题就清楚了。</p>
<h1 id="结案"><a href="#结案" class="headerlink" title="结案"></a>结案</h1><p>其实这个问题，是这么回事：</p>
<p>在配置了自定义域名之后，GitHub 会往仓库里放一个名为 <code>CNAME</code> 的文件，而我在用 hexo 提交的时候，我本地完全没有关于这个文件的任何记录，导致远端仓库的 CNAME 文件又丢了，而在 Caddy 更新的时候，怀疑 Caddy 在进行 merge 操作，merge 操作需要用户提供用户名和邮箱，但是运行 Caddy 的 <code>www-data</code> 用户下没有这两个配置，于是就导致了上面的错误。</p>
<p>至于解决方案嘛，要么就往博客的源码里面放一个名为 <code>CNAME</code> 文件并且保证内容正确，要么就干脆不配置自定义域名了。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Caddy</tag>
        <tag>Custom domain</tag>
      </tags>
  </entry>
  <entry>
    <title>更改 Google Play 市场使用的区域</title>
    <url>/change-google-play-market-location.html</url>
    <content><![CDATA[<p>首先需要注意的一点是，目前所谓 Market Unlocker 等伪装工具已经失效了，Google 判定你商店区域的依据之一，是你登记在 Google Payments 中的当前住址。你登记的住址在哪，你的商店就在哪。</p>
<p>那么事情就简单了，如果要转区的话，在保证你目前该账户 <strong>余额小于 $10 (或等额货币)</strong> 时，更改 Google Payments 中该账户当前住址为你想要的地区的住址即可，然后在手持设备上 <strong>删除这个账户</strong> 并 <strong>重新登录</strong> ，然后就可以看到转区成功了。</p>
<p>不过转区前区域的余额是无法在转区后的区域中使用的，比如你从美区转到日区，那么你账户里的美刀就冻在里面花不出去了，除非你再转回美区。</p>
<hr>
<p>参考资料：</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxleGNsYXNzcm9vbS5jb20vaW50ZXJuZXQvZ29vZ2xlL2dvb2dsZS1hY2NvdW50LWxvY2F0aW9uLWNoYW5nZS8=">GOOGLE 帳戶的地區判定對使用者有哪些影響<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Google Play</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Workbench 中各个列属性的含义</title>
    <url>/column-flags-in-mysql-workbench.html</url>
    <content><![CDATA[<ul>
<li><code>PK</code>: 主键 (Primary Key)</li>
<li><code>NN</code>: 非空 (Not Null)</li>
<li><code>UQ</code>: 唯一索引 (Unique Index)</li>
<li><code>BIN</code>: 二进制 (Binary) 将数据储存为二进制字符串</li>
<li><code>UN</code>: 无符号的 (Unsigned)</li>
<li><code>ZF</code>: 零填充的 (Zero Fill) 如：INT (5) 的列中，<code>12</code> 会被填充为 <code>00012</code></li>
<li><code>AI</code>: 自增长的 (Auto Increment)</li>
<li><code>G</code>: 生成出来的 (Generated) 如：根据公式从其它列中生成的数据</li>
</ul>
<span id="more"></span>

<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM2NjM5NzEvMzgzMzg1OA==">What do column flags mean in MySQL Workbench?<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy93b3JrYmVuY2gvZW4vd2ItdGFibGUtZWRpdG9yLWNvbHVtbnMtdGFiLmh0bWw=">Columns Tab - MySQL Workbench Manual<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>column flag</tag>
      </tags>
  </entry>
  <entry>
    <title>Concourse 实战 - 监控 GitHub release 并自动构建镜像</title>
    <url>/concourse-practise-build-and-push-docker-image.html</url>
    <content><![CDATA[<p>距离上一篇 Concourse 相关的文章发布，已过去两年有余，期间因为没什么使用场景，不知道该怎么继续写下去，于是就断了。这次，我终于有机会将 Concourse 用到我自己的 home lab，并成功完成了一条 pipeline。</p>
<span id="more"></span>

<h2 id="背景及需求"><a href="#背景及需求" class="headerlink" title="背景及需求"></a>背景及需求</h2><p>偶然在网上看到了一个可以多端直播推流的工具，叫<span class="exturl" data-url="aHR0cHM6Ly9hbnRtZWRpYS5pby8="> Ant Media Server<i class="fa fa-external-link-alt"></i></span>，但是它的安装程序并不支持我正在用的 <code>Ubuntu 22.04 LTS</code>，同时它也没有提供制作好的 Docker 镜像，只能自己手动构建。可手动构建也太不优雅，根本不能忍，所以萌生了一个需求：监控 <code>Ant Media Server</code> 的 GitHub releases，如果有新的版本发布，那么就自动构建新的 Docker 镜像，并推送到我的 Docker Hub 中。</p>
<h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><p>首先，我要实现在 Concourse 里面监控 GitHub release。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9naXRodWItcmVsZWFzZS1yZXNvdXJjZS8=">github-release<i class="fa fa-external-link-alt"></i></span>这个 resource type 就是干这件事的，所以我们可以在 pipeline 中定义这样一个 resource：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">github-release</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">ant-media</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">Ant-Media-Server</span></span><br><span class="line">    <span class="comment"># 默认监视的是"release-"开头的tag</span></span><br><span class="line">    <span class="comment"># 但Ant Media Server的tag都是以"ams-"开头的</span></span><br><span class="line">    <span class="comment"># 所以需要指定一下</span></span><br><span class="line">    <span class="attr">tag_filter:</span> <span class="string">"ams-v?([^v].*)"</span></span><br></pre></td></tr></tbody></table></figure>

<p>资源光在 <code>resources</code> 里面定义好还不够，我们需要在 pipeline 里面用 <code>get</code> 这个 task 来让 Concourse 做出从这个资源获取数据的操作。所以，开始写 pipeline 咯。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build-image</span> <span class="comment"># pipeline的名字</span></span><br><span class="line">  <span class="attr">public:</span> <span class="literal">true</span> <span class="comment"># 公开就意味着用户不需登录也能在dashboard中看到</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">ant-media-server</span> <span class="comment"># 这里要写上面定义的resource的名字</span></span><br><span class="line">      <span class="attr">trigger:</span> <span class="literal">true</span> <span class="comment"># 这个资源将作为一个触发器</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样就实现了让 Concourse 监控这个 GitHub release，并在发布新 release 的时候触发 pipeline 运行。而这个 task 在运行的时候，会将 release 中的 artifact 下载到 <code>ant-media-server</code> 这个目录中，所以我们也不用担心下载文件的问题。同时它还会把 release 的版本号写在 <code>version</code> 这个文件中，后面我们可以利用这个文件来生成 Docker 镜像的 tag。</p>
<p>有了 Ant Media Server 的成品文件，按照<span class="exturl" data-url="aHR0cHM6Ly9yZXNvdXJjZXMuYW50bWVkaWEuaW8vZG9jcy9kb2NrZXItYW5kLWRvY2tlci1jb21wb3NlLWluc3RhbGxhdGlvbg==">官方文档<i class="fa fa-external-link-alt"></i></span>的说法，接下来只要做两件事：下载 Dockerfile，执行 <code>docker build</code> 命令就行。但是放在 pipeline 里面，就没这么简单了。</p>
<p>先做第一件事，下载 Dockerfile。感谢<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pncmlmZi9odHRwLXJlc291cmNl"> jgriff/http-resource<i class="fa fa-external-link-alt"></i></span>这个仓库，它可以实现在 Concourse 里面通过 HTTP 下载一个文件。那么接下来 pipeline 里面可以这么写：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 因为这不是Concourse官方提供的resource type</span></span><br><span class="line"><span class="comment"># 所以需要在这里定义一个名为http-resource的resource type</span></span><br><span class="line"><span class="comment"># 并声明由jgriff/http-resource这个Docker镜像来实现</span></span><br><span class="line"><span class="attr">resource_types:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http-resource</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">jgriff/http-resource</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="comment"># 前略</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server-dockerfile</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">http-resource</span> <span class="comment"># 上面定义好这个resource type之后，就可以在这里用了</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="comment"># 指定要下载的文件</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://raw.githubusercontent.com/ant-media/Scripts/master/docker/Dockerfile_Process</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build-image</span> <span class="comment"># pipeline的名字</span></span><br><span class="line">  <span class="attr">public:</span> <span class="literal">true</span> <span class="comment"># 公开就意味着用户不需登录也能在dashboard中看到</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">  <span class="comment"># 让这两个task并行执行，节省时间</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">in_parallel:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 下载ant-media-server-dockerfile这个resource指定的文件</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">ant-media-server-dockerfile</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在 Dockerfile 可以下载到了，但是它是被保存在 <code>ant-media-server-dockerfile/body</code> 这个文件里面的，我们需要把它移动到 <code>ant-media-server</code> 这个目录里，才能保证后面成功运行 <code>docker build</code>。所以接下来要用 <code>mv</code> 命令把文件移过去。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build-image</span></span><br><span class="line">  <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">  <span class="comment"># 前略</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">move-dockerfile</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># task运行在Linux环境</span></span><br><span class="line">      <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">      <span class="comment"># task将通过ubuntu这个Docker镜像运行</span></span><br><span class="line">      <span class="attr">image_resource:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">        <span class="attr">source:</span> </span><br><span class="line">          <span class="attr">repository:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="comment"># 将这两个资源传给镜像</span></span><br><span class="line">      <span class="attr">inputs:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server-dockerfile</span></span><br><span class="line">      <span class="comment"># 因为修改了ant-media-server这个资源的内容</span></span><br><span class="line">      <span class="comment"># 所以要将其输出，这样后续的task才能取到修改后的内容</span></span><br><span class="line">      <span class="attr">outputs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">run:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">mv</span></span><br><span class="line">        <span class="attr">args:</span> [<span class="string">"ant-media-server-dockerfile/body"</span>, <span class="string">"ant-media-server/Dockerfile"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>有了 Dockerfile，接下来就可以开始着手构建了。不用想，对于构建 Docker 镜像这样常见的 task，Concourse 预先制作好了 <a href="https://github.com/concourse/oci-build-task/"><code>concourse/oci-build-task</code></a>这个镜像来给我们用。</p>
<p>但是首先我们需要创建一个包含着 build args 的文件，因为文档的 <code>docker build</code> 命令中提到了 <code>--build-arg AntMediaServer=&lt;Replace_With_Ant_Media_Server_Zip_File&gt;</code> 这个参数，而 Ant Media Server 的 zip 文件名又会随着 release 而变化，同时 <code>oci-build-task</code> 的参数 <code>BUILD_ARGS_*</code> 并不支持 shell 命令，也就是说我不能通过 <code>BUILD_ARGS_AntMediaServer=ant-media-server-community-$(cat version).zip</code> 这样的方法来生成，那么只能用 <code>oci-build-task</code> 的 <code>BUILD_ARGS_FILE</code> 参数，传进去一个生成好的 build args file。</p>
<p>所以我们需要在 pipeline 中增加这两步来完成镜像的构建操作。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build-image</span></span><br><span class="line">  <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">  <span class="comment"># 前略</span></span><br><span class="line">  <span class="comment"># 生成build args file</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">generate-build-args</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">image_resource:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">        <span class="attr">source:</span> </span><br><span class="line">          <span class="attr">repository:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="attr">inputs:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">outputs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">run:</span> </span><br><span class="line">        <span class="comment"># 这里我曾经试过 </span></span><br><span class="line">        <span class="comment"># path: echo</span></span><br><span class="line">        <span class="comment"># args: ["AntMediaServer=ant-media-server-community-$(cat ant-media-server/version).zip", "&gt;", "ant-media-server/build_args.txt"]</span></span><br><span class="line">        <span class="comment"># 但是没成功，因为Concourse会把args做字符串拼接处理，最后当成一整个字符串传给命令</span></span><br><span class="line">        <span class="comment"># 所以其实变成了 echo "AntMediaServer=ant-media-server-community-$(cat ant-media-server/version).zip &gt; ant-media-server/build_args.txt"</span></span><br><span class="line">        <span class="comment"># 很明显这只能把这串字符串打在屏幕上，并不能生成文件</span></span><br><span class="line">        <span class="comment"># 所以只能通过调用sh来执行命令，把命令当成参数传给sh</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">sh</span></span><br><span class="line">        <span class="attr">args:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="string">-exc</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">'echo "AntMediaServer=ant-media-server-community-$(cat ant-media-server/version).zip" &gt; ant-media-server/build_args.txt'</span></span><br><span class="line">  <span class="comment"># 开始构建镜像</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">build-image</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">image_resource:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">registry-image</span></span><br><span class="line">        <span class="attr">source:</span> </span><br><span class="line">          <span class="attr">repository:</span> <span class="string">concourse/oci-build-task</span></span><br><span class="line">      <span class="comment"># 构建所需的文件都在ant-media-server这个资源中</span></span><br><span class="line">      <span class="comment"># 所以将它传给这个task</span></span><br><span class="line">      <span class="attr">inputs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="comment"># 将task输出的资源命名为image，并将其输出</span></span><br><span class="line">      <span class="attr">outputs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">image</span></span><br><span class="line">      <span class="attr">params:</span></span><br><span class="line">        <span class="attr">CONTEXT:</span> <span class="string">ant-media-server</span></span><br><span class="line">        <span class="attr">BUILD_ARGS_FILE:</span> <span class="string">ant-media-server/build_args.txt</span></span><br><span class="line">      <span class="comment"># 缓存构建结果，加速将来的新的构建</span></span><br><span class="line">      <span class="attr">caches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">run:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">build</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>oci-build-task</code> 成功后，会把镜像保存到 <code>image/image.tar</code> 文件中。要将它上传到 Docker Hub，我们还需要定义一个 <code>registry-image</code> 类型的 resource，来指定要将镜像上传到哪里。</p>
<p>因为上传 Docker Hub 需要登陆，而把 token 写在 pipeline 里面是非常蠢的行为，所以我把登陆信息放到了 Vault 中。向 Vault 放登陆信息很简单，在 <code>/concourse</code> 这个 path 中新建两个 secret 就可以了：</p>
<ul>
<li><code>/shared/dockerhub_username</code>，key 是 <code>value</code>，value 填写 Docker Hub 的用户名</li>
<li><code>/shared/dockerhub_token</code>，key 是 <code>value</code>，value 填写 Docker Hub 的 access token</li>
</ul>
<p>之所以我把登陆信息放到 <code>/shared</code> 这个 path 下，是因为我在 Vault 中配置了这个 path 作为一个公共的 path，在构建的时候要根据实际情况来修改，比如改成 team 的名字，或者放在 <code>/{team}/{pipeline}/</code> 下面。具体请参考 Concourse 与 Vault 集成相关的文档，这里不再赘述。</p>
<p>放好登陆信息后，就可以添加这样一个 resource：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="comment"># 前略</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server-docker</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">registry-image</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">"((dockerhub_username))/ant-media-server"</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">"((dockerhub_username))"</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">"((dockerhub_token))"</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后在 pipeline 最后增加两个 task，一个是读取 <code>ant-media-server/version</code> 的值，将其写在名为 <code>tag</code> 的变量中，后面我们会用这个变量来指定镜像的 tag；另一个就是对 <code>ant-media-server-docker</code> 这个资源执行 <code>put</code> 的操作，将 <code>image/image.tar</code> 这个镜像上传到 Docker Hub。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build-image</span></span><br><span class="line">  <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">  <span class="comment"># 前略</span></span><br><span class="line">  <span class="comment"># load_var用来从文件读入数据，并将其放在一个变量中</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">load_var:</span> <span class="string">tag</span></span><br><span class="line">    <span class="comment"># 指定要读的文件</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">ant-media-server/version</span></span><br><span class="line">    <span class="comment"># 为避免自动识别给我识别错，干脆直接指定文件内容的格式</span></span><br><span class="line">    <span class="comment"># trim就是纯文本，读取之后会去掉头尾的空白</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">trim</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">put:</span> <span class="string">ant-media-server-docker</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">image/image.tar</span></span><br><span class="line">      <span class="comment"># 上传时，同时更新latest和相关semver的镜像</span></span><br><span class="line">      <span class="comment"># 比如上传2.5.3时，会同时更新2.5，2，latest这三个tag</span></span><br><span class="line">      <span class="attr">bump_aliases:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 这里注意要指明从local var source中寻找变量，也就是开头的.:</span></span><br><span class="line">      <span class="comment"># 否则会找不到这个变量</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">"((.:tag))"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="完整的pipeline"><a href="#完整的pipeline" class="headerlink" title="完整的pipeline"></a>完整的 pipeline</h2><p>至此这个 pipeline 就完成了，下面我附上已经部署过的版本，供参考。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">resource_types:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http-resource</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">jgriff/http-resource</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">github-release</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">owner:</span> <span class="string">ant-media</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">Ant-Media-Server</span></span><br><span class="line">    <span class="attr">tag_filter:</span> <span class="string">"ams-v?([^v].*)"</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server-dockerfile</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">http-resource</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://raw.githubusercontent.com/ant-media/Scripts/master/docker/Dockerfile_Process</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server-docker</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">registry-image</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">"((dockerhub_username))/ant-media-server"</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">"((dockerhub_username))"</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">"((dockerhub_token))"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build-image</span></span><br><span class="line">  <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">build_log_retention:</span></span><br><span class="line">    <span class="comment"># 只保留最近5次的构建记录，以节省空间</span></span><br><span class="line">    <span class="attr">builds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">in_parallel:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">ant-media-server-dockerfile</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">load_var:</span> <span class="string">tag</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">ant-media-server/version</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">trim</span></span><br><span class="line">    <span class="attr">reveal:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">move-dockerfile</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">image_resource:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">        <span class="attr">source:</span> </span><br><span class="line">          <span class="attr">repository:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="attr">inputs:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server-dockerfile</span></span><br><span class="line">      <span class="attr">outputs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">run:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">mv</span></span><br><span class="line">        <span class="attr">args:</span> [<span class="string">"ant-media-server-dockerfile/body"</span>, <span class="string">"ant-media-server/Dockerfile"</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">generate-build-args</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">image_resource:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">        <span class="attr">source:</span> </span><br><span class="line">          <span class="attr">repository:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="attr">inputs:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">outputs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">run:</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">sh</span></span><br><span class="line">        <span class="attr">args:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="string">-exc</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">'echo "AntMediaServer=ant-media-server-community-$(cat ant-media-server/version).zip" &gt; ant-media-server/build_args.txt'</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">build-image</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">image_resource:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">registry-image</span></span><br><span class="line">        <span class="attr">source:</span> </span><br><span class="line">          <span class="attr">repository:</span> <span class="string">concourse/oci-build-task</span></span><br><span class="line">      <span class="attr">inputs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ant-media-server</span></span><br><span class="line">      <span class="attr">outputs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">image</span></span><br><span class="line">      <span class="attr">params:</span></span><br><span class="line">        <span class="attr">CONTEXT:</span> <span class="string">ant-media-server</span></span><br><span class="line">        <span class="attr">BUILD_ARGS_FILE:</span> <span class="string">ant-media-server/build_args.txt</span></span><br><span class="line">      <span class="attr">caches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">run:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">put:</span> <span class="string">ant-media-server-docker</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">image/image.tar</span></span><br><span class="line">      <span class="attr">bump_aliases:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">"((.:tag))"</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>concourse</tag>
        <tag>concourse-ci</tag>
        <tag>vault</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 Concourse CI - 快速入门</title>
    <url>/concourse-quick-start.html</url>
    <content><![CDATA[<p>最近公司需要用到一个名叫 <code>Concourse CI</code> 的 <code>CI/CD</code> 工具，那么我当然就要学习一下啦。顺便还能水一篇，啊不，写一篇博客，当作学习过程中的笔记。</p>
<span id="more"></span>

<h2 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h2><p>Concourse 使用 <code>PostgreSQL</code> 数据库来存储数据，所以首先要初始化好一个数据库。</p>
<p>如果要使用自建的数据库，那么可以参考<span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL3Bvc3RncmVzcWwtbm9kZS5odG1s">这篇官方文档<i class="fa fa-external-link-alt"></i></span>。</p>
<p>我这里用的是 <a href="https://railway.app/?referralCode=WQBcCO"><code>Railway</code></a>的数据库实例，准备步骤如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 给Concourse创建个单独的schema</span></span><br><span class="line"><span class="keyword">CREATE</span> SCHEMA concourse;</span><br><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE concourse <span class="keyword">WITH</span> ENCRYPTED PASSWORD <span class="string">'concourse'</span>;</span><br><span class="line"><span class="comment">-- 使新用户可以登陆</span></span><br><span class="line"><span class="keyword">ALTER</span> ROLE concourse <span class="keyword">WITH</span> LOGIN;</span><br><span class="line"><span class="comment">-- 给用户concourse赋予schema级的权限</span></span><br><span class="line"><span class="keyword">GRANT</span> USAGE,<span class="keyword">CREATE</span> <span class="keyword">ON</span> SCHEMA concourse <span class="keyword">TO</span> concourse;</span><br><span class="line"><span class="comment">-- 给用户concourse赋予所有表的全部权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA concourse <span class="keyword">TO</span> concourse;</span><br><span class="line"><span class="comment">-- 给用户concourse赋予所有序列的全部权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> SEQUENCES <span class="keyword">IN</span> SCHEMA concourse <span class="keyword">TO</span> concourse;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装Concourse-CI"><a href="#安装Concourse-CI" class="headerlink" title="安装Concourse CI"></a>安装 Concourse CI</h2><p>这里我将用两台服务器完成 Concourse 的部署，一个用来部署 <code>web</code> 节点，一个用来部署 <code>worker</code> 节点。</p>
<h3 id="Web节点"><a href="#Web节点" class="headerlink" title="Web节点"></a>Web 节点</h3><p>Concourse 的 web 节点中会运行一个名为 <code>TSA</code> 的服务用来注册 <code>worker</code> 节点，所以首先我们要在 <code>web</code> 节点创建 <code>TSA</code> 服务所需的 SSH 密钥对。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/docker/concourse</span><br><span class="line"><span class="comment"># 用于让web节点生成和验证用户的session token</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -m PEM -f ./session_signing_key</span><br><span class="line"><span class="comment"># 生成TSA端的密钥对</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -m PEM -f ./tsa_host_key</span><br><span class="line"><span class="comment"># 稍后要将worker节点的公钥放在这里面</span></span><br><span class="line"><span class="comment"># 其实就是SSH的authorized_keys</span></span><br><span class="line"><span class="built_in">touch</span> authorized_worker_keys</span><br></pre></td></tr></tbody></table></figure>

<p>然后编写 <code>docker-compose.yml</code>：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">concourse:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">concourse/concourse:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">concourse</span></span><br><span class="line">    <span class="comment"># 因为Concourse要开好几个端口，我懒得一个个配，直接host网络拉倒</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 让Concourse启动web节点</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">web</span></span><br><span class="line">    <span class="comment"># 把刚刚创建的密钥挂载进容器</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/boris1993/docker/concourse:/keys</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="comment"># HTTP代理配置，按需</span></span><br><span class="line">      <span class="comment"># 为啥要配懂得都懂，就是网络加速，如果你的网络能顺畅拉资源那不配也没问题</span></span><br><span class="line">      <span class="attr">HTTP_PROXY:</span> <span class="string">http://127.0.0.1:8899</span></span><br><span class="line">      <span class="attr">HTTPS_PROXY:</span> <span class="string">http://127.0.0.1:8899</span></span><br><span class="line">      <span class="attr">ALL_PROXY:</span> <span class="string">socks5://127.0.0.1:8899</span></span><br><span class="line">      <span class="comment"># Web节点监听8085端口</span></span><br><span class="line">      <span class="attr">CONCOURSE_BIND_PORT:</span> <span class="number">8085</span></span><br><span class="line">      <span class="comment"># 外部访问地址，因为我只在内网用，所以就配个内网IP就行</span></span><br><span class="line">      <span class="attr">CONCOURSE_EXTERNAL_URL:</span> <span class="string">http://192.168.1.123:8085</span></span><br><span class="line">      <span class="comment"># 密钥配置</span></span><br><span class="line">      <span class="attr">CONCOURSE_SESSION_SIGNING_KEY:</span> <span class="string">/keys/session_signing_key</span></span><br><span class="line">      <span class="attr">CONCOURSE_TSA_HOST_KEY:</span> <span class="string">/keys/tsa_host_key</span></span><br><span class="line">      <span class="attr">CONCOURSE_TSA_AUTHORIZED_KEYS:</span> <span class="string">/keys/authorized_worker_keys</span></span><br><span class="line">      <span class="comment"># 数据库配置</span></span><br><span class="line">      <span class="attr">CONCOURSE_POSTGRES_HOST:</span> <span class="string">containers-us-east-123.railway.app</span></span><br><span class="line">      <span class="attr">CONCOURSE_POSTGRES_USER:</span> <span class="string">concourse</span></span><br><span class="line">      <span class="attr">CONCOURSE_POSTGRES_PORT:</span> <span class="number">5511</span></span><br><span class="line">      <span class="attr">CONCOURSE_POSTGRES_PASSWORD:</span> <span class="string">concourse</span></span><br><span class="line">      <span class="attr">CONCOURSE_POSTGRES_DATABASE:</span> <span class="string">railway</span></span><br><span class="line">      <span class="comment"># 配置一个本地用户用于首次登陆</span></span><br><span class="line">      <span class="attr">CONCOURSE_ADD_LOCAL_USER:</span> <span class="string">concourse:concourse</span></span><br><span class="line">      <span class="comment"># 将这个本地用户加入main team，即将其作为管理员</span></span><br><span class="line">      <span class="attr">CONCOURSE_MAIN_TEAM_LOCAL_USER:</span> <span class="string">concourse</span></span><br></pre></td></tr></tbody></table></figure>

<p>接下来执行 <code>docker compose up -d</code> 启动容器，过几分钟就可以在 <code>http://192.168.1.123:8085</code> 打开 Concourse 的页面了。首次启动可能耗时比较久，因为要花时间初始化数据库里面的各种表。</p>
<h3 id="Worker节点"><a href="#Worker节点" class="headerlink" title="Worker节点"></a>Worker 节点</h3><p>上面启动的 <code>web</code> 节点只是用来给我们看的，它并不能执行任何的构建任务，所以还需要启动至少一个 <code>worker</code> 节点来运行构建任务。</p>
<p>首先还是生成密钥：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/docker/concourse-worker</span><br><span class="line"><span class="comment"># 只需要生成worker的SSH密钥</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -m PEM -f ./worker_key</span><br></pre></td></tr></tbody></table></figure>

<p>生成了 worker 节点的 SSH 密钥对之后，我们需要把 <code>worker_key.pub</code> 中的内容添加到 web 节点的 <code>authorized_worker_keys</code> 文件中，以通知 web 节点可以接受这个 worker 的加入请求。<code>authorized_worker_keys</code> 文件改好后需要重启 web 节点的 Docker 容器以使修改生效。</p>
<p>接下来编写 <code>docker-compose.yml</code>：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">concourse-worker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">concourse/concourse:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">concourse_worker</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 让Concourse以worker模式运行</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">worker</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 密钥所在的位置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/ubuntu/docker/concourse:/keys</span></span><br><span class="line">      <span class="comment"># worker节点的数据目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/ubuntu/docker/concourse/data:/opt/concourse/</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 节点名字</span></span><br><span class="line">      <span class="attr">CONCOURSE_NAME:</span> <span class="string">'worker-1'</span></span><br><span class="line">      <span class="comment"># 在Docker中运行的话，必须手动指定运行环境是containerd</span></span><br><span class="line">      <span class="attr">CONCOURSE_RUNTIME:</span> <span class="string">containerd</span></span><br><span class="line">      <span class="attr">CONCOURSE_CONTAINERD_DNS_SERVER:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">      <span class="comment"># web节点TSA服务的位置</span></span><br><span class="line">      <span class="attr">CONCOURSE_TSA_HOST:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.123</span><span class="string">:2222</span></span><br><span class="line">      <span class="comment"># worker节点的密钥</span></span><br><span class="line">      <span class="attr">CONCOURSE_TSA_PUBLIC_KEY:</span> <span class="string">/keys/tsa_host_key.pub</span></span><br><span class="line">      <span class="attr">CONCOURSE_TSA_WORKER_PRIVATE_KEY:</span> <span class="string">/keys/worker_key</span></span><br><span class="line">      <span class="attr">CONCOURSE_WORK_DIR:</span> <span class="string">/opt/concourse/worker</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后执行 <code>docker compose up -d</code> 启动即可。</p>
<h2 id="安装Fly-CLI"><a href="#安装Fly-CLI" class="headerlink" title="安装Fly CLI"></a>安装 Fly CLI</h2><p>虽然 Concourse 带有一个 Web 界面，但是我们在 Web 界面里面干不了什么，因为它的所有管理操作都需要通过它的 <code>Fly CLI</code> 来完成。</p>
<p>要安装 <code>Fly CLI</code>，你可以从刚才打开的 Dashboard 里面下载，也可以到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2UvcmVsZWFzZXM="> Concourse 的 GitHub Releases<i class="fa fa-external-link-alt"></i></span>中下载。</p>
<p>macOS 用户可能会想，我能不能用 <code>Homebrew</code> 来安装这个东西？一开始我也是这么想的，但是后面我发现，fly 的版本是要跟着 web 节点的版本走的，所以死了这条心，老老实实从 Dashboard 里面下载吧。</p>
<h2 id="检查worker的状态"><a href="#检查worker的状态" class="headerlink" title="检查worker的状态"></a>检查 worker 的状态</h2><p>为了确保 worker 节点是成功连接到 web 节点，我们需要用 <code>fly</code> 命令来检查 worker 节点的状态。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个名为default的target，登陆至http://192.168.1.123:8085</span></span><br><span class="line"><span class="comment"># 需要点击下面显示的URL，在浏览器中完成登陆过程</span></span><br><span class="line">$ fly login -t default -c http://192.168.1.123:8085</span><br><span class="line">logging <span class="keyword">in</span> to team <span class="string">'main'</span></span><br><span class="line"></span><br><span class="line">navigate to the following URL <span class="keyword">in</span> your browser:</span><br><span class="line"></span><br><span class="line">  http://192.168.1.123:8085/login?fly_port=49290</span><br><span class="line"></span><br><span class="line">or enter token manually (input hidden):</span><br><span class="line">target saved</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出这个target的workers</span></span><br><span class="line"><span class="comment"># 看到刚刚启动的worker节点，即说明这个worker成功连上了</span></span><br><span class="line">$ fly -t default workers</span><br><span class="line">name          containers  platform  tags  team  state    version  age</span><br><span class="line">worker-1      0           linux     none  none  running  2.4      14h14m</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>世间万物都可以从一个 hello world 学起，Concourse 也不例外。我们可以跟着 Concourse Tutorial [^3] 中 <code>Hello World</code> 一节的描述，把这个 task 执行起来。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/starkandwayne/concourse-tutorial.git</span><br><span class="line">Cloning into <span class="string">'concourse-tutorial'</span>...</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3794 (delta 0), reused 4 (delta 0), pack-reused 3789</span><br><span class="line">Receiving objects: 100% (3794/3794), 11.18 MiB | 25.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (2270/2270), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> concourse-tutorial/tutorials/basic/task-hello-world</span><br><span class="line">$ fly -t default execute -c task_hello_world.yml</span><br><span class="line">uploading task-hello-world <span class="keyword">done</span></span><br><span class="line">executing build 1 at http://localhost:8080/builds/1</span><br><span class="line">initializing</span><br><span class="line">waiting <span class="keyword">for</span> docker to come up...</span><br><span class="line">Pulling busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d...</span><br><span class="line">sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d: Pulling from library/busybox</span><br><span class="line">0669b0daf1fb: Pulling fs layer</span><br><span class="line">0669b0daf1fb: Verifying Checksum</span><br><span class="line">0669b0daf1fb: Download complete</span><br><span class="line">0669b0daf1fb: Pull complete</span><br><span class="line">Digest: sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d</span><br><span class="line"></span><br><span class="line">Successfully pulled busybox@sha256:afe605d272837ce1732f390966166c2afff5391208ddd57de10942748694049d.</span><br><span class="line"></span><br><span class="line">running <span class="built_in">echo</span> hello world</span><br><span class="line">hello world</span><br><span class="line">succeeded</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，Concourse 收到这个 task 之后，下载了一个 Busybox 的 Docker 镜像，然后执行了 <code>echo hello world</code> 这条命令。那么，Concourse 是怎么知道要如何执行一个 task 呢？这就得从上面运行的 <code>task_hello_world.yml</code> 说起了。</p>
<h2 id="一个task的配置文件"><a href="#一个task的配置文件" class="headerlink" title="一个task的配置文件"></a>一个 task 的配置文件</h2><p>Task 是 Concourse 的流水线 (pipeline) 中最小的配置单元，我们可以把它理解成一个函数，在我们配置好它的行为之后，它将永远按照这个固定的逻辑进行操作。</p>
<p>上面的 <code>task_hello_world.yml</code> 就是配置了一个 task 所要进行的操作，它的内容不多，我们一块一块拆开来看。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image_resource:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">  <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line"></span><br><span class="line"><span class="attr">run:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">echo</span></span><br><span class="line">  <span class="attr">args:</span> [<span class="string">hello</span> <span class="string">world</span>]</span><br></pre></td></tr></tbody></table></figure>

<p><code>platform</code> 属性指定了这个 task 要运行在哪种环境下。需要注意，这里指的是 worker 运行的环境，比如这里指定的 <code>linux</code>，就意味着 Concourse 将会挑选一个运行在 Linux 中的 worker。</p>
<p><code>image_resource</code> 属性指定了这个 task 将会运行在一个镜像容器中。其中的 <code>type</code> 属性说明这个镜像是一个 Docker 镜像，<code>source</code> 中 <code>{repository: busybox}</code> 说明了要使用 Docker 仓库中的 <code>busybox</code> 作为基础镜像。</p>
<p><code>run</code> 属性就是这个 task 实际要执行的任务，其中的 <code>path</code> 指定了要运行的命令，这里可以是指向命令的绝对路径、相对路径，如果命令在 <code>$PATH</code> 中，那么也可以直接写命令的名称；<code>args</code> 就是要传递给这个命令的参数。</p>
<p>如果要执行的命令非常复杂，我们也可以把命令写在一个 shell 脚本中，然后在 <code>run.path</code> 中指向这个脚本，比如这样：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">run:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./hello-world.sh</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样一来，就很清楚了。这个 task 会在一台 Linux 宿主机中执行，它将在一个 busybox 镜像中运行 <code>echo hello world</code> 这条命令。</p>
<h2 id="把多个task串起来"><a href="#把多个task串起来" class="headerlink" title="把多个task串起来"></a>把多个 task 串起来</h2><p>虽然我们在上面已经有了一个能用的 task，但是上面说了，task 只是一个 pipeline 的最小组成部分。而且在正式环境中，一个 CI/CD 任务可能会用到多个 task 来完成完整的构建任务。那么，怎么把多个 task 串起来呢？手动去做这件事显然不现实，所以就有了 pipeline。</p>
<p>这里我们还是用 Concourse Tutorial [^3] 中的示例来演示。</p>
<p>首先我们先看一下这个配置文件的内容：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">job-hello-world</span></span><br><span class="line">    <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">hello-world</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">echo</span></span><br><span class="line">            <span class="attr">args:</span> [<span class="string">hello</span> <span class="string">world</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>一个 pipeline 可以有多个 job，这些 job 决定了这个 pipeline 将会以怎样的形式来执行。而一个 job 中最重要的配置，是 plan，即需要执行的步骤。一个 plan 中的作业步，可以用来获取或更新某个资源，也可以用来执行某一个 task。</p>
<p>上面这个 pipeline 只有一个名为 <code>job-hello-world</code> 的 job，这个 job 里面只有一个作业步，名为 <code>hello-world</code>，是一个 task，操作是在一个 busybox 镜像中执行 <code>echo hello world</code> 命令。</p>
<p>在使用这个 pipeline 之前，我们需要把它注册到 Concourse 中。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -t 指明要操作的target</span></span><br><span class="line"><span class="comment"># -c 指明pipeline的配置文件</span></span><br><span class="line"><span class="comment"># -p 指明pipeline的名字</span></span><br><span class="line">$ fly -t default set-pipeline -c pipeline.yml -p hello-world</span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  job job-hello-world has been added:</span><br><span class="line">+ name: job-hello-world</span><br><span class="line">+ plan:</span><br><span class="line">+ - config:</span><br><span class="line">+     container_limits: {}</span><br><span class="line">+     image_resource:</span><br><span class="line">+       <span class="built_in">source</span>:</span><br><span class="line">+         repository: busybox</span><br><span class="line">+       <span class="built_in">type</span>: docker-image</span><br><span class="line">+     platform: linux</span><br><span class="line">+     run:</span><br><span class="line">+       args:</span><br><span class="line">+       - hello world</span><br><span class="line">+       path: <span class="built_in">echo</span></span><br><span class="line">+   task: hello-world</span><br><span class="line">+ public: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">apply configuration? [yN]: y</span><br><span class="line">pipeline created!</span><br><span class="line">you can view your pipeline here: http://localhost:8080/teams/main/pipelines/hello-world</span><br><span class="line"></span><br><span class="line">the pipeline is currently paused. to unpause, either:</span><br><span class="line">  - run the unpause-pipeline <span class="built_in">command</span>:</span><br><span class="line">    fly -t default unpause-pipeline -p hello-world</span><br><span class="line">  - click play next to the pipeline <span class="keyword">in</span> the web ui</span><br></pre></td></tr></tbody></table></figure>

<p>现在一个新的 pipeline 就被注册到 Concourse 中了。在它的 Web UI 中也能看到这个 pipeline。</p>
<p><img data-src="https://blog-static.boris1993.com/concourse-quick-start/concourse-with-pipeline.png" alt="Pipeline"></p>
<p>但是，这个 pipeline 现在还是暂停状态的，需要把它恢复之后才能使用。那么怎么恢复呢？其实上面 <code>set-pipeline</code> 操作的输出已经告诉我们了。</p>
<blockquote>
<p>the pipeline is currently paused. to unpause, either:<br>- run the unpause-pipeline command:<br><code>fly -t default unpause-pipeline -p hello-world</code><br>- click play next to the pipeline in the web ui</p>
<p>这个 pipeline 目前是被暂停的，如果要恢复，可以使用下面两种方法之一：<br>- 运行 unpause-pipeline 命令：<br><code>fly -t default unpause-pipeline -p hello-world</code><br>- 在 Web UI 中点击 pipeline 的播放按钮</p>
</blockquote>
<p>在成功恢复 pipeline 之后，我们可以看到原来蓝色的 paused 字样变成了灰色的 pending 字样，说明现在这个 pipeline 正在等待任务。</p>
<p>接下来我们就可以手动执行一下这个 pipeline，来检查它是否正常。具体操作说起来太啰嗦，我直接借用 Concourse Tutorial 里面的一个动图来替我说明。</p>
<p><img data-src="https://blog-static.boris1993.com/concourse-quick-start/concourse-manually-run-pipeline.gif" alt="Manually start a pipeline"></p>
<h2 id="自动触发job"><a href="#自动触发job" class="headerlink" title="自动触发job"></a>自动触发 job</h2><p>虽然我们在 Web UI 上点一下加号就能触发 job 开始执行，但是 CI/CD 讲究的就是一个自动化，每次更新都手动去点一下，显然谁都受不了这么折腾。所以，Concourse 也提供了几种自动触发 job 执行的方法。</p>
<p>一种方法是向 Concourse API 发送一个 <code>POST</code> 请求。这种就是 webhook，没什么特殊的，在版本控制系统里面配置好 webhook 的参数就好了。</p>
<p>另一种方法是让 Concourse 监视某一个资源，在资源发生改变之后自动触发 job 执行。下面我详细说说这个功能。</p>
<p>这里我们假设一个场景：我们有一个 Git 仓库，里面有一个名为 <code>test.txt</code> 的文件。我们想在每次这个仓库收到新 commit 之后，打印出 <code>test.txt</code> 的内容。</p>
<p>按照这个思路，我在 Concourse 中注册了如下的 pipeline：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 先定义一个Git资源</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">resource-git-test</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="comment"># 这里换成你自己的一个Git仓库</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">https://gitee.com/boris1993/git-test.git</span></span><br><span class="line">      <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># 如果想要这个任务定期执行，那么可以在这里定义一个计时器</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timer</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">time</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="comment"># 这里定义这个计时器</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">2m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># 定义一个job</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">job-show-file-content</span></span><br><span class="line">    <span class="attr">public:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="comment"># 第一步：获取resource-git-test中定义的资源</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">resource-git-test</span></span><br><span class="line">        <span class="comment"># 在资源发生更新的时候触发</span></span><br><span class="line">        <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 如果要让任务定期重复执行，那么这里也要将定时器作为一个资源</span></span><br><span class="line">      <span class="comment"># 并打开trigger开关</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">timer</span></span><br><span class="line">        <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 第二步：在控制台打印文件内容</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">show-file-content</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">inputs:</span></span><br><span class="line">            <span class="comment"># resource-git-test中定义的资源将作为这个步骤的输入资源</span></span><br><span class="line">            <span class="comment"># 即让resource-git-test中的文件对该步骤可见</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">resource-git-test</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="comment"># 因为我们都懂的原因，Docker中心仓库有可能会连不上</span></span><br><span class="line">            <span class="comment"># 而在执行构建的时候，Concourse会到仓库检查镜像的版本</span></span><br><span class="line">            <span class="comment"># 所以这里用registry_mirror配置了一个Docker仓库的镜像站</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>, <span class="attr">registry_mirror:</span> <span class="string">https://dockerhub.azk8s.cn</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">cat</span></span><br><span class="line">            <span class="comment"># 在引入input资源后，工作目录下就可以看到这个资源相关的文件夹</span></span><br><span class="line">            <span class="attr">args:</span> [<span class="string">"./resource-git-test/test.txt"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>创建 <code>git-test</code> 仓库、编辑 <code>test.txt</code> 等等操作不是重点，也没啥难度，这里不啰嗦了。在完成编辑文件，和 push 到远程仓库后，我们等待 Concourse 检查远程仓库更新，并执行构建步骤。</p>
<p>在 pipeline 视图中点击 <code>resource-git-test</code> 这个资源，就可以看到这个资源的检查历史，展开某条记录后，还可以看到这条历史相关的构建。</p>
<p><img data-src="https://blog-static.boris1993.com/concourse-quick-start/concourse-git-resource-trigger.png" alt="Git resource trigger"></p>
<p>在 Concourse 检查到 git 仓库的更新后，就会执行下面指定的构建步骤。结果大概会是这个样子的：</p>
<p><img data-src="https://blog-static.boris1993.com/concourse-quick-start/concourse-git-resource-trigger-result.png" alt="Git resource trigger execution result"></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>至此，我们完整的配置了一个简单的 pipeline。后面我会根据文档，或者根据工作中遇到的情况，继续补充权限管理、复杂的 case 等相关的博文。</p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnLw==">Concourse CI<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2U=">Concourse - GitHub<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2V0dXRvcmlhbC5jb20v">Concourse Tutorial<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>concourse</tag>
        <tag>concourse-ci</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 Concourse CI - 使用变量</title>
    <url>/concourse-using-vars.html</url>
    <content><![CDATA[<p>在实际编写配置文件时，我们不可能保证所有相关的值都是一成不变的。有的值可能会根据运行时的状态来指定，也有可能它是类似 token 一样的机密信息，必须从一个可信渠道获取。为了应对这种情况，我们就需要在配置文件中引入变量。</p>
<span id="more"></span>

<h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>在 Concourse 的语法规则中，如果要声明一个变量，就用双括号把变量名字包裹起来，就像这样：<code>((a-variable))</code>。借用 Concourse Tutorials 中的一个例子，我们看一下具体在配置文件中，是如何声明一个变量的。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">show-animal-names</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">show-animal-names</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">          <span class="attr">image_resource:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">            <span class="attr">source:</span> {<span class="attr">repository:</span> <span class="string">busybox</span>}</span><br><span class="line">          <span class="attr">run:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">env</span></span><br><span class="line">            <span class="attr">args:</span> []</span><br><span class="line">          <span class="attr">params:</span></span><br><span class="line">            <span class="attr">CAT_NAME:</span> <span class="string">((cat-name))</span></span><br><span class="line">            <span class="attr">DOG_NAME:</span> <span class="string">((dog-name))</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里需要穿插一个内容，就是 task 的 <code>params</code> 属性。它的作用是把里面指定的键值对作为环境变量传到容器中。</p>
<p>我们可以看到，它声明了两个变量：<code>cat-name</code> 和 <code>dog-name</code>，分别作为环境变量 <code>CAT_NAME</code> 和 <code>DOG_NAME</code> 的值。这样，就完成了变量的声明。</p>
<h2 id="为变量传值"><a href="#为变量传值" class="headerlink" title="为变量传值"></a>为变量传值</h2><p>变量声明好了，那就要传值了。Concourse 支持通过命令行参数、通过文件，以及通过密钥管理器 (credentials manager) 来传入变量的值。</p>
<p>这里有一点需要注意，通过命令行参数或者文件传入的值，是不会根据外部条件变化的，你可以将其理解成 fly 会先把配置文件做文本替换然后再注册到 Concourse。如果要修改变量的值，那么就需要重新运行 <code>fly set-pipeline</code> 命令来修改。</p>
<h3 id="通过命令行参数传值"><a href="#通过命令行参数传值" class="headerlink" title="通过命令行参数传值"></a>通过命令行参数传值</h3><p>我们可以在 <code>fly</code> 命令中使用 <code>-v</code> 参数来为变量传值，它的格式是 <code>-v key=value</code>，要对多个变量赋值就要使用多个 <code>-v</code> 参数。</p>
<p>如果要为上文提到的配置文件传值，那么我们可以这样执行命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 为变量赋值并注册pipeline</span></span><br><span class="line">fly -t tutorial sp -p parameters -c pipeline.yml -v cat-name=garfield -v dog-name=odie</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们可以执行 <code>fly -t tutorial trigger-job -j parameters/show-animal-names -w</code> 这条命令来触发任务执行，来检查传值是否成功。</p>
<h3 id="通过文件传值"><a href="#通过文件传值" class="headerlink" title="通过文件传值"></a>通过文件传值</h3><p>要使用文件传值，我们首先需要创建一个包含变量名和值的 YAML 文件。为了方便起见我直接用 heredoc 创建，当然你可以选择任何你喜欢的方式。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从标准输入创建文件</span></span><br><span class="line"><span class="comment"># 当接收到EOF这个字符串时停止接收内容</span></span><br><span class="line">$ <span class="built_in">cat</span> &gt; credentials.yml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">heredoc&gt; cat-name: garfield</span></span><br><span class="line"><span class="string">heredoc&gt; dog-name: odie</span></span><br><span class="line"><span class="string">heredoc&gt; EOF</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样我们就得到了一个这样的文件：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">cat-name:</span> <span class="string">garfield</span></span><br><span class="line"><span class="attr">dog-name:</span> <span class="string">odie</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后在 <code>fly</code> 命令中，我们就可以用 <code>-l</code> 参数来通过文件为变量赋值：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">fly -t tutorial sp -p parameters -c pipeline.yml -l credentials.yml</span><br></pre></td></tr></tbody></table></figure>

<h3 id="通过密钥管理器传值"><a href="#通过密钥管理器传值" class="headerlink" title="通过密钥管理器传值"></a>通过密钥管理器传值</h3><p>如上文所述，通过参数和文件赋值，不仅存在诸多不便，同时还无法保证机密信息的安全性。所以，Concourse 也支持与密钥管理器集成。Concourse 支持多种密钥管理器，具体的支持列表可以在官网的<span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL2NyZWRzLmh0bWw="> Credential Management<i class="fa fa-external-link-alt"></i></span>处查询。这里我们使用 Vault 进行演示。</p>
<p>由于 Vault 的安装和配置与本文无关，所以这里略过不讲。</p>
<h4 id="Concourse的配置"><a href="#Concourse的配置" class="headerlink" title="Concourse的配置"></a>Concourse 的配置</h4><p>Concourse 默认是没有配置密钥管理器的，如果要将 Vault 与 Concourse 集成起来，那么需要为 web 节点配置如下环境变量：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Vault的地址，协议可以是HTTP也可以是HTTPS</span></span><br><span class="line">CONCOURSE_VAULT_URL=https://vault.example.com:8200</span><br><span class="line"><span class="comment"># 你也可以为Concourse指定CA证书所在的位置</span></span><br><span class="line">CONCOURSE_VAULT_CA_CERT=path/to/ca.crt</span><br></pre></td></tr></tbody></table></figure>

<p>配置完毕后重启 web 节点，就完成了 Concourse 的配置。</p>
<h4 id="在Vault中的准备工作"><a href="#在Vault中的准备工作" class="headerlink" title="在Vault中的准备工作"></a>在 Vault 中的准备工作</h4><p>根据<span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnL3ZhdWx0LWNyZWRlbnRpYWwtbWFuYWdlci5odG1s"> The Vault credential manager<i class="fa fa-external-link-alt"></i></span>的描述，Concourse 会在 Vault 中按照以下的规则查找变量的值，并取出其中 <code>value</code> 这个 key 所对应的内容：</p>
<ul>
<li><code>/concourse/TEAM_NAME/PIPELINE_NAME/VAR_NAME</code></li>
<li><code>/concourse/TEAM_NAME/VAR_NAME</code></li>
</ul>
<p>以上文提到的那个 pipeline 为例子，我使用系统自带的 <code>main</code> 这个 team，并将这个 pipeline 命名为了 <code>parameters</code>，那么在寻找 <code>cat-name</code> 这个变量时，Concourse 就会先后在 <code>/concourse/main/parameters/cat-name</code> 和 <code>/concourse/main/cat-name</code> 中查找。</p>
<p>所以为了满足这个条件，我们需要在 Vault 中完成以下几件事：</p>
<ol>
<li>新建一个 secret engine，将其命名为 <code>concourse</code></li>
<li>新建一个 secret，path 填写 <code>main/parameters/cat-name</code>，secret data 新增一条 key 为 <code>value</code>，值为 <code>garfield</code> 的记录</li>
<li>再新建一个 secret，path 填写 <code>main/parameters/dog-name</code>，secret data 新增一条 key 为 <code>value</code>，值为 <code>odie</code> 的记录</li>
</ol>
<p>这样，就在 Vault 中设定好了变量的值。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>此时，我们回到 Concourse，触发这个 task 执行，如果配置正确的话，就可以看到这样的输出了：</p>
<p><img data-src="https://blog-static.boris1993.com/concourse-using-vars/concourse-fetch-parameter-value-from-vault.png" alt="Fetch parameter value from Vault"></p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2UtY2kub3JnLw==">Concourse CI<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmNvdXJzZS9jb25jb3Vyc2U=">Concourse - GitHub<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cHM6Ly9jb25jb3Vyc2V0dXRvcmlhbC5jb20v">Concourse Tutorial<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>concourse</tag>
        <tag>concourse-ci</tag>
        <tag>vault</tag>
      </tags>
  </entry>
  <entry>
    <title>为 webapp 设定单独的 context.xml</title>
    <url>/customize-context-xml-for-individual-webapp.html</url>
    <content><![CDATA[<p>要给某个 webapp 设定单独的 <code>context.xml</code>，只需要在 <code>${WEBAPP_ROOT}/webapp</code> 目录下新建一个 <code>META-INF</code> 目录，并将 <code>context.xml</code> 放进去，就可以了。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>设计并实现一个简易的短 URL 服务</title>
    <url>/designing-and-implementing-a-short-url-service.html</url>
    <content><![CDATA[<p>突然就对短链接服务的原理来了兴趣，于是就查了些资料，自己实现了一个很简陋的演示性的短链接服务。</p>
<span id="more"></span>

<h2 id="短链接服务是怎么工作的"><a href="#短链接服务是怎么工作的" class="headerlink" title="短链接服务是怎么工作的"></a>短链接服务是怎么工作的</h2><p>短链接服务这玩意，说来其实非常简单，就是给用户传来的 URL 起个别名，然后把别名与原链接的映射关系记录在数据库里。</p>
<p>用户访问短链接时，请求首先会到短链接服务的服务器；短链接服务端收到请求，取出对应的原 URL，最后通知用户端的浏览器做个跳转。</p>
<h2 id="301跳转？还是302跳转？"><a href="#301跳转？还是302跳转？" class="headerlink" title="301跳转？还是302跳转？"></a>301 跳转？还是 302 跳转？</h2><p>尽管按照语义来讲，301 跳转更合适，因为一个短 URL 必定只对应一个长 URL，但是看起来生产上更多使用 302 跳转，因为这样的话请求会经过短网址提供商的服务器，短网址提供商就可以收集到用户的一些信息，然后把这些信息变现。</p>
<h2 id="如何生成短链接"><a href="#如何生成短链接" class="headerlink" title="如何生成短链接"></a>如何生成短链接</h2><p>上面说到，短链接服务的核心就是要给长链接生成一个 “别名”，那么这个别名应该怎么生成呢？</p>
<p>我相信不少人一上来就会想到哈希算法，比如给原 URL 做个 MD5，虽然不是不行，就是哈希算法有碰撞这么个问题，虽然影响不大吧，但处理起来还是个麻烦。</p>
<p>上网一顿冲浪，我发现其实这个生成的算法非常简单，就是直接用发号器生成一个 ID，把这个 ID 跟原链接绑定就行。足够简单，而且不会碰撞。</p>
<p>不过既然都提到这两种算法了，不如顺便介绍一下。</p>
<h3 id="发号器方案"><a href="#发号器方案" class="headerlink" title="发号器方案"></a>发号器方案</h3><p>发号器方案本质上就是生成分布式 ID，如果要简单处理，那么可以使用 <code>Redis</code> 的 <code>incr</code> 操作，或者取数据库的自增序列；复杂情况的话，可以让数据库集群中每个节点各负责生成某一范围的数字，或者使用雪花算法等 UUID 生成算法。</p>
<p>在得到发号器生成的数字之后，再将其转换为 62 进制数，就可以当成短 URL 的 ID 了。这么做的原因，一方面是可以一定程度上防止直接暴露序列的值产生的安全问题；另一方面，因为为了保证序列够用，发号器返回的数字会比较大，将低进制数转换为高进制数可以显著减少字符数量。</p>
<h3 id="哈希算法方案"><a href="#哈希算法方案" class="headerlink" title="哈希算法方案"></a>哈希算法方案</h3><blockquote>
<ol>
<li>将长网址 md5 生成 32 位签名串，分为 4 段，每段 8 个字节</li>
<li>对这四段循环处理，取 8 个字节，将他看成 16 进制串与 0x3fffffff (30 位 1) 与操作，即超过 30 位的忽略处理</li>
<li>这 30 位分成 6 段，每 5 位的数字作为字母表的索引取得特定字符，依次进行获得 6 位字符串</li>
<li>总的 md5 串可以获得 4 个 6 位串，取里面的任意一个就可作为这个长 url 的短 url 地址</li>
</ol>
<p>摘自 <span class="exturl" data-url="aHR0cHM6Ly9odWZhbmd5dW4uY29tLzIwMTcvc2hvcnQtdXJsLw==">短网址 (short URL) 系统的原理及其实现<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>解决了理论问题，接下来就要面对现实问题：用什么实现，和跑在哪里。</p>
<p>因为这只是一个演示性的短链接服务，目前定位是就我一个人玩，所以我一方面不想花时间在部署和维护上，另一方面也想趁机玩点没玩过的东西。所以我决定把这玩意放在 <code>CloudFlare Workers</code> 上面，用 <code>TypeScript</code> 语言开发，数据存放在 <code>CloudFlare Workers KV</code> 数据库里。这样，我就只需要关心代码怎么写，其他的包括维护数据库、估算服务器压力这些事都不用担心。</p>
<p>数据库中我需要用两个表，一个表用来存放当前的序列值，和<code>短URL -&gt; 原URL</code> 的映射，这个表是服务的核心；另一个表用来存放<code>长URL -&gt; 短URL</code> 的映射，这么设计的原因是，针对相同的长 URL，我不需要在生成新的短 URL，既节省空间，也能稍微节省点能源不是。</p>
<p>而生成短链接的算法，我当然选择最简单的数据库序列。但因为 <code>CloudFlare Workers KV</code> 并不支持真正的序列，所以我在数据库里面用一个专门的 key 当作序列来用。这个选型有一个风险就是，在高并发状态下我无法保证序列的值不会重复，因为<code>取出序列 -- 生成ID -- 保存新的序列</code>这个操作不是原子性的，高并发状态下可能会有多个请求同时取到相同的序列，进而生成相同的 ID，最后就会产生错误的结果。不过，还是那句话，就我一个人用的玩意，暂时先不考虑那么多。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>这个服务的流程分两大部分，生成新的短 URL，和查询短 URL 并完成跳转。查询操作没什么梗，查到了就返回，查不到就 404 呗。</p>
<p>生成新的短 URL 的话，大致就是这么个流程：</p>
<pre><code class="highlight mermaid">graph TD;
    start[开始];
    finish[结束];
    request_received[收到生成的请求];
    check_existing_record{检查是否已经生成过};
    return_existing_record[返回已有的短URL];
    fetch_current_sequence[查询当前的序列];
    calculate_base62[计算序列的62进制数值];
    increase_sequence_number[序列增1];
    save_to_database[将短URL和新的序列存入数据库];
    return_new_generated_short_url[返回生成的短URL];
    
    start --&gt; request_received;
    request_received --&gt; check_existing_record;

    check_existing_record --&gt;|Y| return_existing_record;
    return_existing_record --&gt; finish;

    check_existing_record --&gt;|N| fetch_current_sequence;
    fetch_current_sequence --&gt; calculate_base62;
    calculate_base62 --&gt; increase_sequence_number;
    increase_sequence_number --&gt; save_to_database;
    save_to_database --&gt; return_new_generated_short_url;
    return_new_generated_short_url --&gt; finish;</code></pre>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里就只放具体实现相关的代码了，完整的代码库可以到参考文档第一条的 GitHub 仓库看到。</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> url <span class="keyword">from</span> <span class="string">'url'</span>;</span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">RequestBody</span>, <span class="title class_">ResponseBody</span>, <span class="title class_">ShortUrl</span> } <span class="keyword">from</span> <span class="string">'./model'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起始的序列值</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">INITIAL_SEQUENCE_NUMBER</span> = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Env</span> {</span><br><span class="line">    [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">fetch</span>(</span><br><span class="line">        <span class="attr">request</span>: <span class="title class_">Request</span>,</span><br><span class="line">        <span class="attr">env</span>: <span class="title class_">Env</span>,</span><br><span class="line">        <span class="attr">ctx</span>: <span class="title class_">ExecutionContext</span></span><br><span class="line">    ): <span class="title class_">Promise</span>&lt;<span class="title class_">Response</span>&gt; {</span><br><span class="line">        <span class="keyword">switch</span> (request.<span class="property">method</span>) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'POST'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">handlePostRequest</span>(request, env);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'GET'</span>:</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">handleGetRequest</span>(request, env);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleGetRequest</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: Request,</span></span><br><span class="line"><span class="params">    env: Env</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Response</span>&gt; {</span><br><span class="line">    <span class="comment">// 取URL中的path部分</span></span><br><span class="line">    <span class="keyword">let</span> url_parts = url.<span class="title function_">parse</span>(request.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">let</span> path = url_parts.<span class="property">pathname</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有path部分，或者path有多层</span></span><br><span class="line">    <span class="comment">// 那么视为无效请求</span></span><br><span class="line">    <span class="comment">// 合法的短URL格式为：https://mydomain.com/RlB2PdD</span></span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">null</span> || path.<span class="title function_">split</span>(<span class="regexp">/\/(?=.)/</span>).<span class="property">length</span> !== <span class="number">2</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">"No short URL key provided or invalid path. Returning 400"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">"No short URL key provided or the path is invalid."</span>, {</span><br><span class="line">            <span class="attr">status</span>: <span class="number">400</span></span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pathParts = path?.<span class="title function_">split</span>(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 专门处理下favicon.ico的请求</span></span><br><span class="line">    <span class="comment">// 可能是我的实现有问题，不一定必须</span></span><br><span class="line">    <span class="keyword">if</span> (pathParts[<span class="number">1</span>] === <span class="string">"favicon.ico"</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出path，即短URL的key</span></span><br><span class="line">    <span class="keyword">let</span> key = pathParts[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">`Looking for the target URL with key <span class="subst">${key}</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对env.SHORT_URL操作，就是对SHORT_URL这个KV数据库做操作</span></span><br><span class="line">    <span class="comment">// 这里就是从数据库中查询这个key对应的长URL</span></span><br><span class="line">    <span class="keyword">let</span> shortUrlJson = <span class="keyword">await</span> env.<span class="property">SHORT_URL</span>.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (shortUrlJson === <span class="literal">null</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">`No target URL found for key <span class="subst">${key}</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">"No target URL found"</span>, {</span><br><span class="line">            <span class="attr">status</span>: <span class="number">404</span></span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造返回的JSON，然后返回一个HTTP 302让浏览器跳转</span></span><br><span class="line">    <span class="keyword">let</span> shortUrlObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(shortUrlJson) <span class="keyword">as</span> <span class="title class_">ShortUrl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">`Target URL for key <span class="subst">${key}</span> is <span class="subst">${shortUrlObject.url}</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Response</span>.<span class="title function_">redirect</span>(shortUrlObject.<span class="property">url</span>, <span class="number">302</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handlePostRequest</span>(<span class="params"></span></span><br><span class="line"><span class="params">    request: Request,</span></span><br><span class="line"><span class="params">    env: Env</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Response</span>&gt; {</span><br><span class="line">    <span class="keyword">let</span> requestBody = <span class="keyword">await</span> request.<span class="title function_">json</span>() <span class="keyword">as</span> <span class="title class_">RequestBody</span>;</span><br><span class="line">    <span class="keyword">let</span> targetUrl = requestBody.<span class="property">url</span>!;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">`Creating a short URL for target <span class="subst">${targetUrl}</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询这个长URL是否已经有对应的短URL</span></span><br><span class="line">    <span class="comment">// SHORT_URL_MAPPING表记录的是长URL对应的短URL</span></span><br><span class="line">    <span class="keyword">let</span> existingShortUrl = <span class="keyword">await</span> env.<span class="property">SHORT_URL_MAPPING</span>.<span class="title function_">get</span>(targetUrl) <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">if</span> (existingShortUrl !== <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 查到了，就直接返回</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">`Existing short URL key <span class="subst">${existingShortUrl}</span> found for <span class="subst">${targetUrl}</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> responseBody = <span class="keyword">new</span> <span class="title class_">ResponseBody</span>(existingShortUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(</span><br><span class="line">            <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(responseBody),</span><br><span class="line">            {</span><br><span class="line">                <span class="attr">status</span>: <span class="number">201</span>,</span><br><span class="line">                <span class="attr">headers</span>: {</span><br><span class="line">                    <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出当前的序列值，将其转换为62进制，作为短URL的key</span></span><br><span class="line">    <span class="keyword">let</span> curentSequence = <span class="keyword">await</span> <span class="title function_">getCurrentSequence</span>(env);</span><br><span class="line">    <span class="keyword">let</span> key = <span class="title function_">string10to62</span>(curentSequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">new</span> <span class="title class_">ShortUrl</span>(targetUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存短URL，更新序列</span></span><br><span class="line">    <span class="keyword">await</span> env.<span class="property">SHORT_URL</span>.<span class="title function_">put</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">    <span class="keyword">await</span> env.<span class="property">SHORT_URL_MAPPING</span>.<span class="title function_">put</span>(targetUrl, key);</span><br><span class="line">    <span class="keyword">await</span> env.<span class="property">SHORT_URL</span>.<span class="title function_">put</span>(<span class="string">"sequence"</span>, <span class="string">`<span class="subst">${++curentSequence}</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">`Created a new short URL key <span class="subst">${key}</span> for <span class="subst">${targetUrl}</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回生成的结果</span></span><br><span class="line">    <span class="keyword">let</span> responseBody = <span class="keyword">new</span> <span class="title class_">ResponseBody</span>(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(responseBody),</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">status</span>: <span class="number">201</span>,</span><br><span class="line">            <span class="attr">headers</span>: {</span><br><span class="line">                <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出当前的序列值，如果数据库中未初始化，</span></span><br><span class="line"><span class="comment"> * 那么就将初始序列写入数据库，然后返回初始序列。</span></span><br><span class="line"><span class="comment"> * 这个方法不涉及序列的更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getCurrentSequence</span>(<span class="params">env: Env</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; {</span><br><span class="line">    <span class="keyword">let</span> currentSequence = <span class="keyword">await</span> env.<span class="property">SHORT_URL</span>.<span class="title function_">get</span>(<span class="string">"sequence"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentSequence === <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">await</span> env.<span class="property">SHORT_URL</span>.<span class="title function_">put</span>(<span class="string">"sequence"</span>, <span class="string">`<span class="subst">${INITIAL_SEQUENCE_NUMBER}</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable constant_">INITIAL_SEQUENCE_NUMBER</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentSequence;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将10进制数转换为62进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">string10to62</span>(<span class="params"><span class="built_in">number</span>: <span class="built_in">number</span></span>) {</span><br><span class="line">    <span class="keyword">var</span> chars = <span class="string">'0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ'</span>.<span class="title function_">split</span>(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">var</span> radix = chars.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> qutient = +<span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">let</span> mod = qutient % radix;</span><br><span class="line">        qutient = (qutient - mod) / radix;</span><br><span class="line">        arr.<span class="title function_">unshift</span>(chars[mod]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (qutient);</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">''</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="一些改进空间"><a href="#一些改进空间" class="headerlink" title="一些改进空间"></a>一些改进空间</h2><p>因为针对相同的长 URL 并不需要每次都返回相同的短 URL，所以<code>长URL -&gt; 短URL</code> 表中，我可以给每条记录都加一个 TTL，在有效期内，每次针对相同的长 URL 的生成请求都会返回同一个短 URL，同时刷新 TTL；而超过有效期后，这条映射就会被删除，对应的长 URL 则会生成新的短 URL。这样一定程度上既可以防止恶意刷接口炸数据库，同时也可以清除掉不太可能再被用到的数据。</p>
<p>而在如上改动的影响下，必然会出现多个短 URL 对应同一个长 URL 的情况，这多少也是浪费了一些空间。所以我感觉可以在<code>短URL -&gt; 长URL</code> 映射表中，增加一个最后访问时间字段，每有一个短 URL 的请求，就更新这个时间到请求的时间。再启动一个定时任务，定时扫描每个短链接的最后访问时间，并将在指定时间（如半年）内没有被访问过的短链接删除。（我觉得，应该没有人把短链接当成永久链接吧？就算不考虑被删，万一服务商跑路了呢？</p>
<p>此外，还可以给<code>短URL -&gt; 长URL</code> 映射表中再增加一个访问次数字段，以便结合其他收集到的数据来做分析。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My9jZi13b3JrZXItc2hvcnQtdXJs">cf-worker-short-url - GitHub<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGlubGluaXNtaW5lL3AvOTUyMzA5NS5odG1s">短网址服务 (TinyURL) 生成算法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI5MjcwMDM0L2Fuc3dlci80NjQ0NjkxMQ==">短 URL 系统是怎么设计的？ - iammutex 的回答 - 知乎<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9odWZhbmd5dW4uY29tLzIwMTcvc2hvcnQtdXJsLw==">短网址 (short URL) 系统的原理及其实现<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>短链接</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭 Vercel 的部署结果通知</title>
    <url>/disable-vercel-deployment-notification.html</url>
    <content><![CDATA[<p>每次 Vercel 部署之后，它都会在部署的 commit 下面发个类似这样的留言：</p>
<blockquote>
<p>Successfully deployed to the following URLs:</p>
<h2 id="blog-–-x2F"><a href="#blog-–-x2F" class="headerlink" title="blog – ./"></a>blog – ./</h2><hr>
<p>blog-boris1993.vercel.app</p>
<p>boris1993.com</p>
<p><a href="http://www.boris1993.com/">www.boris1993.com</a></p>
</blockquote>
<p>而且 GitHub 还会给我发邮件通知这个留言的内容，但是这个消息说实话没啥用，白白麻烦人而已，后来发现，在项目根目录创建一个名为 <code>vercel.json</code> 的文件，里面写上这样的配置就行：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"github"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"silent"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个配置的作用就是让 Vercel 不再往这个 repo 的 commit 下面评论部署状态。提交之后，Vercel 就会在这次部署开始遵循 <code>vercel.json</code> 的设定，不会再发送评论，自然也就不会有那封 “骚扰邮件” 了。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Vercel</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter 与 interceptor 的区别</title>
    <url>/filter-vs-interceptor.html</url>
    <content><![CDATA[<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><ul>
<li><code>Filter</code> 是 <code>Servlet</code> 规范制定的，受 <code>Servlet</code> 容器支持，接口定义在 <code>javax.servlet</code> 包中。</li>
<li><code>Filter</code> 是被 Web Server（如 <code>Tomcat</code>）调用。</li>
<li><code>Filter</code> 需要在 <code>web.xml</code> 中定义之后才会起作用。</li>
<li><code>Filter</code> 只在请求的前后起作用，<code>Servlet</code> 对于 <code>Filter</code> 来说是一个黑盒。</li>
<li><code>Filter</code> 的执行顺序是：<ul>
<li><code>void init(FilterConfig)</code> - 容器在初始化 <code>Filter</code> 时调用，在 <code>Filter</code> 生命周期内仅会被调用一次。方法可以抛出 <code>ServletException</code>。</li>
<li><code>doFilter(ServletRequest, ServletResponse, FilterChain)</code> - Web 容器每一次请求都会调用该方法。该方法将容器的请求和响应作为参数传递进来， <code>FilterChain</code> 用来调用下一个 <code>Filter</code>。</li>
<li><code>void destroy()</code> - 当容器销毁 Filter 实例时调用该方法，可以在方法中销毁资源，该方法在 Filter 的生命周期只会被调用一次。</li>
</ul>
</li>
</ul>
<h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><ul>
<li><code>Interceptor</code> 是 <code>Spring</code> 容器内的，由 <code>Spring</code> 框架提供支持。接口 <code>HandlerInterceptor</code> 定义在 <code>org.springframework.web.servlet</code> 包中。</li>
<li><code>Interceptor</code> 是被 <code>Spring</code> 调用。</li>
<li><code>Interceptor</code> 可以深入到方法前后、异常抛出前后等，比起 <code>Filter</code> 有更大的弹性。</li>
<li><code>Interceptor</code> 还允许用户介入请求的生命周期，可以在请求过程中获取信息，通常与请求更加耦合。</li>
<li><code>Interceptor</code> 的执行顺序是：<ul>
<li>请求到达 <code>DispatcherServlet</code></li>
<li><code>DispatcherServlet</code> 将请求发送至 <code>Interceptor</code>，<code>Interceptor</code> 执行 <code>preHandle()</code> 方法</li>
<li>请求到达 <code>Controller</code></li>
<li>请求结束后，<code>Interceptor</code> 执行 <code>postHandle()</code> 方法</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9laW52ZXJuZS5naXRodWIuaW8vcG9zdC8yMDE3LzA4L3NwcmluZy1pbnRlcmNlcHRvci12cy1maWx0ZXIuaHRtbA==">Spring Interceptor vs Filter 拦截器和过滤器区别<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODI4OTcwNTUzMzU4">Spring Interceptor vs Filter - 掘金<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lY2xpcHNlLWVlNGouZ2l0aHViLmlvL2plcnNleS5naXRodWIuaW8vZG9jdW1lbnRhdGlvbi9sYXRlc3QvZmlsdGVycy1hbmQtaW50ZXJjZXB0b3JzLmh0bWw=">Chapter 10. Filters and Interceptors - Jersey 2.37 User Guide<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Spring MVC</tag>
        <tag>Filter</tag>
        <tag>Interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭 IPv6 或调整 IPv6 优先级以解决微软模拟飞行更新下载过慢的问题</title>
    <url>/fixing-downloading-too-slow-msfs-2020.html</url>
    <content><![CDATA[<blockquote>
<p>太长不看：关闭 IPv6 或许可以解决。如果你平时要用到 IPv6，那就在更新之前先禁用 IPv6，更新完了再打开；如果开不开 IPv6 对你来说没区别的话，那永久关闭也不是不可以。当然如果你愿意，下文提到的改注册表的方案也是可用的。</p>
</blockquote>
<hr>
<p>这两天在给微软模拟飞行下载更新的时候，就算挂着网易 UU，速度也一直很慢，时常在 0.5MB/s~5MB/s 之间波动，不论怎么换节点也不能跑出正常的速度。今天经过一顿上网冲浪，发现这个问题的根源，在 IPv6。</p>
<p><del>其实网上针对这个问题已经有一些解决方案了，但内容看下来都一样，不外乎教你怎么关掉 IPv6。但我一方面要用到 IPv6，另一方面也不想那么粗暴的解决问题，所以又稍微做了点研究，顺便写了个小工具方便其他有这个问题的玩家。</del> 经过一段时间的试用后发现，临时 / 永久关闭 IPv6 实际上是最优雅的方案……</p>
<span id="more"></span>

<p>起先为了测试，我先禁用了 IPv6，然后开启网易 UU 并开始更新微软模拟飞行，结果很符合预期，下载速度达到了 150MB/s，那么可以确定，IPv6 就是这个问题的元凶。</p>
<p>解决这个问题的突破点，在微软的这篇文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vdHJvdWJsZXNob290L3dpbmRvd3Mtc2VydmVyL25ldHdvcmtpbmcvY29uZmlndXJlLWlwdjYtaW4td2luZG93cw==">为高级用户配置 Windows IPv6 的指南<i class="fa fa-external-link-alt"></i></span>，里面提到我可以设定首选 IPv4 还是 IPv6，于是我就在保留 IPv6 启动的同时，看了眼注册表里 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters</code> 路径下的 <code>DisabledComponents</code> 这个键，它的值转换成二进制是 <code>0000 1000</code>，也就是说，目前我是首选使用 IPv6 进行连接的。</p>
<p>那么，根据文档中的计算方法，我把第 5 个位改成了 1，也就是改成了 <code>0010 1000</code>，然后重启电脑，再挂上加速器并开始更新，这次果然速度也提升到了 150MB/s，说明这个修改有效了。</p>
<p>顺便我又到<span class="exturl" data-url="aHR0cHM6Ly90ZXN0LWlwdjYuY29tLw=="> https://test-ipv6.com/<i class="fa fa-external-link-alt"></i></span>测试了一下，结果是<code>你已经有 IPv6 地址了，但你的浏览器不太愿意用</code>，那么可以确定，我现在仍然可以使用 IPv6，但默认情况下系统将优先使用 IPv4。</p>
<p>考虑到其他玩家可能也有类似的困扰，我顺手写了一个小工具来做这件事，代码开源在 GitHub。你们可以到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvcmlzMTk5My9pcHY2X3ByZWZlcmVuY2VfdG9nZ2xlci9yZWxlYXNlcy9sYXRlc3Q="> Releases<i class="fa fa-external-link-alt"></i></span>下载我编译好的版本。如果你访问 GitHub 有困难，也可以到<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vYm9yaXMxOTkzL2lwdjZfcHJlZmVyZW5jZV90b2dnbGVyL3JlbGVhc2Vz"> GitEE 的发行版<i class="fa fa-external-link-alt"></i></span>中下载，它们是一样的。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>微软模拟飞行</tag>
        <tag>微软模拟飞行更新慢</tag>
        <tag>微软模拟飞行下载慢</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 FlatMap “展平” 一系列数据</title>
    <url>/flatten-a-group-of-data-by-flatmap.html</url>
    <content><![CDATA[<p>在处理业务数据时，偶尔会需要从一系列逗号分隔的数据中取出各个元素并去重。本文将介绍如何通过 Java 8 中的 <code>FlatMap</code> 简化这个操作。</p>
<span id="more"></span>

<h2 id="介绍需求"><a href="#介绍需求" class="headerlink" title="介绍需求"></a>介绍需求</h2><p>假设现在有这样子的一个排班信息：</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>班组</th>
</tr>
</thead>
<tbody><tr>
<td> 2019-01-02</td>
<td>Unit-2, Unit-3</td>
</tr>
<tr>
<td>2019-01-03</td>
<td>Unit-2</td>
</tr>
<tr>
<td>2019-01-04</td>
<td>Unit-1, Unit-3</td>
</tr>
<tr>
<td>2019-01-01</td>
<td>Unit-2, Unit-3</td>
</tr>
<tr>
<td>2019-01-05</td>
<td>Unit-3</td>
</tr>
<tr>
<td>2019-01-06</td>
<td>Unit-1, Unit-2</td>
</tr>
<tr>
<td>2019-01-07</td>
<td>Unit-1</td>
</tr>
<tr>
<td>2019-01-08</td>
<td>Unit-2, Unit-3</td>
</tr>
</tbody></table>
<p>而目标是，从中取出这个表中的所有班组，并去重和排序，即最终的结果是 <code>Unit-1, Unit-2, Unit-3</code>。</p>
<h2 id="准备示例数据"><a href="#准备示例数据" class="headerlink" title="准备示例数据"></a>准备示例数据</h2><p>在代码中，我们这样来构造这些数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 准备假数据</span></span><br><span class="line"><span class="type">WorkSchedule</span> <span class="variable">workSchedule1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkSchedule</span>(<span class="string">"2019-01-01"</span>, <span class="string">"Unit-2, Unit-3"</span>);</span><br><span class="line"><span class="type">WorkSchedule</span> <span class="variable">workSchedule2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkSchedule</span>(<span class="string">"2019-01-02"</span>, <span class="string">"Unit-2"</span>);</span><br><span class="line"><span class="type">WorkSchedule</span> <span class="variable">workSchedule3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkSchedule</span>(<span class="string">"2019-01-03"</span>, <span class="string">"Unit-1, Unit-3"</span>);</span><br><span class="line"><span class="type">WorkSchedule</span> <span class="variable">workSchedule4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkSchedule</span>(<span class="string">"2019-01-04"</span>, <span class="string">"Unit-2, Unit-3"</span>);</span><br><span class="line"><span class="type">WorkSchedule</span> <span class="variable">workSchedule5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkSchedule</span>(<span class="string">"2019-01-05"</span>, <span class="string">"Unit-3"</span>);</span><br><span class="line"><span class="type">WorkSchedule</span> <span class="variable">workSchedule6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkSchedule</span>(<span class="string">"2019-01-06"</span>, <span class="string">"Unit-1, Unit-2"</span>);</span><br><span class="line"><span class="type">WorkSchedule</span> <span class="variable">workSchedule7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkSchedule</span>(<span class="string">"2019-01-07"</span>, <span class="string">"Unit-1"</span>);</span><br><span class="line"><span class="type">WorkSchedule</span> <span class="variable">workSchedule8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkSchedule</span>(<span class="string">"2019-01-08"</span>, <span class="string">"Unit-2, Unit-3"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;WorkSchedule&gt; workSchedules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">workSchedules.add(workSchedule1);</span><br><span class="line">workSchedules.add(workSchedule2);</span><br><span class="line">workSchedules.add(workSchedule3);</span><br><span class="line">workSchedules.add(workSchedule4);</span><br><span class="line">workSchedules.add(workSchedule5);</span><br><span class="line">workSchedules.add(workSchedule6);</span><br><span class="line">workSchedules.add(workSchedule7);</span><br><span class="line">workSchedules.add(workSchedule8);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="不使用流的做法"><a href="#不使用流的做法" class="headerlink" title="不使用流的做法"></a>不使用流的做法</h2><p>如果不使用流，那么我们可以通过 <code>for</code> 循环取数据，和使用 <code>TreeSet</code> 实现去重和排序。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; unitNames = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (WorkSchedule workSchedule : workSchedules) {</span><br><span class="line">    String[] arrUnitName = workSchedule.getUnits().split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String unitName : arrUnitName) {</span><br><span class="line">        unitNames.add(unitName.trim());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="使用流的做法"><a href="#使用流的做法" class="headerlink" title="使用流的做法"></a>使用流的做法</h2><p>如果使用流，则可以这样做：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;String&gt; units = workSchedules.stream()</span><br><span class="line">        <span class="comment">// 根据逗号，将班组名拆分成 String[]</span></span><br><span class="line">        <span class="comment">// 这一步将生成8个新的 String[] 对象</span></span><br><span class="line">        .map(i -&gt; i.getUnits().split(<span class="string">","</span>))</span><br><span class="line">        <span class="comment">// 从上面的 String[] 生成一个新的</span></span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        <span class="comment">// 切掉每个元素两端的空格</span></span><br><span class="line">        .map(String::trim)</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        .distinct()</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        .sorted()</span><br><span class="line">        <span class="comment">// 收集到一个List中</span></span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></tbody></table></figure>

<p>如果上面代码的注释还是无法让您理解，那么，我还准备了每一步流操作的示意图。(感谢 <code>Intellij IDEA</code> 提供了这个强大的功能)</p>
<p>首先，在 <code>map</code> 方法中，<code>List</code> 的每个元素都会根据逗号分隔，并生成一个 <code>String[]</code> 对象。</p>
<p><img data-src="https://blog-static.boris1993.com/flatten-a-group-of-data-by-flatmap/0-split.png" alt="Split"></p>
<p><code>flatmap</code> 方法会将上面 <code>map</code> 方法返回的各个流 “拼接” 成为一个流，即 “展平”。</p>
<p><img data-src="https://blog-static.boris1993.com/flatten-a-group-of-data-by-flatmap/1-flatmap.png" alt="FlatMap"></p>
<p>接下来继续使用 <code>map</code> 方法，对流中的每个元素进行 <code>trim</code> 操作。</p>
<p><img data-src="https://blog-static.boris1993.com/flatten-a-group-of-data-by-flatmap/2-trim.png" alt="Trim"></p>
<p>然后调用 <code>distinct</code> 和 <code>sorted</code> 方法实现去重和排序。</p>
<p><img data-src="https://blog-static.boris1993.com/flatten-a-group-of-data-by-flatmap/3-distinct.png" alt="Distinct"><br><img data-src="https://blog-static.boris1993.com/flatten-a-group-of-data-by-flatmap/4-sort.png" alt="Sort"></p>
<p>最后，使用 <code>collect</code> 方法，将流中的数据 “收集” 到一个 <code>List</code> 中。</p>
<p><img data-src="https://blog-static.boris1993.com/flatten-a-group-of-data-by-flatmap/5-collect.png" alt="Collect"></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码技巧</tag>
        <tag>FlatMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd 和 Brent 判圈算法</title>
    <url>/floyd-and-brent-cycle-detection-algorithm.html</url>
    <content><![CDATA[<p>今天刷<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUvZGVzY3JpcHRpb24v"> 141. Linked List Cycle<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkvZGVzY3JpcHRpb24v"> 142. Linked List Cycle II<i class="fa fa-external-link-alt"></i></span>学到了两个新的判断链表是否存在环的算法 - <code>Floyd龟兔赛跑算法</code>和 <code>Brent判圈算法</code>。</p>
<span id="more"></span>

<h2 id="Floyd龟兔赛跑算法"><a href="#Floyd龟兔赛跑算法" class="headerlink" title="Floyd龟兔赛跑算法"></a>Floyd 龟兔赛跑算法</h2><p>这个算法的核心思想是，如果有限状态机、迭代函数或者链表上存在环，那么在某个环上以不同速度前进的两个指针必定在某个时间会相遇。也就是说，对于一个链表，可以分别使用两个指针进行遍历，慢指针一次走一步，快指针一次走两步，如果快慢指针相遇了，那么说明链表中存在环。</p>
<p>当发现有环之后，让快指针停止，慢指针从当前位置继续向前遍历，并计算走过的步数。在慢指针与快指针再次相遇之后，慢指针走过的步数，就是环的长度。</p>
<p>如果要计算环的入口，那么可以将一个指针移动到链表的起点，另一个指针不动，然后使两个指针每次同时向前走一步，当二者再次相遇的时候，指针所在的位置就是环的起点。至于这个操作的原理，原谅我数学很差，想不明白，所以借<span class="exturl" data-url="aHR0cHM6Ly94eXpnaGlvLnh5ei9DeWNsZURldGVjdGlvbi8=">浅谈判圈算法 - xyZGHio<i class="fa fa-external-link-alt"></i></span>一文中的解释：</p>
<blockquote>
<p>这里令起始处为 A、环的入口处为 B，在判断是否有环阶段时快慢相遇之处为 C。并记 AB 长度为 a、记 BC 长度为 b、环的长度为 r。且在判断是否有环过程中，快指针每次走 2 步、慢指针每次走 1 步。则快、慢指针相遇时，快指针走过的长度是慢指针走过长度的 2 倍。<br><img data-src="https://blog-static.boris1993.com/floyd-and-brent-cycle-detection-algorithm/floyd-find-cycle-entry.jpg"><br>此时不难看出，当快、慢指针相遇时，快、慢指针走过的长度均是环长度的整数倍。故如果期望找到环的入口位置，即 B 处。则只需在两个指针相遇之时，将其中任意一个指针放置到起始处 A，而另一个指针依然位于相遇处 C。然后两个指针按照每次均走 1 步的速度向前走，当二者再次相遇之时，即是 B 处。<br>原因在于，对于相遇后继续往前走的指针而言，由于其已经走过了若干圈环的长度，此时只需再走 a 步即可到达环的入口。这个地方换个角度想会更容易理解，如果该指针先走 a 步再走若干圈环的长度，其必然位于环的入口处；而对于相遇后从起始处 A 开始走的指针而言，其显然走 a 步后，必然也会位于环的入口处。故此时两个指针第二次相遇之时，说明他们均已经走完 a 步。即到达环的入口处。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/linked-list-cycle-ii</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找环的入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">intersect</span> <span class="operator">=</span> getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ptr1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ptr2</span> <span class="operator">=</span> intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) {</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找快慢两个指针交会的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">getIntersect</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) {</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) {</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Brent判环算法"><a href="#Brent判环算法" class="headerlink" title="Brent判环算法"></a>Brent 判环算法</h2><p>Brent 算法跟 Floyd 算法比较起来，其优点是缩短了判断是否有环的耗时（根据 Wikipedia 的说法，Brent 算法的平均耗时比 Floyd 算法少 36%），但是这个算法无法找到环的入口。</p>
<p>这个算法同样会使用快和慢两个指针，判断是否有环的依据仍然是看两个指针是否会相遇，但是快指针和慢指针的走法与 Floyd 算法不同。这个算法中，快指针每一次会向前 2n 步（n 为从 1 开始算起的回合数），即第一回合快指针走 2 步，第二回合走 4 步，以此类推。回合结束后，慢指针直接传送到快指针所在的位置。在每个回合的快指针移动过程中判断快指针是否与慢指针交会，如果交会，那么就判定存在环。</p>
<p>代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/linked-list-cycle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前回合快指针已走的步数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stepsMovedByFast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前回合快指针最多能走的步数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stepLimitForFast</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) {</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            stepsMovedByFast++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果快指针往前走的时候与慢指针相会</span></span><br><span class="line">            <span class="comment">// 那就说明链表中存在环</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 快指针走完了能走的步数，即回合结束</span></span><br><span class="line">            <span class="keyword">if</span> (stepsMovedByFast == stepLimitForFast) {</span><br><span class="line">                <span class="comment">// 快指针在下一回合能走的步数翻倍</span></span><br><span class="line">                stepLimitForFast *= <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 清零计步器</span></span><br><span class="line">                stepsMovedByFast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 慢指针传送到快指针所在的位置</span></span><br><span class="line">                slow = fast;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另外讲一个趣闻：这个算法还有个名字叫 <code>The Teleporting Turtle（会传送的乌龟）</code>，因为套用 Floyd 龟兔赛跑算法的概念，把快指针看作兔子，慢指针看作乌龟的话，那么乌龟是靠传送而不是行走前进的。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>判圈算法</tag>
        <tag>Floyd判圈算法</tag>
        <tag>Brent判圈算法</tag>
        <tag>龟兔赛跑算法</tag>
        <tag>The Teleporting Turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Google Cloud Logging 的日志输出中增加类名、方法名和行数</title>
    <url>/gcp-logging-show-class-and-method-name.html</url>
    <content><![CDATA[<p>由于我司目前的项目都运行在 Google Cloud Platform (以下简称 GCP) 上，那么自然而然的，我们选择了使用 GCP 的 Logging 来查看日志。在使用过程中，我们发现了一个问题，那就是我们无法直观的看到日志是从什么地方打印出来的，经常需要通过日志内容，在代码里面通过全文搜索来定位。这样就产生了一个需求：可不可以把这条日志所在的类、方法，和行数一起打印在日志中？</p>
<span id="more"></span>

<h2 id="日志是怎么生成的"><a href="#日志是怎么生成的" class="headerlink" title="日志是怎么生成的"></a>日志是怎么生成的</h2><p>既然要实现自动化地修改日志的内容，那么我们首先得要知道，日志的内容是怎么产生的。根据我们的 <code>logback-spring.xml</code> 中的配置，我们可以定位到，日志是从 <code>StackdriverJsonLayout</code> 这个类中生成出来的。</p>
<p>打开这个文件，阅读源码，发现有一个名为 <code>toJsonMap</code> 的方法很像我们这次的目标，为了大家省事，我从 GitHub 上把这段源码拿到了这里。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert a logging event into a Map.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the logging event</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map which should get rendered as JSON</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title function_">toJsonMap</span><span class="params">(ILoggingEvent event)</span> {</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includeMDC) {</span><br><span class="line">        event.getMDCPropertyMap().forEach((key, value) -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (!FILTERED_MDC_FIELDS.contains(key)) {</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includeTimestamp) {</span><br><span class="line">        map.put(StackdriverTraceConstants.TIMESTAMP_SECONDS_ATTRIBUTE,</span><br><span class="line">                TimeUnit.MILLISECONDS.toSeconds(event.getTimeStamp()));</span><br><span class="line">        map.put(StackdriverTraceConstants.TIMESTAMP_NANOS_ATTRIBUTE,</span><br><span class="line">                TimeUnit.MILLISECONDS.toNanos(event.getTimeStamp() % <span class="number">1_000</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    add(StackdriverTraceConstants.SEVERITY_ATTRIBUTE, <span class="built_in">this</span>.includeLevel,</span><br><span class="line">            String.valueOf(event.getLevel()), map);</span><br><span class="line">    add(JsonLayout.THREAD_ATTR_NAME, <span class="built_in">this</span>.includeThreadName, event.getThreadName(), map);</span><br><span class="line">    add(JsonLayout.LOGGER_ATTR_NAME, <span class="built_in">this</span>.includeLoggerName, event.getLoggerName(), map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意看这个if块，我们的日志语句就是在这里被处理的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includeFormattedMessage) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> event.getFormattedMessage();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.includeExceptionInMessage) {</span><br><span class="line">            <span class="type">IThrowableProxy</span> <span class="variable">throwableProxy</span> <span class="operator">=</span> event.getThrowableProxy();</span><br><span class="line">            <span class="keyword">if</span> (throwableProxy != <span class="literal">null</span>) {</span><br><span class="line">                <span class="type">String</span> <span class="variable">stackTrace</span> <span class="operator">=</span> getThrowableProxyConverter().convert(event);</span><br><span class="line">                <span class="keyword">if</span> (stackTrace != <span class="literal">null</span> &amp;&amp; !stackTrace.equals(<span class="string">""</span>)) {</span><br><span class="line">                    message += <span class="string">"\n"</span> + stackTrace;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, message);</span><br><span class="line">    }</span><br><span class="line">    add(JsonLayout.MESSAGE_ATTR_NAME, <span class="built_in">this</span>.includeMessage, event.getMessage(), map);</span><br><span class="line">    add(JsonLayout.CONTEXT_ATTR_NAME, <span class="built_in">this</span>.includeContextName, event.getLoggerContextVO().getName(), map);</span><br><span class="line">    addThrowableInfo(JsonLayout.EXCEPTION_ATTR_NAME, <span class="built_in">this</span>.includeException, event, map);</span><br><span class="line">    addTraceId(event, map);</span><br><span class="line">    add(StackdriverTraceConstants.SPAN_ID_ATTRIBUTE, <span class="built_in">this</span>.includeSpanId,</span><br><span class="line">            event.getMDCPropertyMap().get(StackdriverTraceConstants.MDC_FIELD_SPAN_ID), map);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.serviceContext != <span class="literal">null</span>) {</span><br><span class="line">        map.put(StackdriverTraceConstants.SERVICE_CONTEXT_ATTRIBUTE, <span class="built_in">this</span>.serviceContext);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.customJson != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.customJson.isEmpty()) {</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : <span class="built_in">this</span>.customJson.entrySet()) {</span><br><span class="line">            map.putIfAbsent(entry.getKey(), entry.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addCustomDataToJsonMap(map, event);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看起来篇幅好像很大，但是仔细一看，不难明白，它就是生成了一个 <code>Map</code>，而这个 <code>Map</code> 里面放的，就是最后我们在 GCP Logging 里面将要看到的日志。好了，目标找到了，那就准备动手吧。</p>
<h2 id="修改日志内容"><a href="#修改日志内容" class="headerlink" title="修改日志内容"></a>修改日志内容</h2><p>要修改的方法找到了，但是我们仍不知道应该怎么取得类名、方法和行号。经过又一顿网上冲浪，加上在源码里面一刨一刨的翻，和一点小小的灵感，最后得知这些信息全部可以通过 <code>ILoggingEvent#getCallerData()</code> 方法取得。请原谅因为时间过去的有点久，我已经找不到当时给我指路的文章，所以也就不能放在下面的参考中了。</p>
<p>那么我们就开始着手实现这个需求吧。首先在项目里面新建一个类，因为我们的目的是重写 <code>toJsonMap</code> 这个方法，所以要让它继承 <code>StackdriverJsonLayout</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcpLoggingLayout</span> <span class="keyword">extends</span> <span class="title class_">StackdriverJsonLayout</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">toJsonMap</span><span class="params">(ILoggingEvent event)</span> {</span><br><span class="line">        <span class="comment">// 先调用原本的方法，把日志的信息全部生成好</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="built_in">super</span>.toJsonMap(event);</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] callerData = event.getCallerData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有callerData，那后面也没法操作了</span></span><br><span class="line">        <span class="keyword">if</span> (callerData == <span class="literal">null</span> || callerData.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素就是这个日志所在位置的信息</span></span><br><span class="line">        <span class="type">StackTraceElement</span> <span class="variable">stackTraceElement</span> <span class="operator">=</span> callerData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我只需要类名，不需要前面的包名</span></span><br><span class="line">        <span class="comment">// 而 getClassName() 会返回类的全限定名</span></span><br><span class="line">        <span class="comment">// 所以我把它拆了，取最后一个元素，也就是类名</span></span><br><span class="line">        String[] classNameParts = stackTraceElement.getClassName().split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">callerClass</span> <span class="operator">=</span> classNameParts[classNameParts.size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> stackTraceElement.getMethodName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">lineNumber</span> <span class="operator">=</span> stackTraceElement.getLineNumber().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个是原本的日志信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalMessage</span> <span class="operator">=</span> map.get(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把类名、方法名、行数附加在原本的信息前面</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">enhancedMessage</span> <span class="operator">=</span> <span class="string">"class="</span> + callerClass + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"method="</span> + methodName + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"line="</span> + lineNumber + <span class="string">" "</span></span><br><span class="line">                                + originalMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把改好的日志放回去</span></span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, enhancedMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样我们的日志里就带上了类名、方法名，和行号了。但是到了这里并没有结束，因为上面的代码有一个问题：框架打出来的日志也带上了这些信息。虽然不影响使用，但是它不好看，我不想要。所以我决定继续优化一下。</p>
<h2 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h2><p>稍加思索，我提出了两个新的需求：</p>
<ul>
<li>要根据包名过滤，只给指定的包里面的类加上这些信息。这样，我就可以排除掉所有无关的包。</li>
<li>还要根据类名过滤，遇到被指定的类，我就不加上这些信息。因为对于启动类 (就是放 <code>main</code> 方法那个)，和一些用于健康检查的类，它们打出的日志也没必要加上这些信息。</li>
</ul>
<p>但是很明显，原厂的功能并不足以实现这两个需求。我为了这两个需求，新增了两个参数：<code>appPackage</code> 用来指定应用的包名，<code>excludedClassNames</code> 用来指定要被排除的类。</p>
<p>增加了参数，那必然也要修改代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcpLoggingLayout</span> <span class="keyword">extends</span> <span class="title class_">StackdriverJsonLayout</span> {</span><br><span class="line">    <span class="keyword">private</span> String appPackage;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; excludedClassNames;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppPackage</span><span class="params">(String appPackage)</span> {</span><br><span class="line">        <span class="built_in">this</span>.appPackage = appPackage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAppPackage</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.appPackage;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要注意</span></span><br><span class="line">    <span class="comment">// 我为了 logback-spring.xml 写起来方便，所以在XML中这个属性是一个逗号分隔的字符串</span></span><br><span class="line">    <span class="comment">// 但是在代码里面，我为了用 contains 方法，所以用了一个List来存放</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExcludedClassNames</span><span class="params">(String excludedClassNames)</span> {</span><br><span class="line">        <span class="built_in">this</span>.excludedClassNames =</span><br><span class="line">            Arrays.stream(excludedClassNames.split(<span class="string">","</span>))</span><br><span class="line">                .map(String::trim)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter就没啥讲究了</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getExcludedClassNames</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.excludedClassNames;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">toJsonMap</span><span class="params">(ILoggingEvent event)</span> {</span><br><span class="line">        <span class="comment">// 先调用原本的方法，把日志的信息全部生成好</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="built_in">super</span>。toJsonMap(event);</span><br><span class="line"></span><br><span class="line">        StackTraceElement[] callerData = event.getCallerData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有callerData，那后面也没法操作了</span></span><br><span class="line">        <span class="keyword">if</span> (callerData == <span class="literal">null</span> || callerData.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素就是这个日志所在位置的信息</span></span><br><span class="line">        <span class="type">StackTraceElement</span> <span class="variable">stackTraceElement</span> <span class="operator">=</span> callerData[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了通过包名匹配，所以先拿出来全限定名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">callerClassFullName</span> <span class="operator">=</span> stackTraceElement.getClassName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是应用所在的包打出来的日志，那么不处理</span></span><br><span class="line">        <span class="keyword">if</span> (!callerClassFullName.contains(appPackage)) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        String[] classNameParts = stackTraceElement.getClassName().split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">callerClass</span> <span class="operator">=</span> classNameParts[classNameParts.size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类是被排除的，那就不处理</span></span><br><span class="line">        <span class="keyword">if</span> (excludedClassNames.contains(callerClass)) {</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> stackTraceElement.getMethodName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">lineNumber</span> <span class="operator">=</span> String.valueOf(stackTraceElement.getLineNumber());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个是原本的日志信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalMessage</span> <span class="operator">=</span> map.get(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把类名、方法名、行数附加在原本的信息前面</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">enhancedMessage</span> <span class="operator">=</span> <span class="string">"class="</span> + callerClass + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"method="</span> + methodName + <span class="string">" "</span></span><br><span class="line">                                + <span class="string">"line="</span> + lineNumber + <span class="string">" "</span></span><br><span class="line">                                + originalMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把改好的日志放回去</span></span><br><span class="line">        map.put(JsonLayout.FORMATTED_MESSAGE_ATTR_NAME, enhancedMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了修改代码，日志配置文件 <code>logback-spring.xml</code> 也要针对我们新增的两个属性作出修改。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/cloud/gcp/autoconfigure/logging/logback-appender.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/cloud/gcp/logging/logback-json-appender.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/defaults.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- CONSOLE输出部分略 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE_JSON"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.encoder.LayoutWrappingEncoder"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指向我们上面写的GcpLoggingLayout --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"com.boris1993.myapplication.config.GcpLoggingLayout"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 应用的包名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appPackage</span>&gt;</span>com.boris1993.myapplication<span class="tag">&lt;/<span class="name">appPackage</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要排除的类名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逗号后面的空格可有可无，为了好看我选择加上，反正最后会被trim掉 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludedClassNames</span>&gt;</span>APP, HealthCheck<span class="tag">&lt;/<span class="name">excludedClassNames</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他GCP Logging配置略 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- springProfile配置略 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后就可以部署到 GCP 上面看效果了，或者在本机使用对应的 profile 启动，然后检查控制台里面打印出来的 JSON。</p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5zcHJpbmcuaW8vc3ByaW5nLWNsb3VkLWdjcC9tdWx0aS9tdWx0aV9fc3RhY2tkcml2ZXJfbG9nZ2luZy5odG1s">Stackdriver Logging<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1jbG91ZC9zcHJpbmctY2xvdWQtZ2NwL2Jsb2IvMTRhNzQ3YTVkOGZkMzYyYWI3NzNlNDNhY2FmYWU1ZWNhZWJiZDcyZC9zcHJpbmctY2xvdWQtZ2NwLWxvZ2dpbmcvc3JjL21haW4vamF2YS9vcmcvc3ByaW5nZnJhbWV3b3JrL2Nsb3VkL2djcC9sb2dnaW5nL1N0YWNrZHJpdmVySnNvbkxheW91dC5qYXZhI0w0NQ==">StackdriverJsonLayout.java - GitHub<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>Google Cloud Logging</tag>
        <tag>Stackdriver</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Spring Boot 应用中配置统一的请求响应</title>
    <url>/generify-response-format-in-spring-boot-applications.html</url>
    <content><![CDATA[<p>在前后端分离的架构下，后端通常是一个 RESTFul 的接口，而因为 HTTP 的响应码数量有限，无法灵活的反映出接口执行的各种结果，在这种情况下，就需要通过自定义的结构来表达接口最终的状态和返回的信息。而我正好最近在一个项目中实现了一个基于 <code>ControllerAdvice</code> 的统一请求响应的功能，在这里记录一下实现的方式。</p>
<span id="more"></span>

<h2 id="创建common模块"><a href="#创建common模块" class="headerlink" title="创建common模块"></a>创建 common 模块</h2><p>因为这是一个公共的功能，所以需要创建一个新的 Maven 模块，并被所有项目引用为依赖。具体操作这里不再赘述。以下的所有代码，如无特殊说明，都将存在于这个 common 模块中。</p>
<h2 id="定义全局的错误码"><a href="#定义全局的错误码" class="headerlink" title="定义全局的错误码"></a>定义全局的错误码</h2><p>首先我们需要定义一个全局的错误码，使得项目中的所有模块都可以使用统一的一套返回码来表达自己接口的状态。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口返回码和描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ReturnCode</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OK(<span class="string">"0000"</span>, <span class="string">"成功"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端异常，当发生未知异常时使用该错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FAIL(<span class="string">"9999"</span>, <span class="string">"失败"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数中包含无效参数或请求体为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INVALID_REQUEST_PARAM(<span class="string">"0001"</span>, <span class="string">"请求参数中包含无效参数或请求体为空"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新数据的主键与已有数据重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DUPLICATED_RECORD(<span class="string">"0002"</span>, <span class="string">"新数据的主键与已有数据重复"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未找到对应记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NON_EXISTENT_RECORD(<span class="string">"0003"</span>, <span class="string">"未找到对应记录，请检查主键或操作流水号"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名校验失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SIGNATURE_VERIFICATION_FAIL(<span class="string">"0004"</span>, <span class="string">"签名校验失败"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为各模块自定义的错误码</span></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    ReturnCode(<span class="keyword">final</span> String code, <span class="keyword">final</span> String message) {</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据状态码获取其错误信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 状态码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 错误码对应的错误信息。如果没有找到则返回{<span class="doctag">@code</span> null}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessageByCode</span><span class="params">(String code)</span> {</span><br><span class="line">        <span class="keyword">for</span> (ReturnCode item : values()) {</span><br><span class="line">            <span class="keyword">if</span> (item.code.equals(code)) {</span><br><span class="line">                <span class="keyword">return</span> item.message;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="定义统一响应结构"><a href="#定义统一响应结构" class="headerlink" title="定义统一响应结构"></a>定义统一响应结构</h2><p>在这个项目中，我选择在这个结构中定义三个字段：错误码 <code>errCode</code>，错误信息 <code>errMessage</code>，和返回的数据 <code>data</code>。</p>
<p>同时，用于构造响应体的类应该同时兼顾数据合法性和灵活性，所以我决定不允许通过构造方法或者 setter 来填充信息，而是使用定义好了的静态方法来完成构造。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公共响应参数&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 成功的返回通过{<span class="doctag">@link</span> CommonResponseParams#ofSuccessful()}或{<span class="doctag">@link</span> CommonResponseParams#ofSuccessful(Object)}生成&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 失败的返回通过{<span class="doctag">@link</span> CommonResponseParams#ofFailure()}或{<span class="doctag">@link</span> CommonResponseParams#ofFailure(ReturnCode)}生成</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonResponseParams</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回码 - 必填</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String errCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回描述 - 必填</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String errMessage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务数据 - 必填</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个{<span class="doctag">@link</span> CommonResponseParams}对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errCode    返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errMessage 返回描述</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data    业务数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CommonResponseParams</span><span class="params">(<span class="keyword">final</span> String errCode, <span class="keyword">final</span> String errMessage, <span class="keyword">final</span> Object data)</span> {</span><br><span class="line">        <span class="built_in">this</span>.errCode = errCode;</span><br><span class="line">        <span class="built_in">this</span>.errMessage = errMessage;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回成功结果，没有响应数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title function_">ofSuccessful</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> ofSuccessful(<span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回成功结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 返回的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;     返回的数据的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CommonResponseParams <span class="title function_">ofSuccessful</span><span class="params">(<span class="keyword">final</span> T content)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResponseParams</span>(</span><br><span class="line">                ReturnCode.OK.getCode(),</span><br><span class="line">                ReturnCode.OK.getMessage(),</span><br><span class="line">                JSONArray.toJSON(content));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回失败结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title function_">ofFailure</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResponseParams</span>(</span><br><span class="line">                ReturnCode.FAIL.getCode(),</span><br><span class="line">                ReturnCode.FAIL.getMessage(),</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title function_">ofFailure</span><span class="params">(String errMessage)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResponseParams</span>(</span><br><span class="line">                ReturnCode.FAIL.getCode(),</span><br><span class="line">                errMessage,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回失败结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnCode 错误的返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title function_">ofFailure</span><span class="params">(ReturnCode returnCode)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResponseParams</span>(</span><br><span class="line">                returnCode.getCode(),</span><br><span class="line">                returnCode.getMessage(),</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回带有自定义错误信息的失败结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnCode 错误相关的返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errMessage 自定义的错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公共响应参数实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommonResponseParams <span class="title function_">ofFailure</span><span class="params">(ReturnCode returnCode, String errMessage)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResponseParams</span>(</span><br><span class="line">                returnCode.getCode(),</span><br><span class="line">                errMessage,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="定义统一的业务异常基类"><a href="#定义统一的业务异常基类" class="headerlink" title="定义统一的业务异常基类"></a>定义统一的业务异常基类</h2><p>为了减少不必要的 <code>try-catch</code> 模版代码，业务异常必须不能为受检异常；而为了与其它的运行时异常区分开来，业务异常类就不能直接继承 <code>RuntimeException</code>，而是需要继承于一个自定义的基类。同时，这个业务异常基类不能被直接使用，所以必须是一个抽象类。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务异常基类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseBizException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> {</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">ReturnCode</span> <span class="variable">returnCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseBizException</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseBizException</span><span class="params">(ReturnCode returnCode)</span> {</span><br><span class="line">        <span class="built_in">super</span>(returnCode.getMessage());</span><br><span class="line">        <span class="built_in">this</span>.returnCode = returnCode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务异常不记录stack trace</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title function_">fillInStackTrace</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="定义统一的异常处理方法"><a href="#定义统一的异常处理方法" class="headerlink" title="定义统一的异常处理方法"></a>定义统一的异常处理方法</h2><p>在上面的准备工作全部完成后，就可以开始着手配置统一的异常处理方法。之所以选择不使用 <code>AOP</code> 实现，是因为在这个情况下，业务接口必须返回 <code>Object</code> 类型，而这样一来，会降低代码层面的可读性。使用 <code>ControllerAdvice</code> 注解实现则没有这个限制，业务接口可以自由选择自己合适的数据类型。</p>
<p>需要注意的是，因为我们所有的 controller 类都会带有 <code>RestController</code> 注解，所以在 <code>ControllerAdvice</code> 注解中，我们使用 <code>annotations</code> 参数指定了这个配置类仅针对带有 <code>RestController</code> 的类启用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一异常处理配置类&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 包装格式见{<span class="doctag">@link</span> CommonResponseParams}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnifiedExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理数据库连接失败抛出的异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 带有数据库连接失败信息的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(CannotCreateTransactionException.class)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResponseParams <span class="title function_">handleCannotCreateTransactionException</span><span class="params">(CannotCreateTransactionException e)</span> {</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(<span class="string">"数据库连接失败"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理未知的运行时错误</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResponseParams <span class="title function_">handleUnknownRuntimeExceptions</span><span class="params">(RuntimeException e)</span> {</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(e.getMessage());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理公共请求参数校验失败异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 参数校验失败抛出的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 带有校验失败原因提示信息的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResponseParams <span class="title function_">handleRequestParamValidationExceptions</span><span class="params">(MethodArgumentNotValidException e)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMessage</span> <span class="operator">=</span> Optional.ofNullable(e.getBindingResult().getFieldError())</span><br><span class="line">                .map(FieldError::getDefaultMessage)</span><br><span class="line">                .orElse(ReturnCode.INVALID_REQUEST_PARAM.getMessage());</span><br><span class="line"></span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(ReturnCode.INVALID_REQUEST_PARAM, errMessage);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求body为空的异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 带有请求体无效错误的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResponseParams <span class="title function_">handleHttpMessageNotReadableException</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(ReturnCode.INVALID_REQUEST_PARAM);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理新增数据主键重复异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 带有主键重复错误的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(DuplicateKeyException.class)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResponseParams <span class="title function_">handleDuplicateKeyException</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofFailure(ReturnCode.DUPLICATED_RECORD);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理业务异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 业务异常对应的失败返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseBizException.class)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResponseParams <span class="title function_">handleBizExceptions</span><span class="params">(BaseBizException e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (e.getReturnCode() != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">ReturnCode</span> <span class="variable">returnCode</span> <span class="operator">=</span> e.getReturnCode();</span><br><span class="line">            log.error(returnCode.getMessage());</span><br><span class="line">            <span class="keyword">return</span> CommonResponseParams.ofFailure(returnCode);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isNotBlank(e.getMessage())) {</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> CommonResponseParams.ofFailure(e.getMessage());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> CommonResponseParams.ofFailure();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里详细说一下各个方法的作用。</p>
<p>第一个方法用于处理 <code>CannotCreateTransactionException</code> 异常类，这个异常会在应用无法成功连接数据库时被抛出。处理方式就是返回一个错误信息为 “数据库连接失败” 的失败结果。</p>
<p>第二个方法用于处理 <code>RuntimeException</code> 异常，这个方法的意义在于，我们无法预见所有可能出现的异常，所以使用这个方法作为一个兜底的处理方法。</p>
<p>第三个方法用于处理 <code>MethodArgumentNotValidException</code> 异常。因为这个项目中我们选择使用 <code>javax.validation.constraints</code> 包中的注解实现输入参数合法性的校验，而当校验失败时会抛出 <code>MethodArgumentNotValidException</code> 异常，并且在异常中会包含具体的校验失败的原因。同时为了保证方法的健壮性，在代码中也保证了如果无法获取到校验失败信息，就会选择 <code>INVALID_REQUEST_PARAM</code> 这个错误码作为兜底的错误信息。</p>
<p>第四个方法用于处理 <code>HttpMessageNotReadableException</code> 异常。如果一个接口方法的参数中存在被 <code>@RequestBody</code> 标记的参数，但是在请求该接口时 body 为空时，就会抛出这个异常。在出现了这个异常后，就会返回带有 <code>INVALID_REQUEST_PARAM</code> 错误信息的失败结果。</p>
<p>第五个方法用于处理 <code>DuplicateKeyException</code> 异常。因为这个项目中一部分数据的主键是由请求发起方生成的，同时数据库中也会将这一列定为主键来实现插入接口的幂等性。一旦出现网络状况不佳的情况时，发起方会尝试再次调用接口。而在重发请求时，可能数据已经在上一个请求中就已经成功插入了，只是因为网络不佳导致发起方没能接收到返回，在第二次请求中重复插入相同主键的数据，就会抛出这个异常。为了最终接口返回信息的可读性，我们选择在这里返回一个用户友好的信息。</p>
<p>最后一个方法就是这里的主角了，它用于处理所有继承了 <code>BaseBizException</code> 的业务异常。这个方法中，我们对应着 <code>CommonResponseParams</code> 中不同的静态方法，实现了对应的错误处理逻辑。</p>
<h2 id="定义统一的成功响应处理方法"><a href="#定义统一的成功响应处理方法" class="headerlink" title="定义统一的成功响应处理方法"></a>定义统一的成功响应处理方法</h2><p>上面洋洋洒洒写了一堆针对异常的处理逻辑，但是接口成功执行的处理逻辑也不能落下。这里我们使用 <code>RestControllerAdvice</code> 表示这是一个接口增强类，同时实现了 <code>ResponseBodyAdvice</code> 接口，用于实现实际的处理逻辑。</p>
<p>在这个配置类上，我们也指定了该配置类仅针对被 <code>RestController</code> 标记的类生效。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一响应格式配置类&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 包装格式见{<span class="doctag">@link</span> CommonResponseParams}</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Boris Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnifiedReturnConfig</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object body,</span></span><br><span class="line"><span class="params">                                  MethodParameter returnType,</span></span><br><span class="line"><span class="params">                                  MediaType selectedContentType,</span></span><br><span class="line"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span><br><span class="line"><span class="params">                                  ServerHttpRequest request,</span></span><br><span class="line"><span class="params">                                  ServerHttpResponse response)</span> {</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> CommonResponseParams) {</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommonResponseParams.ofSuccessful(body);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码的重点是在 <code>beforeBodyWrite</code> 方法中。这个方法会在 <code>HttpMessageConverter#write()</code> 方法执行前，也就是返回被发出去之前被调用。借助这个功能，我们就可以实现在业务接口返回之后，将返回信息重新包装。</p>
<p>实现逻辑很简单，如果返回信息是一个 <code>CommonResponseParams</code> 对象，那么就认为这个返回信息已经被包装好了，所以不再进行二次包装，直接返回；否则就通过 <code>CommonResponseParams#ofSuccessful()</code> 方法，将返回信息包装为一个成功响应的格式，再返回到客户端。</p>
<h2 id="最后的一点配置"><a href="#最后的一点配置" class="headerlink" title="最后的一点配置"></a>最后的一点配置</h2><p>在上文中，统一返回格式的配置已经完成了。但是有的人可能会发现，虽然在自己的项目中引用了这个模块，但是实际上却没有生效，这是因为上面的配置类都存在于另一个 jar 包中，导致在应用启动时这些请求并没有被自动发现。解决方法也很简单，在项目的启动类 (即 <code>xxxApplication</code>) 中加上 <code>@ComponentScan</code> 注解，并在注解参数中加上 <code>UnifiedReturnConfig</code> 和 <code>UnifiedExceptionHandler</code> 所在的包名即可。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>统一响应</tag>
      </tags>
  </entry>
  <entry>
    <title>解决命令行中 Git 显示中文文件名乱码</title>
    <url>/git-commandline-unescape-chinese-characters.html</url>
    <content><![CDATA[<p>在用 Git 管理包含中文的文件时，会出现类似这样的 “乱码”：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">    <span class="string">"\345\271\277\345\221\212\345\220\214\346\255\245\345\271\263\345\217\260\346\216\245\345\217\243\346\226\207\346\241\2432.0.docx.new"</span></span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></tbody></table></figure>

<p>解决方法是配置 Git 的全局属性 <code>core.quotepath</code> 为 <code>false</code>，即执行命令 <code>git config --global core.quotepath false</code>，然后再执行 <code>git status</code>，就可以看到中文正常显示了：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">    广告同步平台接口文档2.0.docx.new</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>为了改桥接，我决定破解中兴 F450G V2 光猫</title>
    <url>/hacking-zte-f450g-v2-onu.html</url>
    <content><![CDATA[<p>还记得我<a href="/setting-up-microserver-gen8-routeros.html">之前买了个猫棒来替换光猫</a>么？用了一个来月，发现这玩意真的不稳定，短则几分钟长则一两天它必定自己重启一次，导致我的网络时不时就会断线。这玩意不好使，我也没有别的光猫，只好找电信装维师傅给我改桥接。可哪成想一个师傅踢皮球让我找另一个师傅，另一个一听我说是<code>悦me</code> 直接就说不能改，只有 SDN 光猫能改。那你们逼我的，我自己改。</p>
<span id="more"></span>

<h2 id="光猫信息"><a href="#光猫信息" class="headerlink" title="光猫信息"></a>光猫信息</h2><p>我的这款光猫是 <code>EPON上行悦me网关</code>，型号是<code>中兴 ZXHN F450G</code>，区域是上海，硬件版本 <code>V2.0</code>。</p>
<p><img data-src="https://blog-static.boris1993.com/hacking-zte-f450g-v2-onu/f450g-onu-info.png"></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>开始折腾光猫之前，一定要把当前光猫里存的配置备份好，尤其是 <code>LOID</code>，万一折腾砸了，还可以改回去，或者重新注册，让局端重新下发正确的配置。我已经有了 <code>telecomadmin</code> 的密码，就直接登进后台，把配置抄了下来。</p>
<p><img data-src="https://blog-static.boris1993.com/hacking-zte-f450g-v2-onu/onu-settings-backup.png"></p>
<h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><blockquote>
<p>首先我要大力感谢这篇帖子，那天我就是照着这里面的内容操作的。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hpbmFkc2wubmV0L3RocmVhZC0xMjc2NjYtMS0xLmh0bWw=">https://www.chinadsl.net/thread-127666-1-1.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="复位光猫，开启telnet"><a href="#复位光猫，开启telnet" class="headerlink" title="复位光猫，开启telnet"></a>复位光猫，开启 telnet</h3><p>首先，拔掉光纤，用细针捅住光猫后面的复位孔，直到光猫前面板下方的两个灯都熄灭，只剩下上面的电信 logo 亮着，以彻底复位光猫。这一步是为了重新打开 telnet，因为这个光猫在插上光纤之后 telnet 就会被禁用，只有拔掉光纤并彻底复位才能再把 telnet 打开。</p>
<p>复位后光猫会自动重启，拿根网线，把电脑接上光猫的 LAN 口（别接 LAN 2，那是给 IPTV 用的），电脑设定静态 IP 地址 <code>192.168.1.100</code>（其实除了 <code>192.168.1.1</code> 之外，整个 <code>192.168.1.0/24</code> 网段随便你选），子网掩码 <code>255.255.255.0</code>。</p>
<p>接下来持续 <code>ping 192.168.1.1</code>，光猫启动好之后会有响应，接下来用 telnet 连接 192.168.1.1，使用用户名 <code>root</code> 和密码 <code>Zte521</code> 登进光猫 shell。</p>
<h3 id="需要通过telnet做的配置"><a href="#需要通过telnet做的配置" class="headerlink" title="需要通过telnet做的配置"></a>需要通过 telnet 做的配置</h3><p>首先用以下命令实现在光纤插入后 telnet 仍然可用。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 打开telnet</span></span><br><span class="line">sendcmd 1 DB <span class="built_in">set</span> TelnetCfg 0 TS_Enable 1</span><br><span class="line"><span class="comment"># 允许局域网登陆</span></span><br><span class="line">sendcmd 1 DB <span class="built_in">set</span> TelnetCfg 0 Lan_Enable 1</span><br><span class="line"><span class="comment"># 插上光纤后不关闭telnet</span></span><br><span class="line">sendcmd 1 DB <span class="built_in">set</span> TelnetCfg 0 Lan_EnableAfterOlt 1</span><br><span class="line"><span class="comment"># 最多允许5个用户同时登陆telnet，避免自己被锁在外面</span></span><br><span class="line">sendcmd 1 DB <span class="built_in">set</span> TelnetCfg 0 Max_Con_Num 5</span><br><span class="line"><span class="comment"># 打开23端口</span></span><br><span class="line">sendcmd 1 DB <span class="built_in">set</span> PortControl 3 PortEnable 1</span><br><span class="line"><span class="comment"># 保存配置</span></span><br><span class="line">sendcmd 1 DB save</span><br></pre></td></tr></tbody></table></figure>

<p>然后可以用 <code>sendcmd 1 DB p TelnetCfg</code> 确认下配置。后面的操作也可以用 <code>sendcmd 1 DB p 表名</code>这条命令确认配置，就不再重复了。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tbl</span> <span class="attr">name</span>=<span class="string">"TelnetCfg"</span> <span class="attr">RowCount</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Row</span> <span class="attr">No</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"TS_Enable"</span> <span class="attr">val</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"Wan_Enable"</span> <span class="attr">val</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"Lan_Enable"</span> <span class="attr">val</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"TS_Port"</span> <span class="attr">val</span>=<span class="string">"23"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"TSLan_Port"</span> <span class="attr">val</span>=<span class="string">"23"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"TS_UName"</span> <span class="attr">val</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"TS_UPwd"</span> <span class="attr">val</span>=<span class="string">"Zte521"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"TSLan_UName"</span> <span class="attr">val</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"TSLan_UPwd"</span> <span class="attr">val</span>=<span class="string">"Zte521"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"Max_Con_Num"</span> <span class="attr">val</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"ProcType"</span> <span class="attr">val</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"Lan_EnableAfterOlt"</span> <span class="attr">val</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"TS_Sprtwl_Mode"</span> <span class="attr">val</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">DM</span> <span class="attr">name</span>=<span class="string">"WanWebLinkToTS"</span> <span class="attr">val</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Tbl</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后禁用掉 TR069。电信局端通过 TR069 协议下发配置，而我们自己改的桥接肯定跟局端的配置不一样，不关掉这玩意相当于白忙活。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用TR069的58000端口</span></span><br><span class="line">sendcmd 1 DB <span class="built_in">set</span> PortControl 6 PortEnable 0</span><br><span class="line">sendcmd 1 DB save</span><br></pre></td></tr></tbody></table></figure>

<p>虽然原帖中说还要把远程管理配置乱改以斩草除根，我是懒得改，应该关了端口就行，因为一来直到现在一个星期了我的配置都还在，二来重新设备注册的时候也会卡在<code>等待ITMS下发配置</code>，所以 TR069 应该是已经被掐了。</p>
<p>然后需要骗过光猫，让它认为 ITMS 下发配置已经成功。一开始搞的时候没做这一步，就发现过几分钟网页就打不开，nslookup 一下发现解析全去了 192.168.1.1，又打开个网站说试试，结果直接被光猫劫持到了设备注册页面。直接在光猫的表里面改掉 ITMS 状态，再清理 DNS 缓存之后就正常了。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sendcmd 1 DB <span class="built_in">set</span> PDTCTUSERINFO 0 Status 0</span><br><span class="line">sendcmd 1 DB <span class="built_in">set</span> PDTCTUSERINFO 0 Result 1</span><br><span class="line">sendcmd 1 DB save</span><br></pre></td></tr></tbody></table></figure>

<p>接下来改掉光猫的最大用户数。其实要改桥接的话，这个改不改都没关系，反正我也不用光猫上网。但还是顺手改了。也不需要改什么最大用户数，直接关掉限制完事。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sendcmd 1 DB <span class="built_in">set</span> CltLmt 8 Enable 0</span><br><span class="line">sendcmd 1 DB save</span><br></pre></td></tr></tbody></table></figure>

<p>至此 telnet 里面要搞的东西就都搞完了。虽然原帖里面还提到改掉 <code>telecomadmin</code> 的密码，但是既然 TR069 都废了，密码自然也不会再变。正好之前从装维师傅那要到的密码还能用，我也懒得再改。</p>
<h3 id="登进后台配桥接"><a href="#登进后台配桥接" class="headerlink" title="登进后台配桥接"></a>登进后台配桥接</h3><p>插上光纤，用 telecomadmin 登进光猫后台。先看一眼<code>网关注册信息</code>，因为光猫复位不会丢 LOID，所以插上光纤之后，<code>光路（OLT）认证</code>应该就是认证成功的状态；而上面在 telnet 里面也改掉了 ITMS 认证状态，所以<code>管理（ITMS）注册</code>也应该是注册成功的状态。</p>
<p><img data-src="https://blog-static.boris1993.com/hacking-zte-f450g-v2-onu/gateway-registration-status.png"></p>
<p>进入<code>网络</code>的<code>网络设置</code>，点开<code>连接名称</code>下拉菜单，看有没有 <code>INTERNET_B_VID</code>，如果有，而且连接模式是<code>路由</code>，那就删了它。然后下拉菜单选<code>新建WAN连接</code>，连接模式选<code>桥接</code>，业务类型选<code>上网</code>，IP 模式选 <code>IPv4&amp;IPv6</code>，点保存，光猫端就配置完成了。</p>
<p><img data-src="https://blog-static.boris1993.com/hacking-zte-f450g-v2-onu/onu-wan-config.png"></p>
<h2 id="齐活"><a href="#齐活" class="headerlink" title="齐活"></a>齐活</h2><p>到这光猫就改好桥接了，从光猫上扯根网线连上自己的路由器拨号，就可以上网了。正好改完桥接那天，RouterOS 有更新，看 PPPoE 接口的 uptime 可以看出来，从 RouterOS 重启之后到现在，链接就没断过。之前用猫棒的时候，uptime 就没多于过 2 天。</p>
<p><img data-src="https://blog-static.boris1993.com/hacking-zte-f450g-v2-onu/routeros-connection-uptime.png"></p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>光猫</tag>
        <tag>桥接</tag>
        <tag>F450G</tag>
      </tags>
  </entry>
  <entry>
    <title>在 NexT 主题中接入 Google AdSense</title>
    <url>/hexo-next-enable-google-adsense.html</url>
    <content><![CDATA[<p>这个博客从建站到现在，也差不多有两三年时间了，一直以来也都是一种 “用爱发电” 的状况，看到其他博主都开始通过接入广告联盟来挣零花钱，说不心动那是不可能的。所以就研究了一下怎么在这个博客里面接入 Google AdSense。</p>
<p>在使用本文介绍的方法前，请检查您的 NexT 主题版本是否为 <code>v6.0.2</code> 或后续版本，因为本文涉及的功能是在 <code>v6.0.2</code> 引入的。</p>
<span id="more"></span>

<p>虽然网上已经有很多类似的博文了，我为什么还要再写一篇呢？主要是因为，很多文章在添加认证代码的时候，都是直接修改 <code>themes/next/layout/_partials/head.swig</code> 或者 <code>themes/next/layout/_custom/google_adsense.ejs</code> 等位置，说白了就是在 NexT 主题所在的目录动手了，而我并不喜欢这种侵入性强的操作。经过一点简单的搜索，我发现是可以通过数据文件来实现非侵入性的修改的，所以就想讲一下我的做法。<del>当然借此机会还能水一篇博文何乐而不为 / 滑稽</del></p>
<p>那么言归正传，一起来看一下我是怎么配置的吧。</p>
<h2 id="注册Google-AdSense"><a href="#注册Google-AdSense" class="headerlink" title="注册Google AdSense"></a>注册 Google AdSense</h2><p>要接入 AdSense，那当然要有一个 AdSense 的账户。进入<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNuL2Fkc2Vuc2Uvc3RhcnQv"> Google AdSense<i class="fa fa-external-link-alt"></i></span>主页，点击 “开始使用”，跟随页面提示填好各项信息，这部分操作很简单，就不多废话了。</p>
<p>但是这里可能有一个坑，就是我只能接入一个裸域名，不知道是我的问题还是 AdSense 就是这么要求的。我的博客地址是 <code>https://www.boris1993.com</code>，但是在页面上输入网站地址之后，AdSense 会把 <code>www</code> 这个二级域名去掉，变成裸域名 <code>https://boris1993.com</code>，所以我只好把裸域名也关联到了我的博客站上。你们在配置的时候，记得注意一下这个地方。如果你知道具体的原因，或者解决方案，那么也请不吝赐教，在留言区告诉我。</p>
<h2 id="添加AdSense代码"><a href="#添加AdSense代码" class="headerlink" title="添加AdSense代码"></a>添加 AdSense 代码</h2><p>在注册完成后，AdSense 会给你一串代码，并要求你把这串代码放在 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中。注意这里就是我跟他们不一样的地方了。</p>
<p>同时再次提醒确认你的 NexT 主题的版本是不是 <code>v6.0.2</code> 或后续版本。如果不是的话，你要么考虑升级，要么可以点❌关闭了。</p>
<p>首先，我们需要在主题配置文件中指定自定义 layout 文件的位置。当然，这步也是在数据文件中操作的。什么？你还没有用数据文件这个功能？那你赶紧学习并且用起来吧，省的每次更新主题还要担心丢配置。</p>
<p>在 <code>source/_data/next.yml</code> 中增加如下配置：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 配置的原文可以在themes/next/_config.yml的24行找到(针对v7.5.0)</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment"># 因为我们只需要自定义head部分，所以就只配置head这一个属性，其他都保持默认</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br></pre></td></tr></tbody></table></figure>

<p>指定好 <code>head.swig</code> 的位置之后，我们继续在 <code>source/_data</code> 中创建 <code>head.swig</code> 文件，并把 AdSense 给我们的那串代码放在 <code>head.swig</code> 里面，就像这样：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-ad-client</span>=<span class="string">"██████████"</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后可以重新启动一下本地的 Hexo 环境，检查 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中有没有出现刚才添加的代码。检查没有问题之后，就可以部署到生产环境使上面的修改生效了。为了保险起见，在生产环境上也要检查一下 <code>&lt;head&gt;&lt;/head&gt;</code> 标记中有没有出现刚才添加的代码。确认没有问题之后，就可以回到 AdSense 页面中点击验证按钮了。</p>
<p>注意，如果 AdSense 告诉你检查不通过，你一定不要频繁点击再次检查，一定要先确定检查不通过的原因，并在排除问题之后再重新检查，因为每天检查次数是有限制的，如果超过限制，就只能等 24 小时之后再检查了<del>（别问我是怎么知道的</del>。</p>
<p>然后 AdSense 会开始审核阶段，这期间我们静静等待审核结果的邮件就好了。</p>
<p><del>因为在写这篇博文的时候，我也在等 AdSense 审核，所以这篇文章暂且先告一段落，等有了结果我再更新后面的内容。</del></p>
<p>等了这么久，终于收到 Google 的邮件说我通过了审核，可以开始投放广告了。那么，我们也可以开始继续完成后面的工作了。</p>
<h2 id="配置广告模块"><a href="#配置广告模块" class="headerlink" title="配置广告模块"></a>配置广告模块</h2><p>进入 AdSense 管理后台之后，进入侧边栏的<code>广告 -&gt; 概览</code>。在这里我们可以配置广告会在什么位置展示了。</p>
<p>因为我并不希望让我的网站满地都是广告，而影响正常内容的展示，而是，只在首页左侧边栏最下面，和在每篇博文结束的位置，各放置一个广告。所以我就需要到<code>按广告单元</code>这个页面手动配置两个广告模块。在这个截图里我们可以看到已经有了两个广告模块，那是因为我已经配置好了。</p>
<p><img data-src="https://blog-static.boris1993.com/hexo-next-enable-google-adsense/adsense-conf-ad-module.png" alt="Configuring ad modules"></p>
<h3 id="添加广告模块"><a href="#添加广告模块" class="headerlink" title="添加广告模块"></a>添加广告模块</h3><p>点击<code>展示广告</code>按钮来新建一个类型为<code>展示</code>的广告。在顶部文本框填入广告模块的名字，比如 <code>side ad</code>，然后在右边栏选择广告的尺寸，是自适应的，还是固定长宽的。如果是自适应尺寸，那么还需要选择广告的大致形状。配置完毕后，点击<code>保存</code>按钮，一个广告模块就配置好了。</p>
<p><img data-src="https://blog-static.boris1993.com/hexo-next-enable-google-adsense/adsense-conf-ad-module-sidebar.png" alt="Sidebar ad module"></p>
<p>按照同样的操作，继续添加一个名为 <code>bottom ad</code> 的展示广告。这样，我们就添加好了两个广告模块。</p>
<h3 id="配置博客页面"><a href="#配置博客页面" class="headerlink" title="配置博客页面"></a>配置博客页面</h3><p>广告模块是创建好了，但是我们还需要配置广告展示的位置。这里我依旧使用数据文件功能，来实现非侵入性的修改。</p>
<p>首先，在 <code>source/_data/</code> 目录新建两个文件，分别命名为 <code>sidebar.swig</code> 和 <code>post-body-end.swig</code>，分别用来存放侧边栏广告和文章底部广告的代码。</p>
<p>还记得刚才添加完广告模块之后弹出的那一片代码吗？把它们原样默写到这两个文件里就好啦。开玩笑的，谁记得住那一大堆东西啊。回到<code>按广告单元</code>这个页面，在刚才添加的广告单元那里，有一个形似 <code>&lt;&gt;</code> 的按钮，点击它，就可以看到这个广告单元的配置代码了。</p>
<p>把 <code>side ad</code> 的代码复制到 <code>sidebar.swig</code> 中，来把这个侧边栏广告真正的放到侧边栏上。比如我的广告代码是这样的：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- side ad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span> <span class="attr">class</span>=<span class="string">"adsbygoogle"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">style</span>=<span class="string">"display:block"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-client</span>=<span class="string">"████████████████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-slot</span>=<span class="string">"██████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-format</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-full-width-responsive</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="comment">// 因为直接执行AdSense的代码会出现 No slot size for availableWidth=0 的错误</span></span></span><br><span class="line"><span class="language-javascript">     <span class="comment">// 并且这个广告位会无法正常展示</span></span></span><br><span class="line"><span class="language-javascript">     <span class="comment">// 所以加一个 event listener，在页面加载完毕之后再执行</span></span></span><br><span class="line"><span class="language-javascript">     <span class="comment">// 参考：https://stackoverflow.com/a/37822404/3833858</span></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">'load'</span>, <span class="keyword">function</span>(<span class="params"></span>) {</span></span><br><span class="line"><span class="language-javascript">          (adsbygoogle = <span class="variable language_">window</span>.<span class="property">adsbygoogle</span> || []).<span class="title function_">push</span>({});</span></span><br><span class="line"><span class="language-javascript">     });</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后把 <code>bottom ad</code> 的代码复制到 <code>post-body-end.swig</code>，来把这个广告放到文章底部。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bottom ad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span> <span class="attr">class</span>=<span class="string">"adsbygoogle"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">style</span>=<span class="string">"display:block"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-client</span>=<span class="string">"████████████████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-slot</span>=<span class="string">"██████████"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-ad-format</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-full-width-responsive</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     (adsbygoogle = <span class="variable language_">window</span>.<span class="property">adsbygoogle</span> || []).<span class="title function_">push</span>({});</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>接下来继续修改 <code>source/_data/next.yml</code> 中 <code>custom_file_path</code> 的配置：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br><span class="line">  <span class="comment"># 加入下面两行</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="string">source/_data/sidebar.swig</span> <span class="comment"># 侧边栏广告</span></span><br><span class="line">  <span class="attr">postBodyEnd:</span> <span class="string">source/_data/post-body-end.swig</span> <span class="comment"># 博文末尾广告</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样，广告就放置好了。接下来，把博客发布上去，就可以开始打广告了。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
        <tag>adsense</tag>
      </tags>
  </entry>
  <entry>
    <title>从字节码看 synchronized 关键字是怎么工作的</title>
    <url>/how-synchronized-works-in-java.html</url>
    <content><![CDATA[<p>昨天面试的时候被问到 Java 中的 <code>synchronized</code> 关键字是什么原理，虽然凭着记忆打出来是通过控制对象头的 Monitor 来实现，但是毕竟没吃透这个知识点，还是没啥底气。干脆，这次就从字节码上看看，用了 <code>synchronized</code> 关键字的方法，到底是怎么执行的。</p>
<span id="more"></span>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>说起 <code>synchronized</code> 的最简单的使用场景，我马上就想起双检单例模式。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Test INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Test</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Test.class) {</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) {</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="反编译成字节码"><a href="#反编译成字节码" class="headerlink" title="反编译成字节码"></a>反编译成字节码</h2><p>把 <code>Test</code> 类先编译了，然后用 <code>javap -c Test.class</code> 反编译，就能看到这个类的字节码了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"Test.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title function_">getInstance</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// 把静态变量INSTANCE加载到栈</span></span><br><span class="line">       <span class="number">3</span>: ifnonnull     <span class="number">37</span>                  <span class="comment">// 如果值不是null，那么跳转到标签37</span></span><br><span class="line">       <span class="number">6</span>: ldc           #<span class="number">8</span></span><br><span class="line">       <span class="number">8</span>: dup</span><br><span class="line">       <span class="number">9</span>: astore_0</span><br><span class="line">      <span class="number">10</span>: monitorenter                      <span class="comment">// 进入synchronized块</span></span><br><span class="line">      <span class="number">11</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// 把静态变量INSTANCE加载到栈</span></span><br><span class="line">      <span class="number">14</span>: ifnonnull     <span class="number">27</span>                  <span class="comment">// 如果值不是null，那么跳转到标签27</span></span><br><span class="line">      <span class="number">17</span>: <span class="keyword">new</span>           #<span class="number">8</span>                  <span class="comment">// new一个Test对象</span></span><br><span class="line">      <span class="number">20</span>: dup</span><br><span class="line">      <span class="number">21</span>: invokespecial #<span class="number">13</span>                 <span class="comment">// 执行构造函数</span></span><br><span class="line">      <span class="number">24</span>: putstatic     #<span class="number">7</span></span><br><span class="line">      <span class="number">27</span>: aload_0</span><br><span class="line">      <span class="number">28</span>: monitorexit                       <span class="comment">// 退出synchronized块</span></span><br><span class="line">      <span class="number">29</span>: goto          <span class="number">37</span></span><br><span class="line">      <span class="number">32</span>: astore_1</span><br><span class="line">      <span class="number">33</span>: aload_0</span><br><span class="line">      <span class="number">34</span>: monitorexit</span><br><span class="line">      <span class="number">35</span>: aload_1</span><br><span class="line">      <span class="number">36</span>: athrow</span><br><span class="line">      <span class="number">37</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field INSTANCE:LTest;</span></span><br><span class="line">      <span class="number">40</span>: areturn</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">          <span class="number">11</span>    <span class="number">29</span>    <span class="number">32</span>   any</span><br><span class="line">          <span class="number">32</span>    <span class="number">35</span>    <span class="number">32</span>   any</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">14</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">20</span>                 <span class="comment">// String test</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">22</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意看 <code>10: monitorenter</code> 和 <code>28: monitorexit</code> 这两条字节码，这就是 <code>synchronized</code> 关键字实际做了的事。</p>
<h2 id="Java对象头和Monitor"><a href="#Java对象头和Monitor" class="headerlink" title="Java对象头和Monitor"></a>Java 对象头和 Monitor</h2><p>要说明白 <code>monitorenter</code> 和 <code>monitorexit</code> 实际干了点啥，那就得先整明白 Java 对象的对象头。</p>
<p>一个 Java 对象，在内存中的布局包括三块区域：对象头、实例数据、和对齐填充。</p>
<p><img data-src="https://blog-static.boris1993.com/how-synchronized-works-in-java/java_object_memory_allocation.png"></p>
<p>别的东西咱们先不看，只看对象头这部分。对象头的最后 2bit 就存储了锁的标志位。</p>
<p>至于 Monitor，Java 官方文档是这么描述的：</p>
<blockquote>
<p>Synchronization is built around an internal entity known as the intrinsic lock or monitor lock. (The API specification often refers to this entity simply as a “monitor.”) Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object’s state and establishing happens-before relationships that are essential to visibility.</p>
<p>Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object’s fields has to acquire the object’s intrinsic lock before accessing them, and then release the intrinsic lock when it’s done with them. </p>
<p>同步是围绕着一个名为 “内在锁” 或 “monitor 锁” 的机制构建的。（API 规范文档中，通常会称其为 “monitor”）<br>内在锁一方面保证了针对一个对象的专属访问权限，另一方面保证了对可见性很重要的 happens-before 原则。<br>每个对象都会有一个与其相关联的内在锁。按照约定，如果一个线程需要持续持有对一个对象的独家访问权限，那么这个线程必须先获得到这个对象的内在锁，然后在执行完毕后释放掉这个内在锁。</p>
</blockquote>
<p>代码执行到 <code>monitorenter</code> 指令，说明开始进入 <code>synchronized</code> 代码块，这时候 JVM 会尝试获取这个对象的 <code>monitor</code> 所有权，即尝试加锁；而执行到 <code>monitorexit</code> 指令，就说明要么 <code>synchronized</code> 代码块执行完毕，要么代码执行的时候抛出了异常，这时候 JVM 就会释放这个对象的 <code>monitor</code> 所有权，即释放锁。</p>
<h2 id="继续深入细节"><a href="#继续深入细节" class="headerlink" title="继续深入细节"></a>继续深入细节</h2><p>上面说的也是云里雾里的，咱继续往深处挖，看看具体的实现。</p>
<p><code>Monitor</code> 这个东西，看 Java 源码找不到，得找虚拟机的 C++ 源码。比如我们常用的 HotSpot 虚拟机中，<code>Monitor</code> 是由 <code>ObjectMonitor</code> 类实现的：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 为了解释方便，仅抄录了相关的代码，并重排了位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectMonitor</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ObjectMonitor</span>() {</span><br><span class="line">            _header       = <span class="literal">NULL</span>;</span><br><span class="line">            _count        = <span class="number">0</span>;</span><br><span class="line">            _waiters      = <span class="number">0</span>,</span><br><span class="line">            _recursions   = <span class="number">0</span>;</span><br><span class="line">            _object       = <span class="literal">NULL</span>;</span><br><span class="line">            _owner        = <span class="literal">NULL</span>;</span><br><span class="line">            _WaitSet      = <span class="literal">NULL</span>;</span><br><span class="line">            _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">            _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">            _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">            _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">            FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">            _EntryList    = <span class="literal">NULL</span> ;</span><br><span class="line">            _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">            _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">            OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">            _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">intptr_t</span>  _count;          <span class="comment">// reference count to prevent reclaimation/deflation</span></span><br><span class="line">                                            <span class="comment">// at stop-the-world time.  See deflate_idle_monitors().</span></span><br><span class="line">                                            <span class="comment">// _count is approximately |_WaitSet| + |_EntryList|</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待锁的线程会被封装成ObjectWaiter对象</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">void</span> *  <span class="keyword">volatile</span> _owner;                <span class="comment">// 一个指针，指向当前拥有锁的线程</span></span><br><span class="line">        ObjectWaiter * <span class="keyword">volatile</span> _WaitSet;       <span class="comment">// 一个队列，保存着waiting状态的线程</span></span><br><span class="line">        ObjectWaiter * <span class="keyword">volatile</span> _EntryList ;    <span class="comment">// 一个队列，保存着因等待锁而被阻塞的线程</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当多个线程同时访问一段 <code>synchronized</code> 代码时，会发生这些操作：</p>
<ul>
<li>线程首先会进入<code>_EntryList</code>，在该线程获取到对象的 <code>monitor</code> 之后，<code>_owner</code> 会指向这个线程，然后<code>_count</code> 计数器加一。<ul>
<li>如果得到 <code>monitor</code> 的这个线程调用了 <code>wait()</code> 方法，那么这个线程将会释放掉 monitor 的所有权，<code>_owner</code> 变量变回 NULL，<code>_count</code> 计数器也会减一，同时这个线程会进入<code>_WaitSet</code> 等待被唤醒。</li>
<li>如果这个线程执行完毕，那么它也将释放 <code>monitor</code>，并复位<code>_count</code> 的值，这样其他的线程也就可以获得 <code>monitor</code> 来加锁了。</li>
</ul>
</li>
<li>上一个线程释放掉 <code>monitor</code> 后，<code>_EntryList</code> 中的线程就会开始争抢 <code>monitor</code>，具体哪个线程能成功得到 <code>monitor</code> 是不确定的。</li>
</ul>
<p>而正因为 Monitor 对象存在于每个 Java 对象头的 <code>mark word</code> 中，所以每个 Java 对象都可以用作锁。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9keW1hbnp5LmdpdGh1Yi5pby8yMDE3LzA4LzA3L3N5bmNocm9uaXplZCVFNCVCOCU4RSVFNSVBRiVCOSVFOCVCMSVBMSVFNyU5QSU4NE1vbml0b3Iv">synchronized 与对象的 Monitor<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2Vzc2VudGlhbC9jb25jdXJyZW5jeS9sb2Nrc3luYy5odG1s">Intrinsic Locks and Synchronization<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNjQwMTk3NTEzMjMw">啃碎并发（七）：深入分析 Synchronized 原理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0pldEJyYWlucy9qZGs4dV9ob3RzcG90L2Jsb2IvbWFzdGVyL3NyYy9zaGFyZS92bS9ydW50aW1lL29iamVjdE1vbml0b3IuaHBwI0wxNDQtTDE2Mg==">objectMonitor.hpp - JetBrains/jdk8u_hotspot<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTY1NTU1NDIvd2h5LWRvLXdlLW5lZWQtdG8tY2FsbC1tb25pdG9yZXhpdC1pbnN0cnVjdGlvbi10d2ljZS13aGVuLXdlLXVzZS1zeW5jaHJvbml6ZWQ=">Why do we need to call ‘monitorexit’ instruction twice when we use ‘synchronized’ keyword? - StackOverflow<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试问题</tag>
        <tag>syncronized</tag>
      </tags>
  </entry>
  <entry>
    <title>突然情绪爆发，暴哭了一场</title>
    <url>/i-cried-just-now.html</url>
    <content><![CDATA[<p>刚才久违的暴哭了一场。</p>
<p>嘛，其实也没暴走多久，满打满算，也就暴走了一个刘强东那么久。</p>
<p>无奈，最近一段时间里，发生了太多闹心的事。</p>
<p>有多闹心呢？你想想，能让一个网瘾少年连游戏都不想玩了，你就想这是有多闹心吧。</p>
<p>已经不记得上次哭是什么时候了，甚至，已经忘了该怎么哭了。</p>
<p>我说我连该怎么引导自己哭出来，都是查的知乎，你信吗。</p>
<p>当然也不是没来由的就哭了，主要还是最近心力交瘁，最后因为一件屁事情绪爆发了。</p>
<p>您要是想看个来龙去脉呢，那就继续往下，看我这个祥林嫂的絮叨吧。</p>
<span id="more"></span>

<p>起初呢，是年中那会，经过哥们啊、领导们啊、当然还有我自己的努力，争取到了一个外派的机会</p>
<p>嗯，这里插句嘴，其实现在我心里都抱着一点歉意的，因为当时领导也是有在挽留的，怎奈当时王八吃秤砣，铁了心的要出去看看这个大世界，最后就还是出来了。</p>
<p>那既然外派出来了，那当然是想要好好的干啊。一方面呢，当时本来就是奔着这边有没玩过的技术，我是来学习的；另一方面呢，我毕竟是外派出来的，也挂着咱老东家的脸呢，出来混，丢啥不能丢老东家的脸呐。</p>
<p>头先派我俩活，一个我忘了是啥了，另一个是给现有的一个系统设计并新增一个功能。</p>
<p>这两次呢，也没跟我规定啥时候交货。我寻思着，按照这个难度，我设计啊编码啊给你做的精细点，一星期也差不多吧。</p>
<p>结果周五验收的时候，负责人表示，我觉得你时间有点太长了。</p>
<p>第一个活，负责人表示我快了一天就搞定，最慢也就三天，按你这效率我不如不要你了。</p>
<p>第二个呢，负责人表示，这个应该四天就能解决的。</p>
<p>这就不太对了吧。开始的时候也没有定一个 deadline，可最后又说你不应该花这么多时间，这是什么操作啊？</p>
<p>第二个活呢，我当时上交设计文档的时候，负责人表示没有什么要修改的，那么我就按照我自己的设计稿去做了。可到了交货的时候，却砍了一个功能。</p>
<p>为啥我要把这个被砍了的功能拎出来说呢？因为那天上午，我就是在写这个功能。如果一开始就砍了不要，那我真的确确实实就只花了四天就完成了。</p>
<p>当时想，算了算了，屁大点事，懒得反驳了，没劲。大不了我后面再证明我自己嘛。</p>
<p>但是我错了。</p>
<p>在上面发生的事情之后不久，我们开始从头设计和开发一个新的系统。而今天这次暴走，也是从这时候开始埋下了雷。</p>
<p>在这个新项目开始不久，某一天，老东家那边的领导跟我讲，这边对我的效率好像不太满意，有一点不想再要我的意思。</p>
<p>我一听，这不行啊。真就这么给我踹回去了，我无所谓，可是这多少会影响那哥们，和老东家的面子啊。</p>
<p>你看啊，咱哥们，又是拼缝，又是联系，里外里没少折腾，最后就整进来这么个怂蛋，这要是后面咱哥们再想介绍谁过来，那他领导不也得犯嘀咕，他可别再给我整个怂蛋来啊。</p>
<p>再看咱老东家，也是费劲巴拉的没少折腾了，结果这废物没干几天就让踹回去了，脸上也不好看啊。</p>
<p>那咋整呢？废话，更玩命的干呗。豁出去命挣个脸皮呗。</p>
<p>可事实整明，我还是 too young too naive 了。脸皮没那么好挣，但是精神却可以消耗的很快。</p>
<p>从谈话之后，我就开始 5*8 的满负载工作。去卫生间，要快。喝水，要快。任何事，都不能影响我的进度。</p>
<p>然后，有一天，就在临下班的时候，突然一阵头晕，我发现我的右眼的上半部分，看不见了。</p>
<p>具体是什么症状呢？就像是一张损坏的图片。下半部分还是画面本来的样子。而上半部分，只剩下一片灰色。</p>
<p>所幸，不是永久的。它只持续了不到一分钟。</p>
<p>但是，我很害怕。我怕下次，就变成了一只眼睛半只瞎。我怕下次，就变成了两只眼睛一只瞎。</p>
<p>当天挂了眼科急诊，第二天又挂了眼科门诊。好在经过各种检查，眼睛没有任何问题，诊断是一时性的供血不足。而且时间很短，没有对眼睛造成什么永久性的损伤。</p>
<p>但是大夫后面说了一句话，让我不淡定了。</p>
<p>“这种一过性的症状，通常不是眼睛的病变，而有可能是脑部的问题。”</p>
<p>啥？老子年纪轻轻的，脑子就坏了？老子不答应！</p>
<p>可我不答应没用啊，还是得拿诊断结果说话。再联系到那段时间总有右脑隐隐的偏头疼，所以也害怕是有肿瘤或者血栓在里面。</p>
<p>于是就先后做了脑 CT 和 MRI。</p>
<p>又是各种请假。而且都这种情况了，我个废物还在考虑会不会拖团队的后腿。</p>
<p>最后结果出来，也算是意料之中，检查都是正常。</p>
<p>脑子里没有什么不该有的东西。血管也很通畅。死不掉，也瘫不了。悬下的心，算是放下了。</p>
<p>既然没事了，那就继续干活吧。</p>
<p>可是好景不长，没过一两天，右耳开始感觉耳鸣。</p>
<p>一开始没管它，结果越是不管，声音越是大。正巧那两天虫子开始叫起来。我一时分不清是真的耳鸣，还是虫子太响。</p>
<p>既然有疑惑，那就得去查。越拖着，疑心越重，没病都能拖出癔症。</p>
<p>其实我是个很胆小的人。我害怕的，不是虫子骑脸，不是被疯子攮了。我怕的是，突然生大病，让远在半个中国以北的爹妈操碎心。</p>
<p>看耳朵的时候，大夫倒是干脆，直接就说，耳屎太多了。开了瓶药，滴两天，把耳屎泡软了之后，找大夫给我取出来，就解决了。</p>
<p>但是这事吧，它就不能平平稳稳的过去。</p>
<p>取耳屎的前一天晚上，滴完了药之后，耳朵眼里开始觉得肿胀，而且，右耳几乎听不见了。</p>
<p>我干哦！最后一天晚上都不让我好好过吗？而且急诊又没有耳鼻喉科！玩我呢吧！</p>
<p>没办法求助万能的网络，结果是，耳屎彻底泡发了，涨起来堵住了耳道，造成传导性耳聋。</p>
<p>哦。耳屎堵了啊。好吧睡觉。明天给孙子掏出来。</p>
<p>第二天，也就是昨天，一大早心事重重的就醒了。赶了早班车，挂最早的号，去掏耳屎。</p>
<p>中间发生了一个插曲。大夫掏耳屎用的是一个吸气的管子，来把耳屎吸出来。而这个管子，让我弄堵住了。是的耳屎太多把管子堵了。</p>
<p>大夫都一脸很受不了的表情，说这玩意都给堵了。</p>
<p>吸完右耳吸左耳。你以为吸完了就完了？右耳里面，还有块钉子户你敢信？</p>
<p>我还得滴两天药水，再过来掏一次。</p>
<p>然后一整天去体检、去退还光猫，这些杂事就按下不表。</p>
<p>晚上回去之后，也不知道是心太累，还是天太热，只觉得心烦意乱。哥几个联机打游戏，我都没法专心的去玩，不知道思绪在哪，一团乱麻。</p>
<p>想着，也到了吃饭的时候了吧，于是就去做饭。做饭的时候，也是心神不宁。</p>
<p>菜出来了，吃了一口，咸，没法吃。</p>
<p>这时候，突然情绪就爆发了。</p>
<p>为什么？为什么就这么多破事？为什么工作也干不好，身体也养不好，就连菜都炒不好？</p>
<p>当时就觉得想哭。但是，又哭不出来。</p>
<p>就像前两天，上海一位住户，住着数百万的房子，却在台风天坏了马桶，蹲地痛哭。区别只是，我没哭出来。</p>
<p>忍着恶心，扔掉饭菜，出门觅食。虽然当时一点胃口都没有，但还是强迫自己吃了一碗小馄饨。</p>
<p>因为，任由自己的坏心情折腾自己，只会让自己离抑郁更近一步。老子，不答应。老子，要乐呵的活着。</p>
<p>然后就是一觉醒来，到了今天 5 点。时间是睡饱了，可是精神还是没有恢复。</p>
<p>早饭是逼着自己吃的。想出去走走，结果隔一分钟换一个目的地。</p>
<p>而且，还是半憋着想哭。</p>
<p>这不是个事，这样下去，解决不了。这样下去，老子要崩。</p>
<p>果断掉头回住处。上网搜，“想哭哭不出来”。嗯，网络就是好，各路大神给支招。</p>
<p>挑了个简单的，只需要三步。</p>
<p>刚做完一步半，感觉就上来了。眼泪啊，kua 的一下，就出来了。</p>
<p>来的快，去的也快。感觉已经哭爽了，再也哭不出来之后，整理思绪，写下了这些絮絮叨叨的东西。</p>
<p>果然啊，心情不好的时候，哭一场，就什么都过去了。</p>
<p>谢谢您耐着性子，跟着这个胆小的家伙，回顾了一下这段波折的人生。</p>
<p>我写这么多呢，就是为了发泄一下。您呢，就当看了一篇文笔拙劣的小说吧。</p>
<p>$EOF.</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA 警告 Field injection is not recommended</title>
    <url>/idea-warninig-field-injection-is-not-recommended.html</url>
    <content><![CDATA[<p>前些天在开发过程中，发现 IDEA 在一个 <code>@Autowired</code> 注解上打了一个警告，内容是 <code>Field injection is not recommended</code>。多年面向 Spring 开发的经验告诉我，使用 <code>@Autowired</code> 注解进行依赖注入，肯定是没有问题的。但是我的代码洁癖不允许我这么不明不白的留一个警告在这里。所以，带着我的洁癖，和我的好奇心，我开始研究起了这个警告。</p>
<span id="more"></span>

<h2 id="警告信息"><a href="#警告信息" class="headerlink" title="警告信息"></a>警告信息</h2><p>这个警告，和警告的处理建议，在 IDEA 中是这么写的：</p>
<p><img data-src="https://blog-static.boris1993.com/idea-warninig-field-injection-is-not-recommended/warning-message.png" alt="Warning Message"></p>
<p>翻译过来是这个意思：</p>
<blockquote>
<p>不建议直接在字段上进行依赖注入。<br>Spring 开发团队建议：在 Java Bean 中永远使用构造方法进行依赖注入。对于必须的依赖，永远使用断言来确认。</p>
</blockquote>
<h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>既然 IDE 给了警告，那就先着手修改。一开始，代码是这样子的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DependencyClass aDependency;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>根据提示，我将代码修改成了这样子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DependencyClass aDependency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AClass</span><span class="params">(DependencyClass aDependency)</span> {</span><br><span class="line">        <span class="built_in">this</span>.aDependency = aDependency;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后警告就消失了，同时运行没有问题，说明这个修改是可行的。</p>
<p>另外，如果你的项目中引入了 <code>Lombok</code>，那么代码甚至可以精简成这样子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 该注解指示Lombok为所有没被初始化过的final的变量创建构造方法</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DependencyClass aDependency;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是，光是改好代码还远远不够，我需要知道，为什么 Spring 团队会提出这一项要求，以及，直接使用 <code>@Autowired</code> 进行依赖注入有什么问题。</p>
<h2 id="依赖注入的类型"><a href="#依赖注入的类型" class="headerlink" title="依赖注入的类型"></a>依赖注入的类型</h2><p>经过我的了解，Spring 有三种依赖注入的类型。</p>
<h3 id="基于field的注入"><a href="#基于field的注入" class="headerlink" title="基于field的注入"></a>基于 field 的注入</h3><p>所谓基于 field 的注入，就是在变量上使用 <code>@Autowired</code> 注解进行依赖注入。这是我们最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式。它用起来就像这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DependencyClass aDependency;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="基于setter方法的注入"><a href="#基于setter方法的注入" class="headerlink" title="基于setter方法的注入"></a>基于 setter 方法的注入</h3><p>通过 <code>setter()</code> 方法，以及在方法上加入 <code>@Autowired</code> 注解，来完成的依赖注入，就是基于 setter 方法的注入。它用起来就像这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DependencyClass aDependency;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setADependency</span><span class="params">(DependencyClass aDependency)</span> {</span><br><span class="line">    <span class="built_in">this</span>.aDependency = aDependency;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注：在 <code>Spring 4.3</code> 及以后的版本中，setter 上面的 <code>@Autowired</code> 注解是可以不写的。</p>
<h3 id="基于构造方法的注入"><a href="#基于构造方法的注入" class="headerlink" title="基于构造方法的注入"></a>基于构造方法的注入</h3><p>将各个必需的依赖全部放在带有 <code>@Autowired</code> 注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。它用起来就像这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span> {</span><br><span class="line">    <span class="comment">// 这里 final 修饰符并不是必须的，但是我喜欢这么做</span></span><br><span class="line">    <span class="comment">// 因为这样不仅可以在代码上防止 aDependency 被修改</span></span><br><span class="line">    <span class="comment">// 在语义上也可以表明 aDependency 是不应该被修改的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DependencyClass aDependency;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AClass</span><span class="params">(DependencyClass aDependency)</span> {</span><br><span class="line">        <span class="built_in">this</span>.aDependency = aDependency;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注：在 <code>Spring 4.3</code> 及以后的版本中，如果这个类只有一个构造方法，那么这个构造方法上面也可以不写 <code>@Autowired</code> 注解。</p>
<h2 id="基于field的注入有什么问题"><a href="#基于field的注入有什么问题" class="headerlink" title="基于field的注入有什么问题"></a>基于 field 的注入有什么问题</h2><p>基于 field 的注入，虽然不是绝对禁止使用，但是它可能会带来一些隐含的问题。比如，在<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J1YW5nb25nMTIwMy9hcnRpY2xlL2RldGFpbHMvNTA5OTIxNDc=">这篇博客<i class="fa fa-external-link-alt"></i></span>中，作者给出了这样的一个代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserAccountServiceImpl</span><span class="params">()</span>{</span><br><span class="line">    <span class="built_in">this</span>.school = user.getSchool();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>初看起来好像没有什么问题，<code>User</code> 类会被作为一个依赖被注入到当前类中，同时这个类的 <code>school</code> 属性将在初始化时通过 <code>user.getSchool()</code> 方法来获得值。但是，这个代码在运行时，却会抛出如下的异常：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name '...' defined in file [....class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [...]: Constructor threw exception; nested exception is java.lang.NullPointerException</span><br></pre></td></tr></tbody></table></figure>

<p>即，在执行 <code>UserAccountServiceImpl()</code> 这个构造方法时出现了 NPE。</p>
<p>出现这个问题的原因是，Java 在初始化一个类时，是按照<code>静态变量或静态语句块 –&gt; 实例变量或初始化语句块 –&gt; 构造方法 -&gt; @Autowired</code> 的顺序 [^1]，那么显而易见，在执行这个类的构造方法时，<code>user</code> 对象尚未被注入，它的值还是 <code>null</code>，从而产生了 NPE。</p>
<p>此外，在代码质量方面，因为基于 field 的注入用起来实在是太方便了，增加一个依赖只需要声明一个变量，然后给它加上 <code>@Autowired</code> 注解，就可以了。而这份便利，有可能会导致这个类的依赖变得越来越多，功能越来越杂，最终违反了单一功能原则。这虽然不会导致功能异常，但是这将增大后续维护的难度。（话虽然这么说，就算我用了基于构造方法的注入，但是用 Lombok 简化了构造方法，这么一来，增加一个依赖又变得更方便了，只需要加一行变量声明就行，如果在不注重代码质量的时候，这也会加剧类的膨胀。所以最后还是得靠工具和审查流程，以及开发者的自觉，来保证代码质量……）</p>
<p>还有一点我个人的感受，就是基于 field 的注解会占据过多的屏幕空间。按照我个人的代码习惯，每个注入之间都要插入一行空行，来把它们分割开来。这意味着，每个注入都将占据 3 行。如果这个类有过多的依赖，那么很有可能光是依赖注入的部分，就会占据大半个屏幕，这会让我看起来很不舒服。当然，出现这种情况，可能同时也意味着这个类已经过于膨胀，违反单一功能原则了。</p>
<h2 id="基于setter的注入和基于构造方法的注入该怎么选择，有什么优点"><a href="#基于setter的注入和基于构造方法的注入该怎么选择，有什么优点" class="headerlink" title="基于setter的注入和基于构造方法的注入该怎么选择，有什么优点"></a>基于 setter 的注入和基于构造方法的注入该怎么选择，有什么优点</h2><p>对于两种注入方式的取舍，Spring 开发团队提供了他们的意见 [^3]：</p>
<blockquote>
<p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies.</p>
</blockquote>
<p>简而言之，<code>对于必需的依赖，使用基于构造方法的注入；对于可选的依赖，使用基于setter的注入</code>。</p>
<p>同时 Spring 开发团队也讲明了两种注入方式的优点。对于基于构造方法的注入，Spring 团队是这么说的：</p>
<blockquote>
<p>The Spring team generally advocates constructor injection as it enables one to implement application components as immutable objects and to ensure that required dependencies are not null. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.<br>Spring 团队提倡使用基于构造方法的注入，因为这样一方面可以将依赖注入到一个不可变的变量中 (注：<code>final</code> 修饰的变量)，另一方面也可以保证这些变量的值不会是 null。此外，经过构造方法完成依赖注入的组件 (注：比如各个 <code>service</code>)，在被调用时可以保证它们都完全准备好了。与此同时，从代码质量的角度来看，一个巨大的构造方法通常代表着出现了代码异味，这个类可能承担了过多的责任。</p>
</blockquote>
<p>而对于基于 setter 的注入，他们是这么说的：</p>
<blockquote>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later.<br>基于 setter 的注入，则只应该被用于注入非必需的依赖，同时在类中应该对这个依赖提供一个合理的默认值。如果使用 setter 注入必需的依赖，那么将会有过多的 null 检查充斥在代码中。使用 setter 注入的一个优点是，这个依赖可以很方便的被改变或者重新注入。</p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>虽然上面洋洋洒洒写 (chao) 了那么多，又是分析优劣，又是分析场景的，但是按照我现在仅有的开发经验来看，好像怎么注入区别都不大 (除了 setter 注入，这个我没用过)，要说我为什么一定要用构造方法注入，最大的原因其实就是为了去掉那个警告……</p>
<p>也有人说，都这么写习惯了，又没出啥问题，你把这个警告关了不就行了吗？我的回答是：</p>
<p><img data-src="https://blog-static.boris1993.com/idea-warninig-field-injection-is-not-recommended/but-i-resist.png" alt="だが断る！"></p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2MjMxNTU1LzM4MzM4NTg=">Spring Bean: Is autowired attribute initialised before constructor?<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly93d3cudm9qdGVjaHJ1emlja2EuY29tL2ZpZWxkLWRlcGVuZGVuY3ktaW5qZWN0aW9uLWNvbnNpZGVyZWQtaGFybWZ1bC8=">Field Dependency Injection Considered Harmful<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy80LjIueC9zcHJpbmctZnJhbWV3b3JrLXJlZmVyZW5jZS9odG1sL2JlYW5zLmh0bWwjYmVhbnMtc2V0dGVyLWluamVjdGlvbg==">Setter-based dependency injection<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC 错误 Illegal mix of collations 解决方法</title>
    <url>/illegal-mix-of-collations.html</url>
    <content><![CDATA[<p>最近项目开发时遇到了一个错误，内容是<br><code>Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation '='</code><br>经查是关联查询时两个表的排序规则 (collation) 不同导致的。</p>
<span id="more"></span>

<p>解决方法也很简单，有两种方法：</p>
<p>一种是在查询的 SQL 中指定另一张表的 collation，这是一种权宜之计，治标不治本。代码是这样的：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设左表的排序规则是 utf8_general_ci,</span></span><br><span class="line"><span class="comment">-- 而右表的排序规则是 utf8_unicode_ci</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    `a`.`column1`,</span><br><span class="line">    `b`.`column2`</span><br><span class="line"><span class="keyword">FROM</span> `table_1` <span class="keyword">AS</span> `a`</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `table_2` <span class="keyword">AS</span> `b`</span><br><span class="line">    <span class="keyword">ON</span> `a`.`id` <span class="operator">=</span> `b`.`id`</span><br><span class="line">    <span class="keyword">COLLATE</span> `utf8_general_ci`</span><br></pre></td></tr></tbody></table></figure>

<p>另一种方法是修改表和列的排序规则，将其统一。这个方法从根本上解决了这个问题。操作方法可以参考<a href="/database/mysql/mysql-convert-tables-and-columns-collation.html">在 MySQL 中修改表和列的排序规则
</a>。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 ELK 日志平台 - 安装 Elastic Search</title>
    <url>/install-elk-part-es.html</url>
    <content><![CDATA[<p>最近搭建了一次 ELK 日志平台，在此记录一下安装步骤。由于本次模拟的是服务器不能连接互联网的情况，所以全部安装步骤皆使用 RPM 或 tar 包的方式安装。本文主要记录安装 Elastic Search 的过程。</p>
<span id="more"></span>

<h1 id="安装JRE"><a href="#安装JRE" class="headerlink" title="安装JRE"></a>安装 JRE</h1><p>首先这套平台是基于 Java 的，所以 Java 运行环境当然是不能少。但因为这上面不涉及 Java 的开发，所以不需要装 JDK，装 JRE 就够了，还能省下一些磁盘空间。我这里选择 <code>JRE8u161</code>。</p>
<p>我这次选择使用 RPM 包安装。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo rpm -ivh jre-8u161-linux-x64.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>安装完毕后，验证安装是否成功：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 检验当前用户下是否安装成功</span></span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检验sudo环境下是否安装成功</span></span><br><span class="line">sudo java -version</span><br></pre></td></tr></tbody></table></figure>

<p>若都输出如下内容则说明安装成功：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">java version "1.8.0_161"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></tbody></table></figure>

<p>至此 Java 环境配置完成</p>
<h1 id="安装Elastic-Search"><a href="#安装Elastic-Search" class="headerlink" title="安装Elastic Search"></a>安装 Elastic Search</h1><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="使用RPM包安装"><a href="#使用RPM包安装" class="headerlink" title="使用RPM包安装"></a>使用 RPM 包安装</h3><p>直接使用 rpm 命令安装该 RPM 包</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo rpm --install elasticsearch-6.2.2.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>CentOS 7 使用 systemd 管理开机自启动项，而且安装过程已经配置好针对 systemd 的启动脚本，使用如下命令激活</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> elasticsearch.service</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用tar-gz包安装"><a href="#使用tar-gz包安装" class="headerlink" title="使用tar.gz包安装"></a>使用 tar.gz 包安装</h3><p>首先新建一个名为 elk 的用户，用于运行 ELK 平台</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">useradd -m elk</span><br></pre></td></tr></tbody></table></figure>

<p>下载好 Elastic Search 的安装包，将其复制到 /opt 并解压，然后试运行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> elasticsearch-6.1.3.tar.gz /opt</span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">sudo tar xvzf elasticsearch-6.1.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要将Elastic Search目录的所有权设为将要运行该软件的用户</span></span><br><span class="line"><span class="comment"># Elastic Search不允许以root用户运行，安全方面亦不建议以root权限运行程序</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R elk:elk elasticsearch-6.1.3</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> elasticsearch-6.1.3/bin</span><br><span class="line">./elelasticsearch</span><br></pre></td></tr></tbody></table></figure>

<p>启动成功后，在另一终端使用 curl 尝试连接 Elastic Search</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:9200</span><br></pre></td></tr></tbody></table></figure>

<p>若有如下返回，则说明 Elastic Search 启动成功</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"name"</span> <span class="punctuation">:</span> <span class="string">"LWmSd17"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"cluster_name"</span> <span class="punctuation">:</span> <span class="string">"elasticsearch"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"cluster_uuid"</span> <span class="punctuation">:</span> <span class="string">"lkbXufQpQuiLaE5kzVKAeA"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"version"</span> <span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"number"</span> <span class="punctuation">:</span> <span class="string">"6.1.3"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"build_hash"</span> <span class="punctuation">:</span> <span class="string">"af51318"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"build_date"</span> <span class="punctuation">:</span> <span class="string">"2018-01-26T18:22:55.523Z"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"build_snapshot"</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"lucene_version"</span> <span class="punctuation">:</span> <span class="string">"7.1.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"minimum_wire_compatibility_version"</span> <span class="punctuation">:</span> <span class="string">"5.6.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"minimum_index_compatibility_version"</span> <span class="punctuation">:</span> <span class="string">"5.0.0"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"tagline"</span> <span class="punctuation">:</span> <span class="string">"You Know, for Search"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h2><h3 id="系统配置文件修改"><a href="#系统配置文件修改" class="headerlink" title="系统配置文件修改"></a>系统配置文件修改</h3><p>Elastic Search 需要调整文件描述符大于 65535、最大线程数大于 4096、以及 <code>vm.max_map_count</code> 大于 262144。所以修改操作系统配置文件以满足此要求。</p>
<p>在 <code>/etc/security/limits.conf</code> 插入如下内容</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* hard nofile 65536</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nproc  4096</span><br><span class="line">* soft nproc  4096</span><br></pre></td></tr></tbody></table></figure>

<p>在 <code>/etc/sysctl.conf</code> 中插入如下内容</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></tbody></table></figure>

<p>然后执行 <code>sysctl -p</code>，并重新登录，使配置生效。若配置成功，则可见 Elastic Search 启动过程中相关的警告信息将不再出现。</p>
<h3 id="Elastic-Search配置文件修改"><a href="#Elastic-Search配置文件修改" class="headerlink" title="Elastic Search配置文件修改"></a>Elastic Search 配置文件修改</h3><p><strong>以下文件位置根据安装方法不同而不同</strong><br><strong>若使用 RPM 包方式安装，则文件位于 /etc/elasticsearch</strong><br><strong>若使用 tar 包方式安装，则文件位于解压出来的目录的 conf 文件夹中</strong></p>
<ul>
<li><p>修改 <code>cluster.name</code><br>我们应当将集群名设置成一个能清晰地表明该集群的作用的名字，如 <code>logging-prod</code>。</p>
</li>
<li><p>修改 <code>node.name</code><br>为每个 Elastic Search 节点起一个清晰易懂的名字绝不会是一件坏事。<br>节点名字可以是一个自定义的名字，如 <code>prod-data-2</code>，也可以使用 <code>${HOSTNAME}</code> 来把本机的主机名作为该节点的节点名。</p>
</li>
<li><p>其他详细配置<br>要想了解更多配置，可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L2luZGV4Lmh0bWw="> Elasticsearch Reference
<i class="fa fa-external-link-alt"></i></span>的 <strong>Set up Elasticsearch</strong> 部分。</p>
</li>
</ul>
<h3 id="配置自动启动"><a href="#配置自动启动" class="headerlink" title="配置自动启动"></a>配置自动启动</h3><p>如果使用 RPM 包方式安装，则此步可忽略。</p>
<p>若使用 tar 包方式安装，则进入 Elastic Search 的 bin 目录后运行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">./elasticsearch -d -p ../logs/elasticsearch.pid</span><br></pre></td></tr></tbody></table></figure>

<p>使 Elastic Search 以 daemon 模式启动并监控启动过程。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L19pbnN0YWxsYXRpb24uaHRtbA==">Elastic Search Installation Guide<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Elastic Search</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 ELK 日志平台 - 安装 Kibana</title>
    <url>/install-elk-part-kibana.html</url>
    <content><![CDATA[<p>上一次我们安装好了 Elastic Search 和 Logstash，本次我们继续安装 Kibana。</p>
<span id="more"></span>

<h1 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装 Kibana</h1><p>Kibana 也提供了 RPM 安装包，所以还是一样的套路：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo rpm -ivh kibana-6.2.2-x86_64.rpm</span><br></pre></td></tr></tbody></table></figure>

<h1 id="配置Kibana及防火墙"><a href="#配置Kibana及防火墙" class="headerlink" title="配置Kibana及防火墙"></a>配置 Kibana 及防火墙</h1><p>编辑 <code>/etc/kibana.yml</code></p>
<p>这里比较关键的一点，是要指定 Elastic Search 的位置。如果 Elastic Search 是安装在本机，并监听默认的 9200 端口的话，则不需要修改该配置。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># The URL of the Elasticsearch instance to use for all your queries.</span></span><br><span class="line"><span class="comment">#elasticsearch.url: "http://localhost:9200"</span></span><br></pre></td></tr></tbody></table></figure>

<p>另外 Kibana 默认仅能从本机访问，若要开放给局域网，还需要修改 Kibana 监听的地址和端口号，并配置防火墙允许该端口通信：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Kibana is served by a back end server. This setting specifies the port to use.</span></span><br><span class="line"><span class="comment">#server.port: 5601</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.</span></span><br><span class="line"><span class="comment"># The default is 'localhost', which usually means remote machines will not be able to connect.</span></span><br><span class="line"><span class="comment"># To allow connections from remote users, set this parameter to a non-loopback address.</span></span><br><span class="line"><span class="comment"># 如果要绑定到特定的某一块网卡，那么就将这里的地址设为那块网卡的IP地址</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">"0.0.0.0"</span></span><br></pre></td></tr></tbody></table></figure>

<p>Cent OS 7 使用 firewalld 管理防火墙，所以使用如下命令开放 Kibana 的端口：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=5601/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure>

<h1 id="启动Kibana"><a href="#启动Kibana" class="headerlink" title="启动Kibana"></a>启动 Kibana</h1><p>我们这里同样使用 systemd 来管理 Kibana 的起停和自启动。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> kibana</span><br><span class="line">sudo systemctl start kibana</span><br></pre></td></tr></tbody></table></figure>

<p>然后即可使用浏览器访问 Kibana</p>
<h1 id="配置index-pattern"><a href="#配置index-pattern" class="headerlink" title="配置index pattern"></a>配置 index pattern</h1><p>Kibana 启动后，会要求配置索引，根据提示步骤配置即可。配置过程结束后，可到 Discover 页检查是否读到数据。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9raWJhbmEvY3VycmVudC9pbmRleC5odG1s">Kibana User Guide<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 ELK 日志平台 - 安装 Logstash</title>
    <url>/install-elk-part-logstash.html</url>
    <content><![CDATA[<p>上回书说道，我们已经安装好了 Elastic Search。那么这次，我们继续安装 Logstash。</p>
<span id="more"></span>

<h1 id="安装Logstash"><a href="#安装Logstash" class="headerlink" title="安装Logstash"></a>安装 Logstash</h1><p>为了安装方便，本次依旧选择使用 RPM 包安装。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo rpm -ivh logstash-6.2.2.rpm</span><br></pre></td></tr></tbody></table></figure>

<p>安装结束后，运行 Logstash 以检查安装是否成功。使用如下命令启动 Logstash，并配置输入源为基本输入 (stdin)，以及输出到基本输出 (stdout)：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 因为使用RPM方式安装，导致/usr/share/logstash/data仅root才可写入，所以需要使用sudo环境</span></span><br><span class="line">sudo /usr/share/logstash/bin/logstash -e <span class="string">'input{ stdin{} } output{ stdout{} }'</span></span><br></pre></td></tr></tbody></table></figure>

<p>在日志滚动停止后，随意输入一些字符串，比如”hello world”，并回车，检查输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">2018-02-26T07:18:07.904Z localhost.localdomain hello world</span><br></pre></td></tr></tbody></table></figure>

<p>可见 Logstash 成功从 stdin 读取到了输入，并打印到了 stdout，证实安装成功。</p>
<h1 id="配置Logstash"><a href="#配置Logstash" class="headerlink" title="配置Logstash"></a>配置 Logstash</h1><h2 id="Logstash系统配置"><a href="#Logstash系统配置" class="headerlink" title="Logstash系统配置"></a>Logstash 系统配置</h2><p>编辑 <code>/etc/logstash/logstash.yml</code>，修改 Logstash 系统级配置。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 配置节点名，若未配置则默认取本机主机名作为节点名</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">elk-logstash-node-0</span></span><br></pre></td></tr></tbody></table></figure>

<p>其他配置项略，如有需要请参考 Logstash Reference。</p>
<h2 id="日志输入输出配置"><a href="#日志输入输出配置" class="headerlink" title="日志输入输出配置"></a>日志输入输出配置</h2><p>这里我们配置让 Logstash 接收 Cent OS 的系统日志。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">input {</span><br><span class="line">  file {</span><br><span class="line">    path =&gt; "/var/log/messages*"</span><br><span class="line">    type =&gt; "syslog"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># Filter not needed. Commented out.</span><br><span class="line">#filter {</span><br><span class="line">#</span><br><span class="line">#}</span><br><span class="line"></span><br><span class="line">output {</span><br><span class="line">  elasticsearch {</span><br><span class="line">    hosts =&gt; "localhost:9200"</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另外，本例中还需要配置 Logstash 以 root 权限运行以读取系统日志 (messages 文件默认权限为 600)，实际使用时需要按照实际需求配置。</p>
<p>编辑 <code>/etc/systemd/system/logstash.service</code>，修改 user 和 group 为 root</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=logstash</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">User</span>=root</span><br><span class="line"><span class="attr">Group</span>=root</span><br><span class="line"><span class="comment"># Load env vars from /etc/default/ and /etc/sysconfig/ if they exist.</span></span><br><span class="line"><span class="comment"># Prefixing the path with '-' makes it try to load, but if the file doesn't</span></span><br><span class="line"><span class="comment"># exist, it continues onward.</span></span><br><span class="line"><span class="attr">EnvironmentFile</span>=-/etc/default/logstash</span><br><span class="line"><span class="attr">EnvironmentFile</span>=-/etc/sysconfig/logstash</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/share/logstash/bin/logstash <span class="string">"--path.settings"</span> <span class="string">"/etc/logstash"</span></span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">WorkingDirectory</span>=/</span><br><span class="line"><span class="attr">Nice</span>=<span class="number">19</span></span><br><span class="line"><span class="attr">LimitNOFILE</span>=<span class="number">16384</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></tbody></table></figure>

<p>然后使 systemd 重新加载配置文件并重新启动 Logstash</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart logstash</span><br></pre></td></tr></tbody></table></figure>

<h2 id="使Logstash开机自启动"><a href="#使Logstash开机自启动" class="headerlink" title="使Logstash开机自启动"></a>使 Logstash 开机自启动</h2><p>由于 RPM 包安装时已经放好了自启动的配置文件，我们只需要在 systemd 中激活它就可以了。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> logstash</span><br><span class="line">sudo systemctl start logstash</span><br></pre></td></tr></tbody></table></figure>

<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9sb2dzdGFzaC9jdXJyZW50L2luZGV4Lmh0bWw=">Logstash Reference<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 的一个 SNI 的 bug</title>
    <url>/java-8-sni-bug.html</url>
    <content><![CDATA[<p>联动<a href="/tools/nginx/resolving-nginx-sni-issue.html">上一篇博文</a>，在解决了 OpenResty 上那个 SNI 的问题之后，我们发现有一个 Java 应用也有类似的问题。而最后发现，这是因为我们当前版本的 Java 中有一个 bug……</p>
<p>简单来说，就是在 <code>Java 1.8u141</code> 之前，<code>HttpsURLConnection#setDefaultHostnameVerifier()</code> 方法会破坏 SNI，而正好我们的代码里有这么一行：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -&gt; <span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>翻了下框架的代码，发现如果我不设定这个值，框架也调用这个方法来指定它默认的 hostname verifier；而如果我传个 null，那么它会抛个异常给我。所以，代码层面没有很方便的解决方案。</p>
<p>无奈，最后决定，先临时换了个没开启 SNI 的域名，暂时解决掉问题，然后升级 Java 到 <code>1.8u181</code>，一劳永逸。</p>
<hr>
<p>终于，我也有机会理直气壮地喊出 “这是 Java 的 bug” 了！（笑</p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzA4MTc5MzQvZXh0ZW5kZWQtc2VydmVyLW5hbWUtc25pLWV4dGVuc2lvbi1ub3Qtc2VudC13aXRoLWpkazEtOC0wLWJ1dC1zZW5kLXdpdGgtamRrMS03">Extended server_name (SNI Extension) not sent with jdk1.8.0 but send with jdk1.7.0<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsuamF2YS5uZXQvYnJvd3NlL0pESy04MDcyNDY0">Custom HostnameVerifier disables SNI support on client in Java 8<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>SNI</tag>
        <tag>Java 8</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Java bean 中实现 setter 的链式调用</title>
    <url>/java-bean-chaining-setters.html</url>
    <content><![CDATA[<p>在经年累月的开发中，你是不是已经对动辄数行的<code>.setXXX()</code> 方法厌烦了呢？在这篇博文中，我将介绍一个小技巧，可以稍稍让你的代码变得美观一些。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常来说，一个 POJO 大致上会是这样的</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getScore</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(Integer score)</span> {</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，在赋值的时候，会是这样的</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">james</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">james.setName(<span class="string">"James"</span>);</span><br><span class="line">james.setAge(<span class="number">22</span>);</span><br><span class="line">james.setScore(<span class="number">80</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>上面这三行 set 方法，本来没干什么事，却要写 3 行代码六十多个字，是不是看起来很难受，写起来很费劲？</p>
<p>那么，这时候就可以通过链式调用 setter 来显著减少代码行数。</p>
<h2 id="Setter的链式调用"><a href="#Setter的链式调用" class="headerlink" title="Setter的链式调用"></a>Setter 的链式调用</h2><p>首先，要实现链式调用 setter，就得稍微修改一下 setter 方法。放心，改动量是很小的，对业务是没有影响的，操作也是一劳永逸的。</p>
<p>具体做法呢，就是让 setter 返回这个 POJO 类型，而不是 void，然后将 <code>this</code> 返回，比如这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Student <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">setAge</span><span class="params">(Integer age)</span> {</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">setScore</span><span class="params">(Integer score)</span> {</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，在创建对象的时候，就可以这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().setName(<span class="string">"james"</span>).setAge(<span class="number">22</span>).setScore(<span class="number">80</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>怎么样？是不是突然变得很短很简洁？写起来是不是很方便？</p>
<p>但是，要一个个改那么多 setter，也挺麻烦的，特别是 IDE 里面还不一定能自动化，有没有更好的办法？</p>
<p>答案是，有！</p>
<p>是啥呢？</p>
<p>Lombok！</p>
<h2 id="用Lombok实现setter的链式调用"><a href="#用Lombok实现setter的链式调用" class="headerlink" title="用Lombok实现setter的链式调用"></a>用 Lombok 实现 setter 的链式调用</h2><p>Lombok 是一个自动生成模版代码的工具，像构造方法啊、getter 和 setter 啊，都可以用一个或多个注解来代替，然后在编译期由 Lombok 替你写这部分的代码。如果你还没用过，那么请务必学习和试用一下，它可以为你省下那些浪费在模版代码上的时间。</p>
<p>在引入了 Lombok 之后，你就可以把上文的 <code>Student</code> 类重构成这样子了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>是的，你不再需要去写 getter 和 setter 了，更不需要一个个的去修改来让它支持链式调用了。只需要两个注解，就可以完成上面的一大片工作。</p>
<p>第一行的 <code>@Data</code> 注解，是一系列注解的集合，用来生成一系列的模版代码。由于这不是本文重点，所以就不再展开说了。</p>
<p>第二行的 <code>@Accessors</code> 注解，就是这里的重点了，它用来设定 Lombok 应该怎样生成 setter 和 getter 代码。而其中的 <code>chain</code> 属性，就是打开链式 setter 的开关，将它打开之后，就可以生成支持链式调用的 setter 方法。</p>
<p>然后，你就可以像上文一样，去享受链式调用了。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自定义注解</title>
    <url>/java-customized-annotations.html</url>
    <content><![CDATA[<p>注解是 Java 5 引入的一个新特性，它提供了一个用来将信息和元数据与程序元素相关联的能力，其作用如同一个修饰符，本身并不包含任何程序逻辑。</p>
<p>本文将介绍如何创建和使用自定义的注解。</p>
<span id="more"></span>

<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>Java 自带了四个作用于注解上的注解，即元注解，分别是：</p>
<ul>
<li><code>@Documented</code>，用于注明该注解是否包含于 JavaDoc 中</li>
<li><code>@Retention</code>，用于注明这个注解将保留到什么时候</li>
<li><code>@Target</code>，用于注明这个注解将作用于哪些元素上</li>
<li><code>@Inherit</code>，用于注明该注解是否会被子类继承</li>
</ul>
<h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><code>@Retention</code></h2><p><code>@Retention</code> 元注解定义了这个注解的生命周期，即这个注解将保留到什么时候。注解的生命周期有这三种：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：仅在源码中保留，在编译期就会被丢弃。比如 <code>@Override</code> 和 <code>@SuppressWarnings</code> 就属于这类注解</li>
<li><code>RetentionPolicy.CLASS</code>：注解将会被写入到字节码中，但是在运行时会被丢弃。这个是默认的生命周期。</li>
<li><code>RetentionPolicy.RUNTIME</code>：该注解将保留至运行时。这意味着在运行时可以通过反射机制读取到注解的信息。</li>
</ul>
<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><code>@Target</code></h2><p><code>@Target</code> 元注解指定了该注解将可用于哪些元素上。可用的参数有如下几种：</p>
<ul>
<li><code>ElementType.ANNOTATION_TYPE</code>，用于描述注解。<code>@Target(ElementType.ANNOTATION_TYPE)</code> 标注的注解将成为一个元注解。</li>
<li><code>ElementType.CONSTRUCTOR</code>，用于描述构造方法</li>
<li><code>ElementType.FIELD</code>，用于描述成员变量、对象、属性（包括 enum 实例）</li>
<li><code>ElementType.LOCAL_VARIABLE</code>，用于描述局部变量</li>
<li><code>ElementType.METHOD</code>，用于描述方法</li>
<li><code>ElementType.PACKAGE</code>，用于描述包</li>
<li><code>ElementType.PARAMETER</code>，用于描述参数</li>
<li><code>ElementType.TYPE</code>，用于描述类、接口（包括注解）、enum 生命声明</li>
</ul>
<p>Java 8 中又新增了两个参数：</p>
<ul>
<li><code>ElementType.TYPE_PARAMETER</code>，可以用在 Type 的声明前</li>
<li><code>ElementType.TYPE_USE</code>，可以用在使用 Type 的地方</li>
</ul>
<h1 id="编写自定义注解及相关方法"><a href="#编写自定义注解及相关方法" class="headerlink" title="编写自定义注解及相关方法"></a>编写自定义注解及相关方法</h1><p>自定义注解的类型为 <code>@interface</code>，注解中可以包含方法，方法名将作为注解的属性。</p>
<p>注解中的方法不可以有参数，也不可以抛出异常，同时方法只能返回原始类型、<code>String</code>、<code>Class</code>、<code>enums</code>、注解类型，以及上述类型的数组。方法的默认值不可以是 <code>null</code>。</p>
<p>下面将通过一个示例演示如何编写和使用自定义注解相关的方法。</p>
<p>示例将分别创建两个名为 <code>@JsonSerializable</code> 和 <code>@JsonElement</code> 的注解，以及一个名为 <code>JsonUtils</code> 的工具类。</p>
<p><code>@JsonSerializable</code> 标记一个类可以被序列化成 JSON，<code>@JsonElement</code> 标记一个成员变量将会被包含在这个 JSON 中；<code>JsonUtils</code> 工具类包含将对象序列化为 JSON 的方法。</p>
<h2 id="JsonSerializable"><a href="#JsonSerializable" class="headerlink" title="@JsonSerializable"></a><code>@JsonSerializable</code></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记一个类可以被序列化成JSON</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解要在运行时通过反射获取，所以retention为runtime</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解作用于一个类，所以target为type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonSerializable {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="JsonElement"><a href="#JsonElement" class="headerlink" title="@JsonElement"></a><code>@JsonElement</code></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记一个成员变量将会被包含在这个JSON中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解要在运行时通过反射获取，所以retention为runtime</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为这个注解作用于成员变量，所以target为field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JsonElement {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定该成员变量在JSON中的key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="JsonUtils"><a href="#JsonUtils" class="headerlink" title="JsonUtils"></a><code>JsonUtils</code></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonUtils</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象序列化为JSON</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 要序列化的对象，需要有{<span class="doctag">@link</span> JsonSerializable}注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 序列化后的JSON字符串，如果不可序列化则是null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">serializeToJson</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查对象是否可以被序列化</span></span><br><span class="line">        <span class="keyword">if</span> (!isSerializable(object)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得对象所属的类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> object.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得类中的所有方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得所有方法的方法名，后面用于搜索</span></span><br><span class="line">        List&lt;String&gt; methodNames = Arrays.stream(methods).map(Method::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得类中所有成员变量，包括public、protected、private、和默认访问权限的</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个空的HashMap，用于存放要序列化的属性的名字和值</span></span><br><span class="line">        Map&lt;String, String&gt; elements = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(fields.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有成员变量</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) {</span><br><span class="line">            <span class="comment">// 如果有JsonElement注解</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(JsonElement.class)) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取得变量名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> field.getName();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拼接其对应getter方法名</span></span><br><span class="line">                <span class="comment">// 不直接使用setAccessible()方法是因为我不喜欢这么干，这会破坏封装性</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">getterName</span> <span class="operator">=</span> <span class="string">"get"</span> + fieldName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查这个变量是否有getter方法</span></span><br><span class="line">                <span class="keyword">if</span> (methodNames.contains(getterName)) {</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果有getter方法，则根据方法名取得对应的方法实例</span></span><br><span class="line">                    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(getterName);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取得JsonElement注解中设定的key值</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">keyName</span> <span class="operator">=</span> field.getAnnotation(JsonElement.class).key();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果key的值为空字符串，则使用属性名作为JSON中的key名</span></span><br><span class="line">                    <span class="comment">// 否则取指定的key名</span></span><br><span class="line">                    <span class="comment">// 并调用变量对应的getter方法取得变量的值</span></span><br><span class="line">                    <span class="comment">// 最后放入HashMap中</span></span><br><span class="line">                    elements.put(<span class="string">""</span>.equals(keyName) ? field.getName() : keyName, String.valueOf(method.invoke(object)));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历HashMap，构造JSON内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> elements.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                <span class="comment">// 取得每个元素的key名和值，拼接成 \t"key":"value" 的形式</span></span><br><span class="line">                .map(entry -&gt; <span class="string">"\t\""</span> + entry.getKey() + <span class="string">"\":\""</span> + entry.getValue() + <span class="string">"\""</span>)</span><br><span class="line">                <span class="comment">// 每行元素间插入分隔符，逗号分隔每行数据，\n实现换行</span></span><br><span class="line">                .collect(Collectors.joining(<span class="string">",\n"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后拼接JSON首尾的大括号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"{\n"</span> + jsonBody + <span class="string">"\n}"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查对象是否可被序列化成JSON</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 将被序列化的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否可被序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSerializable</span><span class="params">(Object object)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// null不可被序列化</span></span><br><span class="line">        <span class="keyword">if</span> (object == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> object.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有JsonSerializable注解，即可被序列化</span></span><br><span class="line">        <span class="keyword">return</span> clazz.isAnnotationPresent(JsonSerializable.class);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="使用自定义注解"><a href="#使用自定义注解" class="headerlink" title="使用自定义注解"></a>使用自定义注解</h1><p>首先创建一个 <code>BookModel</code> 类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 书籍信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JsonSerializable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookModel</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement(key = "bookname")</span> <span class="comment">// 在JSON中将bookName重命名为bookname</span></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement</span></span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonElement</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookModel{"</span> +</span><br><span class="line">                <span class="string">"bookName='"</span> + bookName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", category='"</span> + category + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getter，setter和构造方法略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来在 main 方法里构造对象，并将其序列化成 JSON：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">BookModel</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookModel</span>(<span class="string">"Head First Java"</span>, <span class="string">"Java"</span>, <span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        System.out.println(JsonUtils.serializeToJson(book));</span><br><span class="line">    } <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>序列化后的结果将是这样：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"bookname"</span><span class="punctuation">:</span><span class="string">"Head First Java"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"category"</span><span class="punctuation">:</span><span class="string">"Java"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"price"</span><span class="punctuation">:</span><span class="string">"55"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>Annotations</tag>
      </tags>
  </entry>
  <entry>
    <title>快速理解 Java 中的守护线程</title>
    <url>/java-daemon-thread.html</url>
    <content><![CDATA[<p>面试的时候被问到 “了解不了解守护线程”，可本菜别提了解了，听都没听说过。所以面试之后赶紧上网冲浪学习起来。</p>
<span id="more"></span>

<h2 id="什么是守护线程"><a href="#什么是守护线程" class="headerlink" title="什么是守护线程"></a>什么是守护线程</h2><p>首先我们要知道，Java 中存在两种线程，用户线程和守护线程。</p>
<p>用户线程就是我们平时最常用到的那种线程，它属于高优先级线程，JVM 在退出前会等待所有用户线程完成。</p>
<p>守护线程则是低优先级线程，它的作用是为用户线程提供服务，不会阻止 JVM 退出（不能 100% 保证，不良的代码仍会阻止 JVM 退出）。</p>
<blockquote>
<p>即 Thread#setDaemon (boolean) 方法的 JavaDoc 提到的<br>The Java Virtual Machine exits when the only threads running are all daemon threads.</p>
</blockquote>
<h2 id="守护线程能干什么"><a href="#守护线程能干什么" class="headerlink" title="守护线程能干什么"></a>守护线程能干什么</h2><p>常见的场景有垃圾回收、释放未使用的对象的内存、从缓存中释放不需要的条目等等。</p>
<h2 id="怎么创建守护线程"><a href="#怎么创建守护线程" class="headerlink" title="怎么创建守护线程"></a>怎么创建守护线程</h2><p>调用 <code>Thread#setDaemon(boolean)</code> 方法就可以让一个线程变成守护线程，如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Main thread exited."</span>);</span><br><span class="line">        }));</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Thread is running..."</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                System.out.println(<span class="string">"Thread exited."</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一定要在Thread#start()前调用，否则会抛IllegalThreadStateException异常</span></span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Main thread exiting....."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将上面代码运行后，可以在控制台看到如下输出：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Main thread exiting.....</span><br><span class="line">Main thread exited.</span><br></pre></td></tr></tbody></table></figure>

<p>可见，虽然线程中执行的是一个死循环，但是 JVM 在结束时，不会理会 <code>thread</code> 还在运行，直接就退出了。同样还可以看到的是，<code>finally</code> 块并没有执行，所以在守护线程中不要使用任何需要关闭的资源，比如打开文件，因为守护线程退出的时候，它没有任何机会来关闭文件，就会导致数据丢失（我感觉就像 <code>kill -9</code> 掉一个正在内存中处理文件内容的进程，<code>SIGKILL</code> 信号不会给这个进程任何善后的时间）。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>守护线程</tag>
        <tag>面试</tag>
        <tag>daemon thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的垃圾回收算法</title>
    <url>/java-gc-algorithms.html</url>
    <content><![CDATA[<p>在 <a href="/projects/java/fundamentals/java-jvm-runtime-data-areas.html">JVM 运行时的数据区域</a>中了解到了 JVM 的内存模型，那么既然使用了内存，就要考虑如何回收内存。与 C 语言不同，Java 不需要开发人员人工回收内存，而是交给 Java 的垃圾回收机制来完成。</p>
<span id="more"></span>

<h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h2><p>在 Java 中，GC 的对象是堆和方法区。栈中的栈帧随着方法的调用和退出，会自行完成压栈和出栈操作，每个栈帧所需的内存空间也是在类结构确定下来时就已知的，所以不怎么需要考虑内存的回收问题。但是堆和方法区则不一样，这部分的空间是动态分配和回收的，同时也只有在运行时才可得知要生成哪些对象以及需要多少空间。</p>
<p>判断对象是否可以被回收通常有两种算法：<code>引用计数法</code>和<code>可达性分析法</code>。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法会给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就会加一；反之，每当一个引用失效时，计数器就会减一。任何时候，如果引用计数为 0，则说明这个对象可以被回收。</p>
<p><img data-src="https://blog-static.boris1993.com/java-gc-algorithms/reference-counter.png" alt="Reference counter"></p>
<p>但是，这个算法有一个问题，那就是无法处理循环引用，即这样：</p>
<p><img data-src="https://blog-static.boris1993.com/java-gc-algorithms/circular-reference.png" alt="Circular reference"></p>
<p>此时，<code>对象1</code>，<code>对象2</code>，<code>对象3</code> 都是不可达状态，理论上这三个对象都应该被回收，但是因为它们三个形成循环引用，引用计数器不为零，导致 GC 不会回收它们的空间。所以实际上，JVM 并没有采用这种判断方法。</p>
<h3 id="可达性分析法-根搜索算法"><a href="#可达性分析法-根搜索算法" class="headerlink" title="可达性分析法(根搜索算法)"></a>可达性分析法 (根搜索算法)</h3><p>可达性分析法的原理是，从根对象 (GC Root) 开始向下搜索，搜索走过的路径称为 “引用链”，对象与引用链可以形成一个图，当任一个对象没有到根对象的引用链，即在这个图中该对象是不可达的，那么就判定这个对象是可以被回收的。</p>
<p>Java 语言使用如下几种 GC Root 对象：</p>
<blockquote>
<ol>
<li>虚拟机栈 (栈帧中的本地变量表) 中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI 引用的对象</li>
</ol>
</blockquote>
<p>还是用上面这个循环引用作为示例：</p>
<p><img data-src="https://blog-static.boris1993.com/java-gc-algorithms/circular-reference.png" alt="Circular reference"></p>
<p>此时虽然<code>对象1</code>、<code>对象2</code>、<code>对象3</code> 互相之间存在引用，但是从根对象开始无法找到到达它们的路径，即它们三个都是<code>不可达</code>的，也就是可以被回收的。</p>
<h2 id="如何进行回收"><a href="#如何进行回收" class="headerlink" title="如何进行回收"></a>如何进行回收</h2><p>在根搜索算法的基础上，现代虚拟机中实现了三种算法：<code>标记-清除算法</code>，<code>复制算法</code>，<code>标记-整理算法</code>。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记 - 清除算法</h3><p>标记 - 清除算法把垃圾回收过程分成标记和清除两个阶段。在标记阶段，通过根节点标记所有可达的对象，也就是说，未被标记的对象都是不可达的对象。然后在清除阶段回收所有未被标记的对象。详细来说的话，就是当堆中的有效内存空间被耗尽时，就会停止整个程序 (stop the world)，然后逐步开始标记和清除工作。</p>
<p>标记的过程，实际上是遍历所有的 GC Roots，并标记所有可达的对象。而清除的过程，则是遍历堆中所有的对象，并清除没有被标记的对象。</p>
<p>在回收过程中一定要停止程序运行的原因，是为了避免在标记完成而尚未开始清除时，有新的可达的对象被创建出来。一旦出现这种情况，因为新创建的对象没有被标记，所以在清除阶段这个对象又会被清除。如果停止了程序的运行，那么在清除过程中，对象的状态不会发生变化，也就不会发生前面说的这种问题。</p>
<p>这个算法尽管可以有效的回收内存，但是也有两个比较大的缺点：</p>
<ol>
<li>遍历所有对象的效率比较低，导致程序停止运行的时间比较长</li>
<li>这种方法清理出的内存空间是不连续的，会造成空闲空间碎片化，并会影响数组分配空间。同时为了得知哪些空间是可用的，JVM 还需要额外维护内存闲置空间的信息。</li>
</ol>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法的思想，是将原有的内存空间分成两部分，每次只使用其中一部分。在垃圾回收时，会从正在使用的部分中，将标记的对象复制到另一块内存中，然后清除正在使用的内存块，并交换两块内存的角色，来完成空间的回收。</p>
<p>该算法比标记 - 清除算法的效率高，但是该算法不适合活动对象较多的场合，比如老年代空间。此外，该算法会造成一定程度的内存空间浪费，因为总是有一片内存空间是被闲置的。为了节省空间，考虑到新生代空间中的对象存活时间大多不会很长，所以虚拟机可以选择不将内存对半分，而是将内存分割成一块比较大的 Eden 空间和两块比较小的 Survivor 空间 (<code>From Survivor</code> 和 <code>To Survivor</code>)，每次同时使用 Eden 和其中一个 Survivor。比如 HotSpot 虚拟机默认为 Eden 分配 80% 的空间，为两个 Survivor 各分配 10% 的空间。</p>
<p>Eden 区，如其名字 “伊甸园” 一般，对象在被创建时，首先会放在这个区域；Survivor 区，也如其名字 “幸存者区” 一样，存放的是每次垃圾回收后被保留下来的对象。</p>
<p>在每次垃圾回收时，Eden 区中不能被回收的对象，和 From Survivor 区中不能被回收的对象，都将被复制到 To Survivor 区中，然后回收 Eden 区和 From Survivor 区的空间，并且幸存下来的对象的 age 属性会加一，最后 From Survivor 和 To Survivor 两者的角色对调。如果发生 Survivor 空间不足以存放所有活动对象时，则会使用老年代来进行分配担保，大的对象会跳过 Survivor 区直接进入老年代。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记 - 整理算法</h3><p>因为复制算法在活动对象较多时，会发生很多的复制操作，导致算法效率比较低，而老年代的特点就是活动的对象比较多。“标记 - 整理” 算法就是为了应对这一情况而诞生的。</p>
<p>标记 - 整理算法把垃圾回收过程分成标记和整理两个阶段。标记阶段的做法与 “标记 - 清除” 算法一样，遍历所有的 GC Roots 并标记出活动的对象；而在整理阶段，所有的活动对象都会向内存空间的一端移动 (比如全部从内存空间的其实位置开始排列)，然后将边界以外的内存直接清理。</p>
<p>该算法的另一个优点是，因为该算法不会分割内存空间，而且每次回收后对象占用的空间肯定小于回收前所占用的空间，所以不再需要额外的空间进行分配担保。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法实际上就是根据不同内存空间的特性，一般是将堆分为新生代和老年代，并根据其各自的特点，在新生代使用复制算法回收，在老年代使用标记 - 整理算法回收。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>垃圾回收</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Java 中如何实现在多个线程全部完成后再执行后续的代码</title>
    <url>/java-how-to-wait-for-threads-before-continuing.html</url>
    <content><![CDATA[<p>面试的时候被问到，如何在 5 个线程全部执行完毕之后，再继续执行后续的代码。迫于对多线程的东西了解不多，只答出一个 <code>CountDownLatch</code>，还大概答出一个用 <code>Future</code> 的思路。回来痛定思痛，请出了万能的 ChatGPT，学到了其他的几种方法。</p>
<span id="more"></span>

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>在 Java 中可以使用 <code>CountDownLatch</code> 来实现线程间的协调和等待。<code>CountDownLatch</code> 是一个同步工具类，它允许一个或多个线程等待一组事件发生。</p>
<p>在这个问题中，我们可以创建一个初始值为 5 的 <code>CountDownLatch</code>，每个线程完成时调用 <code>countDown()</code> 方法将计数器减一，主线程调用 <code>await()</code> 方法等待计数器归零后再执行后续代码。</p>
<p>下面是一个示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(numThreads);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 5 个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numThreads; i++) {</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(latch);</span><br><span class="line">            thread.start();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="comment">// P.S.：我当时想不起来可以await了，就答了个用循环检查CountDownLatch......</span></span><br><span class="line">        latch.await();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行后续代码</span></span><br><span class="line">        System.out.println(<span class="string">"All threads have finished executing."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(CountDownLatch latch)</span> {</span><br><span class="line">            <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 线程执行一些操作</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" has finished executing."</span>);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 线程执行完毕后调用 countDown() 方法</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的示例代码中，<code>MyThread</code> 类表示线程的实现。在 <code>run()</code> 方法中，线程执行一些操作，然后调用 <code>countDown()</code> 方法通知 <code>CountDownLatch</code> 计数器减一。在主线程中，我们创建 5 个线程并启动它们，然后调用 <code>await()</code> 方法等待所有线程执行完毕。最后，当所有线程执行完毕时，主线程输出一条消息，并继续执行后续代码。</p>
<h2 id="使用join-方法"><a href="#使用join-方法" class="headerlink" title="使用join()方法"></a>使用 join () 方法</h2><p>如果不使用 <code>CountDownLatch</code>，可以使用 Java 的线程 <code>join()</code> 方法来等待所有线程执行完毕。<code>join()</code> 方法可以使得一个线程在另一个线程结束后再执行。具体来说，可以在主线程中依次调用每个线程的 <code>join()</code> 方法，让主线程等待每个线程执行完毕后再继续执行后续代码。</p>
<p>下面是一个使用 <code>join()</code> 方法实现的示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        List&lt;MyThread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">            thread.start();</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (MyThread thread : threads) {</span><br><span class="line">            <span class="comment">// join()方法的JavaDoc写的清晰明了：</span></span><br><span class="line">            <span class="comment">// Waits for this thread to die.</span></span><br><span class="line">            thread.join();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"All threads have finished executing."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" has finished executing."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的示例代码中，<code>MyThread</code> 类表示线程的实现。在主线程中，我们创建 5 个线程并启动它们，然后依次调用每个线程的 <code>join()</code> 方法等待线程执行完毕。最后，当所有线程执行完毕时，主线程输出一条消息，并继续执行后续代码。</p>
<p>需要注意的是，<code>join()</code> 方法会阻塞当前线程，直到被等待的线程执行完毕。因此，在使用 <code>join()</code> 方法时要小心，以避免出现死锁等问题。</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>使用 <code>Future</code> 类也可以实现等待多个线程执行完毕。<code>Future</code> 是 Java 提供的一种异步计算的机制，可以在一个线程中调用另一个线程并等待其执行结果。具体来说，可以使用 <code>ExecutorService</code> 的 <code>invokeAll()</code> 方法启动多个线程，将返回的 <code>Future</code> 对象保存到一个列表中，然后调用每个 <code>Future</code> 对象的 <code>get()</code> 方法等待线程执行完毕。</p>
<p>下面是一个使用 <code>Future</code> 类实现的示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        List&lt;Callable&lt;Void&gt;&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            Callable&lt;Void&gt; task = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">            tasks.add(task);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Void&gt;&gt; futures = executor.invokeAll(tasks);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Void&gt; future : futures) {</span><br><span class="line">            <span class="comment">// Waits if necessary for the computation to complete,</span></span><br><span class="line">            <span class="comment">// and then retrieves its result.</span></span><br><span class="line">            future.get();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行后续代码</span></span><br><span class="line">        System.out.println(<span class="string">"All threads have finished executing."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Void&gt; {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" has finished executing."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在上面的示例代码中，<code>MyTask</code> 类表示线程的实现。在主线程中，我们使用 <code>ExecutorService</code> 的 <code>invokeAll()</code> 方法启动多个线程，并将返回的 <code>Future</code> 对象保存到一个列表中。然后，我们依次调用每个 <code>Future</code> 对象的 <code>get()</code> 方法等待线程执行完毕。最后，当所有线程执行完毕时，主线程输出一条消息，并继续执行后续代码。</p>
<p>需要注意的是，在使用 <code>Future</code> 类时要小心，以避免出现线程池满载等问题。在实际应用中，可以根据需要调整线程池大小或使用其他调度机制来处理大量的并发任务。</p>
<h2 id="wait-和notifyAll"><a href="#wait-和notifyAll" class="headerlink" title="wait()和notifyAll()"></a>wait () 和 notifyAll ()</h2><p>可以使用 Java 的 <code>wait()</code> 和 <code>notifyAll()</code> 方法来实现等待多个线程执行完毕。具体来说，可以在主线程中创建一个共享的计数器变量，每个线程在执行完毕后将计数器减一。当计数器为 0 时，说明所有线程执行完毕，可以调用 <code>notifyAll()</code> 方法唤醒主线程继续执行后续代码。</p>
<p>下面是一个使用 <code>wait()</code> 和 <code>notifyAll()</code> 方法实现的示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MyThread</span>(countDownLatch).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (countDownLatch) {</span><br><span class="line">            <span class="keyword">while</span> (countDownLatch.getCount() &gt; <span class="number">0</span>) {</span><br><span class="line">                countDownLatch.wait();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"All threads have finished executing."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(CountDownLatch countDownLatch)</span> {</span><br><span class="line">            <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" has finished executing."</span>);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">synchronized</span> (countDownLatch) {</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    countDownLatch.notifyAll();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的示例代码中，MyThread 类表示线程的实现。在主线程中，我们创建 5 个线程并启动它们，然后使用一个共享的计数器变量 countDownLatch 记录线程执行的状态。当每个线程执行完毕时，将计数器减一，并调用 notifyAll () 方法唤醒主线程。在主线程中，我们使用 wait () 方法等待所有线程执行完毕，直到计数器为 0。</p>
<p>P.S.：感觉这个实现有种莫名其妙的别扭感……</p>
<h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><p>使用 <code>CompletionService</code> 可以比较方便地实现等待所有线程执行完毕的功能。<code>CompletionService</code> 是 Java 提供的一个接口，它可以将任务提交给线程池执行，并在任务执行完毕后立即返回结果，从而实现异步执行和结果收集的功能。</p>
<p>具体来说，可以创建一个 <code>ExecutorService</code> 对象作为线程池，然后将任务提交给 <code>CompletionService</code> 执行。在提交任务时，可以使用 <code>submit()</code> 方法返回一个 <code>Future</code> 对象，用于后续获取任务执行的结果。使用 <code>CompletionService</code> 的 <code>take()</code> 方法可以等待任意一个任务执行完毕并返回结果，从而避免了使用 <code>join()</code> 方法等待所有线程执行完毕的阻塞等待。</p>
<p>下面是一个使用 <code>CompletionService</code> 实现的示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        CompletionService&lt;Void&gt; completionService = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            completionService.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="comment">// Retrieves and removes the Future representing the next completed task,</span></span><br><span class="line">            <span class="comment">// waiting if none are yet present.</span></span><br><span class="line">            completionService.take();</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + i + <span class="string">" has finished executing"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"All threads have finished executing."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Void&gt; {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" has finished executing."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="线程的getState-方法"><a href="#线程的getState-方法" class="headerlink" title="线程的getState()方法"></a>线程的 getState () 方法</h2><p>除了 <code>CountDownLatch</code> 和 <code>Future</code> 类，还有其他实现方法。其中一个比较简单的方法是使用 Java 的线程状态<code>（Thread.State）</code>来判断所有线程是否执行完毕。</p>
<p>具体来说，可以将所有线程保存到一个列表中，然后在主线程中依次调用每个线程的 <code>getState()</code> 方法，检查线程状态是否为 <code>Terminated</code>。如果所有线程都已经执行完毕，则可以继续执行后续代码。</p>
<p>下面是一个使用线程状态实现的示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        List&lt;MyThread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">            thread.start();</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allThreadsFinished</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!allThreadsFinished) {</span><br><span class="line">            allThreadsFinished = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (MyThread thread : threads) {</span><br><span class="line">                <span class="keyword">if</span> (thread.getState() != Thread.State.TERMINATED) {</span><br><span class="line">                    allThreadsFinished = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"All threads have finished executing."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" has finished executing."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的示例代码中，<code>MyThread</code> 类表示线程的实现。在主线程中，我们创建 5 个线程并启动它们，然后循环检查每个线程的状态，直到所有线程都执行完毕。在每次循环中，我们先将 <code>allThreadsFinished</code> 标志设为 <code>true</code>，然后依次检查每个线程的状态。如果有任何一个线程的状态不是 <code>Terminated</code>，则将 <code>allThreadsFinished</code> 标志设为 <code>false</code>，并跳出循环。等待一段时间后重新检查线程状态，直到所有线程都执行完毕。</p>
<p>需要注意的是，使用线程状态进行等待需要定期检查所有线程的状态，因此会占用一定的 CPU 资源。在实际应用中，可以根据需要调整等待的时间间隔以及检查的次数，以平衡等待时间和 CPU 资源的消耗。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>使用 <code>CyclicBarrier</code> 也可以比较方便地实现等待所有线程执行完毕的功能。<code>CyclicBarrier</code> 是 Java 提供的一个同步辅助类，它可以让一组线程等待彼此达到某个共同的屏障点。</p>
<p>具体来说，可以创建一个 <code>CyclicBarrier</code> 对象，并指定需要等待的线程数量。每个线程在执行完自己的任务后，调用 <code>CyclicBarrier</code> 的 <code>await()</code> 方法，表示已经到达了屏障点。当所有线程都到达了屏障点后，<code>CyclicBarrier</code> 就会释放所有线程，从而实现等待所有线程执行完毕的功能。</p>
<p>下面是一个使用 <code>CyclicBarrier</code> 实现的示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 创建 CyclicBarrier 对象，等待 5 个线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(</span><br><span class="line">                        <span class="number">5</span>,</span><br><span class="line">                        () -&gt; {</span><br><span class="line">                            <span class="comment">// 所有线程到达屏障点时执行的操作</span></span><br><span class="line">                            System.out.println(<span class="string">"All threads have finished executing."</span>);</span><br><span class="line">                        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>(cyclicBarrier)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(CyclicBarrier cyclicBarrier)</span> {</span><br><span class="line">            <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" has finished executing."</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的示例代码中，<code>MyTask</code> 类表示线程的实现。在主线程中，我们创建一个 <code>CyclicBarrier</code> 对象，并指定需要等待的线程数量为 5。每个线程在执行完自己的任务后，调用 <code>CyclicBarrier</code> 的 <code>await()</code> 方法，表示已经到达了屏障点。当所有线程都到达了屏障点后，<code>CyclicBarrier</code> 就会执行屏障操作，这里是输出 <code>All threads have finished executing.</code>。</p>
<p>需要注意的是，如果其中一个线程在等待过程中被中断或者抛出异常，那么 <code>CyclicBarrier</code> 就会被破坏，所有线程都会被唤醒并抛出 <code>BrokenBarrierException</code> 异常。因此，在实现时需要捕获 <code>InterruptedException</code> 和 <code>BrokenBarrierException</code> 异常。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>面试</tag>
        <tag>CountDownLatch</tag>
        <tag>Future</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的内部类和 private 修饰符</title>
    <url>/java-inner-class-and-private-identifier.html</url>
    <content><![CDATA[<p>一个 <code>private</code> 属性只能被它所在的类访问，这件事地球人都知道。但是，你有没有想过，这条规则有没有可能在某种情况下，会变得不成立？</p>
<p>本文将通过一个小例子，来演示怎么让 <code>private</code> 修饰符 “失效”，以及它为什么会 “失效”。</p>
<span id="more"></span>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>废话不多说，先写一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">outerClassName</span> <span class="operator">=</span> <span class="string">"outerClass"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOuterClassName</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(outerClassName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line"></span><br><span class="line">        innerClass.printOuterClassName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码是不是感觉有一丝异样？为什么在内部类里，能直接访问到外部类的 <code>private</code> 属性？难道 <code>private</code> 修饰符真的 “失效” 了？</p>
<p>别急，待我们把这个 class 反编译了，从字节码层面来看看它到底有什么猫腻。毕竟，字节码可不会骗人。</p>
<h2 id="反编译外部类"><a href="#反编译外部类" class="headerlink" title="反编译外部类"></a>反编译外部类</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ javap -c OuterClass.class</span><br><span class="line">Compiled from <span class="string">"OuterClass.java"</span></span><br><span class="line">public class com.boris1993.OuterClass {</span><br><span class="line">  public com.boris1993.OuterClass();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial <span class="comment">#2                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       4: aload_0</span><br><span class="line">       5: ldc           <span class="comment">#3                  // String outerClass</span></span><br><span class="line">       7: putfield      <span class="comment">#1                  // Field outerClassName:Ljava/lang/String;</span></span><br><span class="line">      10: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           <span class="comment">#4                  // class com/boris1993/OuterClass</span></span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial <span class="comment">#5                  // Method "&lt;init&gt;":()V</span></span><br><span class="line">       7: astore_1</span><br><span class="line">       8: new           <span class="comment">#6                  // class com/boris1993/OuterClass$InnerClass</span></span><br><span class="line">      11: dup</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: dup</span><br><span class="line">      14: invokevirtual <span class="comment">#7                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span></span><br><span class="line">      17: pop</span><br><span class="line">      18: invokespecial <span class="comment">#8                  // Method com/boris1993/OuterClass$InnerClass."&lt;init&gt;":(Lcom/boris1993/OuterClass;)V</span></span><br><span class="line">      21: astore_2</span><br><span class="line">      22: aload_2</span><br><span class="line">      23: invokevirtual <span class="comment">#9                  // Method com/boris1993/OuterClass$InnerClass.printOuterClassName:()V</span></span><br><span class="line">      26: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  static java.lang.String access<span class="variable">$000</span>(com.boris1993.OuterClass);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      <span class="comment">#1                  // Field outerClassName:Ljava/lang/String;</span></span><br><span class="line">       4: areturn</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有没有发现，78 行出现了一个我们没有写过的方法 <code>access$000</code>？而且从注释来看，它接受一个 <code>OuterClass</code> 类型的参数，而且返回的正是外部类的 <code>outerClassName</code> 的值。</p>
<p>既然我们没定义这个方法，那就是编译器偷偷的给咱整了点活。至于为啥编译器要这么干，结合上面这个例子，也不难猜出来：这就是给内部类访问它的 <code>private</code> 属性用的。</p>
<h2 id="反编译内部类"><a href="#反编译内部类" class="headerlink" title="反编译内部类"></a>反编译内部类</h2><p>但是咱不能光猜啊，咱还得有证据。证据哪来？当然是内部类的字节码。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ javap -c OuterClass<span class="variable">$InnerClass</span>.class</span><br><span class="line">Compiled from <span class="string">"OuterClass.java"</span></span><br><span class="line">public class com.boris1993.OuterClass<span class="variable">$InnerClass</span> {</span><br><span class="line">  final com.boris1993.OuterClass this<span class="variable">$0</span>;</span><br><span class="line"></span><br><span class="line">  public com.boris1993.OuterClass<span class="variable">$InnerClass</span>(com.boris1993.OuterClass);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: aload_1</span><br><span class="line">       2: putfield      <span class="comment">#1                  // Field this$0:Lcom/boris1993/OuterClass;</span></span><br><span class="line">       5: aload_0</span><br><span class="line">       6: invokespecial <span class="comment">#2                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       9: <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  public void printOuterClassName();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       3: aload_0</span><br><span class="line">       4: getfield      <span class="comment">#1                  // Field this$0:Lcom/boris1993/OuterClass;</span></span><br><span class="line">       7: invokestatic  <span class="comment">#4                  // Method com/boris1993/OuterClass.access$000:(Lcom/boris1993/OuterClass;)Ljava/lang/String;</span></span><br><span class="line">      10: invokevirtual <span class="comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      13: <span class="built_in">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>嗯，果然没错，在第 20 行这一条指令里，它调用了上面我们看到的那个 <code>access$000()</code> 方法。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>简谈 JVM 中的几种引用</title>
    <url>/java-jvm-reference.html</url>
    <content><![CDATA[<p>在 <a href="/projects/java/fundamentals/java-gc-algorithms.html">Java 的垃圾回收算法</a>一文中，我们知道 JVM 是根据一个对象有没有被引用来判断要不要对其进行垃圾回收的。但是，如果我们为了提升垃圾回收的效率，想要再把垃圾回收的条件更细化一些，比如只在内存非常紧张的时候才回收某些对象，那么光靠一个粗略的 “引用”，就显得心有余而力不足了。所以，在 <code>JDK 1.2</code> 版本之后，Java 扩充了引用的概念，将其扩充成了<code>强引用</code>，<code>软引用</code>，<code>弱引用</code>，<code>虚引用</code>四个更细化的概念。</p>
<p>本文将参考《深入理解 Java 虚拟机 (第 3 版)》中<code>再谈引用</code>一节，简述一下这四种引用的概念，以及被引用的对象何时会被垃圾回收器回收。</p>
<span id="more"></span>

<h2 id="强引用-Strongly-reference"><a href="#强引用-Strongly-reference" class="headerlink" title="强引用(Strongly reference)"></a>强引用 (Strongly reference)</h2><p>强引用是最传统的 “引用” 的定义，指在代码中普遍存在的引用赋值，比如 <code>Object obj = new Object()</code>。不论在任何情况下，只要强引用关系存在，那么垃圾回收器就永远不会回收掉被引用的对象。</p>
<h2 id="软引用-Soft-reference"><a href="#软引用-Soft-reference" class="headerlink" title="软引用(Soft reference)"></a>软引用 (Soft reference)</h2><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象纳入回收范围进行第二次回收，如果在回收之后仍没有足够的内存，才会抛出内存溢出异常。在 <code>JDK 1.2</code> 版本之后提供了 <code>SoftReference</code> 类来实现软引用。</p>
<p>软引用对象可以用在类似缓存的场景中，比如在一个图片编辑器中，应用可以将用户打开的文件读入一个软引用对象。</p>
<p>如果要创建一个软引用对象，那么可以使用如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">SoftReference&lt;String&gt; stringSoftReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="string">"string"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="弱引用-Weak-reference"><a href="#弱引用-Weak-reference" class="headerlink" title="弱引用(Weak reference)"></a>弱引用 (Weak reference)</h2><p>弱引用也是用来被描述非必须的对象，但它的强度比软引用要更弱一些。被弱引用关联的对象只能生存到下一次垃圾回收发生时。当垃圾回收器开始工作后，无论当前剩余内存是否足够，被弱引用关联的对象都会被回收掉。在 <code>JDK 1.2</code> 版本之后提供了 <code>WeakReference</code> 类来实现弱引用。</p>
<p>弱引用常见于一些集合类中，尤其在哈希表中。因为哈希表的接口允许用户使用任何 Java 对象作为 key 来使用，而当一个键值被存入哈希表后，哈希表本身就有了对这些键和值的引用。如果这些引用是强引用，那么只要这个哈希表对象存活，哈希表关联的键和值也就永远不会被回收。如果这个哈希表同时又包含了大量的对象，那么就可能会长时间占用服务器的大量内存。这类问题的解决办法就是使用弱引用来关联这些对象，比如使用 <code>WeakHashMap</code>。</p>
<p>如果要创建一个弱引用对象，那么可以使用如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">WeakReference&lt;String&gt; stringWeakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="string">"string"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="虚引用-Phantom-reference"><a href="#虚引用-Phantom-reference" class="headerlink" title="虚引用(Phantom reference)"></a>虚引用 (Phantom reference)</h2><p>虚引用也叫 “幽灵引用” 或 “幻影引用”，是最弱的一种引用。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，同时用户也无法通过一个虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个系统通知。在 <code>JDK 1.2</code> 版本之后提供了 <code>PhantomReference</code> 类来实现虚引用。</p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMzIwMDI0NA==">Java 强软弱虚引用介绍及使用场景<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWpvcmNlbi9wLzM5NjgwMTguaHRtbA==">java 中四种引用类型<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 运行时的数据区域</title>
    <url>/java-jvm-runtime-data-areas.html</url>
    <content><![CDATA[<p>JVM 在运行时，会按照程序执行的需要来创建一系列的运行时数据区域。有的区域只会随 JVM 起停而被创建和销毁，有的区域则会独立分配给各个线程，并随线程的起停而创建和销毁。这些运行时区域，按照功能和性质不同，会分成如下几部分：</p>
<ul>
<li>线程专有 <ul>
<li><a href="#pc-program-counter-%E5%AF%84%E5%AD%98%E5%99%A8">pc (program counter) 寄存器</a></li>
<li><a href="#JVM%E6%A0%88">JVM 栈</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a></li>
</ul>
</li>
<li>线程间共享<ul>
<li><a href="#%E5%A0%86">堆</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a><ul>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="pc-program-counter-寄存器"><a href="#pc-program-counter-寄存器" class="headerlink" title="pc(program counter)寄存器"></a>pc (program counter) 寄存器</h2><p>JVM 允许同时运行多个线程，每个线程都有它自己的 PC 寄存器。在任意时刻，每个 JVM 线程都在执行一个方法中的某条语句，而这个正在被执行的方法，就叫做这个线程的 “当前方法”。</p>
<p>如果当前方法不是一个本地 (native) 方法，那么 PC 寄存器的内容是当前正在执行的指令的地址；如果当前方法是本地方法，那么 PC 寄存器的值则是空 (undefined) 的。</p>
<h2 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a>JVM 栈</h2><p>每个 JVM 都会在其启动时创建自己私有的 JVM 栈，栈之中存储的是<a href="/projects/java/fundamentals/java-jvm-stack-frame.html">栈帧</a>，用于存储局部变量和方法调用信息。</p>
<p>规范中允许栈的深度可以是固定的，也可以根据要求动态的扩展和收缩。如果是固定深度的栈，那么每个栈的深度会在其创建时按照需要独立指定。</p>
<p>当请求创建的栈大于所允许的深度，那么 JVM 会抛出 <code>StackOverflowError</code> 异常；当程序试图扩大一个可以动态伸缩的栈，或者试图为新的线程创建一个栈，但是可用内存不足以完成这个操作时，那么 JVM 会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 JVM 栈类似，保存了本地方法的调用信息。</p>
<p>本地方法栈的空间可以是固定的，也可以是动态伸缩的。</p>
<p>当程序申请了大于所允许的本地方法栈空间，那么 JVM 会抛出 <code>StackOverflowError</code> 异常；如果程序申请扩展一个可以动态伸缩的本地方法栈，或者试图创建一个栈，但是可用内存不足以满足要求时，JVM 会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>在 JVM 启动时，会创建一个共享于所有线程的堆空间，其中存放着所有的对象，和被分配好空间的数组。用于存放对象的空间由一个自动化的存储空间管理机制，即垃圾回收机制 (garbage collector)，来进行管理。堆空间可以是固定大小的，也可以是按需伸缩的。</p>
<p>如果程序试图申请扩大堆空间，但是存储管理机制无法满足需求时，JVM 会抛出 <code>OutOfMemory</code> 异常。</p>
<p>在堆中，JVM 又根据作用不同，将内存空间分为如下几部分：</p>
<h3 id="新生代-New-generation"><a href="#新生代-New-generation" class="headerlink" title="新生代(New generation)"></a>新生代 (New generation)</h3><p>新生代保留的是生命周期短，并且很快就会被回收掉的对象。其中的空间又随着 “复制算法” 这一垃圾回收算法而被分为 <code>Eden Space</code> 和 <code>Survivor Space</code>。具体可以参考 <a href="/projects/java/fundamentals/java-gc-algorithms.html">Java 的垃圾回收算法</a>这篇博文。</p>
<h3 id="老年代-Tenured-generation"><a href="#老年代-Tenured-generation" class="headerlink" title="老年代(Tenured generation)"></a>老年代 (Tenured generation)</h3><p>在多次垃圾回收后仍然存活的对象，将会被放到老年代空间中。因此可以认为，老年代中的对象的生命周期都是比较长的。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区 (method area) 是一个共享于所有 JVM 线程的空间，创建于 JVM 启动时，其中主要存放的是类的元数据，包括类的类型信息、常量池、方法数据、方法的代码等，这些数据主要来源于 class 文件。方法区逻辑上属于堆的一部分，但是为了与堆区分开来，方法区通常又叫<code>非堆</code>。</p>
<p>类型信息包括类的完整名称、父类的完整名称、类型修饰符 (<code>private</code>/<code>protected</code>/<code>public</code>)，和类型的直接接口类表。</p>
<p>方法的数据包括方法的名称、返回类型、参数、方法的修饰符、字节码、操作数栈和方法栈帧的局部变量区大小，和异常表。</p>
<p>方法区的大小可以是固定的，也可以是按需伸缩的，但是根据虚拟机实现的不同，垃圾回收机制可能不会回收或压缩方法区的空间。</p>
<p>如果方法区的可用内存无法满足一次申请空间的请求，那么 JVM 会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="永久代和Metaspace"><a href="#永久代和Metaspace" class="headerlink" title="永久代和Metaspace"></a>永久代和 Metaspace</h3><p>在 HotSpot VM 中，永久代和 Metaspace 就是方法区的具体实现。在 Java 8 之前，方法区是以永久代的形式存在的；而从 Java 8 之后，永久代就被 Metaspace 取而代之了。</p>
<p>在 Java 1.7 和之前版本中，永久代是一块独立于堆的内存空间，在物理内存上与堆是连续的。同时，在 Java 1.7 中，一部分原属于永久代的内容也在逐步被移动到其他位置，比如符号引用被移动到了本地内存 (native memory) 中，字符串常量池和类的静态变量则被移动到了堆中。</p>
<p>从 Java 8 开始，永久代被 Metaspace 取而代之。Metaspace 的内存空间不再与堆连续，而是存在于本地内存中。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池对应 class 文件中的 <a href="/projects/java/fundamentals/java-jvm-constant-pool.html"><code>constant_pool</code> 表</a>。</p>
<p>运行时常量池中包含了数值常量和属性的引用。每个运行时常量池的空间都会在类或接口被创建时生成，并且从方法区中分配空间。在创建运行时方法区时，如果申请的空间大于方法区可提供的空间，那么 JVM 会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>[^1]: 《The Java Virtual Machine Specification (Java SE 8 Edition)》 - 2.5 Run-Time Data Areas<br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGFlN2U1ZGU1MWQ0NTI0OTg1MGNmOWY=">面试官，Java8 JVM 内存结构变了，永久代到元空间<i class="fa fa-external-link-alt"></i></span><br>[^3]: <a href="/projects/java/fundamentals/java-jvm-runtime-data-areas.html#jvm-method-area">方法区 - JVM 运行时的数据区域</a><br>[^4]: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXN0ZXIvcC85NzY4Mjk4Lmh0bWwjJUU2JTk2JUI5JUU2JUIzJTk1JUU1JThDJUJBJUU2JUIwJUI4JUU0JUI5JTg1JUU1JThDJUJBJUU1JTg1JTgzJUU3JUE5JUJBJUU5JTk3JUI0">方法区（永久区、元空间） - 深入理解 JAVA 虚拟机（内存模型 + GC 算法 + JVM 调优）<i class="fa fa-external-link-alt"></i></span><br>[^5]: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGFkZGl4L3AvNTMwOTU1MC5odG1s">Java8 内存模型 — 永久代 (PermGen) 和元空间 (Metaspace)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 的栈帧</title>
    <url>/java-jvm-stack-frame.html</url>
    <content><![CDATA[<p>栈帧是支持 JVM 进行方法调用和执行的数据结构，它是 <a href="/projects/java/fundamentals/java-jvm-runtime-data-areas.html">JVM 运行时的数据区域</a>的栈元素，其中包含了方法的局部变量表、操作数栈、动态链接方法，和返回地址等信息。</p>
<span id="more"></span>

<p>局部变量表和操作数栈的空间，在编译期就已经可以确定下来，并会随着方法表的 code 属性一并提供给 JVM，所以每个栈帧的空间不会受运行时数据的影响，而仅取决于 JVM 的实现。</p>
<p>每当一个方法被调用都会生成一个栈帧，并在方法执行完毕后被销毁，并且对于每个活动的线程，只有栈顶的栈帧是活动的，这个栈帧被称为 “活动栈帧”，与其相关联的方法被称为 “活动方法”，以及与其相关联的类被称为 “活动类”。</p>
<h1 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h1><p>每个栈帧中都会有一个被称为 “局部变量表” 的数组，其中保存着方法的局部变量。局部变量表的大小在编译期就已经确定下来，并保存在 class 文件的 code 区。各个变量可通过数组下标的方式被定位到，对于需要占用两个元素的数据类型，比如 <code>long</code> 和 <code>double</code>，其对应的下标使用较小的那个值。</p>
<p>在方法执行时，JVM 使用局部变量表完成参数值到参数列表的传递过程的。如果调用的是类方法，那么参数会从局部变量表第 0 位开始向后排列。如果调用的是实例方法 (非 static 方法)，则局部变量表第 0 位默认用于传递方法所属对象的实例的引用，在方法中使用 <code>this</code> 关键字可以访问到这个隐含的参数，其余的参数则从第 1 位开始向后排列；在参数表分配完毕后，方法体内部定义的变量会按照其顺序和作用域分配剩余的位置。</p>
<h1 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h1><p>每个栈帧中都有一个被称为 “操作数栈” 的栈。操作数栈的最大深度也是在编译期就可以确定下来，并保存在 class 文件的 code 区。</p>
<p>在栈帧创建初期，其中的操作数栈是空的。JVM 提供了一系列的指令，用于将值压入操作数栈，同时也有指令来从操作数栈中取出值并进行计算，并将计算结果压入操作数栈。比如 <code>iadd</code> 指令会从操作数栈中取出最顶部的两个 <code>int</code> 数值，将其相加，然后将结果压入操作数栈。</p>
<p>压入操作数栈的元素的类型必须与指令的要求严格匹配，比如使用 <code>iadd</code> 指令将一个 <code>float</code> 和一个 <code>double</code> 相加是不允许的，这一点不仅在编译期会被严格确定，在类校验阶段也会进行检查。</p>
<h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>每个栈帧都包含一个指向运行时常量池的引用，用来支持方法调用过程中的动态链接。</p>
<p>字节码中的方法调用指令会以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用时转化成直接引用，这种称为静态解析；另一部分将在每一次运行期间转化为直接引用，这种称为动态链接。</p>
<h1 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h1><p>当一个方法开始执行后，只有两种方式可以退出这个方法：执行方法返回的指令，和遇到未处理的异常。</p>
<p>执行方法返回的指令称为 “正常方法调用出口 (Normal Method Invocation Completion)”，在这种情况下，如果方法有返回值，那么返回值将会被传递到上方的调用者。此时，当前栈帧将被用来恢复调用者的状态，包括调用者的本地变量表和操作数栈，并会修改 pc 寄存器的值来跳过方法调用指令。</p>
<p>当方法执行期间遇到了异常，并没有找到对应的异常处理器时，导致的方法返回称为 “异常方法调用出口 (Abrupt Method Invocation Completion)”，在这种情况下将不会有值被传回上方调用者。</p>
<h1 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h1><p>虚拟机规范允许具体的 JVM 实现增加一些规范中没有的信息到栈帧中，比如调试信息等，这些信息的内容将取决于 JVM 的具体实现。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程概念</title>
    <url>/java-multi-threading-concepts.html</url>
    <content><![CDATA[<p>本文记录一些 Java 多线程相关的概念性的知识。</p>
<span id="more"></span>

<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p><img data-src="https://blog-static.boris1993.com/java-multi-threading-concepts/java-thread-states.png" alt="Java thread states"></p>
<h2 id="新建-New"><a href="#新建-New" class="headerlink" title="新建(New)"></a>新建 (New)</h2><p>线程已被创建，但是尚未启动</p>
<h2 id="可运行-Runnable"><a href="#可运行-Runnable" class="headerlink" title="可运行(Runnable)"></a>可运行 (Runnable)</h2><p>此线程在 JVM 中正在运行</p>
<h2 id="阻塞-Blocked"><a href="#阻塞-Blocked" class="headerlink" title="阻塞(Blocked)"></a>阻塞 (Blocked)</h2><p>此线程正在等待获取一个监视锁 (monitor lock)，需要其他线程显式唤醒</p>
<h2 id="等待-Waiting"><a href="#等待-Waiting" class="headerlink" title="等待(Waiting)"></a>等待 (Waiting)</h2><p>此线程正在无限期等待另一个线程完成某些工作</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object#wait()</code></td>
<td><code>Object#notify()</code> 或 <code>Object#notifyAll()</code></td>
</tr>
<tr>
<td><code>Thread#join()</code></td>
<td>被调用的线程执行完毕</td>
</tr>
</tbody></table>
<h2 id="限期等待-Timed-waiting"><a href="#限期等待-Timed-waiting" class="headerlink" title="限期等待(Timed waiting)"></a>限期等待 (Timed waiting)</h2><p>此线程正在有限期等待另一个线程完成某些工作</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>Thread.sleep()</code></td>
<td>设定的休眠时间结束</td>
</tr>
<tr>
<td><code>Object#wait(long timeout)</code></td>
<td>时间结束 / <code>Object#notify()</code> / <code>Object#notifyAll()</code></td>
</tr>
<tr>
<td><code>Thread#join(long millis)</code></td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
</tbody></table>
<h2 id="终止-Terminated"><a href="#终止-Terminated" class="headerlink" title="终止(Terminated)"></a>终止 (Terminated)</h2><p>线程结束</p>
<h1 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h1><p>见 <a href="/projects/java/fundamentals/java-multi-threading-how-to.html">Java 如何创建和运行多线程</a></p>
<h1 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><code>synchronized</code></h2><h3 id="同步一个代码块"><a href="#同步一个代码块" class="headerlink" title="同步一个代码块"></a>同步一个代码块</h3><p>只作用于同一个对象，如多个 <code>Thread</code> 使用同一个 <code>Runnable</code> 时。一个线程若要使用此方法，则必须获得 obj 对象的锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">something</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="同步一个方法"><a href="#同步一个方法" class="headerlink" title="同步一个方法"></a>同步一个方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 只作用于同一个对象。</span></span><br><span class="line"><span class="comment">// 一个线程若要使用此方法，则必须获得该方法所在对象的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">synchronized</span> <span class="title function_">something</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 作用于整个类</span></span><br><span class="line"><span class="comment">// 一个线程若要使用此方法，则必须获得该方法所在类的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="title function_">aStaticMethod</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="同步一个类"><a href="#同步一个类" class="headerlink" title="同步一个类"></a>同步一个类</h3><p>作用于整个类，即使两个线程使用同一个类的不同对象，也会进行同步。一个线程若要使用此方法，则必须获得该类的锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">something</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizationExample.class) {</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h2><p><code>ReentrantLock</code> 是 <code>java.util.concurrent</code> 包中的锁</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LockDemo</span> <span class="variable">lockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        executorService.execute(lockDemo);</span><br><span class="line">        executorService.execute(lockDemo);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h1><h2 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread#join()"></a><code>Thread#join()</code></h2><p>在 A 线程中调用 B 线程的 <code>join()</code> 方法，会将当前线程挂起，直到目标线程结束。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ticketCount.get() &gt; <span class="number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount.getAndDecrement() + <span class="string">" tickets"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" stopped."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待 t1 执行完毕</span></span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Thread-0 started.</span><br><span class="line">Thread-0 has 5 tickets</span><br><span class="line">Thread-0 has 4 tickets</span><br><span class="line">Thread-0 has 3 tickets</span><br><span class="line">Thread-0 has 2 tickets</span><br><span class="line">Thread-0 has 1 tickets</span><br><span class="line">Thread-0 stopped.</span><br><span class="line">Thread-1 started.</span><br><span class="line">Thread-2 started.</span><br><span class="line">Thread-1 has 5 tickets</span><br><span class="line">Thread-2 has 5 tickets</span><br><span class="line">Thread-2 has 4 tickets</span><br><span class="line">Thread-1 has 4 tickets</span><br><span class="line">Thread-2 has 3 tickets</span><br><span class="line">Thread-1 has 3 tickets</span><br><span class="line">Thread-2 has 2 tickets</span><br><span class="line">Thread-1 has 2 tickets</span><br><span class="line">Thread-1 has 1 tickets</span><br><span class="line">Thread-2 has 1 tickets</span><br><span class="line">Thread-1 stopped.</span><br><span class="line">Thread-2 stopped.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="wait-，notify-，和notifyAll"><a href="#wait-，notify-，和notifyAll" class="headerlink" title="wait()，notify()，和notifyAll()"></a><code>wait()</code>，<code>notify()</code>，和 <code>notifyAll()</code></h2><p><code>wait()</code> 将当前线程变为等待状态，<code>notify()</code> 和 <code>notifyAll()</code> 将等待状态的线程唤醒。<code>wait()</code> 方法必须在有锁 (即 <code>synchronized</code>) 的代码块中执行。</p>
<p>当有多个线程处于等待状态时，<code>notify()</code> 会任意选择一个线程来唤醒，选择的方式由 JVM 的实现来决定；而 <code>notifyAll()</code> 则会唤醒所有等待中的线程。</p>
<p>因为线程唤醒后，程序将会从 <code>wait()</code> 的下一条语句中开始执行，所以 <code>wait()</code> 方法应当总在 <code>while</code> 循环中调用，通过循环条件控制线程是否继续等待。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            wait();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">WaitNotifyDemo</span> <span class="variable">waitNotifyDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用after()后，遇到wait()进入等待状态</span></span><br><span class="line">        executorService.execute(waitNotifyDemo::after);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用before()后，遇到`notifyAll()`，唤醒所有线程</span></span><br><span class="line">        executorService.execute(waitNotifyDemo::before);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 如何创建和运行多线程</title>
    <url>/java-multi-threading-how-to.html</url>
    <content><![CDATA[<p>本文通过一个简单的示例，介绍一下在 Java 中如何创建和运行多线程，以及我在学习过程中遇到的问题。包括：</p>
<ul>
<li>如何实现多线程</li>
<li>如何在线程间共享资源</li>
<li>共享资源时可能出现的问题</li>
</ul>
<span id="more"></span>

<h1 id="多线程的实现方法"><a href="#多线程的实现方法" class="headerlink" title="多线程的实现方法"></a>多线程的实现方法</h1><p>多线程有三种实现方式：</p>
<ol>
<li>继承 <code>Thread</code> 类，并实现其 <code>run()</code> 方法；</li>
<li>实现 <code>Runnable</code> 接口，并实现其 <code>run()</code> 方法；</li>
<li>和实现 <code>Callable</code> 接口，并实现其 <code>run()</code> 方法。</li>
</ol>
<p>通常来说，我们会通过实现 <code>Runnable</code> 接口来实现多线程，因为继承 <code>Thread</code> 类可能会有多继承的问题，而实现接口则没有这方面的影响。</p>
<p>下面示例会创建一个 <code>MyThread</code> 的类来实现，然后在 <code>main()</code> 中运行。</p>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承 <code>Thread</code> 类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String threadName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.threadName = threadName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">            System.out.println(threadName + <span class="string">" has "</span> + ticketCount-- + <span class="string">" tickets"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"thread1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"thread2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"thread3"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现 <code>Runnable</code> 接口</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String threadName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.threadName = threadName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">            System.out.println(threadName + <span class="string">" has "</span> + ticketCount-- + <span class="string">" tickets"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"thread1"</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"thread2"</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"thread3"</span>)).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现 <code>Callable</code> 接口</h2><p>** TODO: 这东西看起来好像有点复杂，在这里先占个坑，改日单开一篇记录学习过程 **</p>
<h1 id="执行start-方法与执行run-方法的区别"><a href="#执行start-方法与执行run-方法的区别" class="headerlink" title="执行start()方法与执行run()方法的区别"></a>执行 <code>start()</code> 方法与执行 <code>run()</code> 方法的区别</h1><p>实际上，唯一合法的运行多线程的方式，是调用 <code>start()</code> 方法，但是为什么不能调用 <code>run()</code> 方法呢？</p>
<p>因为 <code>start()</code> 方法会开辟一个新的线程，并且在新的线程中调用目标的 <code>run()</code> 方法。但是直接调用 <code>run()</code> 则不会创建新的线程，而是像调用其他任何一个方法那样，他将会在当前线程中执行。</p>
<p>这么说可能有些生涩，那么还是通过上面的例子来帮助理解。</p>
<p>在调用了 <code>start()</code> 方法后，程序的输出是这样子的，注意观察每行输出是由哪个线程写出来的：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">thread1 has 5 tickets</span><br><span class="line">thread3 has 5 tickets</span><br><span class="line">thread2 has 5 tickets</span><br><span class="line">thread3 has 4 tickets</span><br><span class="line">thread1 has 4 tickets</span><br><span class="line">thread3 has 3 tickets</span><br><span class="line">thread2 has 4 tickets</span><br><span class="line">thread3 has 2 tickets</span><br><span class="line">thread1 has 3 tickets</span><br><span class="line">thread3 has 1 tickets</span><br><span class="line">thread2 has 3 tickets</span><br><span class="line">thread1 has 2 tickets</span><br><span class="line">thread2 has 2 tickets</span><br><span class="line">thread1 has 1 tickets</span><br><span class="line">thread2 has 1 tickets</span><br></pre></td></tr></tbody></table></figure>

<p>可见输出是乱序的。然而调用 <code>run()</code> 方法之后，输出变成了这样：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">thread1 has 5 tickets</span><br><span class="line">thread1 has 4 tickets</span><br><span class="line">thread1 has 3 tickets</span><br><span class="line">thread1 has 2 tickets</span><br><span class="line">thread1 has 1 tickets</span><br><span class="line">thread2 has 5 tickets</span><br><span class="line">thread2 has 4 tickets</span><br><span class="line">thread2 has 3 tickets</span><br><span class="line">thread2 has 2 tickets</span><br><span class="line">thread2 has 1 tickets</span><br><span class="line">thread3 has 5 tickets</span><br><span class="line">thread3 has 4 tickets</span><br><span class="line">thread3 has 3 tickets</span><br><span class="line">thread3 has 2 tickets</span><br><span class="line">thread3 has 1 tickets</span><br></pre></td></tr></tbody></table></figure>

<p>看起来像是三个线程按照创建的顺序依次执行，但实际上只是先后调用了它们三个的 <code>run()</code> 方法而已，并没有新的线程被创建出来。</p>
<h1 id="多线程共享资源"><a href="#多线程共享资源" class="headerlink" title="多线程共享资源"></a>多线程共享资源</h1><p>上文中卖票这个例子，都是开了三个线程，各卖各的票，但是实际上它们应该是从同一组票池中卖票。接下来，就把例子修改一下，让这三个线程共享资源。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String threadName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.threadName = threadName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// Thread.currentThread().getName() 打印出正在执行的线程的名字</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount-- + <span class="string">" tickets"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"MyThread"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="为什么用Runnable而不用Thread"><a href="#为什么用Runnable而不用Thread" class="headerlink" title="为什么用Runnable而不用Thread"></a>为什么用 <code>Runnable</code> 而不用 <code>Thread</code></h1><p><code>Thread(Runnable target)</code> 的 JavaDoc 中，<code>target</code> 参数的描述是这么写的：</p>
<blockquote>
<p>the object whose run method is invoked when this thread is started</p>
</blockquote>
<p>以及 <code>Thread#run()</code> 是这样写的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) {</span><br><span class="line">        target.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同时 <code>run()</code> 的 JavaDoc 有如下描述：</p>
<blockquote>
<p>If this thread was constructed using a separate Runnable run object, then that Runnable object’s run method is called.</p>
</blockquote>
<p>说明，在将一个 <code>Runnable</code> 对象赋给一个或多个 <code>Thread</code> 后，这些 <code>Thread</code> 调用的都是这一个 <code>Runnable</code> 对象的 <code>run()</code> 方法，所操作的数据也是这一个 <code>Runnable</code> 对象里面的数据。</p>
<p>依旧用例子说话。</p>
<p>在上一节的代码的 <code>t1.start()</code> 这一行打个断点，看看这三个线程的信息。</p>
<p>根据上面的 JavaDoc，这里特别关注线程的 <code>target</code> 属性。</p>
<p><img data-src="https://blog-static.boris1993.com/java-multi-threading-how-to/thread-target-to-same-runnable.png" alt="Thread target to the same Runnable"></p>
<p>可见，这三个 <code>Thread</code> 都使用了 <code>MyThread@534</code> 这个对象。也就是说，这三个线程都调用了 <code>MyThread@534</code> 的 <code>run()</code> 方法，并且在操作 <code>MyThread@534</code> 这个对象的成员变量。</p>
<p>然后，换成继承 <code>Thread</code> 的形式：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String threadName)</span> {</span><br><span class="line">        <span class="built_in">this</span>.threadName = threadName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount-- + <span class="string">" tickets"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"MyThread1"</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"MyThread2"</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">"MyThread3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样，在 <code>t1.start()</code> 上打断点，得到结果如下：</p>
<p><img data-src="https://blog-static.boris1993.com/java-multi-threading-how-to/thread-running-separately.png" alt="Threads running separately"></p>
<p>可以发现，这三个 <code>Thread</code> 不止没有 <code>target</code>，甚至它们的成员变量都是各自有一份，何谈线程之间共享。</p>
<h1 id="多线程的同步问题"><a href="#多线程的同步问题" class="headerlink" title="多线程的同步问题"></a>多线程的同步问题</h1><p>将<a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90">多线程共享资源</a>这一节的代码执行，得到了这样的输出：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Thread-0 has 20 tickets</span><br><span class="line">Thread-2 has 19 tickets</span><br><span class="line">Thread-1 has 19 tickets</span><br><span class="line">Thread-2 has 17 tickets</span><br><span class="line">Thread-0 has 18 tickets</span><br><span class="line">Thread-2 has 15 tickets</span><br><span class="line">Thread-1 has 16 tickets</span><br><span class="line">Thread-2 has 13 tickets</span><br><span class="line">Thread-0 has 14 tickets</span><br><span class="line">Thread-2 has 11 tickets</span><br><span class="line">Thread-1 has 12 tickets</span><br><span class="line">Thread-0 has 10 tickets</span><br><span class="line">Thread-2 has 9 tickets</span><br><span class="line">Thread-0 has 7 tickets</span><br><span class="line">Thread-1 has 8 tickets</span><br><span class="line">Thread-0 has 5 tickets</span><br><span class="line">Thread-2 has 6 tickets</span><br><span class="line">Thread-0 has 3 tickets</span><br><span class="line">Thread-1 has 4 tickets</span><br><span class="line">Thread-0 has 1 tickets</span><br><span class="line">Thread-2 has 2 tickets</span><br></pre></td></tr></tbody></table></figure>

<p>鞥？第二行和第三行好像不太对劲？线程 1 和线程 2 把同一张票重复卖了两次？果然出现了线程的同步问题了。</p>
<p>发生这个问题的原因是，Java 中的自增、自减不是线程安全的。一个自增自减操作，实际上包含了三步：</p>
<ol>
<li>获取变量当前的值</li>
<li>为该值加 1 或减 1</li>
<li> 写回新值</li>
</ol>
<p>那么要解决这个问题，就需要加锁，来保证 “读 - 算 - 写” 这个操作具有原子性，或者使用 <code>AtomicInteger</code> 类提供的原子操作。</p>
<h2 id="使用synchronized关键字加锁"><a href="#使用synchronized关键字加锁" class="headerlink" title="使用synchronized关键字加锁"></a>使用 <code>synchronized</code> 关键字加锁</h2><p>尝试使用 <code>synchronized</code> 关键字给 <code>run()</code> 方法加锁，代码修改如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount-- + <span class="string">" tickets"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" stopped."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行后得到如下结果：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Thread-0 started.</span><br><span class="line">Thread-0 has 20 tickets</span><br><span class="line">Thread-0 has 19 tickets</span><br><span class="line">Thread-0 has 18 tickets</span><br><span class="line">Thread-0 has 17 tickets</span><br><span class="line">Thread-0 has 16 tickets</span><br><span class="line">Thread-0 has 15 tickets</span><br><span class="line">Thread-0 has 14 tickets</span><br><span class="line">Thread-0 has 13 tickets</span><br><span class="line">Thread-0 has 12 tickets</span><br><span class="line">Thread-0 has 11 tickets</span><br><span class="line">Thread-0 has 10 tickets</span><br><span class="line">Thread-0 has 9 tickets</span><br><span class="line">Thread-0 has 8 tickets</span><br><span class="line">Thread-0 has 7 tickets</span><br><span class="line">Thread-0 has 6 tickets</span><br><span class="line">Thread-0 has 5 tickets</span><br><span class="line">Thread-0 has 4 tickets</span><br><span class="line">Thread-0 has 3 tickets</span><br><span class="line">Thread-0 has 2 tickets</span><br><span class="line">Thread-0 has 1 tickets</span><br><span class="line">Thread-0 stopped.</span><br><span class="line">Thread-2 started.</span><br><span class="line">Thread-2 stopped.</span><br><span class="line">Thread-1 started.</span><br><span class="line">Thread-1 stopped.</span><br></pre></td></tr></tbody></table></figure>

<p>可见 <code>run()</code> 方法被 <code>Thread-0</code> 上锁，被上锁的方法在释放锁前只能被一个线程所访问，<code>Thread-1</code> 和 <code>Thread-2</code> 都在 <code>Thread-0</code> 执行结束并释放锁后才开始运行，并且也都进行了一次对 <code>run()</code> 的上锁 - 释放过程。</p>
<p>如果只对 <code>ticketCount--</code> 操作上锁呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到了这里，而不是对run方法上锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">                <span class="keyword">if</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount-- + <span class="string">" tickets"</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" stopped."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行之后得到了这样的结果：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Thread-0 started.</span><br><span class="line">Thread-2 started.</span><br><span class="line">Thread-1 started.</span><br><span class="line">Thread-0 has 20 tickets</span><br><span class="line">Thread-2 has 19 tickets</span><br><span class="line">Thread-1 has 18 tickets</span><br><span class="line">Thread-0 has 17 tickets</span><br><span class="line">Thread-1 has 16 tickets</span><br><span class="line">Thread-2 has 15 tickets</span><br><span class="line">Thread-0 has 14 tickets</span><br><span class="line">Thread-1 has 13 tickets</span><br><span class="line">Thread-2 has 12 tickets</span><br><span class="line">Thread-1 has 11 tickets</span><br><span class="line">Thread-0 has 10 tickets</span><br><span class="line">Thread-2 has 9 tickets</span><br><span class="line">Thread-1 has 8 tickets</span><br><span class="line">Thread-0 has 7 tickets</span><br><span class="line">Thread-2 has 6 tickets</span><br><span class="line">Thread-2 has 5 tickets</span><br><span class="line">Thread-0 has 4 tickets</span><br><span class="line">Thread-1 has 3 tickets</span><br><span class="line">Thread-2 has 2 tickets</span><br><span class="line">Thread-1 has 1 tickets</span><br><span class="line">Thread-0 stopped.</span><br><span class="line">Thread-2 stopped.</span><br><span class="line">Thread-1 stopped.</span><br></pre></td></tr></tbody></table></figure>

<p>三个线程在结束休眠后开始竞争锁，得到锁的线程操作了 <code>ticketCount</code>，然后释放了锁。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>这次尝试将 <code>ticketCount</code> 换成 <code>AtomicInteger</code> 类型，并且使用 <code>AtomicInteger#getAndDecrement()</code> 方法进行原子的自减计算，修改后的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ticketCount.get() &gt; <span class="number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount.getAndDecrement() + <span class="string">" tickets"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" stopped."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>main()</code> 方法内容依旧不变，运行之后出现了这样的结果：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Thread-1 started.</span><br><span class="line">Thread-2 started.</span><br><span class="line">Thread-0 started.</span><br><span class="line">Thread-1 has 19 tickets</span><br><span class="line">Thread-0 has 18 tickets</span><br><span class="line">Thread-2 has 20 tickets</span><br><span class="line">Thread-1 has 17 tickets</span><br><span class="line">Thread-0 has 16 tickets</span><br><span class="line">Thread-2 has 15 tickets</span><br><span class="line">Thread-1 has 13 tickets</span><br><span class="line">Thread-2 has 12 tickets</span><br><span class="line">Thread-0 has 14 tickets</span><br><span class="line">Thread-0 has 11 tickets</span><br><span class="line">Thread-2 has 10 tickets</span><br><span class="line">Thread-1 has 9 tickets</span><br><span class="line">Thread-1 has 8 tickets</span><br><span class="line">Thread-0 has 6 tickets</span><br><span class="line">Thread-2 has 7 tickets</span><br><span class="line">Thread-2 has 4 tickets</span><br><span class="line">Thread-0 has 3 tickets</span><br><span class="line">Thread-1 has 5 tickets</span><br><span class="line">Thread-2 has 2 tickets</span><br><span class="line">Thread-0 has 1 tickets</span><br><span class="line">Thread-1 stopped.</span><br><span class="line">Thread-2 stopped.</span><br><span class="line">Thread-0 stopped.</span><br></pre></td></tr></tbody></table></figure>

<p>虽然没有了脏读，但是线程的执行顺序也无法保证，如果要求线程定序执行，这样就不行了。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者与消费者问题在 Java 中的实现</title>
    <url>/java-multi-threading-producer-consumer-problem.html</url>
    <content><![CDATA[<p>生产者与消费者问题 (Producer-consumer problem)，也叫有限缓冲问题 (Bounded-buffer problem)，是一个经典的多线程同步问题案例。</p>
<p>该问题中有两个线程共享一个固定大小的缓冲区，一个线程作为生产者，负责向缓冲区中放入数据；另一个线程作为消费者，负责从缓冲区中取出数据。该问题的重点在于，要保证当缓冲区满时，生产者不能继续向其中放入数据，而当缓冲区空时，消费者也不能从缓冲区中取出数据。</p>
<p>那么要保证以上两点，需要在缓冲区空时休眠消费者线程，并当缓冲区有数据之后唤醒消费者线程；以及当缓冲区满时休眠生产者线程，在缓冲区有空闲空间后唤醒生产者线程，或者直接在缓冲区满时放弃未存入缓冲区的数据。</p>
<p>这个问题的难点在于可能会产生死锁。当陷入死锁时，生产者和消费者都会处于休眠状态，并等待对方唤醒自己。</p>
<span id="more"></span>

<h1 id="使用同步锁实现"><a href="#使用同步锁实现" class="headerlink" title="使用同步锁实现"></a>使用同步锁实现</h1><h2 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h2><p>产品类代表将要被生产和消费的产品。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者-消费者问题 -- 产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> productId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product{"</span> +</span><br><span class="line">                <span class="string">"productId="</span> + productId +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getProductId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductId</span><span class="params">(<span class="type">int</span> productId)</span> {</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="仓库类"><a href="#仓库类" class="headerlink" title="仓库类"></a>仓库类</h2><p>仓库类用来构造一个存放产品的数组，并带有存取数组的方法 (pop/push)，本质上是一个栈。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者-消费者问题 -- 仓库类(缓冲区)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Warehouse</span> {</span><br><span class="line">    <span class="keyword">private</span> Product[] products;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Warehouse</span><span class="params">()</span> {</span><br><span class="line">        products = <span class="keyword">new</span> <span class="title class_">Product</span>[<span class="number">10</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Warehouse</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        products = <span class="keyword">new</span> <span class="title class_">Product</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产产品</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Product product)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果仓库已满</span></span><br><span class="line">        <span class="keyword">if</span> (top == products.length) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"Warehouse full."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将生产者线程置于等待态</span></span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Warehouse full but failed to wait. Reason:"</span>);</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        products[top++] = product;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在仓库已有产品</span></span><br><span class="line">        <span class="comment">// 可以唤醒消费者线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费产品</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 取出的产品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Product <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果仓库空</span></span><br><span class="line">        <span class="keyword">while</span> (products[<span class="number">0</span>] == <span class="literal">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"Warehouse empty"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒生产者线程</span></span><br><span class="line">            notifyAll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 将消费者线程置于等待态</span></span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Warehouse empty but failed to wait. Reason:"</span>);</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        product = products[--top];</span><br><span class="line">        products[top] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仓库非满，可以唤醒生产者线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String producerName;</span><br><span class="line">    <span class="keyword">private</span> Warehouse warehouse;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(String producerName, Warehouse warehouse)</span> {</span><br><span class="line">        <span class="built_in">this</span>.producerName = producerName;</span><br><span class="line">        <span class="built_in">this</span>.warehouse = warehouse;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        produce();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产产品并存入仓库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(i++);</span><br><span class="line">            warehouse.push(product);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"[PRODUCED] Product "</span> + product.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred in producer thread. Reason: "</span> + e.getMessage());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String consumerName;</span><br><span class="line">    <span class="keyword">private</span> Warehouse warehouse;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(String consumerName, Warehouse warehouse)</span> {</span><br><span class="line">        <span class="built_in">this</span>.consumerName = consumerName;</span><br><span class="line">        <span class="built_in">this</span>.warehouse = warehouse;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        consume();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> warehouse.pop();</span><br><span class="line">            System.out.println(<span class="string">"[CONSUMED] Product "</span> + product.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred in consumer thread. Reason: "</span> + e.getMessage());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main 类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Warehouse</span> <span class="variable">warehouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Warehouse</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(<span class="string">"producer"</span>, warehouse);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(<span class="string">"consumer"</span>, warehouse);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        executorService.execute(consumer);</span><br><span class="line">        executorService.execute(producer);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread pool is down"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Warehouse empty</span><br><span class="line">[PRODUCED] Product 0</span><br><span class="line">[CONSUMED] Product 0</span><br><span class="line">[PRODUCED] Product 1</span><br><span class="line">[CONSUMED] Product 1</span><br><span class="line">[PRODUCED] Product 2</span><br><span class="line">[PRODUCED] Product 3</span><br><span class="line">[PRODUCED] Product 4</span><br><span class="line">[PRODUCED] Product 5</span><br><span class="line">[CONSUMED] Product 5</span><br><span class="line">[PRODUCED] Product 6</span><br><span class="line">[CONSUMED] Product 6</span><br><span class="line">[CONSUMED] Product 4</span><br><span class="line">[CONSUMED] Product 3</span><br><span class="line">[CONSUMED] Product 2</span><br><span class="line">[PRODUCED] Product 7</span><br><span class="line">[CONSUMED] Product 7</span><br><span class="line">[PRODUCED] Product 8</span><br><span class="line">[CONSUMED] Product 8</span><br><span class="line">Warehouse empty</span><br><span class="line">[PRODUCED] Product 9</span><br><span class="line">[CONSUMED] Product 9</span><br><span class="line">Warehouse empty</span><br></pre></td></tr></tbody></table></figure>

<h1 id="使用阻塞队列实现"><a href="#使用阻塞队列实现" class="headerlink" title="使用阻塞队列实现"></a>使用阻塞队列实现</h1><p>相比较于队列，阻塞队列 (Blocking queue) 可以在队列空时阻塞取值操作，并在队列满时阻塞存入操作。</p>
<p>实际上根据调用不同的方法，可以实现在队列空 / 满时抛出异常、返回特殊值、阻塞操作、带超时的阻塞操作，具体请参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzcvZG9jcy9hcGkvamF2YS91dGlsL2NvbmN1cnJlbnQvQmxvY2tpbmdRdWV1ZS5odG1s"> BlockingQueue 文档<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="产品类和仓库类"><a href="#产品类和仓库类" class="headerlink" title="产品类和仓库类"></a>产品类和仓库类</h2><p>产品类实现同上，仓库使用阻塞队列 (<code>ArrayBlockingQueue</code>) 实现。</p>
<h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String producerName;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Product&gt; warehouse;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(String producerName, BlockingQueue&lt;Product&gt; warehouse)</span> {</span><br><span class="line">        <span class="built_in">this</span>.producerName = producerName;</span><br><span class="line">        <span class="built_in">this</span>.warehouse = warehouse;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        produce();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产产品并存入仓库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(i++);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                warehouse.put(product);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred when putting product in producer. Reason: "</span> + e.getMessage());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"[PRODUCED] Product "</span> + product.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred in producer thread. Reason: "</span> + e.getMessage());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String consumerName;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Product&gt; warehouse;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(String consumerName, BlockingQueue&lt;Product&gt; warehouse)</span> {</span><br><span class="line">        <span class="built_in">this</span>.consumerName = consumerName;</span><br><span class="line">        <span class="built_in">this</span>.warehouse = warehouse;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        consume();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                product = warehouse.take();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred when taking product in consumer. Reason: "</span> + e.getMessage());</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"[CONSUMED] Product "</span> + product.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">20</span>) * <span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Exception occurred in consumer thread. Reason: "</span> + e.getMessage());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">[PRODUCED] Product 0</span><br><span class="line">[CONSUMED] Product 0</span><br><span class="line">[PRODUCED] Product 1</span><br><span class="line">[CONSUMED] Product 1</span><br><span class="line">[PRODUCED] Product 2</span><br><span class="line">[CONSUMED] Product 2</span><br><span class="line">[PRODUCED] Product 3</span><br><span class="line">[CONSUMED] Product 3</span><br><span class="line">[PRODUCED] Product 4</span><br><span class="line">[CONSUMED] Product 4</span><br><span class="line">[PRODUCED] Product 5</span><br><span class="line">[PRODUCED] Product 6</span><br><span class="line">[CONSUMED] Product 5</span><br><span class="line">[PRODUCED] Product 7</span><br><span class="line">[PRODUCED] Product 8</span><br><span class="line">[CONSUMED] Product 6</span><br><span class="line">[PRODUCED] Product 9</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程池</title>
    <url>/java-multi-threading-thread-pool.html</url>
    <content><![CDATA[<p>就像数据库连接可以使用连接池管理一样，Java 中的线程也可以使用线程池来管理。本文介绍在 Java 中如何使用线程池，以及有哪些线程池。</p>
<span id="more"></span>

<h1 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h1><p>每个线程的创建和销毁，都会消耗一定的系统资源，尤其在高并发的系统中，频繁创建和销毁线程会造成大量的资源浪费。</p>
<p>那么，为了避免频繁的创建和销毁线程，就可以在系统启动时，预先创建好一定数量的线程，并将其交由线程调度器管理，这就是线程池。</p>
<h1 id="怎么使用线程池"><a href="#怎么使用线程池" class="headerlink" title="怎么使用线程池"></a>怎么使用线程池</h1><p>依旧是用一个示例来演示。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (gthis) {</span><br><span class="line">                <span class="keyword">if</span> (ticketCount &gt; <span class="number">0</span>) {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has "</span> + ticketCount-- + <span class="string">" tickets"</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" stopped."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread pool created"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Assigning jobs to thread pool"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向线程池提交任务</span></span><br><span class="line">        executorService.exeute(myRunnable);</span><br><span class="line">        executorService.execute(myRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在所有线程都完成工作后，线程池会继续等待新的工作任务</span></span><br><span class="line">        <span class="comment">// 所以如果需要程序在完成后退出，需要显式关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) { }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread pool is down"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行后得到如下结果：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Thread pool created</span><br><span class="line">Assigning jobs to thread pool</span><br><span class="line">pool-1-thread-2 started.</span><br><span class="line">pool-1-thread-1 started.</span><br><span class="line">pool-1-thread-1 has 20 tickets</span><br><span class="line">pool-1-thread-2 has 19 tickets</span><br><span class="line">pool-1-thread-1 has 18 tickets</span><br><span class="line">pool-1-thread-2 has 17 tickets</span><br><span class="line">pool-1-thread-1 has 16 tickets</span><br><span class="line">pool-1-thread-2 has 15 tickets</span><br><span class="line">pool-1-thread-1 has 14 tickets</span><br><span class="line">pool-1-thread-2 has 13 tickets</span><br><span class="line">pool-1-thread-2 has 12 tickets</span><br><span class="line">pool-1-thread-1 has 11 tickets</span><br><span class="line">pool-1-thread-1 has 10 tickets</span><br><span class="line">pool-1-thread-2 has 9 tickets</span><br><span class="line">pool-1-thread-1 has 8 tickets</span><br><span class="line">pool-1-thread-2 has 7 tickets</span><br><span class="line">pool-1-thread-2 has 6 tickets</span><br><span class="line">pool-1-thread-1 has 5 tickets</span><br><span class="line">pool-1-thread-2 has 4 tickets</span><br><span class="line">pool-1-thread-1 has 3 tickets</span><br><span class="line">pool-1-thread-2 has 2 tickets</span><br><span class="line">pool-1-thread-1 has 1 tickets</span><br><span class="line">pool-1-thread-1 stopped.</span><br><span class="line">pool-1-thread-2 stopped.</span><br><span class="line">Thread pool is down</span><br></pre></td></tr></tbody></table></figure>

<h1 id="几种线程池的简介"><a href="#几种线程池的简介" class="headerlink" title="几种线程池的简介"></a>几种线程池的简介</h1><h2 id="Single-thread-pool"><a href="#Single-thread-pool" class="headerlink" title="Single thread pool"></a>Single thread pool</h2><p>是用 <code>Executors.newSingleThreadExecutor()</code> 创建。</p>
<p>该线程池仅有一个线程，并拥有一个无边界的队列。提交到队列中的任务将会按顺序执行。如果当前线程在执行过程中出现错误而被终止，那么线程池会创建一个新的线程并继续执行队列中后续的任务。</p>
<p>与使用 <code>Executors.newFixedThreadPool(1)</code> 创建的线程池不同的是，我们不能为 single thread pool 分配更多的线程数。</p>
<h2 id="Fixed-thread-pool"><a href="#Fixed-thread-pool" class="headerlink" title="Fixed thread pool"></a>Fixed thread pool</h2><p>使用 <code>Executors.newFixedThreadPool(int nThreads)</code> 创建。</p>
<p>该线程池维护着固定数量的线程 (nThreads 个)，在任何时间只允许最多 nThreads 个线程执行任务，多出来的任务将会在队列中等待，直到有空闲的线程出现。如果其中一个线程在执行过程中因为错误而异常退出，则线程池会立刻创建一个新的线程并执行后续的任务。</p>
<p>该线程池在显式关闭 (<code>ExecutorService#shutdown</code>) 前将一直存在。</p>
<h2 id="Work-stealing-pool"><a href="#Work-stealing-pool" class="headerlink" title="Work stealing pool"></a>Work stealing pool</h2><p>使用 <code>Executors.newWorkStealingPool(int parallelism)</code> 或 <code>Executors.newWorkStealingPool()</code> 创建。</p>
<p>该线程池无法保证各个被提交的任务将会以何种顺序执行。</p>
<h3 id="newWorkStealingPool-int-parallelism"><a href="#newWorkStealingPool-int-parallelism" class="headerlink" title="newWorkStealingPool(int parallelism)"></a><code>newWorkStealingPool(int parallelism)</code></h3><p>该方法将根据给定的 “并行量 (parallelism)”，来创建一个包含足够数量线程的线程池，并会<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQxMzQzNTAxLzM4MzM4NTg=">使用多个队列来减少线程与队列的争抢<i class="fa fa-external-link-alt"></i></span>。</p>
<p>“并行量” 的值对应于最多允许参与执行任务的线程数量。但实际存在的线程数可能会动态的增减。</p>
<h3 id="Executors-newWorkStealingPool"><a href="#Executors-newWorkStealingPool" class="headerlink" title="Executors.newWorkStealingPool()"></a><code>Executors.newWorkStealingPool()</code></h3><p>将所有的 “可用的处理器” 的数目作为 “并行量” 来创建线程池。</p>
<p>可用的处理器数量使用 <code>Runtime.getRuntime().availableProcessors()</code> 获取，<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExODc4MDI4LzM4MzM4NTg=">其值等同于 CPU 中逻辑处理器的数量<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="Cached-thread-pool"><a href="#Cached-thread-pool" class="headerlink" title="Cached thread pool"></a>Cached thread pool</h2><p>使用 <code>Executors.newCachedThreadPool()</code> 创建。</p>
<p>当接收到新的任务后，线程池会根据有无可用线程，来决定使用线程池中的空闲线程，或者在线程池中创建新的线程。</p>
<p>如果线程池中有线程空置超过 60 秒，则该线程就会被终止并从线程池中移除。</p>
<h2 id="Scheduled-thread-pool"><a href="#Scheduled-thread-pool" class="headerlink" title="Scheduled thread pool"></a>Scheduled thread pool</h2><p>使用 <code>Executors.newScheduledThreadPool(int corePoolSize)</code> 创建。<code>corePoolSize</code> 为线程池中保持的线程数。</p>
<p>该线程池可以指定一个延迟，或指定一个周期，并按照这个计划执行任务。</p>
<h1 id="线程池是如何工作的"><a href="#线程池是如何工作的" class="headerlink" title="线程池是如何工作的"></a>线程池是如何工作的</h1><p>那么，在调用 <code>ExecutorService#execute(Runnable)</code> 之后，线程池究竟做了些什么呢？</p>
<p>在 <code>ThreadPoolExecutor#execute(Runnable)</code> 方法中，有这样一段注释：</p>
<blockquote>
<p>Proceed in 3 steps:</p>
<ol>
<li>If fewer than corePoolSize threads are running, try to<br>start a new thread with the given command as its first<br>task.  The call to addWorker atomically checks runState and<br>workerCount, and so prevents false alarms that would add<br>threads when it shouldn’t, by returning false.</li>
<li>If a task can be successfully queued, then we still need<br>to double-check whether we should have added a thread<br>(because existing ones died since last checking) or that<br>the pool shut down since entry into this method. So we<br>recheck state and if necessary roll back the enqueuing if<br>stopped, or start a new thread if there are none.</li>
<li>If we cannot queue task, then we try to add a new<br>thread.  If it fails, we know we are shut down or saturated<br>and so reject the task.</li>
</ol>
</blockquote>
<p>也就是说：</p>
<pre class="mermaid">flowchart TD
check_running_threads_number{检查正在运行的线程数是否小于corePoolSize};
start_new_thread("调用addWorker尝试开启一个新的线程，并将这个runnable作为第一个task交给这个线程");
try_enqueue_the_task{"尝试将任务加入队列，并重新调用addWorker再次检查能否加入新的worker"};
reject_the_task("此时线程池已经饱和，或者正在被关闭，所以拒绝掉这个task");

开始 --&gt; check_running_threads_number
check_running_threads_number -- 是 --&gt; start_new_thread
start_new_thread -- 成功 --&gt; 结束
start_new_thread -- 失败 --&gt; try_enqueue_the_task
check_running_threads_number -- 否 --&gt; try_enqueue_the_task
try_enqueue_the_task -- 成功 --&gt; 结束
try_enqueue_the_task -- 失败 --&gt; reject_the_task
reject_the_task --&gt; 结束
</pre>

<p>这里要注意一个比较容易引起误解的点，就是在 <code>core pool size &lt; 当前正在运行的线程数量 &lt; max pool size</code> 时，如果有新的任务进来，那么这个任务首先会被放入队列。仅当队列满了的时候，线程池才会为这个新来的任务创建新的线程。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9saWJyYXJ5L2otanRwMDczMC9pbmRleC5odG1s">Thread pools and work queues<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4NDczMTQ5LzM4MzM4NTg=">Core pool size vs maximum pool size in ThreadPoolExecutor - StackOverflow<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 源码阅读 - ArrayList</title>
    <url>/java-read-src-arraylist.html</url>
    <content><![CDATA[<p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p>
<p>这次就来阅读一下 <code>ArrayList</code> 的源码。</p>
<span id="more"></span>

<h2 id="ArrayList的特性"><a href="#ArrayList的特性" class="headerlink" title="ArrayList的特性"></a>ArrayList 的特性</h2><p><code>ArrayList</code> 有如下几个特性：</p>
<ul>
<li>底层是一个动态扩容的数组</li>
<li>它允许存放多个 <code>null</code> 元素</li>
<li>允许存放多个重复的元素</li>
<li>元素在 List 中的顺序由添加顺序决定</li>
<li>不是线程安全的</li>
</ul>
<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { ... }</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码声明了一个叫 <code>ArrayList</code> 的泛型类，继承了 <code>AbstractList</code>，并实现了 <code>List</code>，<code>RandomAccess</code>，<code>Cloneable</code>，<code>Serializable</code> 接口。</p>
<p><code>AbstractList</code> 抽象类提供了一个 “骨架” 级别的 <code>List</code> 接口的实现，用来减少实现一个支持随机存储的 <code>List</code> 的工作量。</p>
<p><code>RandomAccess</code> 中没有声明任何方法，是一个标记接口 (marker interface)，表明了这个类支持快速 (通常是 <code>O(1)</code> 时间复杂度) 的随机存取。在遍历一个集合前，可以用 <code>instanceof</code> 判断这个集合是否实现了 <code>RandomAccess</code>，来选择合适的遍历方法。</p>
<p><code>Cloneable</code> 也是一个标记接口，表明了这个类允许使用 <code>Object.clone()</code> 命令进行属性到属性的复制。</p>
<p><code>Serializable</code> 也是一个标记接口，表明在这个类上启用 Java 的序列化功能。</p>
<h2 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></tbody></table></figure>

<p><code>elementData</code> 数组用来实际存放数据，<code>ArrayList</code> 的空间 (capacity) 对应这个数组的长度 (size)。<code>ArrayList</code> 实现了自己的序列化 (<code>ArrayList#writeObject()</code>) 和反序列化 (<code>ArrayList#readObject()</code>) 方法，所以加上 <code>transient</code> 关键字来使 <code>elementData</code> 不参与 Java 自带的序列化和反序列化过程。</p>
<p><code>size</code> 成员变量记录当前 <code>ArrayList</code> 中元素的数量。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>ArrayList</code> 有三个构造方法</p>
<ul>
<li>使用默认大小的 <code>ArrayList()</code></li>
<li>指定最初大小的 <code>ArrayList(int initialCapacity)</code></li>
<li>根据一个给定集合来初始化的 <code>ArrayList(Collection&lt;? extends E&gt; c)</code></li>
</ul>
<h3 id="使用默认大小"><a href="#使用默认大小" class="headerlink" title="使用默认大小"></a>使用默认大小</h3><p>类中首先指定了默认的大小</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>但是，在它下面，还有这么一个东西：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br></pre></td></tr></tbody></table></figure>

<p>在最初被构造时，<code>elementData</code> 会先指向 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，而不是直接创建一个容量为 10 的数组。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样做的好处在于可以更合理的利用空间。试想一下，如果某个场景中需要创建 5 个 <code>ArrayList</code> 备用，如果直接就分配好空间的话，那么就会消耗掉至少 50 个元素所需要的空间。所以 Java 选择先将 <code>elementData</code> 指向一个空数组，在向 <code>ArrayList</code> 中添加数据时，再去创建合适大小的数组。</p>
<h3 id="指定最初大小"><a href="#指定最初大小" class="headerlink" title="指定最初大小"></a>指定最初大小</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> {</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当指定的大小是一个正整数时，Java 会创建好对应大小的数组，并将 <code>elementData</code> 指向这个数组；如果指定的大小为零，那么 Java 也会将 <code>elementData</code> 指向一个共享的空数组 <code>EMPTY_ELEMENTDATA</code>，注意这个空数组与上文提到的不是同一个；如果指定的大小为负数，则抛出一个异常。</p>
<p>那么为什么要专门把 <code>EMPTY_ELEMENTDATA</code> 和 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 区分出来呢？<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 的 JavaDoc 是这么说的：</p>
<blockquote>
<p>We distinguish this from <code>EMPTY_ELEMENTDATA</code> to know how much to inflate when first element is added.<br>我们将它与 <code>EMPTY_ELEMENTDATA</code> 区分开来，是方便在添加第一个元素时计算要扩张多少空间。</p>
</blockquote>
<h3 id="根据给定的集合初始化"><a href="#根据给定的集合初始化" class="headerlink" title="根据给定的集合初始化"></a>根据给定的集合初始化</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>程序首先试图调用给定集合的 <code>Collection#toArray()</code> 方法，将集合转换成一个 <code>Object[]</code> 数组。</p>
<p>当数组中有元素时，检查 <code>elementData</code> 的数据类型是否为 <code>Object[]</code> 类型，如果不是则使用 <code>Arrays.copyOf()</code> 方法重新复制元素到一个 <code>Object[]</code> 对象中；而当数组中没有元素时，则重新使 <code>elementData</code> 指向 <code>EMPTY_ELEMENTDATA</code>。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>当添加元素时，首先会调用 <code>ensureCapacityInternal()</code> 方法，来保证空间足够。保证有足够空间后，就会向 <code>elementData[size]</code> 处放置被添加的元素，并且使 <code>size</code> 加一。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p><code>ensureCapacityInternal()</code> 方法用于确保在添加元素时有足够的空间。如果空间不足，则会调用 <code>grow()</code> 方法扩容。</p>
<p><code>grow()</code> 方法会将 <code>elementData</code> 扩张为当前的 1.5 倍空间，并使用 <code>Arrays.copyOf()</code> 方法将元素放入新的数组。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算扩容目标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 检查目标容量是否大于当前已有容量</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 增加容量，以确保至少可以容纳minCapacity所指定个数的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity 目标最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newCapacity = olcCapacity + (oldCapacity / 2)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p><code>ArrayList</code> 提供了两种方式来删除一个元素：根据元素位置 (index) 删除，和匹配元素删除。</p>
<h3 id="根据位置删除"><a href="#根据位置删除" class="headerlink" title="根据位置删除"></a>根据位置删除</h3><p>根据位置删除时，首先会检查给定的位置是否越界。如果没有越界，就会先取出被删除的元素，用来向调用方返回。</p>
<p>删除元素的方法是将 <code>index+1</code> 后面的元素重新放在 <code>index</code> 起始的位置上。可以看出，删除操作的消耗是比较高的。</p>
<p>在重新排列元素后，数组中最后一个元素将与倒数第二个元素重复。所以还需要将最后一个元素置为 null，并将 size 减一。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要移动的元素数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(</span><br><span class="line">            <span class="comment">// 源</span></span><br><span class="line">            elementData,</span><br><span class="line">            <span class="comment">// 源位置</span></span><br><span class="line">            index+<span class="number">1</span>,</span><br><span class="line">            <span class="comment">// 目标</span></span><br><span class="line">            elementData,</span><br><span class="line">            <span class="comment">// 目标位置</span></span><br><span class="line">            index,</span><br><span class="line">            <span class="comment">// 要复制的个数</span></span><br><span class="line">            numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="匹配元素删除"><a href="#匹配元素删除" class="headerlink" title="匹配元素删除"></a>匹配元素删除</h3><p>如果向 <code>remove()</code> 方法提供了一个对象，那么 <code>ArrayList</code> 会遍历 <code>elementData</code>，并会删除第一个与给定对象匹配的元素。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> {</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) {</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) {</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="缩减容量"><a href="#缩减容量" class="headerlink" title="缩减容量"></a>缩减容量</h2><p><code>ArrayList#trimToSize()</code> 方法可以将 <code>ArrayList</code> 的容量缩减至当前元素个数。这个操作需要通过 <code>Arrays.copyOf()</code> 方法进行，所以成本也是比较高的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the</span></span><br><span class="line"><span class="comment"> * list's current size.  An application can use this operation to minimize</span></span><br><span class="line"><span class="comment"> * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> {</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) {</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Fail-fast"><a href="#Fail-fast" class="headerlink" title="Fail fast"></a>Fail fast</h2><p>在会改变 <code>elementData</code> 大小的方法中，经常会看到类似 <code>modCount++</code> 这样的操作。那么这个操作的目的是什么呢？</p>
<p>首先来看看 <code>modCount</code> 成员变量的 JavaDoc 是怎么说的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the size of the</span></span><br><span class="line"><span class="comment"> * list, or otherwise perturb it in such a fashion that iterations in</span></span><br><span class="line"><span class="comment"> * progress may yield incorrect results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This field is used by the iterator and list iterator implementation</span></span><br><span class="line"><span class="comment"> * returned by the {<span class="doctag">@code</span> iterator} and {<span class="doctag">@code</span> listIterator} methods.</span></span><br><span class="line"><span class="comment"> * If the value of this field changes unexpectedly, the iterator (or list</span></span><br><span class="line"><span class="comment"> * iterator) will throw a {<span class="doctag">@code</span> ConcurrentModificationException} in</span></span><br><span class="line"><span class="comment"> * response to the {<span class="doctag">@code</span> next}, {<span class="doctag">@code</span> remove}, {<span class="doctag">@code</span> previous},</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> set} or {<span class="doctag">@code</span> add} operations.  This provides</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in</span></span><br><span class="line"><span class="comment"> * the face of concurrent modification during iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass</span></span><br><span class="line"><span class="comment"> * wishes to provide fail-fast iterators (and list iterators), then it</span></span><br><span class="line"><span class="comment"> * merely has to increment this field in its {<span class="doctag">@code</span> add(int, E)} and</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> remove(int)} methods (and any other methods that it overrides</span></span><br><span class="line"><span class="comment"> * that result in structural modifications to the list).  A single call to</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> add(int, E)} or {<span class="doctag">@code</span> remove(int)} must add no more than</span></span><br><span class="line"><span class="comment"> * one to this field, or the iterators (and list iterators) will throw</span></span><br><span class="line"><span class="comment"> * bogus {<span class="doctag">@code</span> ConcurrentModificationExceptions}.  If an implementation</span></span><br><span class="line"><span class="comment"> * does not wish to provide fail-fast iterators, this field may be</span></span><br><span class="line"><span class="comment"> * ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说，<code>modCount</code> 记录了一个 <code>List</code> 的结构被修改的次数，并且提到了如果在迭代过程中修改了 <code>List</code> 的结构，那么可能会导致得到错误的结果。</p>
<p>在迭代或者序列化的过程中，程序会检查 <code>modCount</code> 的值是否被修改过，如果被修改，就会抛出 <code>ConcurrentModificationException</code> 异常。比如 <code>ArrayList.Itr#next()</code> 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>如上文所说，<code>ArrayList</code> 实现了自己的序列化与反序列化方法，所以 <code>elementData</code> 使用 <code>transient</code> 修饰。</p>
<p>在序列化时，程序并不是直接序列化 <code>elementData</code> 这个数组，而是只取出数组中有效的元素 (包括 null 元素)，并逐个序列化每个元素的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment"> * is, serialize it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException{</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) {</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在反序列化时，首先会使 <code>elementData</code> 指向 <code>EMPTY_ELEMENTDATA</code>，只在有元素会被反序列化时，才会为 <code>elementData</code> 扩容并逐个反序列化对应的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException {</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) {</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代器是用于遍历各个集合的标准方法，<code>ArrayList</code> 也不例外，它提供了通过 <code>iterator()</code> 方法获得的 <code>Iterator</code> 的迭代器，以及通过 <code>listIterator()</code> 方法获得的 <code>ListItr</code> 迭代器。</p>
<h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator 迭代器</h3><p>迭代器 <code>Iterator</code> 接口提供了四个方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">// 检查是否还有下一个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个元素</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个当前的元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lambda表达式进行遍历</span></span><br><span class="line">    forEachRemaining(Consumer&lt;? <span class="built_in">super</span> E&gt; action);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在调用 <code>ArrayList#iterator()</code> 方法后，我们可以得到一个 <code>Itr</code> 内部类的实例。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">// 下一个将被返回的元素的下标</span></span><br><span class="line">    <span class="type">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一个被返回的元素的下标; -1 代表尚没有元素被返回</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在开始迭代时这个`ArrayList`的`modCount`</span></span><br><span class="line">    <span class="comment">// 在迭代操作时，迭代器将反复检查`expectedModCount`与当前`modCount`是否相同，一旦不同就会触发`fail fast`机制。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    Itr() {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如果当前迭代位置的下标等于集合的长度</span></span><br><span class="line">        <span class="comment">// 则说明迭代已经结束</span></span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 检查集合的结构是否在迭代过程中被修改过</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得当前迭代位置的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="comment">// 如果下标超出了集合的长度</span></span><br><span class="line">        <span class="comment">// 则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得该集合的所有元素</span></span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前位置超出了集合的长度</span></span><br><span class="line">        <span class="comment">// 则说明集合的结构发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将游标向前移动一个位置</span></span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将上次返回的下标指向当前位置，并返回该位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 因为该方法删除的是lastRet指向的元素</span></span><br><span class="line">        <span class="comment">// 而在未调用next方法前，lastRet是-1</span></span><br><span class="line">        <span class="comment">// 所以不允许这样操作</span></span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查集合的结构是否在迭代过程中被修改过</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 调用集合的remove方法删除元素</span></span><br><span class="line">            ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">            <span class="comment">// 因为集合少了一个元素，所以将游标向前移动一个位置</span></span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            <span class="comment">// 而上次被返回的元素已经没了，</span></span><br><span class="line">            <span class="comment">// 所以lastRet指向-1</span></span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 因为ArrayList#remove修改了modCount</span></span><br><span class="line">            <span class="comment">// 所以这里同步expectedModCount，确保后续的迭代过程中不会触发fail fast机制</span></span><br><span class="line">            <span class="comment">// 所以使用迭代器删除元素是安全的</span></span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        } <span class="keyword">catch</span> (IndexOutOfBoundsException ex) {</span><br><span class="line">            <span class="comment">// 如果在删除操作时发生了数组越界</span></span><br><span class="line">            <span class="comment">// 则说明集合的结构被改变了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> {</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) {</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="ListItr迭代器"><a href="#ListItr迭代器" class="headerlink" title="ListItr迭代器"></a>ListItr 迭代器</h3><p><code>ArrayList</code> 提供了两个方法用来获得一个 <code>ListItr</code> 迭代器，其区别是有无指定下标。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a list iterator over the elements in this list (in proper</span></span><br><span class="line"><span class="comment"> * sequence), starting at the specified position in the list.</span></span><br><span class="line"><span class="comment"> * The specified index indicates the first element that would be</span></span><br><span class="line"><span class="comment"> * returned by an initial call to {<span class="doctag">@link</span> ListIterator#next next}.</span></span><br><span class="line"><span class="comment"> * An initial call to {<span class="doctag">@link</span> ListIterator#previous previous} would</span></span><br><span class="line"><span class="comment"> * return the element with the specified index minus one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">"Index: "</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a list iterator over the elements in this list (in proper</span></span><br><span class="line"><span class="comment"> * sequence).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The returned list iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #listIterator(int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ListItr</code> 继承了前面提到的 <code>Itr</code> 类，也就是说它拥有 <code>Itr</code> 类的所有方法。同时它实现了 <code>ListIterator</code> 接口。</p>
<p><code>ListIterator</code> 接口继承了 <code>Iterator</code> 接口。除了 <code>Iterator</code> 接口中定义的方法外，<code>ListIterator</code> 还另外声明了数个方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">// 在Iterator中存在的方法这里就略过了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有前一个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前迭代一个元素</span></span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取next()方法将要迭代到的元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取previous()方法将要迭代到的元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把通过next()或者previous()得到的元素修改为传入的数据</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个新的元素插入到上一个被迭代的元素和下一个被迭代的元素之间</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ArrayList</code> 中具体的 <code>ListItr</code> 的实现是这样子的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An optimized version of AbstractList.ListItr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">extends</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">// 在构造时直接将cursor指向指定的下标</span></span><br><span class="line">    ListItr(<span class="type">int</span> index) {</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为数组首个元素的下标是0，而cursor不会是负数</span></span><br><span class="line">    <span class="comment">// 所以当cursor不为0时，前面就有元素可供迭代</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cursor指向下一个被迭代的元素的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cursor减一就得到了前一个元素的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前迭代一个元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 检查集合的结构有没有被修改过</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得前一个元素的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果前一个元素的下标是负数</span></span><br><span class="line">        <span class="comment">// 则抛出NoSuchElementException</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取到集合的所有元素</span></span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果此时下标超出了所有元素的长度</span></span><br><span class="line">        <span class="comment">// 则认定集合的结构被外部改变过了</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将cursor指向前一个元素</span></span><br><span class="line">        cursor = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取得前一个元素，并重新设定lastRet的值</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将上一个迭代到的元素修改为指定的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="comment">// 尚无元素被迭代到的时候</span></span><br><span class="line">        <span class="comment">// lastRet是-1</span></span><br><span class="line">        <span class="comment">// 此时没有元素可以被修改</span></span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查集合的结构有没有被修改过</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 尝试使用`ArrayList#set`方法修改上一个被迭代位置的值</span></span><br><span class="line">            ArrayList.<span class="built_in">this</span>.set(lastRet, e);</span><br><span class="line">        } <span class="keyword">catch</span> (IndexOutOfBoundsException ex) {</span><br><span class="line">            <span class="comment">// 如果发生下标越界，则认定集合的结构被外部修改过</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在上一个元素与下一个元素之间插入数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="comment">// 检查集合的结构有没有被修改过</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 取得当前迭代的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试在当前位置插入一个元素</span></span><br><span class="line">            ArrayList.<span class="built_in">this</span>.add(i, e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将cursor后移一个位置</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为修改了集合结构后，modCount会改变</span></span><br><span class="line">            <span class="comment">// 所以需要同步expectedModCount的值</span></span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        } <span class="keyword">catch</span> (IndexOutOfBoundsException ex) {</span><br><span class="line">            <span class="comment">// 如果在操作过程中发生了下标越界</span></span><br><span class="line">            <span class="comment">// 则认定集合的结构被外部修改了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 源码阅读 - equals 和 hashCode 方法</title>
    <url>/java-read-src-hashcode-and-equals.html</url>
    <content><![CDATA[<p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p>
<p>这次就来阅读一下 <code>Object</code> 类里面 <code>hashCode</code> 方法和 <code>equals</code> 方法的源码。</p>
<span id="more"></span>

<h2 id="先看看代码"><a href="#先看看代码" class="headerlink" title="先看看代码"></a>先看看代码</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> {</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，<code>hashCode</code> 方法是一个 native 方法，<code>equals</code> 方法比较了两个对象是否指向同一个内存的地址。</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><h3 id="什么是hash"><a href="#什么是hash" class="headerlink" title="什么是hash"></a>什么是 hash</h3><p>要搞清楚 <code>hashCode</code> 干了什么，那就得要知道 <code>hash</code> 是什么。</p>
<blockquote>
<p>散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字 “指纹” 的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p>
</blockquote>
<h3 id="Java中的hashCode方法"><a href="#Java中的hashCode方法" class="headerlink" title="Java中的hashCode方法"></a>Java 中的 hashCode 方法</h3><p>在 <code>Object</code> 类中的 <code>hashCode</code> 方法是一个 native 方法，我们没办法直接得知它的实现方式，但是我们依旧可以从它的 JavaDoc 中得知一些信息。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment">     * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@link</span> java.util.HashMap}.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of {<span class="doctag">@code</span> hashCode} is:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment">     * class {<span class="doctag">@code</span> Object} does return distinct integers for distinct</span></span><br><span class="line"><span class="comment">     * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment">     * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment">     * technique is not required by the</span></span><br><span class="line"><span class="comment">     * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上面花了很大的篇幅讲了如果要重新实现 <code>hashCode</code> 方法所需要遵循的原则，但是很可惜，我们现在暂时不关注这些。我们现在关注的，是最后一段的内容。</p>
<p>在最后一段中，它讲了通常情况下，程序是怎样计算出 <code>hashCode</code> 的值的。</p>
<blockquote>
<p>This is typically implemented by converting the internal address of the object into an integer<br>通常来说，这是通过把内部的地址转换成一个整型数来实现的</p>
</blockquote>
<p>当然，并不是所有的类都使用了这个计算方法，比如 <code>String</code> 就重新实现了自己的 <code>hashCode</code> 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) {</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        }</span><br><span class="line">        hash = h;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p><code>equals</code> 方法的作用是比较两个对象的内容是否相同。一般来说，<code>Object</code> 类中提供的 <code>equals</code> 方法是没办法满足各个类型自己的需要的，所以它们基本上都实现了自己的 <code>equals</code> 方法。</p>
<p>用一个简单的例子来讲：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"aaa"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"aaa"</span>;</span><br><span class="line">str1.equals(str2); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p>显然，<code>str1</code> 和 <code>str2</code> 是两个不同的对象，如果直接比较它们的内存地址，那么得到的结果肯定是 false。所以可以肯定的是，<code>String</code> 类重写了 <code>equals</code> 方法。那么，我们就简单看一下 <code>String</code> 是怎样实现 <code>equals</code> 方法的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> {</span><br><span class="line">    <span class="comment">// 先检查两个对象的地址是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果被比较的对象地址不同，但它类型相同</span></span><br><span class="line">    <span class="comment">// 那么继续进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果被比较的字符串与本字符串长度相同</span></span><br><span class="line">        <span class="comment">// 那么继续比较其中char数组中的每个元素是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) {</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>既然每个类型都可以实现自己的 <code>equals</code> 方法，那么必然有一个规则来约束它们的实现方式，以保证在何时何地 <code>equals</code> 都可以得到合理的结果。</p>
<p>在 <code>equals</code> 方法的 JavaDoc 中描述了重写该方法所需要遵守的规则：</p>
<blockquote>
<p>It is <i>reflexive</i>: for any non-null reference value <code>x</code>, <code>x.equals(x)</code> should return <code>true</code>.<br>It is <i>symmetric</i>: for any non-null reference values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code>.<br>It is <i>transitive</i>: for any non-null reference values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.<br>It is <i>consistent</i>: for any non-null reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in <code>equals</code> comparisons on the objects is modified.<br>For any non-null reference value <code>x</code>, <code>x.equals(null)</code> should return <code>false</code>.</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>自反性：对于一个非 null 的引用值，<code>x.equals(x)</code> 应当返回 <code>true</code>。<br>对称性：对于两个非 null 的引用值 <code>x</code> 和 <code>y</code>，当且仅当 <code>y.equals(x)</code> 时，<code>x.equals(y)</code> 返回 <code>true</code>。<br>传递性：对于任意非 null 的引用值 <code>x</code>，<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，而且 <code>y.equals(z)</code> 返回 <code>true</code>，那么 <code>x.equals(z)</code> 也应返回 <code>true</code>。<br>一致性：对于任意非 null 的引用值 <code>x</code> 和 <code>y</code>，当两者都未被修改时，多次调用 <code>x.equals(y)</code> 都应一直返回 <code>true</code> 或者 <code>false</code>。<br>对于任意非 null 的引用值 <code>x</code>，<code>x.equals(null)</code> 应返回 <code>false</code>。</p>
</blockquote>
<h2 id="hashCode方法与equals方法的关系"><a href="#hashCode方法与equals方法的关系" class="headerlink" title="hashCode方法与equals方法的关系"></a>hashCode 方法与 equals 方法的关系</h2><p>在 <code>equals</code> 方法的 JavaDoc 上有这么一段话：</p>
<blockquote>
<p>Note that it is generally necessary to override the <code>hashCode</code> method whenever this method is overridden, so as to maintain the general contract for the <code>hashCode</code> method, which states that equal objects must have equal hash codes.<br>在重写 <code>equals</code> 方法时，通常也需要一并重写 <code>hashCode</code> 方法，以便维护 <code>hashCode</code> 方法的约定，即相等的对象必须拥有相同的哈希码</p>
</blockquote>
<p>而在 <code>hashCode</code> 方法的 JavaDoc 中，它有着这样的实现约定：</p>
<blockquote>
<p>Whenever it is invoked on the same object more than once during an execution of a Java application, the <code>hashCode</code> method must consistently return the same integer, provided no information used in <code>equals</code> comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</p>
<p>If two objects are equal according to the <code>equals(Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce the same integer result.</p>
<p>It is <em>not</em> required that if two objects are unequal according to the <code>java.lang.Object#equals(java.lang.Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce distinct integer results.  However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.</p>
</blockquote>
<p>即：</p>
<blockquote>
<p>在程序运行过程中，不论 <code>hashCode</code> 方法被调用了多少次，其返回结果都必须是一个恒定的整型值，以表明在使用 <code>equals</code> 比较对象时所需的信息没有被修改过。但是在程序每次运行之间，<code>hashCode</code> 返回的值则不需要保持一致</p>
<p>如果两个对象使用 <code>equals</code> 方法比较得出了相同 (equal) 的结论，那么对这两个对象执行 <code>hashCode</code> 方法得到的值也必须相同</p>
<p>在两个对象使用 <code>equals</code> 方法比较得出了不相同 (not equal) 的结论时，对这两个对象执行 <code>hashCode</code> 方法得到的值却可以相同。然而，开发人员需要意识到，给不同的对象返回不同的哈希码可以提升 hash table 的性能</p>
</blockquote>
<p>综上所述，我们可以得出如下结论：</p>
<ul>
<li>两个相同 (equal) 的对象必须拥有相同的哈希码</li>
<li>两个哈希码相同的对象却不一定相同 (equal)</li>
</ul>
<p>那么，这两条结论会对我们的程序造成什么影响呢？</p>
<p>首先我们看一下第一条。以 <code>Set</code> 举例，<code>Set</code> 会根据对象的 <code>hashCode</code> 来寻找对象的存储位置，那么可想而知，如果两个对象的值相同，哈希码却不同，那么就会导致 <code>Set</code> 中出现多个重复数据的情况。</p>
<p>而第二条结论出现的原因则是，目前没有任何一种哈希算法，可以保证对每个传入的值都可以计算出一个不同的哈希，这种情况的学名叫<code>哈希碰撞</code>，所以我们只能尽可能的减少出现哈希碰撞的可能性。至于 Java 如何应对哈希碰撞，我将在后续的博文中进行解释。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 源码阅读 - HashMap</title>
    <url>/java-read-src-hashmap.html</url>
    <content><![CDATA[<p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p>
<p>这次就来阅读一下 <code>HashMap</code> 的源码。</p>
<span id="more"></span>

<h2 id="HashMap的特性"><a href="#HashMap的特性" class="headerlink" title="HashMap的特性"></a>HashMap 的特性</h2><p><code>HashMap</code> 有如下的特性：</p>
<ul>
<li><code>HashMap</code> 是根据键值对来存储数据的，多个数据之间的键不能重复。在键重复时，旧的数据将会被覆盖</li>
<li><code>HashMap</code> 中各个数据实际存放的位置与 <code>hashCode()</code> 方法的结果有关，但不是由其结果直接决定</li>
<li><code>HashMap</code> 只允许一个键是 <code>null</code>(因为存储多个键是 <code>null</code> 的数据就违反了第一条特性)，但是允许多个值是 <code>null</code> 的数据</li>
<li><code>HashMap</code> 中数据存储的位置是不确定的，并且可能会因为扩容而改变，所以它的遍历顺序是不确定的</li>
<li><code>HashMap</code> 不是线程安全的，如果需要线程安全性则可以使用 <code>ConcurrentHashMap</code></li>
</ul>
<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码声明了一个名为 <code>HashMap</code> 的泛型类，它继承了 <code>AbstractMap</code>，并实现了 <code>Map</code>，<code>Cloneable</code>，<code>Serializable</code> 接口。</p>
<p><code>AbstractMap</code> 是一个抽象类，它是一个骨架级的 <code>Map</code> 实现，来减少实现一个 Map 所需的工作量。</p>
<p><code>Map</code> 接口顾名思义，它定义了要实现一个 Map 时必须实现的方法。</p>
<h2 id="一些关键的常量和概念"><a href="#一些关键的常量和概念" class="headerlink" title="一些关键的常量和概念"></a>一些关键的常量和概念</h2><p>在深入了解 <code>HashMap</code> 前，有一些关键的概念我们需要知道：</p>
<ul>
<li>哈希桶 (bucket/bin)：一个数组元素中存放的链表，就是一个哈希桶</li>
<li>哈希表：即存放了各个哈希桶的数组</li>
<li>树化阈值：当一个桶的大小超过了树化阈值之后才会将其变成红黑树</li>
<li>非树化阈值：当一个已经变成红黑树的桶中节点数量小于该值时，这个红黑树会被变回链表</li>
<li>最小树化容量：在选择是否将一个链表变成红黑树时，除了会考虑链表长度外，还会考虑哈希表的长度。仅当哈希表长度超过最小树化容量，且某个链表长度超过树化阈值时，这个链表才会被变成红黑树</li>
</ul>
<p>与之对应的有这几个常量值：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小树化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>此外 <code>HashMap</code> 还针对哈希表的扩容定义了一系列的常量和变量：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量。为了保证添加和查找的高效性，HashMap的容量总是2的幂次</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认载荷因子。</span></span><br><span class="line"><span class="comment">// 载荷因子是哈希表在其容量自动增加之前被允许获得的最大数量的度量，决定了哈希表何时扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阈值。它的值等于哈希表容量乘以载荷因子</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的载荷因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h2><p><code>HashMap</code> 存储数据的方式有两种，而这两种方式也正是 <code>Java 1.7</code> 和 <code>Java 8</code> 的分界线，因为 <code>Java 8</code> 对于 <code>HashMap</code> 进行了底层上的改动。</p>
<h3 id="Java-1-7之前"><a href="#Java-1-7之前" class="headerlink" title="Java 1.7之前"></a>Java 1.7 之前</h3><p>因为 <code>HashMap</code> 是依靠 <code>hashCode()</code> 方法的结果来决定元素存储的位置的，而再完美的哈希函数也无法避免哈希碰撞的出现，所以 <code>HashMap</code> 选择采用<code>拉链法</code> (也叫<code>链地址法</code>) 来存储数据。</p>
<p>链地址法是一种结合了数组和链表的存储方式，在每个数组元素中存储的都是一个链表，这些链表被称为<code>桶(bucket/bin)</code>。</p>
<p>为了直观的展示，这里借用一下参考文章 1 [^1] 中的一幅图：</p>
<p><img data-src="https://blog-static.boris1993.com/java-read-src-hashmap/hashing.jpg" alt="拉链法"></p>
<p>我们都知道，一个数组元素只能保存一个数据，但是多个数据经过哈希运算后可能得到相同的哈希值，所以 <code>HashMap</code> 会将哈希值相同的数据存放在相同数组位置中的一个链表中。而在取出元素时，<code>HashMap</code> 首先会根据哈希值找到数组中的位置，然后遍历其中的链表来找到数据。</p>
<h3 id="Java-8之后"><a href="#Java-8之后" class="headerlink" title="Java 8之后"></a>Java 8 之后</h3><p>在一个 <code>HashMap</code> 存储越来越多的数据之后，数据之间发生哈希碰撞的可能性也会越来越大，导致每个数组中的链表也会越来越长，而因为遍历链表操作的时间复杂度是 <code>O(n)</code>，所以链表越长，遍历的效率就越差。所以在 <code>Java 8</code> 中，当数组长度大于 <code>MIN_TREEIFY_CAPACITY</code>，且某个链表长度大于 <code>TREEIFY_THRESHOLD</code> 时，这个链表将会被转换成红黑树。</p>
<p>这里依旧借用参考文章 1 [^1] 中的一幅图：</p>
<p><img data-src="https://blog-static.boris1993.com/java-read-src-hashmap/treeified.jpg" alt="树化后"></p>
<h3 id="数据的存储单元"><a href="#数据的存储单元" class="headerlink" title="数据的存储单元"></a>数据的存储单元</h3><p><code>HashMap</code> 中定义了一个 <code>Node&lt;K,V&gt;</code> 型的数组 <code>table</code> 用于存储数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 这个就是哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></tbody></table></figure>

<p>分别针对树化前和树化后的数据，<code>HashMap</code> 定义了不同的内部类作为其数据的存储单元。</p>
<h4 id="树化前"><a href="#树化前" class="headerlink" title="树化前"></a>树化前</h4><p><code>HashMap</code> 中定义了一个内部类 <code>Node</code>，作为链表中各个元素的存储单元。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; {</span><br><span class="line">    <span class="comment">// 这个节点的哈希，即数组的索引位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点所属的key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点的值</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表中的下一个元素</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) {</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        { <span class="keyword">return</span> key; }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      { <span class="keyword">return</span> value; }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> { <span class="keyword">return</span> key + <span class="string">"="</span> + value; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的哈希值通过将key的哈希和value的哈希异或得到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换这个节点的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> {</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> {</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="树化后"><a href="#树化后" class="headerlink" title="树化后"></a>树化后</h4><p>针对树化后的红黑树，<code>HashMap</code> 定义了一个内部类 <code>TreeNode</code> 作为树中各个元素的存储单元。但是这个类的代码太长了，放在这里不太合适，后面我再单独开一篇博文专门给它。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>HashMap</code> 提供了四个构造方法，我们下面一个一个来看：</p>
<h3 id="可以指定容量和载荷因子的构造方法"><a href="#可以指定容量和载荷因子的构造方法" class="headerlink" title="可以指定容量和载荷因子的构造方法"></a>可以指定容量和载荷因子的构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> {</span><br><span class="line">    <span class="comment">// 初始容量不能小于0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="comment">// 初始容量不能大于最大允许容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 载荷因子必须大于等于0，且不能为无穷大(比如0.0f/0.0f)</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据期望容量返回一个大于等于cap的扩容阈值，并且保证扩容阈值一定是2的幂次</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>虽然上面说<code>扩容阈值 = 哈希表容量 * 加载因子</code>，但是有没有发现，上面的构造方法里面其实并没有初始化 <code>table</code>？实际上，<code>table</code> 在第一次添加数据时才会被初始化，具体的操作我们放到后面再说。</p>
<h3 id="可以指定容量的构造方法"><a href="#可以指定容量的构造方法" class="headerlink" title="可以指定容量的构造方法"></a>可以指定容量的构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> {</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个构造方法就是把默认载荷因子和给定的初始容量传给上面说的那个构造方法，这里就不重复解释了。</p>
<h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 使用默认的载荷因子</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h2><p>我们知道，<code>HashMap</code> 既可以一次只新增一条数据，也可以一次新增多个数据。我们先看它是怎么新增单条数据的。</p>
<h3 id="新增单条数据"><a href="#新增单条数据" class="headerlink" title="新增单条数据"></a>新增单条数据</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> {</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>乍一看好像很简单的样子，一句话轻飘飘的完成了新增数据的任务。但是要展开看的话，信息量可就很大了。</p>
<p>我们从里面到外面一个一个的看。</p>
<h4 id="计算新元素的哈希值"><a href="#计算新元素的哈希值" class="headerlink" title="计算新元素的哈希值"></a>计算新元素的哈希值</h4><p>在上面提到的 <code>putVal</code> 方法中，第一个参数是这个数据的哈希值。那么这个哈希值是怎么计算出来的呢？在 <code>java 8</code> 中，<code>hash</code> 方法是这么实现的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 将key的hashCode与其无符号右移16位之后得到的值做一次异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面这段代码会对 key 的 hashCode 做一个扰动计算，来得到这个 key 在 <code>HashMap</code> 中的哈希值。这个扰动计算的目的就是为了降低发生哈希碰撞的可能性。</p>
<h4 id="向HashMap中增加数据"><a href="#向HashMap中增加数据" class="headerlink" title="向HashMap中增加数据"></a>向 HashMap 中增加数据</h4><p>在计算完 key 的哈希值后，<code>putVal</code> 方法会开始向 <code>HashMap</code> 中添加数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// hash就是key的哈希</span></span><br><span class="line"><span class="comment">// key就是key值</span></span><br><span class="line"><span class="comment">// value就是被添加的数据</span></span><br><span class="line"><span class="comment">// onlyIfAbsent如果是true则不替换数据</span></span><br><span class="line"><span class="comment">// evict如果是false，则说明是在初始化状态</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> {</span><br><span class="line">    <span class="comment">// 将指向哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在计算完本次要操作的哈希表下标后</span></span><br><span class="line">    <span class="comment">// p将指向哈希表的这个下标中的数据</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n将是哈希表的长度</span></span><br><span class="line">    <span class="comment">// 在计算完本次要操作的哈希表下标后，i将是这个下标值</span></span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查哈希表是不是还没有被初始化过，或者哈希表长度为0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 对哈希表进行首次扩容，即初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 经过i = (n - 1) &amp; hash这步运算得到本次插入的位置，即哈希表的数组下标</span></span><br><span class="line">    <span class="comment">// 如果这个位置尚没有元素，说明没有发生哈希碰撞</span></span><br><span class="line">    <span class="comment">// 那么就直接将插入的数据放在这个位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 如果这个位置已经有元素存在了，那就说明发生了哈希碰撞</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希相同，且key值相同，则覆盖这个元素</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表的这个位置已经被变成红黑树了</span></span><br><span class="line">        <span class="comment">// 那么就要调用红黑树版本的putVal，即putTreeVal来完成插入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在哈希相同，key却不同的时候</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环整个单链表，同时使用binCount记录单链表的节点数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在单链表尾部拼接本次插入的数据</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) {</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果单链表的节点数量大于等于树化阈值时，就将这个单链表进行树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果在遍历过程中发现有数据的key与本次操作的key相同</span></span><br><span class="line">                <span class="comment">// 此时e指向要被替换value的节点，并结束遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果e != null，说明需要替换e所指节点的数据</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 这个方法在HashMap中是空实现</span></span><br><span class="line">            <span class="comment">// 但是LinkedHashMap中会有实现</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fail-fast机制</span></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果哈希表长度大于扩容阈值，则对哈希表扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 这个方法在HashMap中也是空的</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码可能看起来比较费劲，这里借用美团博客的一张图来展示 <code>put</code> 方法的执行流程：</p>
<p><img data-src="https://blog-static.boris1993.com/java-read-src-hashmap/putting.png" alt="put方法执行流程"></p>
<h3 id="新增多条数据"><a href="#新增多条数据" class="headerlink" title="新增多条数据"></a>新增多条数据</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> {</span><br><span class="line">    putMapEntries(m, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>依旧是调用了另一个方法实现的添加数据。那么继续深入进去看看。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> {</span><br><span class="line">    <span class="comment">// 传入的map的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的map有数据，才进行后面的运算</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果哈希表尚未初始化，则先计算扩容阈值</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) { <span class="comment">// pre-size</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希表已经初始化完成，但是传入的map的大小超过了扩容阈值</span></span><br><span class="line">        <span class="comment">// 那么就将哈希表扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历传入的map，然后逐个调用putVal方法增加元素</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) {</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap 扩容</h2><p>上面多次提到了 <code>HashMap</code> 的扩容操作，这里我们就详细看看它是怎么扩容的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    <span class="comment">// oldTab指向扩容前的哈希表</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// oldCap是扩容前的哈希表容量，如果哈希表尚未被初始化，那么容量就是0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// oldThr是扩容前的扩容阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">// newCap为扩容后的容量，newThr是扩容后的扩容阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果扩容前的哈希表容量已经是最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">            <span class="comment">// 那么就将扩容阈值设为Integer.MAX_VALUE</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 并停止扩容</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 新容量是旧容量的2倍，且新的扩容阈值也是旧扩容阈值的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果旧的扩容阈值大于0</span></span><br><span class="line">    <span class="comment">// 而同时旧的容量等于0</span></span><br><span class="line">    <span class="comment">// 那么说明已经使用带参数的构造方法设定了载荷因子和初始容量</span></span><br><span class="line">    <span class="comment">// 而且这次是首次扩容</span></span><br><span class="line">    <span class="comment">// 此时初始容量不等于期望容量，且大于期望容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 设定新的容量等于旧的扩容阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果旧的扩容阈值是0</span></span><br><span class="line">    <span class="comment">// 而同时旧的容量等于0</span></span><br><span class="line">    <span class="comment">// 那么说明这个HashMap是用默认构造方法初始化的</span></span><br><span class="line">    <span class="comment">// 而且这次是首次扩容</span></span><br><span class="line">    <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 那么新的容量就等于默认初始容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 新的扩容阈值等于(默认载荷因子 * 默认初始容量)</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的扩容阈值是0</span></span><br><span class="line">    <span class="comment">// 对应当前table为空，但是有阈值的情况</span></span><br><span class="line">    <span class="comment">// 那么就计算新的扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新HashMap的扩容阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用扩容后的容量创建一个新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings({"rawtypes","unchecked"})</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将HashMap的哈希表指向新的哈希表</span></span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果旧的哈希表不为null</span></span><br><span class="line">    <span class="comment">// 则进行重新插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历旧的哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            <span class="comment">// 存储旧的哈希表对应位置中链表的头节点</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果这个位置有数据</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 释放掉旧的链表中的空间</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果这个链表中只有一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 则使用新哈希表的长度计算下标，并插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果这个节点是个红黑树</span></span><br><span class="line">                <span class="comment">// 那么需要选择是拆分这个红黑树，或者将其非树化</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 如果这个链表有数个节点</span></span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 因为扩容后的容量是扩容前容量的2倍</span></span><br><span class="line">                    <span class="comment">// 所以原链表上的节点，既有可能会被放在它原来的位置上(低位)</span></span><br><span class="line">                    <span class="comment">// 也有可能会被放到扩容后新增加的位置上(高位 = 低位 + 旧的容量)</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 低位链表的头节点和尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 高位链表的头节点和尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 存放原来链表中的节点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 遍历旧的链表</span></span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 利用哈希值和旧的容量进行与运算</span></span><br><span class="line">                        <span class="comment">// 如果结果等于0，那么就拼接到低位链表的末尾</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 否则拼接到高位链表的末尾</span></span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果低位链表非空，则将链表放到原位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) {</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 如果高位链表非空，则将链表放到新增加的位置</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> {</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> {</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> {</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 检查哈希表是不是空</span></span><br><span class="line">    <span class="comment">// 以及哈希表中对应下标的第一个元素是不是null，即这个位置是否有节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 因为第一个节点无所谓是链表节点还是红黑树节点</span></span><br><span class="line">        <span class="comment">// 所以先用一个简单的办法检查第一个节点是不是要找的节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 如果是，就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果第一个节点不是要找的节点</span></span><br><span class="line">        <span class="comment">// 而且它后面有别的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 如果后面的节点是红黑树，那么调用红黑树的方法取寻找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则遍历这个链表，寻找符合要求的节点并返回</span></span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            } <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配key来删除</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> {</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时匹配key和value来删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> {</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value, <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> {</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 检查哈希表是不是空</span></span><br><span class="line">    <span class="comment">// 以及哈希表中对应下标的第一个元素是不是null，即这个位置是否有节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) {</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 先检查链表中第一个元素是否匹配</span></span><br><span class="line">        <span class="comment">// 如果匹配就直接取出来</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 否则继续向后遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果后续的节点是红黑树，那么使用红黑树的方法寻找匹配的节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 否则遍历链表，根据hash和key寻找节点</span></span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) {</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    p = e;</span><br><span class="line">                } <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果取到了节点，则开始删除</span></span><br><span class="line">        <span class="comment">// (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))构成了一个判断链条</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) {</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="迭代HashMap"><a href="#迭代HashMap" class="headerlink" title="迭代HashMap"></a>迭代 HashMap</h2><p><code>HashMap</code> 提供了多种迭代的方式，比如迭代 <code>EntrySet</code>，或者迭代 <code>KeySet</code>。</p>
<h3 id="迭代KeySet"><a href="#迭代KeySet" class="headerlink" title="迭代KeySet"></a>迭代 KeySet</h3><p>在迭代 <code>KeySet</code> 的时候，我们可以逐个得到 <code>HashMap</code> 中的 key，然后根据 key 来进行操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个KeySet实例</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> {</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="literal">null</span>) {</span><br><span class="line">        ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; {</span><br><span class="line">    <span class="comment">// 得到KeySet的长度，也是HashMap的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 { <span class="keyword">return</span> size; }</span><br><span class="line">    <span class="comment">// 可以清空这个HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               { HashMap.<span class="built_in">this</span>.clear(); }</span><br><span class="line">    <span class="comment">// 得到一个KeyIterator迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     { <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); }</span><br><span class="line">    <span class="comment">// 检查是否包含某个key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> { <span class="keyword">return</span> containsKey(o); }</span><br><span class="line">    <span class="comment">// 根据key删除某个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> {</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> {</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) {</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; {</span><br><span class="line">    <span class="comment">// 得到下一个节点的key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> { <span class="keyword">return</span> nextNode().key; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="迭代EntrySet"><a href="#迭代EntrySet" class="headerlink" title="迭代EntrySet"></a>迭代 EntrySet</h3><p>在迭代 <code>EntrySet</code> 的时候，我们可以同时得到一个节点的 key 和 value。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个EntrySet实例</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">EntrySet</span>()) : es;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntrySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; {</span><br><span class="line">    <span class="comment">// 得到EntrySet的大小，即HashMap的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 { <span class="keyword">return</span> size; }</span><br><span class="line">    <span class="comment">// 可以清空这个HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               { HashMap.<span class="built_in">this</span>.clear(); }</span><br><span class="line">    <span class="comment">// 得到一个EntryIterator迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntryIterator</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查EntrySet中是否包含某个Entry</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> {</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="literal">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根据传入的Entry在HashMap中匹配并删除对应的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> {</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntrySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> {</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) {</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntryIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; {</span><br><span class="line">    <span class="comment">// 得到下一个节点的Entry</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.Entry&lt;K,V&gt; <span class="title function_">next</span><span class="params">()</span> { <span class="keyword">return</span> nextNode(); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h3><p>为什么上面看到 <code>KeyIterator</code> 和 <code>EntryIterator</code> 就停止了呢？因为它们两个都是继承于 <code>HashIterator</code>，这里我们集中看一下。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> {</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// 下一个要返回的Entry</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// 当前的Entry</span></span><br><span class="line">    <span class="type">int</span> expectedModCount;  <span class="comment">// 结合modCount实现fast-fail机制</span></span><br><span class="line">    <span class="type">int</span> index;             <span class="comment">// 当前哈希表的下标</span></span><br><span class="line"></span><br><span class="line">    HashIterator() {</span><br><span class="line">        <span class="comment">// 取迭代时的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="comment">// 指向当前的哈希表</span></span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="literal">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从哈希表中第一个不为空的位置获取第一个Entry</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) { <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> {} <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否还有节点可供迭代</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> {</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="comment">// 如果当前链表被遍历完了，那么就寻找下一个不是null的链表头</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">do</span> {} <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除当前被迭代的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> {</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 同步新的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面迭代时的算法可以看到，迭代器总是先遍历当前的链表或者红黑树，然后再去遍历哈希表，也就是说，它采用的是深度优先的算法。</p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWM4M2ZhMzUxODgyNTVjNTY2OGFmZDA=">搞懂 Java HashMap 源码<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTYvMDYvMjQvamF2YS1oYXNobWFwLmh0bWw=">Java 8 系列之重新认识 HashMap<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cHM6Ly93d3cuenlidWx1by5jb20va2lyYVNhbGx5L25vdGUvODE5ODQz">集合番 @HashMap 一文通（1.7 版）<i class="fa fa-external-link-alt"></i></span><br>[^4]: <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjkyNjcyMg==">HashMap 源码详细分析 (JDK1.8)<i class="fa fa-external-link-alt"></i></span><br>[^5]: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyNDA4NzcvYXJ0aWNsZS9kZXRhaWxzLzUzMzUxMTg4">Java 集合深入理解（16）：HashMap 主要特点和关键方法源码解读<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 源码阅读 - LinkedList</title>
    <url>/java-read-src-linkedlist.html</url>
    <content><![CDATA[<p>做技术，不能只知其然而不知其所以然。在知道了工具的原理之后，才能更高效的使用这个工具。在程序的世界里，源码里面没有秘密，看懂了源码，也就看懂了原理。</p>
<p>这次就来阅读一下 <code>LinkedList</code> 的源码。</p>
<span id="more"></span>

<h2 id="LinkedList的特性"><a href="#LinkedList的特性" class="headerlink" title="LinkedList的特性"></a>LinkedList 的特性</h2><p><code>LinkedList</code> 有如下几个特性：</p>
<ul>
<li>底层的数据结构是双向链表</li>
<li>存储的数据允许为 <code>null</code></li>
<li>允许存放重复的数据</li>
<li>元素在 List 中的顺序由添加顺序决定</li>
<li>不是线程安全的</li>
</ul>
<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码声明了一个名为 <code>LinkedList</code> 的泛型类，继承了 <code>AbstractSequentialList</code>，并实现了 <code>List</code>，<code>Deque</code>，<code>Cloneable</code>，<code>Serializable</code> 接口。</p>
<p><code>AbstractSequentialList</code> 抽象类提供了一个 “骨架” 级别的 List 实现，用来减少实现一个支持顺序读写的 <code>List</code> 的工作量。</p>
<p><code>Deque</code> 接口约定了要实现一个双向队列 (Double Ended Queue) 所必须要实现的方法。</p>
<p><code>Cloneable</code> 是一个标记接口，表明了这个类允许使用 <code>Object.clone()</code> 命令进行属性到属性的复制。</p>
<p><code>Serializable</code> 也是一个标记接口，表明在这个类上启用 Java 的序列化功能。</p>
<h2 id="如何存储数据"><a href="#如何存储数据" class="headerlink" title="如何存储数据"></a>如何存储数据</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to first node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to last node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></tbody></table></figure>

<p><code>first</code> 和 <code>last</code> 是两个 <code>Node</code> 对象，分别指向了链表中的第一个节点和最后一个节点。<code>size</code> 保存了这个链表中元素的个数。</p>
<p><code>Node</code> 类是 <code>LinkedList</code> 类中的一个内部类，它定义了一个元素实际上是如何被存储的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>item</code> 是实际存储的数据，<code>next</code> 和 <code>prev</code> 则分别指向了下一个元素和上一个元素。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>LinkedList</code> 有两个构造方法，分别用来初始化一个空的链表，和从一个给定的集合中取出元素来初始化一个链表。</p>
<h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>无参的构造方法实际上什么都没有做，返回的 <code>LinkedList</code> 对象中，<code>size</code> 为默认值 <code>0</code>，<code>first</code> 和 <code>last</code> 的值都是 <code>null</code>。</p>
<h3 id="从集合初始化的构造方法"><a href="#从集合初始化的构造方法" class="headerlink" title="从集合初始化的构造方法"></a>从集合初始化的构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个构造方法首先创建了一个空的 <code>LinkedList</code>，然后调用了 <code>addAll</code> 方法将集合中的数据放到这个链表中。</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>在 <code>LinkedList</code> 中插入数据有三种方式：在头部增加节点、在尾部增加节点，和在某个元素间插入节点。</p>
<h3 id="在头部增加节点"><a href="#在头部增加节点" class="headerlink" title="在头部增加节点"></a>在头部增加节点</h3><p>要在链表头部增加节点，可以使用 <code>addFirst(E)</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the beginning of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> {</span><br><span class="line">    linkFirst(e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该方法又调用了一个 <code>private</code> 方法 <code>linkFirst(E)</code> 实现在头部插入数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as first element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>linkFirst(E)</code> 方法首先取出当前的头部元素 <code>first</code>，然后构造了一个新的 <code>Node</code> 对象，新对象的 <code>prev</code> 值为 <code>null</code>，代表它是一个头部元素，<code>next</code> 值为原来的 <code>first</code>，它存储的数据则是这次插入的数据。然后它将链表的 <code>first</code> 设为这次新增加的元素。</p>
<p>根据链表的特性可以知道，如果一个链表不是空的，那么它的 <code>first</code> 必定非空；反之，如果它的 <code>first</code> 为 <code>null</code>，那么这个链表一定为空。所以根据这个规则，它会判断在插入元素前，这个链表是不是空的，如果是空的，那么新元素就同时作为链表的尾 <code>last</code>；如果不是空的，那么就让原来的 <code>first</code> 的 <code>prev</code> 指向新插入的元素。这样操作之后，新元素与原 <code>first</code> 元素之间就出现了一个双向的引用，即完成了一个小的双向链表。</p>
<p>最后使链表的 <code>size</code> 加一，就完成了一次新增头元素的操作。</p>
<h3 id="在尾部增加节点"><a href="#在尾部增加节点" class="headerlink" title="在尾部增加节点"></a>在尾部增加节点</h3><p>在尾部增加节点，可以使用 <code>add(E)</code> 方法或 <code>addLast(E)</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to {<span class="doctag">@link</span> #add}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> {</span><br><span class="line">    linkLast(e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to {<span class="doctag">@link</span> #addLast}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Collection#add})</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，两个方法都是通过一个 <code>private</code> 方法 <code>linkLast(E)</code> 实现的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在尾部插入数据的操作与在头部插入数据的操作类似，依旧是构造一个新的节点，使原来的 <code>last</code> 节点指向新节点，然后根据原链表是否为空执行后续操作。在这里就不多赘述了。</p>
<h3 id="在中间增加节点"><a href="#在中间增加节点" class="headerlink" title="在中间增加节点"></a>在中间增加节点</h3><p>要在链表中间插入数据，可以使用 <code>add(int, E)</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> {</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个方法所做的操作，简单来说就是，将新的元素放到指定位置，并将原来处于这个位置的元素及其所有后续元素全部后移一个位置。</p>
<p>首先它调用了 <code>checkPositionIndex(int)</code> 方法，我们看看它干了什么。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tells if the argument is the index of a valid position for an</span></span><br><span class="line"><span class="comment"> * iterator or an add operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an IndexOutOfBoundsException detail message.</span></span><br><span class="line"><span class="comment"> * Of the many possible refactorings of the error handling code,</span></span><br><span class="line"><span class="comment"> * this "outlining" performs best with both server and client VMs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个方法检查了用户输入的插入位置是不是一个合法的位置，规则就是插入位置必须大于等于 0 且小于等于最大位置。</p>
<p>通过检查之后，它继续判断插入的位置是不是链表的末尾，如果是末尾的话，就直接调用 <code>linkLast(E)</code> 在链表尾部新增一个元素，否则它会先取出现在位于插入位置的节点，然后调用 <code>linkBefore(E, Node)</code> 在链表中间插入元素。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) {</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> {</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>node(int)</code> 方法巧妙的利用了二分法，根据元素所在的位置来决定是从链表头部还是从尾部开始查找节点。</p>
<p><code>linkBefore(E, Node)</code> 方法进行的操作，就像我们在书中学习到的一样，先让新节点建立起到左右两个节点的连接，然后让右边的节点连接到新插入的节点，最后更新链表的大小。</p>
<h3 id="用集合批量增加节点"><a href="#用集合批量增加节点" class="headerlink" title="用集合批量增加节点"></a>用集合批量增加节点</h3><p>之前我们在 <code>LinkedList</code> 的构造方法中看到了一个 <code>addAll(Collection)</code> 方法，现在就来看看它干了什么。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the specified</span></span><br><span class="line"><span class="comment"> * collection's iterator.  The behavior of this operation is undefined if</span></span><br><span class="line"><span class="comment"> * the specified collection is modified while the operation is in</span></span><br><span class="line"><span class="comment"> * progress.  (Note that this will occur if the specified collection is</span></span><br><span class="line"><span class="comment"> * this list, and it's nonempty.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element</span></span><br><span class="line"><span class="comment"> *              from the specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> {</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) {</span><br><span class="line">        succ = <span class="literal">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) {</span><br><span class="line">        <span class="meta">@SuppressWarnings("unchecked")</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="literal">null</span>) {</span><br><span class="line">        last = pred;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的重头戏是 <code>addAll(int, Collection)</code> 方法，它实现了在链表中间批量插入节点的功能。<code>addAll(Collection)</code> 实际上就是调用它在链表末尾批量插入节点。</p>
<p>首先 <code>addAll</code> 方法会检查插入的位置是否合法，如果不合法就会抛出 <code>IndexOutOfBoundsException</code> 异常。然后它将传入的集合转换成一个对象数组，并检查数组长度，如果长度是 0，则说明链表内容未被改变，直接返回 <code>false</code>。</p>
<p>然后它会检查插入的位置，并且记录下插入位置的上一个节点和下一个节点。</p>
<p>接下来这个方法开始遍历传入的集合，并将集合中的数据逐个插入到链表中。插入的逻辑与前面讲的类似，所以就不再赘述了。</p>
<p>最后它会完成一系列收尾工作，包括设定链表尾部的节点，和更新链表的长度，然后返回 <code>true</code>，代表链表成功被更新了。</p>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>因为 <code>LinkedList</code> 也是一个双向队列，所以它既允许从两端开始获取数据，又可以根据下标从指定位置获取数据。</p>
<h3 id="取出头部的节点"><a href="#取出头部的节点" class="headerlink" title="取出头部的节点"></a>取出头部的节点</h3><p><code>LinkedList</code> 提供了多个方法来允许用户从链表头部取出数据，分别有：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or {<span class="doctag">@code</span> null} if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or {<span class="doctag">@code</span> null} if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从头部取出节点的操作都大同小异，区别只是在于取出空值之后是抛异常还是返回 null，以及会不会同时删除头部元素。逻辑很简单，这里就不多赘述了。</p>
<p>除了上面列出的几个方法外，还有 <code>pop()</code>、<code>pollFirst()</code> 等方法也提供了相同的功能，但是代码内容大同小异，所以也不放上来了，以免浪费篇幅。</p>
<h3 id="取出尾部的节点"><a href="#取出尾部的节点" class="headerlink" title="取出尾部的节点"></a>取出尾部的节点</h3><p><code>LinkedList</code> 同样提供了数个方法用于从尾部取出节点，它们的逻辑也基本相同，这里同上文一样，仅展示部分代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the last element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the last element of this list,</span></span><br><span class="line"><span class="comment"> * or returns {<span class="doctag">@code</span> null} if this list is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element of this list, or {<span class="doctag">@code</span> null}</span></span><br><span class="line"><span class="comment"> *         if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : l.item;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the last element of this list,</span></span><br><span class="line"><span class="comment"> * or returns {<span class="doctag">@code</span> null} if this list is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element of this list, or {<span class="doctag">@code</span> null} if</span></span><br><span class="line"><span class="comment"> *     this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="取出中间的节点"><a href="#取出中间的节点" class="headerlink" title="取出中间的节点"></a>取出中间的节点</h3><p>要从链表中的某个位置取出节点，可以使用 <code>get(int)</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它首先还是检查了传入的下标是否合法，如果合法就调用 <code>node(int)</code> 方法取得该节点，并返回其数据。<code>node(int)</code> 方法在上面已经介绍过，这里就不重复介绍了。</p>
<h3 id="查询链表是否包含某个数据"><a href="#查询链表是否包含某个数据" class="headerlink" title="查询链表是否包含某个数据"></a>查询链表是否包含某个数据</h3><p><code>LinkedList</code> 提供了 <code>contains(Object)</code> 方法用来查询该链表是否包含某个数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if this list contains the specified element.</span></span><br><span class="line"><span class="comment"> * More formally, returns {<span class="doctag">@code</span> true} if and only if this list contains</span></span><br><span class="line"><span class="comment"> * at least one element {<span class="doctag">@code</span> e} such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this list is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this list contains the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> {</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index {<span class="doctag">@code</span> i} such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to search for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the first occurrence of the specified element in</span></span><br><span class="line"><span class="comment"> *         this list, or -1 if this list does not contain the element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) {</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) {</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>contains(Object)</code> 方法实际上是调用了 <code>indexOf(Object)</code> 方法，并检查其返回是否为 <code>-1</code>，来判断这个值是否存在于该链表中。</p>
<p><code>indexOf(Object)</code> 方法的逻辑就是，从链表的头部开始，逐个检查其节点的值是否为传入的值。如果链表为空则直接返回 <code>-1</code>。</p>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p><code>LinkedList</code> 提供了一个 <code>set(int, E)</code> 的方法用于修改某个节点的数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> {</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该方法首先检查传入的下标是否合法，检查通过后，它会为指定位置的节点设定新的数据，并返回该节点原有的数据。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p><code>LinkedList</code> 提供了多个方法来从链表中删除节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the first element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the last element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>removeFirst()</code> 和 <code>removeLast()</code> 方法分别可以从链表的头部和尾部取出一个节点，并将其删除。如果链表是空的，则会抛出 <code>NoSuchElementException</code> 异常。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.  Shifts any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the left (subtracts one from their indices).</span></span><br><span class="line"><span class="comment"> * Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>remove(int)</code> 方法可以用来取出并删除指定位置下的一个节点，同时所有处于其后方的节点都将向前移动一个位置。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If this list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> i} such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns {<span class="doctag">@code</span> true} if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> {</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) {</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) {</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) {</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) {</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element in this</span></span><br><span class="line"><span class="comment"> * list (when traversing the list from head to tail).  If the list</span></span><br><span class="line"><span class="comment"> * does not contain the element, it is unchanged.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if the list contained the specified element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> {</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the last occurrence of the specified element in this</span></span><br><span class="line"><span class="comment"> * list (when traversing the list from head to tail).  If the list</span></span><br><span class="line"><span class="comment"> * does not contain the element, it is unchanged.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if the list contained the specified element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span> {</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) {</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) {</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) {</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) {</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>remove(Object)</code> 方法和 <code>removeFirstOccurrence(Object)</code> 方法会从头部遍历整个链表，并检查各个节点是否与传入的参数匹配。一旦找到一个匹配的节点就将其删除，并结束操作。<code>removeLastOccurrence(Object)</code> 方法则是从链表尾部开始查找匹配的节点，并删除第一个匹配到的节点。</p>
<h2 id="将LinkedList当作栈来操作"><a href="#将LinkedList当作栈来操作" class="headerlink" title="将LinkedList当作栈来操作"></a>将 <code>LinkedList</code> 当作栈来操作</h2><p>上面说过，<code>LinkedList</code> 可以被当成一个双向队列来操作。那么，如果我们把这个队列的底部 “封死”，只操作头部，它是不是就变成了一个栈呢？没错，它是可以这样用的，而且也已经有方法来允许我们这样操作了。实际上，<code>push</code> 和 <code>pop</code> 的操作，就是直接调用了 <code>addFirst(E)</code> 和 <code>removeFirst()</code> 方法来实现入栈和出栈操作的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to {<span class="doctag">@link</span> #addFirst}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to push</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> {</span><br><span class="line">    addFirst(e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops an element from the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, removes and returns the first element of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to {<span class="doctag">@link</span> #removeFirst()}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the front of this list (which is the top</span></span><br><span class="line"><span class="comment"> *         of the stack represented by this list)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><code>LinkedList</code> 提供了 <code>iterator()</code> 和 <code>listIterator(int)</code> 方法来获取迭代器。实际上这两个方法都将返回一个 <code>ListItr</code> 实例，区别在于 <code>iterator()</code> 是从链表头部开始迭代，而 <code>listIterator(int)</code> 方法则是从指定位置开始迭代。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">// 上次迭代时返回的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一次迭代即将返回的节点</span></span><br><span class="line">    <span class="comment">// 其实也是当前指向但仍未取值的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个被迭代节点的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nextIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    ListItr(<span class="type">int</span> index) {</span><br><span class="line">        <span class="comment">// 判断开始迭代的位置是否为链表末尾</span></span><br><span class="line">        <span class="comment">// 如果不是末尾就取出开始迭代位置的节点，否则取出null</span></span><br><span class="line">        next = (index == size) ? <span class="literal">null</span> : node(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将nextIndex指向初始迭代位置</span></span><br><span class="line">        nextIndex = index;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查有无下一个节点可供迭代</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如果下一个迭代位置的下标小于链表长度</span></span><br><span class="line">        <span class="comment">// 就认为还有元素可供迭代</span></span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 检查链表的结构有没有被修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经没有节点可供迭代</span></span><br><span class="line">        <span class="comment">// 则抛出NoSuchElementException</span></span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出下一个被迭代的节点</span></span><br><span class="line">        lastReturned = next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next指针像下一个节点移动</span></span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出当前被迭代的节点的值</span></span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextIndex的初始值为0</span></span><br><span class="line">    <span class="comment">// 当它大于0时，就认定该位置的前面仍有节点可供迭代</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一个节点</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 检查链表的结构有没有被修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查前面有无节点可供迭代</span></span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前节点是否为null，如果是，就说明当前已经处于链表的末尾，那么就返回链表最后一个节点；</span></span><br><span class="line">        <span class="comment">// 如果不是，就返回当前位置的上一个节点</span></span><br><span class="line">        <span class="comment">// 然后设定当前位置和上一次返回位置为上一个节点</span></span><br><span class="line">        lastReturned = next = (next == <span class="literal">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个被迭代节点的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一次被迭代节点的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除上一次被迭代的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 检查链表的结构有没有被修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有上一次被迭代的节点</span></span><br><span class="line">        <span class="comment">// 则抛出IllegalStateException</span></span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出将被删除节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后删掉它</span></span><br><span class="line">        unlink(lastReturned);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextIndex--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置上一次被迭代的位置</span></span><br><span class="line">        lastReturned = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为unlink会使modCound加一</span></span><br><span class="line">        <span class="comment">// 所以这里要同步把expectedModCount加一</span></span><br><span class="line">        expectedModCount++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改上次迭代到的节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为lastReturned是某个节点的引用</span></span><br><span class="line">        <span class="comment">// 所以可以直接修改它的值</span></span><br><span class="line">        lastReturned.item = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在下一个被迭代的节点前插入一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 如果已经迭代到链表的末尾，那么就在末尾新增一个节点</span></span><br><span class="line">            linkLast(e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则就在下个被迭代的节点前插入一个节点</span></span><br><span class="line">            linkBefore(e, next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 游标向后移一位</span></span><br><span class="line">        nextIndex++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步expectedModCount</span></span><br><span class="line">        expectedModCount++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> {</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) {</span><br><span class="line">            action.accept(next.item);</span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">        }</span><br><span class="line">        checkForComodification();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>去掉自定义异常中的堆栈跟踪信息</title>
    <url>/java-remove-stack-trace-in-customized-exceptions.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务异常基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseBizException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseBizException</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖fillInStackTrace()方法，抹掉异常中的堆栈跟踪信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title function_">fillInStackTrace</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Maven 的 unable to find valid certification path to requested target 错误</title>
    <url>/maven-unable-to-find-valid-certification-path-to-requested-target.html</url>
    <content><![CDATA[<p>今天我在从公司的 Maven 私库上下载依赖时，Maven 报出了 <code>unable to find valid certification path to requested target</code> 的问题，经查询是因为没有将私库使用的自签名证书导入到 Java 的 keystore。这里写一下我的两个解决方案，方便发生了同样问题的人参考。</p>
<span id="more"></span>

<h2 id="让Maven忽略证书错误"><a href="#让Maven忽略证书错误" class="headerlink" title="让Maven忽略证书错误"></a>让 Maven 忽略证书错误</h2><p>因为在默认情况下，自签名证书是不受信任的，那么我们只要让 Maven 忽略证书错误，就可以解决这个问题了。</p>
<p>我们可以在<code>.bashrc</code> 或<code>.zshrc</code>（或者其他位置，看你用哪个 shell 了）里面加入如下语句：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_OPTS=<span class="string">'-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Djsse.enableSNIExtension=false'</span></span><br></pre></td></tr></tbody></table></figure>

<p>或者，也可以在 <code>~/.mavenrc</code> 中配置这个参数：</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">MAVEN_OPTS</span>=<span class="string">"-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Djsse.enableSNIExtension=false"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="导入证书到keystore"><a href="#导入证书到keystore" class="headerlink" title="导入证书到keystore"></a>导入证书到 keystore</h2><p>首先使用这个命令得到网站上面的证书：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 注意将mavenrepository.mycompany.com替换成实际的地址</span></span><br><span class="line">openssl s_client -showcerts -connect mavenrepository.mycompany.com:443</span><br></pre></td></tr></tbody></table></figure>

<p>在输出中可以看到类似这样的证书信息：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">s:/C=US/ST=North Carolina/L=Raleigh/O=Red Hat, Inc./OU=Red Hat Network/CN=Entitlement Master CA/emailAddress=ca-support@redhat.com</span><br><span class="line"></span><br><span class="line">i:/C=US/ST=North Carolina/L=Raleigh/O=Red Hat, Inc./OU=Red Hat Network/CN=Entitlement Master CA/emailAddress=ca-support@redhat.com</span><br></pre></td></tr></tbody></table></figure>

<p>我们要在这里面寻找 <code>issuer(i:)</code> 和 <code>subject(s:)</code> 相同的证书，这个就是我们要导出的根证书。找到之后，保存证书的哈希（即以 <code>—–BEGIN CERTIFICATE—–</code>开始，以 <code>—–END CERTIFICATE—–</code>结束的这部分内容）到一个文件中，比如 <code>root.crt</code>。</p>
<p>接下来，我们需要使用 <code>keytool</code> 把这个证书导入到 Java 的 keystore 中，命令如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo keytool \</span><br><span class="line">    -importcert \</span><br><span class="line">    <span class="comment"># keystore文件位置需要修改成实际的位置</span></span><br><span class="line">    -keystore /usr/local/java/jdk1.8.0_60/jre/lib/security/cacerts \</span><br><span class="line">    <span class="comment"># keystore密码需要修改成实际的密码，默认密码是changeit</span></span><br><span class="line">    -storepass changeit \</span><br><span class="line">    <span class="comment"># 要导入的证书，就是刚才保存的那个，注意使用实际的位置</span></span><br><span class="line">    -file ~/Downloads/root.crt \</span><br><span class="line">    <span class="comment"># 给证书起个名字</span></span><br><span class="line">    -<span class="built_in">alias</span> <span class="string">"mavenrepository-mycompany"</span></span><br></pre></td></tr></tbody></table></figure>

<p>执行后 keytool 会询问是否信任这个证书，输入 <code>yes</code> 来信任。</p>
<p>导入完成后，Maven 就可以从这个私库下载依赖了。如果你使用 IDEA 的话，那么可能需要重新启动一下 IDEA 才会使新的 keystore 生效。</p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9qZnJvZy5jb20va25vd2xlZGdlLWJhc2UvaG93LXRvLXJlc29sdmUtdW5hYmxlLXRvLWZpbmQtdmFsaWQtY2VydGlmaWNhdGlvbi1wYXRoLXRvLXJlcXVlc3RlZC10YXJnZXQtZXJyb3Iv">How to resolve “unable to find valid certification path to requested target” error? - JFrog<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjEyNTI4MDAvaG93LXRvLXRlbGwtbWF2ZW4tdG8tZGlzcmVnYXJkLXNzbC1lcnJvcnMtYW5kLXRydXN0aW5nLWFsbC1jZXJ0cw==">How to tell Maven to disregard SSL errors (and trusting all certs)?<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>记我将博客的图片存储迁移到 Backblaze</title>
    <url>/migrating-blog-images-to-backblaze.html</url>
    <content><![CDATA[<p>之前我一直把博客的图片放在个人的 OneDrive 上，然后用嵌入功能得到外链放在博客里。但是考虑到国内访问 OneDrive 的延迟还是偏高，以及不折腾不舒服的心理作祟，于是乎在三月份的时候，我把博客的图片从 OneDrive 迁到了 Backblaze 对象存储。</p>
<span id="more"></span>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>开始之前，我们需要准备好这些东西：</p>
<ul>
<li>一个 Backblaze 免费账号</li>
<li>一个 CloudFlare 免费账号</li>
<li>一个域名</li>
<li>还有你的好心情 :-)</li>
</ul>
<p>可能你会担心用对象存储是不是会产生高额的账单，或者会因为超出配额导致图片全部无法加载。说实话我之前不敢用对象存储就是因为有这方面的顾虑，但是在 Backblaze 这里我们完全不用担心。首先，我们用的是免费的账户，而且 Backblaze 甚至不要求你添加信用卡。此外，Backblaze 和 CloudFlare 都是带宽联盟的成员，意味着 Backblaze 与 CloudFlare 之间的流量全部是免费的。</p>
<h2 id="在Backblaze创建存储桶并上传图片"><a href="#在Backblaze创建存储桶并上传图片" class="headerlink" title="在Backblaze创建存储桶并上传图片"></a>在 Backblaze 创建存储桶并上传图片</h2><p>登录进 Backblaze 的 B2 Cloud Storage 之后，点 <code>Create a Bucket</code> 创建一个存储桶就行了。为了防止被人恶意刷流量，我建议创建一个私有的存储桶。加密和对象锁都不需要。</p>
<p>创建成功后，打开这个存储桶的 <code>Bucket Settings</code>，在 <code>Bucket Info</code> 中添加 <code>{"cache-control":"max-age=43200"}</code> 来配置桶的缓存时间。虽然流量不要钱，但是能环保还是环保一点比较好不是？</p>
<p>因为我们创建的是私有存储桶，所以需要创建一个 Application Key 来允许第三方服务访问这个桶。虽然 Backblaze 默认提供了一个 Master Application Key，但是这就像天天用 root 登录 Linux 主机一样，只有中午才能用，因为早晚会出事。在 Application Keys 页面，点 <code>Add a New Application Key</code>，<code>Allow access to Bucket(s)</code> 里面建议选我们这个桶而不是 All，权限当然是 Read and Write。创建成功之后，注意保存好 <code>keyID</code> 和 <code>applicationKey</code>，因为 <code>applicationKey</code> 只会显示一次。</p>
<p>然后需要下载一个支持浏览对象存储的工具，比如我用的<span class="exturl" data-url="aHR0cHM6Ly9zM2Jyb3dzZXIuY29tLz92PTEwLjkuOSZmYW09eDY0"> S3 Browser<i class="fa fa-external-link-alt"></i></span>。然后在 S3 Browser 中新建一个连接，<code>REST Endpoint</code> 填写存储桶的 <code>Endpoint</code>，<code>Access Key ID</code> 就是刚才记下来的 <code>keyID</code>，<code>Secret Access Key</code> 就是 <code>applicationKey</code>。</p>
<p><img data-src="https://blog-static.boris1993.com/migrating-blog-images-to-backblaze/s3-browser-add-account.png"></p>
<p>如果 S3 Browser 可以成功连接到刚才创建的存储桶，那就说明配置正确了。这时候就可以想好目录结构，以及上传图片了。比如我选择把图片按照对应的博文来分类，每个有图的博文都有一个对应的图片目录。</p>
<p><img data-src="https://blog-static.boris1993.com/migrating-blog-images-to-backblaze/s3-browser-list-files.png"></p>
<h2 id="在CloudFlare中配置域名"><a href="#在CloudFlare中配置域名" class="headerlink" title="在CloudFlare中配置域名"></a>在 CloudFlare 中配置域名</h2><p>在到 CloudFlare 配置域名之前，我们先要知道指向一个文件的完整 URL。进入 Browse Files 页面，然后进入这个存储桶，接着随便挑一个文件，点它最右边的详情图标，这里的 <code>Friendly URL</code> 就是我们要找的东西。记下 URL 里面的域名，我们接下来要用到。</p>
<p><img data-src="https://blog-static.boris1993.com/migrating-blog-images-to-backblaze/backblaze-file-details.png"></p>
<p>接下来就可以到 CloudFlare 里面创建一条 CNAME 记录，并把刚才记下来的域名填到目标里面，并且启用 CloudFlare 的代理，这样我们才能享受到带宽联盟的优惠。此外，我们还会针对这个域名配置一些规则，这也需要打开 CloudFlare 的代理开关。</p>
<p>要注意这里只能是二级域名，如 <code>blog-static.boris1993.com</code>，而不能是多级的（<code>blog.static.boris1993.com</code>），否则 CloudFlare 会无法申请证书，也就无法正常启用 HTTPS。</p>
<p><img data-src="https://blog-static.boris1993.com/migrating-blog-images-to-backblaze/cloudflare-cname-record.png"></p>
<p>这时候我们就可以用 <code>https://sub-domain.your-domain.com/file/folder-name/image-name.png</code> 访问这个图片了，但是目前我们只能得到一个 401 页面，因为我们必须要带上一个 Access Token 才能访问私有存储桶的文件。</p>
<h2 id="为请求配置CloudFlare规则"><a href="#为请求配置CloudFlare规则" class="headerlink" title="为请求配置CloudFlare规则"></a>为请求配置 CloudFlare 规则</h2><p>前往 CloudFlare 的规则页面，选择<code>转换规则(Transform Rule)</code>，然后在<code>重写URL</code> 这个 tab 中新增一个规则。</p>
<p>首先，我希望我可以直接用 <code>https://blog-static.boris1993.com/folder-name/file-name.png</code> 就能访问到图片（因为这样看起来更好看），所以我配置了一个路径重写，如果路径中不包含 <code>/file/bucket-name</code>，那么就在路径中补上这一段。</p>
<p>选择<code>路径</code>的<code>重写到</code>，表达式类型选择<code>动态</code>，表达式填写 <code>concat("/file/blog-pics", http.request.uri.path)</code>。这样 CloudFlare 就会自动补全完整的路径。</p>
<p>然后就是访问私有存储桶的 Access Token。Backblaze 支持把 Access Token 放在 <code>Authorization</code> 这个 query parameter 中，所以我们可以选择<code>查询</code>的<code>重写到</code>，表达式类型选择<code>静态(Static)</code>，值目前可以随便写，因为你就算现在拿到一个 token，在 24 小时后也是会过期的，所以后面我会讲怎么用 CloudFlare Workers 来更新这个字段。</p>
<p><img data-src="https://blog-static.boris1993.com/migrating-blog-images-to-backblaze/cloudflare-transform-rule.png"></p>
<p>接下来，根据 Backblaze 官方的建议，我们需要对响应头做一些修改。</p>
<p>切换到<code>修改响应头</code>，新增这样一条规则：</p>
<p><img data-src="https://blog-static.boris1993.com/migrating-blog-images-to-backblaze/cloudflare-update-headers.png"></p>
<p>首先要正确配置 <code>Access-Control-Allow-Origin</code>，来避免跨域问题，我偷懒了直接配了个 <code>*</code>，不知道这么配会不会有盗链的问题，暂时先这样吧。</p>
<p>其次 Backblaze 建议修改 <code>cache-control</code> 这个 header，来延长缓存的有效时间。</p>
<p>最后，需要从响应头中删掉一些 Backblaze 的 header 来增强安全性。</p>
<p>为了方便，我把要删掉的 header 放在这里：</p>
<ul>
<li>x-bz-content-sha1</li>
<li>x-bz-file-id</li>
<li>x-bz-file-name</li>
<li>x-bz-info-s3b-last-modified</li>
<li>x-bz-info-sha256</li>
<li>x-bz-info-src_last_modified_millis</li>
<li>x-bz-upload-timestamp</li>
</ul>
<p>同时我为了能让浏览器缓存这个图片，我还让它添加了 <code>ETag</code> 这个 header，但是我在浏览器里一直看不到这个 header，如果有大佬知道为什么，还请不吝赐教。</p>
<h2 id="自动更新访问存储桶的Token"><a href="#自动更新访问存储桶的Token" class="headerlink" title="自动更新访问存储桶的Token"></a>自动更新访问存储桶的 Token</h2><p>因为后面要修改规则的内容，所以先得拿到规则集和规则的 ID。规则 ID 好办，打开<code>重写URL</code> 规则的编辑页面，我们就能在 URL 的最后一段得到这个规则的 ID。但是规则集 ID 只能调 CloudFlare API 取得。</p>
<figure class="highlight http"><table><tbody><tr><td class="code"><pre><span class="line">GET https://api.cloudflare.com/client/v4/zones/YOUR_ZONE_ID/rulesets</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer YOUR_CLOUDFLARE_API_TOKEN</span><br></pre></td></tr></tbody></table></figure>

<p>把 <code>YOUR_ZONE_ID</code> 替换为你的域名的区域 ID，以及把 <code>YOUR_CLOUDFLARE_API_TOKEN</code> 换成你的 API 令牌。我当时因为不知道这个 API 需要哪些权限，始终创建不出带有正确权限的 API 令牌，所以干脆用了 <code>Global API Key</code>。</p>
<p>这个请求会返回一系列规则集，有 CloudFlare 内部的，也有我们自己的。理论上，名字是 <code>default</code> 并且 <code>phase</code> 是 <code>http_request_transform</code> 的那个就是我们要的。但是为了确认，可以再执行这个请求：</p>
<figure class="highlight http"><table><tbody><tr><td class="code"><pre><span class="line">GET https://api.cloudflare.com/client/v4/zones/YOUR_ZONE_ID/rulesets/RULE_SET_ID</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer YOUR_CLOUDFLARE_API_TOKEN</span><br></pre></td></tr></tbody></table></figure>

<p>跟上条请求一样，替换掉 <code>YOUR_ZONE_ID</code> 和 <code>YOUR_CLOUDFLARE_API_TOKEN</code>，以及将 <code>RULE_SET_ID</code> 替换为上面找到的规则集的 <code>id</code>。执行后会返回这个规则集下的规则。如果返回内容中有我们之前创建的那条<code>重写URL</code> 的规则，那么这就是我们要找的规则集。</p>
<p>然后为了安全起见，我们要为这个 CloudFlare Worker 创建一个 API 令牌。进入<code>我的个人资料</code> –&gt; <code>API令牌</code>，然后点击<code>创建令牌</code>，在接下来的页面中中选择<code>创建自定义令牌</code>，然后如图创建一个令牌。</p>
<p><img data-src="https://blog-static.boris1993.com/migrating-blog-images-to-backblaze/cloudflare-token-for-worker.png"></p>
<p>添加成功后，妥善保存这个令牌。</p>
<p>接下来前往 CloudFlare Workers，创建一个新的 Worker。然后到<code>设置</code> –&gt; <code>变量</code>，添加如下环境变量：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td> B2KeyID</td>
<td>Backblaze 的 <code>keyID</code></td>
</tr>
<tr>
<td>B2AppKey</td>
<td>Backblaze 的 <code>applicationKey</code></td>
</tr>
<tr>
<td>B2BucketName</td>
<td>Backblaze 的存储桶名</td>
</tr>
<tr>
<td> CfAuthKey</td>
<td> 上面创建的 CloudFlare API 令牌</td>
</tr>
<tr>
<td> CfHostname</td>
<td> 上面在 CloudFlare 创建的二级域名</td>
</tr>
<tr>
<td> CfZoneID</td>
<td> 你的域名的区域 ID</td>
</tr>
<tr>
<td>CfRulesetID</td>
<td> 上面拿到的规则集 ID</td>
</tr>
<tr>
<td>CfRuleID</td>
<td> 上面拿到的规则 ID</td>
</tr>
</tbody></table>
<p>然后进入<code>触发器</code>，将<code>路由</code>中的那条记录禁用，因为我们不会用 HTTP 请求来触发这个 Worker。然后再 <code>Cron触发器</code>中添加一个 Cron 触发器。Backblaze 说一个 token 的有效期最大不超过 24 小时，我为了保险起见，选择每半小时就触发这个 Worker 来生成一个新的 token，即 <code>*/30 * * * *</code>。</p>
<p><img data-src="https://blog-static.boris1993.com/migrating-blog-images-to-backblaze/cloudflare-worker-trigger.png"></p>
<p>至此前置任务完成，点击右上角的<code>快速编辑</code>，然后将如下脚本粘贴进去，然后点击<code>保存并部署</code>。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">"fetch"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  event.<span class="title function_">respondWith</span>(<span class="title function_">handleRequest</span>(event.<span class="property">request</span>));</span><br><span class="line">});</span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="string">"scheduled"</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line">  event.<span class="title function_">waitUntil</span>(<span class="title function_">updateRule</span>());</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getB2Token</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; {</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(</span><br><span class="line">    <span class="string">"https://api.backblazeb2.com/b2api/v2/b2_authorize_account"</span>,</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">headers</span>: {</span><br><span class="line">        <span class="title class_">Authorization</span>: <span class="string">"Basic "</span> + <span class="title function_">btoa</span>(B2KeyID + <span class="string">":"</span> + B2AppKey),</span><br><span class="line">      },</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> data.<span class="property">authorizationToken</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">updateRule</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; {</span><br><span class="line">  <span class="keyword">const</span> b2Token = <span class="keyword">await</span> <span class="title function_">getB2Token</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(</span><br><span class="line">    <span class="string">`https://api.cloudflare.com/client/v4/zones/<span class="subst">${CfZoneID}</span>/rulesets/<span class="subst">${CfRulesetID}</span>/rules/<span class="subst">${CfRuleID}</span>`</span>,</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">method</span>: <span class="string">"PATCH"</span>,</span><br><span class="line">      <span class="attr">headers</span>: {</span><br><span class="line">        <span class="string">"Authorization"</span>: <span class="string">`Bearer <span class="subst">${CfAuthKey}</span>`</span></span><br><span class="line">      },</span><br><span class="line">      <span class="attr">body</span>: </span><br><span class="line">      <span class="string">`{</span></span><br><span class="line"><span class="string">        "description": "Replace path for static files for blog",</span></span><br><span class="line"><span class="string">        "action": "rewrite",</span></span><br><span class="line"><span class="string">        "expression": "(http.host eq \\\"<span class="subst">${CfHostname}</span>\\\" and not starts_with(http.request.uri.path, \\\"/file/<span class="subst">${B2BucketName}</span>\\\"))",</span></span><br><span class="line"><span class="string">        "action_parameters": {</span></span><br><span class="line"><span class="string">          "uri": {</span></span><br><span class="line"><span class="string">              "path": {</span></span><br><span class="line"><span class="string">                  "expression": "concat(\\\"/file/<span class="subst">${B2BucketName}</span>\\\", http.request.uri.path)"</span></span><br><span class="line"><span class="string">              },</span></span><br><span class="line"><span class="string">              "query": {</span></span><br><span class="line"><span class="string">                  "value": "Authorization=<span class="subst">${b2Token}</span>"</span></span><br><span class="line"><span class="string">              }</span></span><br><span class="line"><span class="string">          }</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">      }`</span>,</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">text</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleRequest</span>(<span class="params">request</span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">updateRule</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(data);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>等 Worker 被触发之后，就可以在浏览器中访问上面配置的域名，来测试到存储桶的连接是否正常。如果测试没问题，就可以把博客中的图片链接换到新地址了。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>对象存储</tag>
        <tag>OSS</tag>
        <tag>博客图片</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>从 umami v1 迁移到 v2</title>
    <url>/migrating-to-umami-v2.html</url>
    <content><![CDATA[<p>昨天收到 Vercel 发的报警邮件，说我自己部署的分析平台 <code>umami</code> 部署失败。检查之后发现是 <code>umami</code> 有个大版本升级，而升级脚本失败导致新版本部署失败了。那既然报错了，就修呗。</p>
<p>虽然不是什么复杂的问题，但还是记录一下好了，也当是水一篇文。</p>
<span id="more"></span>

<h2 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h2><p>一开始发现自动迁移不成功，那么按照<span class="exturl" data-url="aHR0cHM6Ly91bWFtaS5pcy9kb2NzL21pZ3JhdGUtdjEtdjI=">官方的迁移文档<i class="fa fa-external-link-alt"></i></span>，我手动运行了迁移脚本，但是得到了这样的错误信息：<code>db error: ERROR: must be owner of table _prisma_migrations</code>。看起来是表的权限问题，<code>_prisma_migrations</code> 这个表的 <code>owner</code> 必须是我用来执行脚本的用户。</p>
<p>搜了一下，<code>PostgreSQL</code> 里面每个表都有一个所有者，而我一开始是用 <code>postgres</code> 这个用户初始化的数据库，所以这些表的所有者都是 <code>postgres</code>，之前没有问题，只是因为我给 umami 的用户读写这些表的授权了。</p>
<h2 id="修复数据库"><a href="#修复数据库" class="headerlink" title="修复数据库"></a>修复数据库</h2><p>首先执行了下 <code>select schemaname, tablename, tableowner from pg_tables where schemaname = 'umami'</code>，果不其然这些表的 owner 都是 <code>postgres</code>。</p>
<p>于是尝试执行了下 <code>alter table umami_analytics._prisma_migrations owner to umami_analytics</code>，但是又报错 <code>ERROR: must be member of role umami_user</code>。好么，我一直以为 <code>postgres</code> 用户跟 MySQL 的 <code>root</code> 一样是超管，结果 PostgreSQL 世界里面人人生而平等？好吧，你要权限那我就给你授权，<code>grant postgres to umami_user</code>。</p>
<p>授权之后，重新执行 <code>alter table umami_analytics._prisma_migrations owner to umami_analytics</code>，发现成功了，再执行 umami 的迁移脚本后，发现错误信息变成了 <code>db error: ERROR: must be owner of table account</code>。看来，上面的解决方案奏效了，接下来就是把剩下的表的所有者全都改过来。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> umami_analytics._event_old owner <span class="keyword">to</span> umami_analytics;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> umami_analytics._prisma_migrations owner <span class="keyword">to</span> umami_analytics;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> umami_analytics.account owner <span class="keyword">to</span> umami_analytics;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> umami_analytics."event" owner <span class="keyword">to</span> umami_analytics;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> umami_analytics.event_data owner <span class="keyword">to</span> umami_analytics;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> umami_analytics.pageview owner <span class="keyword">to</span> umami_analytics;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> umami_analytics."session" owner <span class="keyword">to</span> umami_analytics;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> umami_analytics.website owner <span class="keyword">to</span> umami_analytics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> schemaname, tablename, tableowner <span class="keyword">from</span> pg_tables <span class="keyword">where</span> schemaname <span class="operator">=</span> <span class="string">'umami_analytics'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，umami 相关的表的所有者都正确了，回到 Vercel，重新运行失败的部署，发现还是报错。无奈，又试了试手动迁移脚本，竟然成功了，这时候数据库肯定是 v2 的了，再到 Vercel 重新部署，这次就成功了。</p>
<p>注意脚本执行到最后会问要不要删掉 v1 的表，记得不要删。我发现在删掉 v1 的旧表之后，Vercel 的部署又会出新的问题。（我为了验证到底是我的问题还是脚本的问题，回滚了两三次生产数据库。也就是这个数据不重要我才敢这么折腾，好孩子不要学我乱搞生产数据库哦～）</p>
<h2 id="更新博客的配置"><a href="#更新博客的配置" class="headerlink" title="更新博客的配置"></a>更新博客的配置</h2><p>NexT 主题是内建了对 umami 的支持的，但是需要手动指定脚本的位置。根据迁移文档的提示，修正<code>_config.next.yml</code> 中 <code>umami.script_url</code>，重新部署博客即可。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>umami</tag>
        <tag>analytics</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 VisualVM 监控应用 GC</title>
    <url>/monitor-gc-with-visual-vm.html</url>
    <content><![CDATA[<p>我们知道，使用 VisualVM 可以监控 Java 应用的各种运行时信息，包括资源占用、正在运行的线程等等。本文将简单介绍如何使用 VisualVM 的插件 <code>Visual GC</code> 来监控 Java 应用的垃圾回收情况。</p>
<span id="more"></span>

<h2 id="安装Visual-GC插件"><a href="#安装Visual-GC插件" class="headerlink" title="安装Visual GC插件"></a>安装 <code>Visual GC</code> 插件</h2><p>因为 <code>Visual GC</code> 插件并不是随 VisualVM 附带的，需要到插件商店下载。</p>
<p>点击 <code>Tools</code>–&gt;<code>Plugins</code> 打开插件管理窗口，进入 <code>Available Plugins</code>，在左侧窗格中勾选 <code>Visual GC</code>，点击 <code>Install</code>，同意许可协议后，稍等片刻即可完成安装。安装完成之后无需重启 VisualVM。</p>
<p><img data-src="https://blog-static.boris1993.com/monitor-gc-with-visualvm/install-visual-gc.png" alt="Install Visual GC"></p>
<h2 id="监控垃圾回收"><a href="#监控垃圾回收" class="headerlink" title="监控垃圾回收"></a>监控垃圾回收</h2><p>安装完成后，在 VisualVM 的 <code>Applications</code> 窗格中双击要监控的应用，然后在右侧窗格中进入 <code>Visual GC</code>，即可以图形化的方式查看当前该应用中各个内存区域的情况。</p>
<p><img data-src="https://blog-static.boris1993.com/monitor-gc-with-visualvm/monitor-gc.png" alt="Monitor GC"></p>
<p>窗格中的 <code>Spaces</code> 部分展示的是当前各个区域的占用情况；<code>Graphs</code> 部分则包括：</p>
<ul>
<li><code>Compile Time</code>：编译时间，包括编译的次数，和累计的编译时间。图表中的一次脉冲就代表一次编译，脉冲越宽代表编译时间越长</li>
<li><code>Class Loader Time</code>：类加载时间，包括加载了多少个类 (<code>loaded</code>)，卸载了多少个类 (<code>unloaded</code>)，和累计用于类加载的时间</li>
<li><code>GC Time</code>：垃圾回收时间，包括垃圾回收的次数，垃圾回收消耗的时间，和上一次垃圾回收的原因</li>
<li><code>Eden Space</code>：Eden 区的空间，括号中第一位是最大容量，第二位是当前容量，其后冒号跟着的是当前使用了的大小，再往后是发生垃圾回收的次数，和垃圾回收消耗的时间</li>
<li><code>Survivor 0</code> 和 <code>Survivor 1</code>：两个 <code>Survivor</code> 区的空间，同样包括最大容量、当前容量，和当前使用了的大小</li>
<li><code>Old Gen</code>：老年代的空间，同样包括最大容量、当前容量、当前使用了的大小、发生垃圾回收的次数，和垃圾回收消耗的时间</li>
<li><code>Metaspace</code>：Metaspace 的空间 (如果使用的是 Java 1.7 及之前版本，这里则是 <code>Perm Gen</code>)，包括最大容量、当前容量，和当前使用了的大小</li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>VisualVM</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Grafana 监控 RouterOS 运行状态</title>
    <url>/monitoring-routeros-with-grafana.html</url>
    <content><![CDATA[<p>乱翻收藏夹的时候发现我还有个免费的 Grafana Cloud，遂想着把我这些自建的东西都用它监控起来，反正不用白不用。那么第一个就拿我的 RouterOS 软路由开刀吧。</p>
<span id="more"></span>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Mikrotik CHR 7.12</li>
<li>Grafana Cloud - Cloud Free 订阅</li>
<li> Prometheus 2.37</li>
<li>mktxp </li>
<li>CloudFlare Tunnel，如果你像我一样把 Prometheus 部署在家宽的话</li>
</ul>
<h2 id="在RouterOS系统创建组和用户"><a href="#在RouterOS系统创建组和用户" class="headerlink" title="在RouterOS系统创建组和用户"></a>在 RouterOS 系统创建组和用户</h2><p>毕竟还是用第三方工具登陆路由器，还是遵循最小权限原则，给 <code>mktxp</code> 创建一个只包含必要的权限的账号比较好。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">/user<span class="built_in">/group </span><span class="built_in">add</span> <span class="attribute">name</span>=prometheus <span class="attribute">policy</span>=read,api</span><br><span class="line"><span class="built_in">/user </span><span class="built_in">add</span> <span class="attribute">name</span>=prometheus <span class="attribute">group</span>=prometheus <span class="attribute">password</span>=changeme <span class="attribute">disabled</span>=<span class="literal">no</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置mktxp"><a href="#配置mktxp" class="headerlink" title="配置mktxp"></a>配置 mktxp</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FrcHcvbWt0eHA=">mktxp<i class="fa fa-external-link-alt"></i></span>是一个面向 Mikrotik RouterOS 的 Prometheus exporter。选择这个而不是 <code>nshttpd/mikrotik-exporter</code> 主要出于以下两个原因：</p>
<ul>
<li><code>nshttpd/mikrotik-exporter</code> 已经停止更新，最后一次 commit 停留于 2022 年 6 月 17 日</li>
<li>它每一次获取数据都会登入和登出，而这会导致 RouterOS 的日志里面充斥 <code>prometheus</code> 用户的登入和登出记录，就像这样：<br><img data-src="https://blog-static.boris1993.com/monitoring-routeros-with-grafana/mikrotik-exporter-log-spamming.png"></li>
</ul>
<p>我使用 Docker 部署 <code>mktxp</code>，它需要两个配置文件：<code>mktxp.conf</code> 和<code>_mktxp.conf</code>。</p>
<p><code>_mktxp.conf</code> 负责 <code>mktxp</code> 的运行配置，比如端口号、数据获取的间隔时间等。内容如下：</p>
<figure class="highlight toml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[MKTXP]</span></span><br><span class="line">    <span class="attr">port</span> = <span class="number">49090</span></span><br><span class="line">    <span class="attr">socket_timeout</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">initial_delay_on_failure</span> = <span class="number">120</span></span><br><span class="line">    <span class="attr">max_delay_on_failure</span> = <span class="number">900</span></span><br><span class="line">    <span class="attr">delay_inc_div</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">bandwidth</span> = <span class="literal">True</span>                <span class="comment"># Turns metrics bandwidth metrics collection on / off</span></span><br><span class="line">    <span class="attr">bandwidth_test_interval</span> = <span class="number">420</span>   <span class="comment"># Interval for colllecting bandwidth metrics</span></span><br><span class="line">    <span class="attr">minimal_collect_interval</span> = <span class="number">5</span>    <span class="comment"># Minimal metric collection interval</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">verbose_mode</span> = <span class="literal">False</span>            <span class="comment"># Set it on for troubleshooting</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">fetch_routers_in_parallel</span> = <span class="literal">False</span>   <span class="comment"># Set to True if you want to fetch multiple routers parallel</span></span><br><span class="line">    <span class="attr">max_worker_threads</span> = <span class="number">5</span>              <span class="comment"># Max number of worker threads that can fetch routers. Meaningless if fetch_routers_in_parallel is set to False</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">max_scrape_duration</span> = <span class="number">10</span>            <span class="comment"># Max duration of individual routers' metrics collection</span></span><br><span class="line">    <span class="attr">total_max_scrape_duration</span> = <span class="number">30</span>      <span class="comment"># Max overall duration of all metrics collection</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>mktxp.conf</code> 用于配置要监控的 RouterOS 实例，内容如下：</p>
<figure class="highlight toml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Router为路由器的代号，可以改成自己喜欢的值</span></span><br><span class="line"><span class="comment"># 将来在Grafana就是用这个来区分各个RouterOS设备</span></span><br><span class="line"><span class="section">[Router]</span></span><br><span class="line">    <span class="comment"># 是否启用对这个RouterOS设备的监控</span></span><br><span class="line">    <span class="attr">enabled</span> = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路由器的地址</span></span><br><span class="line">    <span class="attr">hostname</span> = <span class="number">192.168</span>.<span class="number">1.1</span></span><br><span class="line">    <span class="comment"># RouterOS API服务的端口</span></span><br><span class="line">    <span class="attr">port</span> = <span class="number">8728</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填写上面创建的 prometheus 用户的账号和密码</span></span><br><span class="line">    <span class="attr">username</span> = prometheus</span><br><span class="line">    <span class="attr">password</span> = changeme</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SSL部分关闭就行</span></span><br><span class="line">    <span class="attr">use_ssl</span> = <span class="literal">False</span>                 <span class="comment"># enables connection via API-SSL servis</span></span><br><span class="line">    <span class="attr">no_ssl_certificate</span> = <span class="literal">False</span>      <span class="comment"># enables API_SSL connect without router SSL certificate</span></span><br><span class="line">    <span class="attr">ssl_certificate_verify</span> = <span class="literal">False</span>  <span class="comment"># turns SSL certificate verification on / off</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下为各个监控的开关，按需设定即可</span></span><br><span class="line">    <span class="attr">installed_packages</span> = <span class="literal">True</span>       <span class="comment"># Installed packages</span></span><br><span class="line">    <span class="attr">dhcp</span> = <span class="literal">True</span>                     <span class="comment"># DHCP general metrics</span></span><br><span class="line">    <span class="attr">dhcp_lease</span> = <span class="literal">True</span>               <span class="comment"># DHCP lease metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">connections</span> = <span class="literal">True</span>              <span class="comment"># IP connections metrics</span></span><br><span class="line">    <span class="attr">connection_stats</span> = <span class="literal">False</span>        <span class="comment"># Open IP connections metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">pool</span> = <span class="literal">True</span>                     <span class="comment"># Pool metrics</span></span><br><span class="line">    <span class="attr">interface</span> = <span class="literal">True</span>                <span class="comment"># Interfaces traffic metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">firewall</span> = <span class="literal">True</span>                 <span class="comment"># IPv4 Firewall rules traffic metrics</span></span><br><span class="line">    <span class="attr">ipv6_firewall</span> = <span class="literal">False</span>           <span class="comment"># IPv6 Firewall rules traffic metrics</span></span><br><span class="line">    <span class="attr">ipv6_neighbor</span> = <span class="literal">False</span>           <span class="comment"># Reachable IPv6 Neighbors</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">poe</span> = <span class="literal">False</span>                     <span class="comment"># POE metrics</span></span><br><span class="line">    <span class="attr">monitor</span> = <span class="literal">True</span>                  <span class="comment"># Interface monitor metrics</span></span><br><span class="line">    <span class="attr">netwatch</span> = <span class="literal">True</span>                 <span class="comment"># Netwatch metrics</span></span><br><span class="line">    <span class="attr">public_ip</span> = <span class="literal">True</span>                <span class="comment"># Public IP metrics</span></span><br><span class="line">    <span class="attr">route</span> = <span class="literal">True</span>                    <span class="comment"># Routes metrics</span></span><br><span class="line">    <span class="attr">wireless</span> = <span class="literal">False</span>                <span class="comment"># WLAN general metrics</span></span><br><span class="line">    <span class="attr">wireless_clients</span> = <span class="literal">False</span>        <span class="comment"># WLAN clients metrics</span></span><br><span class="line">    <span class="attr">capsman</span> = <span class="literal">False</span>                 <span class="comment"># CAPsMAN general metrics</span></span><br><span class="line">    <span class="attr">capsman_clients</span> = <span class="literal">False</span>         <span class="comment"># CAPsMAN clients metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">user</span> = <span class="literal">True</span>                     <span class="comment"># Active Users metrics</span></span><br><span class="line">    <span class="attr">queue</span> = <span class="literal">True</span>                    <span class="comment"># Queues metrics</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">remote_dhcp_entry</span> = None        <span class="comment"># An MKTXP entry for remote DHCP info resolution (capsman/wireless)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">use_comments_over_names</span> = <span class="literal">True</span>  <span class="comment"># when available, forces using comments over the interfaces names</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">check_for_updates</span> = <span class="literal">False</span>       <span class="comment"># check for available ROS updates</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后用如下 <code>docker-compose.yml</code> 启动 <code>mktxp</code> 即可：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mktxp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ghcr.io/akpw/mktxp:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mktxp</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">49090</span><span class="string">:49090</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;存放以上两个conf的目录&gt;:/home/mktxp/mktxp/</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>mktxp</code> 在启动成功的情况下是没有日志输出的，访问 <code>49090</code> 端口（即<code>_mktxp.conf</code> 中配置的端口），如果能看到一大片 Prometheus 的 metrics，那就说明启动成功了。</p>
<h2 id="配置Prometheus"><a href="#配置Prometheus" class="headerlink" title="配置Prometheus"></a>配置 Prometheus</h2><p>在 <code>prometheus.yml</code> 中添加如下配置：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'mikrotik_exporter'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">'mktxp的主机地址:49090'</span>]</span><br><span class="line">        <span class="comment"># 标签按需，不想要可以去掉</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">instance:</span> <span class="string">'CHR'</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="string">'Production'</span></span><br></pre></td></tr></tbody></table></figure>

<p>重启 Prometheus，然后到 Prometheus 的 <code>Status -&gt; Targets</code> 中，检查 <code>mikrotik_exporter</code> 这个 target 是否存在，以及 <code>State</code> 是不是 <code>UP</code>。</p>
<h2 id="配置Grafana"><a href="#配置Grafana" class="headerlink" title="配置Grafana"></a>配置 Grafana</h2><p>如果你的 Prometheus 是部署在家宽环境，那在配置 Grafana 之前需要先做个内网穿透，让 Prometheus 的 <code>9090/tcp</code> 端口能被外网访问到。内网穿透的方案有很多，比如我就用的 CloudFlare Tunnel。因为本文不是讲内网穿透，所以就不展开讲配置了。</p>
<p>到 Grafana 的 <code>Home -&gt; Connections -&gt; Data sources</code> 中，添加一个新的 Prometheus 数据源，其中 <code>Prometheus server URL</code> 填你的 Prometheus 服务的地址，别的不用管，<code>Save &amp; test</code> 成功就没问题。<br>此外，还可以到 Grafana 的 <code>Explore</code> 页面查询一个 <code>mktxp</code> 的 metrics，来检查 Grafana 是否能成功获取到数据。</p>
<p><img data-src="https://blog-static.boris1993.com/monitoring-routeros-with-grafana/grafana-explore-mktxp-metrics.png"></p>
<p>确认 Grafana 能成功获取到数据后，就可以导入 <code>mktxp</code> 的<span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS9ncmFmYW5hL2Rhc2hib2FyZHMvMTM2NzktbWlrcm90aWstbWt0eHAtZXhwb3J0ZXIv"> Grafana Dashboard<i class="fa fa-external-link-alt"></i></span>了。到 Grafana 的 Dashboards 页面，点击 <code>New</code> 按钮后选择 <code>Import</code>，填写这个 dashboard 的 ID<code>13679</code>，点 <code>Load</code>，在下一个页面给这个 dashboard 绑定我们的 Prometheus，然后点 <code>Import</code>，就可以用了。</p>
<p><img data-src="https://blog-static.boris1993.com/monitoring-routeros-with-grafana/grafana-dashboard.png"></p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>RouterOS</tag>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>让 MyBatis 把查询结果以 Map 形式返回</title>
    <url>/mybatis-return-query-results-in-a-map.html</url>
    <content><![CDATA[<p>在使用 MyBatis 查询数据库时，偶尔会出现短时间高频查询的情况。或者，会被短时间高频率查询的数据需要通过另一个微服务的接口来获取。显而易见，高频率的查询数据库，或者高频率的调用微服务的接口，是会对性能产生一定影响的。</p>
<p>在这种情况下，或许可以考虑将相关的数据一次性全部查询出来，然后根据某一列作为 key，将其存放在一个 Map 中，把这个 Map 当成一个临时的缓存。</p>
<span id="more"></span>

<h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><p>假设有这样的一组数据，其中保存了某公司的一系列基地的信息，包括基地名称、基地代号，和基地所在的区。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>base_name</th>
<th>base_code</th>
<th>location</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td> 梅陇</td>
<td> ML</td>
<td> 徐汇区</td>
</tr>
<tr>
<td> 2</td>
<td> 富锦路</td>
<td> FJL</td>
<td> 宝山区</td>
</tr>
<tr>
<td> 3</td>
<td> 龙阳路</td>
<td> LYL</td>
<td> 浦东新区</td>
</tr>
<tr>
<td> 4</td>
<td> 北翟路</td>
<td> BDL</td>
<td> 普陀区</td>
</tr>
<tr>
<td> 5</td>
<td> 川沙</td>
<td> CS</td>
<td> 浦东新区</td>
</tr>
<tr>
<td> 6</td>
<td> 石龙路</td>
<td> SLL</td>
<td> 闵行区</td>
</tr>
</tbody></table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>MyBatis 查询的代码还是同往常一样，一个 SELECT 查询，返回类型就是这个表对应的实体类。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBaseByNameInMap"</span> <span class="attr">resultType</span>=<span class="string">"com.boris1993.demoapp.entity.BaseDTO"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        `id`,</span><br><span class="line">        `base_name`,</span><br><span class="line">        `base_code`,</span><br><span class="line">        `location`</span><br><span class="line">        FROM `base`</span><br><span class="line">        WHERE del_flag = '0'</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"baseName != null and baseName != ''"</span>&gt;</span></span><br><span class="line">            AND `base_name` = #{baseName}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是在 Mapper 接口中，需要在对应的方法上面加上 <code>@MapKey()</code> 注解。这个注解向 MyBatis 指明了使用<strong>实体的哪一个属性</strong> (而不是列名) 作为 Map 的 key。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@MapKey("baseName")</span></span><br><span class="line">Map&lt;String, BaseDTO&gt; <span class="title function_">queryBaseByNameInMap</span><span class="params">(<span class="meta">@Param("baseName")</span> String baseName)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>编写 service、controller 等部分不是本文重点，按下不表。在不传递 <code>baseName</code> 时，就可以查出这样子的数据了：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"北翟路"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"4"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseName"</span><span class="punctuation">:</span> <span class="string">"北翟路"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseCode"</span><span class="punctuation">:</span> <span class="string">"BDL"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"location"</span><span class="punctuation">:</span> <span class="string">"普陀区"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"龙阳路"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"3"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseName"</span><span class="punctuation">:</span> <span class="string">"龙阳路"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseCode"</span><span class="punctuation">:</span> <span class="string">"LYL"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"location"</span><span class="punctuation">:</span> <span class="string">"浦东新区"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"梅陇"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"1"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseName"</span><span class="punctuation">:</span> <span class="string">"梅陇"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseCode"</span><span class="punctuation">:</span> <span class="string">"ML"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"location"</span><span class="punctuation">:</span> <span class="string">"徐汇区"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"富锦路"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"2"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseName"</span><span class="punctuation">:</span> <span class="string">"富锦路"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseCode"</span><span class="punctuation">:</span> <span class="string">"FJL"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"location"</span><span class="punctuation">:</span> <span class="string">"宝山区"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"石龙路"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"6"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseName"</span><span class="punctuation">:</span> <span class="string">"石龙路"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseCode"</span><span class="punctuation">:</span> <span class="string">"SLL"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"location"</span><span class="punctuation">:</span> <span class="string">"闵行区"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"川沙"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"5"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseName"</span><span class="punctuation">:</span> <span class="string">"川沙"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"baseCode"</span><span class="punctuation">:</span> <span class="string">"CS"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"location"</span><span class="punctuation">:</span> <span class="string">"浦东新区"</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="有什么用呢"><a href="#有什么用呢" class="headerlink" title="有什么用呢"></a>有什么用呢</h2><p>试想一下，在某个表中，只保存了相关基地的名字，但是在业务中又需要返回这个基地的代号等信息，那么就可以这么做了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，调用另一个微服务的接口，把这些基地的信息取出来</span></span><br><span class="line">Map&lt;String, BaseDTO&gt; bases = baseDataFeignClient.queryBaseByNameInMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，按照业务需要，查询出了一个List</span></span><br><span class="line"><span class="comment">// 在这个List中，就包含了一系列的基地的名称</span></span><br><span class="line">List&lt;SomethingOutputVO&gt; aListOfSomething = fetchAListOfSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来，遍历这个List，逐个从bases中取得基地的代号</span></span><br><span class="line"><span class="keyword">for</span> (SomethingOutputVO item : aListOfSomething) {</span><br><span class="line">    item.setBaseCode(bases.get(item.getBaseName()).get(<span class="string">"baseCode"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时，这个 Map 就变成了一个小的缓存，避免了在循环中反复查询数据库或者反复调用微服务接口的问题。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>在 MySQL 中修改表和列的排序规则</title>
    <url>/mysql-convert-tables-and-columns-collation.html</url>
    <content><![CDATA[<p>使用如下 SQL 语句即可更新一张表的字符集 (character set) 和排序规则 (collation)：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 此处假设使用utf8字符集，以及使用utf8_unicode_ci排序规则</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_unicode_ci;</span><br></pre></td></tr></tbody></table></figure>

<p>然后可以使用如下 SQL 查询表和列的字符集和排序规则是否修改成功：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询表的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> `TABLE_SCHEMA`, `TABLE_NAME`, `TABLE_COLLATION`</span><br><span class="line"><span class="keyword">FROM</span> `information_schema`.`TABLES`</span><br><span class="line"><span class="keyword">WHERE</span> `TABLE_NAME` <span class="operator">=</span> <span class="string">'table_name'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询表中每个列的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> `TABLE_SCHEMA`, `TABLE_NAME`, `COLUMN_NAME`, `COLLATION_NAME`</span><br><span class="line"><span class="keyword">FROM</span> `information_schema`.`COLUMNS`</span><br><span class="line"><span class="keyword">WHERE</span> `TABLE_NAME` <span class="operator">=</span> <span class="string">'table_name'</span>;</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>collation</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 的最左匹配原则</title>
    <url>/mysql-leftmost-prefix.html</url>
    <content><![CDATA[<p>依旧是面试查漏补缺。这次是 MySQL 的最左匹配原则。</p>
<p>废话不多说，直接看<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL211bHRpcGxlLWNvbHVtbi1pbmRleGVzLmh0bWw="> MySQL 官方文档<i class="fa fa-external-link-alt"></i></span>给出的例子。</p>
<p>有这么一个表：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    id         <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name  <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX name (last_name, first_name)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，表里面有一个联合索引 <code>(last_name, first_name)</code>。那么，查询的时候，这些语句就可以成功走索引：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">'Doe'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">'Doe'</span> <span class="keyword">AND</span> first_name <span class="operator">=</span> <span class="string">'John'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">'Doe'</span> <span class="keyword">AND</span> (first_name <span class="operator">=</span> <span class="string">'John'</span> <span class="keyword">OR</span> first_name <span class="operator">=</span> <span class="string">'Jane'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">'Doe'</span> <span class="keyword">AND</span> first_name <span class="operator">&gt;=</span> <span class="string">'M'</span> <span class="keyword">AND</span> first_name <span class="operator">&lt;</span> <span class="string">'N'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>而这些查询就无法使用这个索引：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> first_name <span class="operator">=</span> <span class="string">'John'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">'Doe'</span> <span class="keyword">OR</span> first_name <span class="operator">=</span> <span class="string">'John'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说，上面例子中的 <code>last_name</code> 列就是索引的最左前缀，如果要在查询中使用这个索引，那么条件中必须包含 <code>last_name</code>，或者同时包含 <code>last_name</code> 和 <code>first_name</code>。</p>
<blockquote>
<p>MySQL can use multiple-column indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on. If you specify the columns in the right order in the index definition, a single composite index can speed up several kinds of queries on the same table.</p>
</blockquote>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>面试</tag>
        <tag>最左匹配原则</tag>
        <tag>leftmost prefix</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 Hexo 博客完成 NIP-05 验证</title>
    <url>/nostr-nip-05-with-hexo.html</url>
    <content><![CDATA[<h2 id="让Hexo在生成时包含-well-known目录"><a href="#让Hexo在生成时包含-well-known目录" class="headerlink" title="让Hexo在生成时包含.well-known目录"></a>让 Hexo 在生成时包含<code>.well-known</code> 目录</h2><p>编辑 <code>config.yml</code>，添加如下配置：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">".well-known/**"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="转换公钥格式"><a href="#转换公钥格式" class="headerlink" title="转换公钥格式"></a>转换公钥格式</h2><p>Damus 生成的 <code>npub</code> 开头的公钥不能直接用，要先转换成十六进制格式的公钥。可以用<span class="exturl" data-url="aHR0cHM6Ly9kYW11cy5pby9rZXkv">这个网站<i class="fa fa-external-link-alt"></i></span>来转换。</p>
<p>把 <code>npub</code> 开头的公钥粘贴进 <code>damus key</code> 一栏，<code>hex key</code> 会自动计算出来，复制 <code>hex key</code> 的内容备用。</p>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>在 <code>source</code> 目录下新建一个名为<code>.well-known</code> 的目录，然后在<code>.well-known</code> 目录中创建 <code>nostr.json</code>，填写如下信息：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"names"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"你的用户名"</span><span class="punctuation">:</span> <span class="string">"刚刚转换得到的hex key"</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>在本地运行 <code>hexo clean &amp;&amp; hexo g</code>，生成成功后检查 <code>public</code> 目录中是否存在<code>.well-known/nostr.json</code> 文件，如存在则说明配置正确。</p>
<h2 id="配置Nostr"><a href="#配置Nostr" class="headerlink" title="配置Nostr"></a>配置 Nostr</h2><p>提交代码并部署成功后，即可在 <code>nostr</code> 客户端配置 <code>NIP-05</code> 认证，本文以 <code>Damus</code> 为例。</p>
<p>点击左上角头像，进入 <code>Profile</code>，点击 <code>Edit</code>，在 <code>NIP-05 VERIFICATION</code> 一栏中填写<code>你的username@你的博客网站</code>，比如我填写的是 <code>boris1993@www.boris1993.com</code>，最后点击 <code>Save</code>。</p>
<p>如果一切正常的话，在你的 Profile 页面就能看到一个对勾图标，代表验证成功。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>nostr</tag>
        <tag>NIP-05</tag>
        <tag>Damus</tag>
      </tags>
  </entry>
  <entry>
    <title>手动编写代码调用 JSR-303 Bean Validation</title>
    <url>/programatically-call-jsr-303.html</url>
    <content><![CDATA[<p>最近做了一个有点不一样的项目，它是将传入接口的业务参数以 JSON 的形式放在了一个统一的请求体里面，我要将它取出来，再反序列化到一个 Bean 里面。这样会带来一个问题，就是我不能直接使用 <code>@Valid</code> 注解来让框架自行校验参数的合法性，而需要手动调用 <code>Validator</code> 实现对 bean 的校验。</p>
<span id="more"></span>

<p>在这里我就不去还原从请求体取出业务数据并反序列化这个过程了，因为这个操作对于我们实际要实现的功能没有关系。我将在这里新建一个简单的类，设定好适当的校验规则，然后通过一个简单的示例来演示。</p>
<h2 id="示例bean"><a href="#示例bean" class="headerlink" title="示例bean"></a>示例 bean</h2><p>示例的 bean 就是一个喜闻乐见的学生信息，使用 <code>javax.validation.constraints</code> 包中的注解来设定校验规则。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line">    <span class="comment">// 姓名是必填项</span></span><br><span class="line">    <span class="meta">@NotNull(message = "Student name is mandatory")</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别是必填项，仅接受male和female，首字母可以大写也可以小写</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = "(M|male)|(F|female)", message = "Only male or female are accepted")</span></span><br><span class="line">    <span class="meta">@NotNull(message = "Student gender is mandatory")</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成绩不是必填项</span></span><br><span class="line">    <span class="comment">// 成绩必须大于等于0，且小于等于100</span></span><br><span class="line">    <span class="comment">// 因为Max的值是开区间，所以得写101</span></span><br><span class="line">    <span class="meta">@Max(value = 101, message = "Maximum value of score is 100")</span></span><br><span class="line">    <span class="meta">@PositiveOrZero(message = "Score cannot be negative")</span></span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="编写实现"><a href="#编写实现" class="headerlink" title="编写实现"></a>编写实现</h2><p>实现的中心思想就是手动获得一个 <code>Validator</code> 实例，然后调用它来对传入的 bean 进行校验。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/student")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showStudent</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> {</span><br><span class="line">        <span class="comment">// 取得一个Validator实例</span></span><br><span class="line">        <span class="type">Validator</span> <span class="variable">validator</span> <span class="operator">=</span> Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"Validating bean with validator {}"</span>, validator.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Validator#validate方法对这个bean进行校验</span></span><br><span class="line">        <span class="comment">// 所有的</span></span><br><span class="line">        <span class="comment">// ConstraintViolation的泛型类型要设定为被校验bean的类型</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Student&gt;&gt; errors = validator.validate(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里遍历errors这个set，打印出各个错误的信息</span></span><br><span class="line">        errors.forEach(error -&gt; {</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">            <span class="comment">// 对应校验规则里面的message属性</span></span><br><span class="line">            log.error(<span class="string">"Error message: {}"</span>, error.getMessage());</span><br><span class="line">            <span class="comment">// 校验失败的属性名</span></span><br><span class="line">            log.error(<span class="string">"Property path: {}"</span>, error.getPropertyPath());</span><br><span class="line">            <span class="comment">// 导致校验失败的值</span></span><br><span class="line">            log.error(<span class="string">"Error value: {}"</span>, error.getInvalidValue());</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 可以取出所有的校验失败信息，拼接起来之后返回给调用方</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">errMessages</span> <span class="operator">=</span> errors.stream()</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里为了省事直接抛出了RuntimeException</span></span><br><span class="line">            <span class="comment">// 实际使用时建议新建一个自定义业务异常代表这种情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(errMessages);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> student.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>我使用一个这样子的数据来测试上面的校验功能：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"Boris"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"score"</span><span class="punctuation">:</span> <span class="number">180</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>可见，这个数据是无法通过校验的，它没有填写性别，而且分数超过了上限。请求发出去之后，我得到了这样的错误信息：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"timestamp"</span><span class="punctuation">:</span> <span class="string">"2020-01-06T03:03:18.125+0000"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"status"</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"error"</span><span class="punctuation">:</span> <span class="string">"Internal Server Error"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"message"</span><span class="punctuation">:</span> <span class="string">"Maximum value of score is 100, Student gender is mandatory"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"path"</span><span class="punctuation">:</span> <span class="string">"/student"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>同时，控制台里出现了这样的日志：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2020-01-06 11:21:25.971  INFO 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Validating bean with validator org.hibernate.validator.internal.engine.ValidatorImpl</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Student gender is mandatory</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: gender</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: null</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Maximum value of score is 100</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: score</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: 180</span><br><span class="line">2020-01-06 11:21:26.214 ERROR 68021 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:21:26.252 ERROR 68021 --- [nio-9999-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100</span><br><span class="line">    at com.example.demo.StudentController.showStudent(StudentController.java:42) ~[classes/:na]</span><br><span class="line">    堆栈信息太多，下面的略掉了</span><br></pre></td></tr></tbody></table></figure>

<p>看来，校验的代码成功起作用了。</p>
<h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>因为我们现在基本上都是面向 Spring 编程，所以其实上面那些手动获取 <code>Validator</code> 的代码也是不必要的。我们可以让 Spring 自动注入一个 <code>Validator</code> 来实现功能。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> {</span><br><span class="line">    <span class="comment">// 直接注入一个Validator的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/student")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showStudent</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> {</span><br><span class="line">        <span class="comment">// 我们来看看它到底注入了谁</span></span><br><span class="line">        log.info(<span class="string">"Validating bean with validator {}"</span>, validator.getClass().getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Validator#validate方法对这个bean进行校验</span></span><br><span class="line">        <span class="comment">// 所有的</span></span><br><span class="line">        <span class="comment">// ConstraintViolation的泛型类型要设定为被校验bean的类型</span></span><br><span class="line">        Set&lt;ConstraintViolation&lt;Student&gt;&gt; errors = validator.validate(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里遍历errors这个set，打印出各个错误的信息</span></span><br><span class="line">        errors.forEach(error -&gt; {</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">            <span class="comment">// 对应校验规则里面的message属性</span></span><br><span class="line">            log.error(<span class="string">"Error message: {}"</span>, error.getMessage());</span><br><span class="line">            <span class="comment">// 校验失败的属性名</span></span><br><span class="line">            log.error(<span class="string">"Property path: {}"</span>, error.getPropertyPath());</span><br><span class="line">            <span class="comment">// 导致校验失败的值</span></span><br><span class="line">            log.error(<span class="string">"Error value: {}"</span>, error.getInvalidValue());</span><br><span class="line">            log.error(<span class="string">"======================="</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 可以取出所有的校验失败信息，拼接起来之后返回给调用方</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">errMessages</span> <span class="operator">=</span> errors.stream()</span><br><span class="line">                    .map(ConstraintViolation::getMessage)</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里为了省事直接抛出了RuntimeException</span></span><br><span class="line">            <span class="comment">// 实际使用时建议新建一个自定义业务异常代表这种情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(errMessages);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> student.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>重新启动应用，并用相同的数据测试之后，我们得到了这样的日志：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2020-01-06 11:15:17.957  INFO 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Validating bean with validator org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</span><br><span class="line">2020-01-06 11:15:18.071 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Student gender is mandatory</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: gender</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: null</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error message: Maximum value of score is 100</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Property path: score</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : Error value: 180</span><br><span class="line">2020-01-06 11:15:18.072 ERROR 67745 --- [nio-9999-exec-1] com.example.demo.StudentController       : =======================</span><br><span class="line">2020-01-06 11:15:18.089 ERROR 67745 --- [nio-9999-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: Student gender is mandatory, Maximum value of score is 100</span><br><span class="line">    at com.example.demo.StudentController.showStudent(StudentController.java:42) ~[classes/:na]</span><br><span class="line">    下面的堆栈信息依旧略掉</span><br></pre></td></tr></tbody></table></figure>

<p>看来这种方式使用了另一个 <code>Validator</code> 实现，但是没关系，我们依旧能得到正确的结果，并可以使用完全一样的方法来处理错误信息。</p>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmV5b25kamF2YS5uZXQvaG93LXRvLWludm9rZS1qc3ItMzAzLWJlYW4tdmFsaWRhdGlvbi1wcm9ncmFtbWF0aWNhbGx5">How to Invoke JSR 303 Bean Validation Programmatically<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4NzA0MDI1LzM4MzM4NTg=">How to manually trigger spring validation? - StackOverflow<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 连接多个远程仓库</title>
    <url>/push-to-multi-git-repo.html</url>
    <content><![CDATA[<p>有时候我们可能会需要 push 到多个远程仓库，比如同时链接多个代码托管平台的账号，那么可以参考本文所述的方法配置。</p>
<p>保险起见在操作之前请先做好备份工作，毕竟数据无价。</p>
<span id="more"></span>

<h1 id="方法1-添加多个远程仓库"><a href="#方法1-添加多个远程仓库" class="headerlink" title="方法1 - 添加多个远程仓库"></a>方法 1 - 添加多个远程仓库</h1><p>比如要链接两个 Github 仓库，分别是 github1 和 github2，那么：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 github1</span></span><br><span class="line">git remote add github1 https://github.com/username/github1.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 github2</span></span><br><span class="line">git remote add github2 https://github.com/username/github2.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到 github1</span></span><br><span class="line">git push github1 master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到 github2</span></span><br><span class="line">git push github2 master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 github1 更新</span></span><br><span class="line">git pull github1 master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 github2 更新</span></span><br><span class="line">git pull github2 master</span><br></pre></td></tr></tbody></table></figure>

<h1 id="方法2-添加同名多个远程仓库"><a href="#方法2-添加同名多个远程仓库" class="headerlink" title="方法2 - 添加同名多个远程仓库"></a>方法 2 - 添加同名多个远程仓库</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个远程仓库</span></span><br><span class="line">git remote add origin https://github.com/username/github1.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后分别设定push URL</span></span><br><span class="line">git remote set-url --add --push origin https://github.com/username/github1.git</span><br><span class="line">git remote set-url --add --push origin https://github.com/username/github2.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查远程仓库配置</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若配置正确，则结果应当包含一个fetch路径和两个push路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向所有远程仓库推送</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></tbody></table></figure>

<h1 id="方法3-直接修改-git-x2F-config文件"><a href="#方法3-直接修改-git-x2F-config文件" class="headerlink" title="方法3 - 直接修改.git/config文件"></a>方法 3 - 直接修改.git/config 文件</h1><p>用文本编辑器打开本地仓库的 .git/config 文件，然后修改其中的远程仓库配置</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 假设当前的远程仓库名为 origin</span></span><br><span class="line"><span class="section">[remote "origin"]</span></span><br><span class="line">    <span class="attr">url</span> = https://github.com/username/github1.git</span><br><span class="line">    <span class="attr">fetch</span> = +refs/heads/*:refs/remotes/github/*</span><br><span class="line">    <span class="attr">pushurl</span> = https://github.com/username/github1.git</span><br><span class="line">    <span class="attr">pushurl</span> = https://github.com/username/github2.git</span><br></pre></td></tr></tbody></table></figure>

<p>然后直接使用</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></tbody></table></figure>

<p>即可提交至所有版本库</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>我的新冠感染纪实</title>
    <url>/recording-my-infection-of-corona.html</url>
    <content><![CDATA[<p>我，很不幸，于 2022-12-23 夜，新冠奥密克戎发作。不过，最近记录自己被感染的生活好像是个流量密码，那我干脆也蹭一波热点，记录一下我感染之后的感受。</p>
<span id="more"></span>

<h2 id="病发"><a href="#病发" class="headerlink" title="病发"></a>病发</h2><p>说来，一开始有征兆还是在 22 日下午，我从医院开完药出来之后，就偶尔会咳两声，但是嗓子里的感觉又不像是感染，更像是吸入了什么灰尘，喉咙那有点麻麻沙沙的异物感，所以就没放在心上。</p>
<p>正经开始感觉不对劲，是在 12 月 23 日的下午。本来这天阳光不是很足，上海又降温了，好死不死我还没开空调，屋里本来就有点冷。我慢慢开始感觉有点浑身发凉，但是没想到是发病，以为只是单纯的着凉而已，于是打开了空调，期盼能舒服一点。</p>
<p>但是慢慢的事情开始朝不对劲的方向发展，晚上我开始感觉脑袋会忽然飘一下，后背也开始有一种奇怪但熟悉的痛感，我不知道该怎么描述，就是那种你摸上去就会有点钝痛的那种感觉。我发觉这事不是那么简单，我估计是发烧了，但这时候我依旧没往新冠感染上想，以为就是个普通感冒。但是苦于我的温度计找不到了，不量体温又不是个办法，遂硬着头皮，走到小区对面的药房，借了药房的温度计测了一下。结果不出预料，37 度 5。因为药房的温度计也卖完了，于是在咨询了一下怎么吃药之后，就回去了。</p>
<p>说真的，家里必须得时常检查下温度计还能不能找见，发烧的时候顶着寒冷出门绝不是个好主意。我在走路的时候，时不时就会晕一下，过马路左右扭头的时候甚至耳朵嗡的一下，虽然神志清楚，但是总感觉险些要晕过去。也就算我命大，硬是慢慢的走回来了。</p>
<p>书归正传，有时候吧，这事还真就是无巧不成书，正好我在 22 日那天要去医院开我的焦虑症的药，就顺路在药房买了些能对应新冠感染的药，虽然不是布洛芬和对乙酰氨基酚这种值钱玩意，但至少退烧、止痛、镇咳、缓解咽痛的药都拿到了。只是万万没想到第二天就能派上用场…..TAT。</p>
<p>得了医嘱，回来开始吃退烧药。药名叫<code>酚氨咖敏片</code>，说主治感冒、发烧、头痛，里面包含氨基比林、对乙酰氨基酚、咖啡因、马来酸氯苯那敏。吃了药，想到没有体温计还是不行，于是打开各种外卖平台，想看看附近药房有没有能外卖过来的。要不说咱命好呢，正好交大附近的一个药房还有额温枪，不容多想，手起键落下了一单。一看预计 00:23 送达，我还挺美，哪知道临到凌晨的时候美团说已经送达？？？我一问骑手，才知道他们不肯单独为这一个玩意跑这么远，只能等第二天中午再送。行吧，没盼头了，一摸电热毯烧的很热，空调也够劲，睡。</p>
<h2 id="次日"><a href="#次日" class="headerlink" title="次日"></a>次日</h2><p>一晚上觉也没睡太好，醒了有三四次，期间还做了不少奇奇怪怪的梦，到了早上 10 点来钟，迷迷糊糊的醒了，但是感觉非常赖床，左滚右滚就是不想起，还感觉身上似乎出了很多的汗。翻腾了大概半小时，终于鼓起勇气，爬出被窝起床。一摸后背，果然湿漉漉的，出了不少的汗。起来刷过牙洗过脸，开始吃药。过了会看到我这还有不少抗原试剂盒，是中旬上海封城的时候发的，于是就拿了一个测了一下，一开始只看见 C 有杠杠，T 没有，还庆幸不是新冠，但是 15 分钟后，T 这里开始出现浅浅的一道。果然，还是没躲掉。</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/ra-test-result.jpeg" alt="噫！好了！我中了！"></p>
<p>既然中了，那果然还是得搞点更对症的药。问了之前感染过的兄弟，都说布洛芬好使，但是现在药房肯定是买不到了。好在微信上线了一个互助小程序，我成功联系到了两个人，一位给我送了 4 片对乙酰氨基酚，另一位网购了 100 来片布洛芬，我正在等他到货。中午吃过饭之后，跑腿小哥也把药送到了我这里。</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/acetaminophen.jpeg"></p>
<p>之前一直不相信自己是新冠感染的另一个原因就是，很多人都说他们感染之后丧失了嗅觉和味觉，但是我味觉丝毫不受任何影响，吃什么都很有味，包括头一天晚上吃的柚子，和这一天吃的外卖，味觉都很正常，没有发生味觉丧失和味觉改变。或许这个症状也是因人而异吧。至于嗅觉，我是个过敏性鼻炎患者，嗅觉不好使不是一年两年了，所以就算没了我也不知道……</p>
<p>下午也没心情搞什么，躺在床上无所事事，大概三点来钟睡着了，一觉干到 6 点半。醒来没一会接到家里的电话，说已经在来上海的飞机上了。我是感觉又安心又担心，安心当然是因为父母能来照顾我，但是我又非常害怕传染给他们，不过既然来了，也劝不回去，只能车到山前必有路了吧。吃过晚饭，一边写这篇流水账，一边等父母过来。</p>
<p>对了，还没说我买的额温枪呢。实话说我一开始特别怀疑这玩意的准确度，因为中午拿到之后我就测了好几次，那会身体明明感觉到还有一点烧，但是一直都只能测出来 36 度 5、36 度 8。直到刚才 (20:54)，我明显感觉到体温又上来之后，才测出来个 37 度 6，而且这还夹杂在一堆 37 度整、36 度 8 之间。果然还是得整个水银的才靠谱啊。</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/forehead-thermometer.jpeg"></p>
<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>前一天晚上还是有点低烧，看到网上建议忍一忍再吃退烧药，让体温帮助杀灭病毒，所以睡前也没喝布洛芬，直接钻进烧热了电热毯的被窝睡了。一晚上还是各种奇怪的梦。可早上一醒，嘿，你猜怎么着？我不烧了！然而嗓子比前一天加倍的疼，咳嗽好像也略微多了点，还带着白痰。莫非病毒已经被打的溃不成军，妄图用加重咳嗽的方法往外大量散播么？如果屋里只有我一个人的话，那我才懒得管，你随便爱往哪传播就往哪传播去，但是现在我父母也来了，那我的评价就是</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/wanna-run.jpeg"></p>
<p>继续说症状，今天后背还是有类似发烧引发的那种痛感，隐隐还有点头疼，而且偶尔脑袋还是会恍惚一下，大概是发烧导致的问题还没好利索。</p>
<p>中午吃过饭，也没什么精神头干别的，直接从大概一两点睡到了将近 6 点，起来之后，因为头疼搞得很恶心，吐了一大口。好在没有影响食欲，晚饭依旧吃得很香。饭后也没啥精神，待了会就睡了。</p>
<h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>第四天一整天的主旨就是一个字：睡。</p>
<p>头天晚上睡觉的时候，一晚上醒了几次，断断续续的睡到了大概十点来钟，起来也没什么精神，什么都不想干，只想趴着，只想睡觉。但也有值得高兴的事，母上大人做的素面一如既往的好吃。</p>
<p>下午断断续续睡了好几觉，睡醒了就还是头疼。喝了口热水，感觉有点恶心，暗觉不妙，但是也没多想，就想接着睡。但是刚躺下没一会，突然胃就一抽给呕出来一口。说时迟那时快，我强忍着咬紧牙关，光速戴上口罩冲进厕所，哇哇的把中午饭和晚饭都吐干净了。饭吐了不说，还吐了好几口鲜血，场面甚是恐怖。我害怕是肺出血，还特意咳了口痰，还好还好痰里没血。但又想到最近吃的药有点杂，开始担心是不是肝坏了，遂在支付宝上找了个在线问诊，大夫听完我描述说，不像是肝损伤，建议我把药都停了，饭不要吃太烫的，观察一下看看，如果不再吐就没事了。还好还好，不需要去 ICU。完事喝了点水，待了会就准备继续睡觉。可是白天睡了太多，晚上断断续续的差不多两点钟才正经睡着。</p>
<p>为啥我突然开始担心肝呢？因为这几天确实药吃的有点杂，有布洛芬，有胆木浸膏糖浆，还有父母从老家带来的 “新冠治疗方” 中药，我害怕里面有什么成分重叠，给肝脏上了太大压力，就像那些因为害怕而过量服药的人一样。</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/the_chinese_tradition_medicine.jpeg"></p>
<p>不过既然大夫都说把不必要的药都停了，那就遵医嘱呗，反正新冠这玩意最后还是得靠自己，不烧也不死命的咳，那也就别瞎吃药了。</p>
<p>忘了是中午还是下午，顺便又做了个自测，这次变成强阳性了，T 这一杠红的甚是晃眼。</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/ra-test-day4.jpeg"></p>
<p>这两天也算是目前为止精神最差的两天，什么都不想干，要是味觉再没了的话，我可能连饭都不想吃。</p>
<h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><p>今天早上的主题是：疼！</p>
<p>第四天开始，我的左边嗓子就已经开始疼起来了，但是今天我没想到竟能如此的疼！什么吞刀片感，明明是电钻打眼感好吗？而且正好是左边打穿了，正在开始往右边打！</p>
<p>不过也有好消息，就是咳嗽更少了，而且也确实没有再吐血，甚至没有恶心的感觉。精神状态也比前两天好了不少。前两天不止是什么都不想干，听到微信的通知声音都烦躁的很。</p>
<p>而且今天开始，咳嗽的次数又变少了，一天满打满算好像也就不到 10 次的样子。感觉应该是快要康复了？</p>
<p>早饭吃了个黑麦片配小麦胚芽，这还是我在六七月份上海解封之后买的。然后遵医嘱吃了颗奥美拉唑肠溶胶囊养养胃。吃完早饭无所事事，瞎翻手机的时候，看到小区群有人在卖体温计，正好我缺个体温计，只有个感觉并不是那么准的额温枪。没时间多想，果断拿下。呐，就是这玩意：</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/thermometer.jpeg" alt="我也是有体温计的人了"></p>
<p>中午吃的是素面和金枪鱼罐头。饭后虽然说有了点精神，但还是什么都不想干，那不用说，睡！</p>
<p>睡到大概四五点的时候，隐约感觉有点冷，以为是下午睡觉没开空调，屋里降温的原因。想到有了体温计，就测一下吧。可这一测吓我一跳，37 度 5，这是又烧上了？但是感觉又不像，嘴里哈气也没有之前发烧那种哈热气的感觉，摸脑门也不觉得热，让父母摸了一下，好像也没啥大差别，只好不管了，再观察一下。</p>
<p>网上瞎冲浪的时候，看见这么一张图，又想到我晚上睡大床，父母却只能在沙发和帆布床上凑合，瞬间泪如雨下。</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/Fk-Vjo8XwAI19Bx.jpg"></p>
<p>晚饭吃的小米粥和香菇炒油菜，吃过饭之后感觉头疼的厉害，那正好吃片扑热息痛，又退烧又缓解头痛。有一说一我真的觉得扑热息痛比布洛芬好使欸，见效又快又明显。刚刚 (20:52) 又测了下体温，37 度 1，果然是真的又烧起来了，不过拜扑热息痛所赐，并不觉得很难受，甚至有精神继续更新这篇纪实。</p>
<p>一边写文，一边喝椰子水，美得很！</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/coconut-water.jpeg"></p>
<p>如果说大量喝白开水会感觉不舒服或者恶心的话，确实喝果汁是个不错的选择，写文的功夫，我大概已经连着干下去三分之二盒了。确实比喝白开水舒服。</p>
<p>说话的功夫，又到了 21:00，烧上电热毯，休息一会，准备睡觉。</p>
<h2 id="第六天-第八天"><a href="#第六天-第八天" class="headerlink" title="第六天 ~ 第八天"></a>第六天～第八天</h2><p>这三天变化不是很多，想想干脆合起来写好了。</p>
<p>从第六天开始突然感觉症状明显减轻，第六天仍稍微有一点类似发烧的头晕感，但是第七天往后就几乎没有这种感觉，精力也恢复不少，能专心做事或者动脑了。会想起前几天，“脑雾” 比较严重的一次，是在厕所蹲完坑扯了张纸准备擦，但扯下来纸后我鬼使神差开始擦手，擦了两下感觉有点不对，顿了顿才想起来是要擦屁股……</p>
<p>虽然说病情是在好转，但是最近这两天的抗原结果我属实没看明白。第六天测的时候是弱阳性，第七天突然强阳，缓冲液刚滴进去，T 那条就红了，然后第八天呢，又变成非常弱的阳性，缓冲液滴进去 15 分钟之后都得仔细盯才能看到及其不明显的一条杠。难道说，病毒也在跟我玩回光返照么？</p>
<table>
<thead>
<tr>
<th>第六天</th>
<th>第七天</th>
<th>第八天</th>
</tr>
</thead>
<tbody><tr>
<td><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/ra-test-12-28.jpeg"></td>
<td><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/ra-test-12-29.jpeg"></td>
<td><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/ra-test-12-30.jpeg"></td>
</tr>
</tbody></table>
<p>咳嗽倒还是那样，每天还是有十来次咳痰，后面还有一点干咳。看网上的说法，这算是长新冠症状的一种？</p>
<p>然后就是最恶心的症状 – 嗓子吞刀片，这几天就还是该怎么疼就怎么疼，一天下来可能某个时间段稍微好点，但过一会好像又加重。拿手机给自己的嗓子眼拍了张特写，发现咽部有网状白色，而且扁桃腺也肿的厉害，盲猜是诱发咽炎和扁桃腺炎了。照片…… 我想想还是不贴出来了吧，血盆大口也不是那么好看。</p>
<h2 id="第九天-第十二天"><a href="#第九天-第十二天" class="headerlink" title="第九天 ~ 第十二天"></a>第九天～第十二天</h2><p>第九天往后开始没啥大变化，依旧是偶尔咳痰，以及嗓子干痛。问了药房大夫，说吃点消炎药控制咽痛就行，正好我有点蒲地兰消炎片，照着说明书就开始吃。第十一天早上醒来，突然就发现嗓子不疼了，我也懒得再看嗓子眼里面是啥样，盲猜咽炎和扁桃肿大都应该是没了。咳痰依旧偶尔有一点，打算等有时间了去医院再做个检查，顺便照个肺部 CT，看看肺子有没有受影响。</p>
<p>第十一天又测了个抗原，已经完全看不到 T 的那条杠，看来新冠病毒是已经没有了，剩下的症状大概就是所谓的长新冠？</p>
<p><img data-src="https://blog-static.boris1993.com/recording-my-infection-of-corona/ra-test-01-02.jpeg"></p>
<p>而且这几天虽然精力恢复了不少，但还是很困，早上不想起，迷迷糊糊能一直睡到中午，吃过午饭就眼皮发沉又想睡觉。</p>
<h2 id="其他查到的信息"><a href="#其他查到的信息" class="headerlink" title="其他查到的信息"></a>其他查到的信息</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9lLmR4eS5jbi93aXNkb20vZnJvbnQvemhpaHVpaGFvLzEzNzk=">布洛芬和对乙酰氨基酚 你可能不知道的事<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>新冠肺炎</tag>
        <tag>奥密克戎</tag>
        <tag>Omicron</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker 配置 Redis 主从复制</title>
    <url>/redis-replication-in-docker.html</url>
    <content><![CDATA[<p>这篇文章主要介绍如何使用 Docker 在本机搭建一个带有主从复制功能的 Redis 环境，内容包括涉及的目录结构、<code>docker-compose.yml</code> 的编写，以及结果的验证。</p>
<span id="more"></span>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>本文将采用如下的目录结构，其中 <code>data</code> 目录将用于存放各个容器的数据，<code>server</code> 目录存放 <code>docker-compose.yml</code> 以及针对 <code>master</code> 和 <code>slave</code> 节点的配置文件。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    ├── redis-slave1.conf</span><br><span class="line">    └── redis-slave2.conf</span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置Redis节点"><a href="#配置Redis节点" class="headerlink" title="配置Redis节点"></a>配置 Redis 节点</h2><h3 id="配置master节点"><a href="#配置master节点" class="headerlink" title="配置master节点"></a>配置 <code>master</code> 节点</h3><p>编辑 <code>redis-master.conf</code>，修改下列配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS ""</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br></pre></td></tr></tbody></table></figure>

<h3 id="配置slave节点"><a href="#配置slave节点" class="headerlink" title="配置slave节点"></a>配置 <code>slave</code> 节点</h3><p>创建 <code>redis-slave1.conf</code>，修改下列配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS ""</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br><span class="line"></span><br><span class="line"># 配置master节点信息</span><br><span class="line"># 格式：</span><br><span class="line">#slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"># 此处masterip所指定的redis-server-master是运行master节点的容器名</span><br><span class="line"># Docker容器间可以使用容器名代替实际的IP地址来通信</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"># 设定连接主节点所使用的密码</span><br><span class="line">masterauth "redis"</span><br></pre></td></tr></tbody></table></figure>

<p>创建 <code>redis-slave2.conf</code>，修改监听端口号为 <code>6381</code>，其余配置与 <code>redis-slave1.conf</code> 相同。</p>
<h2 id="配置及启动容器"><a href="#配置及启动容器" class="headerlink" title="配置及启动容器"></a>配置及启动容器</h2><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写 <code>docker-compose.yml</code></h3><p>本例中使用 <code>docker-compose</code> 编排相关容器。要说为什么不用 <code>Kubernetes</code>，那是因为对于一个示例来说这玩意太重了。<del>说的一套一套的还不是因为不会用</del></p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 主节点的容器</span></span><br><span class="line">  <span class="attr">redis-server-master:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-server-master</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="comment"># 为了规避Docker中端口映射可能带来的问题</span></span><br><span class="line">    <span class="comment"># 这里选择使用host网络</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="comment"># 指定时区，保证容器内时间正确</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 映射配置文件和数据目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-master.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../data/redis-master:/data</span></span><br><span class="line">    <span class="attr">sysctls:</span></span><br><span class="line">      <span class="comment"># 必要的内核参数</span></span><br><span class="line">      <span class="attr">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"redis-server"</span>, <span class="string">"/usr/local/etc/redis/redis.conf"</span>]</span><br><span class="line">  <span class="comment"># 从节点1的容器</span></span><br><span class="line">  <span class="attr">redis-server-slave-1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-server-slave-1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-server-master</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-slave1.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../data/redis-slave-1:/data</span></span><br><span class="line">    <span class="attr">sysctls:</span></span><br><span class="line">      <span class="attr">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"redis-server"</span>, <span class="string">"/usr/local/etc/redis/redis.conf"</span>]</span><br><span class="line">  <span class="comment"># 从节点2的容器</span></span><br><span class="line">  <span class="attr">redis-server-slave-2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis-server-slave-2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-server-master</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis-slave2.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../data/redis-slave-2:/data</span></span><br><span class="line">    <span class="attr">sysctls:</span></span><br><span class="line">      <span class="attr">net.core.somaxconn:</span> <span class="string">'511'</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">"redis-server"</span>, <span class="string">"/usr/local/etc/redis/redis.conf"</span>]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>在 <code>docker-compose.yml</code> 所在位置执行 <code>docker-compose up</code> 即可启动上述三个容器，<code>docker-compose</code> 会将容器日志打印到终端，在日志中可以看到三个 <code>Redis</code> 服务器在启动过程中的动作，以及从节点加入主节点的信息。</p>
<p>启动成功后，可以在本机使用 <code>redis-cli</code> 连接至主节点。连接成功后，可以使用 <code>info replication</code> 命令检查主从复制的信息。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=14,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6380,state=online,offset=14,lag=1</span><br><span class="line">master_replid:156ad6d206def2c9d423ef95f5311365d454f57d</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></tbody></table></figure>

<p>其中第 5 行的 <code>role:master</code> 指示该节点为主节点，第 6 行的 <code>connected_slaves:2</code> 说明当前有 2 个从节点，第 7、8 行则是两个从节点的信息，包括它们的地址、端口号，和状态。</p>
<p>如果此时查看该项目的目录结构，则可以发现在 <code>data</code> 目录中增加了三个 Redis 服务器的数据目录。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│&nbsp;&nbsp; ├── redis-master</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── dump.rdb</span><br><span class="line">│&nbsp;&nbsp; ├── redis-slave-1</span><br><span class="line">│&nbsp;&nbsp; │&nbsp;&nbsp; └── dump.rdb</span><br><span class="line">│&nbsp;&nbsp; └── redis-slave-2</span><br><span class="line">│&nbsp;&nbsp;     └── dump.rdb</span><br><span class="line">└── server</span><br><span class="line">    ├── docker-compose.yml</span><br><span class="line">    ├── redis-master.conf</span><br><span class="line">    └── redis-slave.conf</span><br></pre></td></tr></tbody></table></figure>

<h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>光是启动成功还不够，还需要测试一下从节点是否能同步主节点的数据。</p>
<p>首先连接到主节点，新增一个 set：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">"bar"</span><br></pre></td></tr></tbody></table></figure>

<p>好的，在主节点里面成功添加了一条数据。那么接下来连接到 <code>slave-1</code>，看一下数据有没有同步过去：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get foo</span><br><span class="line">"bar"</span><br><span class="line">127.0.0.1:6380&gt; set foo baz</span><br><span class="line">(error) READONLY You can't write against a read only replica.</span><br></pre></td></tr></tbody></table></figure>

<p>看来 <code>slave-1</code> 成功的从主节点同步了数据，并且这个节点也按照设定，是一个只读的节点。那么 <code>slave-2</code> 呢？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; get foo</span><br><span class="line">"bar"</span><br><span class="line">127.0.0.1:6381&gt; set foo baz</span><br><span class="line">(error) READONLY You can't write against a read only replica.</span><br></pre></td></tr></tbody></table></figure>

<p>OK，<code>slave-2</code> 也成功的同步了数据，并且正在作为一个只读节点运行着。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby90b3BpY3MvcmVwbGljYXRpb24jY29uZmlndXJpbmctcmVwbGljYXRpb24taW4tZG9ja2VyLWFuZC1uYXQ=">Configuring replication in Docker and NAT - Redis Replication Document<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h2><ul>
<li><a href="/database/Redis/redis-replication-in-docker.html">使用 Docker 配置 Redis 主从复制</a></li>
<li><a href="/database/Redis/redis-sentinel-in-docker.html">使用 Docker 配置 Redis 哨兵</a></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>循序渐进写一个 Servlet (1) - 介绍相关的接口和类</title>
    <url>/java-servlet-1-introducing-classes-and-interfaces.html</url>
    <content><![CDATA[<p>Servlet（Server Applet），全称 Java Servlet，是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。本系列将一步步地写出一个 Servlet 程序。</p>
<p>这篇博文将介绍一些后面会用到的接口和类。</p>
<span id="more"></span>

<h1 id="常用的类和接口"><a href="#常用的类和接口" class="headerlink" title="常用的类和接口"></a>常用的类和接口</h1><h2 id="javax-servlet-Servlet"><a href="#javax-servlet-Servlet" class="headerlink" title="javax.servlet.Servlet"></a><code>javax.servlet.Servlet</code></h2><p><code>javax.servlet.Servlet</code> 是一个接口，它定义了一个 servlet 必须要实现的方法，包括如何初始化一个 servlet，如何让这个 servlet 处理请求，以及如何将这个 servlet 从容器中移除，即 “生命周期方法”。它们被调用的顺序，即 servlet 的生命周期，是这样的：</p>
<ol>
<li>容器生成这个 servlet 的对象，然后调用其 <code>init()</code> 方法完成初始化步骤</li>
<li>当收到请求之后，会调用其 <code>service()</code> 方法来处理请求</li>
<li>当这个 servlet 停止服务时，<code>destroy()</code> 方法会被调用并准备销毁</li>
</ol>
<p>Servlet 的启动时间由 <code>web.xml</code> 中 <code>load-on-startup</code> 属性决定，当值为负数或未设定该属性时，容器可以自由决定何时初始化该 servlet；当值为零或正整数时，容器需要在启动时就初始化该 servlet，此时该属性的值代表初始化的优先级，值越小优先级越高，对于有相同优先级的 servlet，容器可以自行决定加载顺序。</p>
<p>当应用被重新部署，或者在容器停机时，servlet 会被销毁，同时 servet 无法被手动销毁。</p>
<p>除了生命周期方法外，<code>Servlet</code> 接口还有两个方法：</p>
<ol>
<li><code>getServletConfig()</code> 可以让 servlet 取到启动相关的信息</li>
<li><code>getServletInfo()</code> 用来获取 servlet 相关的信息，如作者、版本号、版权信息等</li>
</ol>
<h2 id="javax-servlet-GenericServlet"><a href="#javax-servlet-GenericServlet" class="headerlink" title="javax.servlet.GenericServlet"></a><code>javax.servlet.GenericServlet</code></h2><p><code>GenericServlet</code> 类是一个抽象类，定义了一个协议无关的，通用的 servlet 实现。</p>
<p>它预置了 <code>ServletConfig</code> 接口的实现，并且简易实现了 <code>Servlet</code> 接口中的 <code>init()</code> 方法和 <code>destroy()</code> 方法，开发人员只需要覆盖 <code>service()</code> 方法。</p>
<h2 id="javax-servlet-http-HttpServlet"><a href="#javax-servlet-http-HttpServlet" class="headerlink" title="javax.servlet.http.HttpServlet"></a><code>javax.servlet.http.HttpServlet</code></h2><p><code>HttpServlet</code> 类提供了一个用于处理 HTTP 请求的 servlet 基类。一个 <code>HttpServlet</code> 的子类至少需要覆盖一个方法，而且通常是覆盖如下几个方法：</p>
<ol>
<li><code>doGet()</code>，以实现对 <code>HTTP GET</code> 请求的处理</li>
<li><code>doPost()</code>，以实现对 <code>HTTP POST</code> 请求的处理</li>
<li><code>doPut()</code>，以实现对 <code>HTTP PUT</code> 请求的处理</li>
<li><code>doDelete()</code>，以实现对 <code>HTTP DELETE</code> 请求的处理</li>
<li><code>init()</code> 和 <code>destroy()</code>，以管理 servlet 生命周期内所需的资源</li>
<li><code>getServletInfo()</code>，可以用来自定义 servlet 返回哪些关于自身的信息</li>
</ol>
<p>此外，不建议直接覆盖 <code>service()</code> 方法，因为 <code>HttpServlet#service()</code> 方法中已经实现了根据 HTTP 请求类型调用对应的 <code>doXXX()</code> 方法。</p>
<p>如果某个 HTTP 方法对应的 <code>doXXX()</code> 方法没有被覆盖，则视为该 servlet 不支持这个 HTTP 方法。如在没有覆盖 <code>doGet()</code> 时收到 <code>HTTP GET</code> 请求，则会返回 <code>HTTP 405 METHOD NOT ALLOWED (对应HTTP 1.1)</code> 错误码，或 <code>HTTP 400 BAD REQUEST (对应其他HTTP版本)</code> 错误码。</p>
<p>需要注意的是，<code>HttpServlet</code> 类并没有实现 <code>HTTP CONNECT</code> 和 <code>HTTP PATCH</code> 方法。当请求这两个方法，或其他非<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9NZXRob2Rz">标准<i class="fa fa-external-link-alt"></i></span>方法时，将会返回 <code>HTTP 501 NOT IMPLEMENTED</code> 错误码。</p>
<h1 id="常用的常量"><a href="#常用的常量" class="headerlink" title="常用的常量"></a>常用的常量</h1><ul>
<li>HTTP 方法相关的常量位于 <code>HttpServlet</code> 类中，是 String 类型，命名规则为 <code>METHOD_方法</code>，如 <code>METHOD_GET</code></li>
<li>HTTP 状态码相关的常量位于 <code>HttpServletResponse</code> 类中，是 int 类型，命名规则为 <code>SC_状态码名</code>，如 <code>SC_OK</code>、<code>SC_NOT_FOUND</code></li>
</ul>
<h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul>
<li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个 Servlet (1) - 介绍相关的接口和类</a></li>
<li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个 Servlet (2) - 第一个 servlet</a></li>
<li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个 Servlet (3) - 分别处理 GET 和 POST</a></li>
<li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个 Servlet (4) - 会话追踪</a></li>
<li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个 Servlet (5) - Filter</a></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>循序渐进写一个 Servlet (2) - 第一个 servlet</title>
    <url>/java-servlet-2-first-servlet.html</url>
    <content><![CDATA[<p>Servlet（Server Applet），全称 Java Servlet，是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。本系列将一步步地写出一个 Servlet 程序。</p>
<p>这篇博文将演示如何创建一个 servlet。</p>
<span id="more"></span>

<h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><p>首先，使用 Maven 的 <code>maven-archetype-webapp</code> 创建一个 Java Webapp 项目。这样就可以得到一个 Java Webapp 项目的基本骨架。将项目命名为 <code>servletdemo</code>。</p>
<h1 id="创建Servlet对象"><a href="#创建Servlet对象" class="headerlink" title="创建Servlet对象"></a>创建 Servlet 对象</h1><p>新建一个名为 DemoServlet 的类。</p>
<p>因为 <code>GenericServlet</code> 已经实现了一个 servlet 的生命周期方法，而且这里也不需要对生命周期方法做定制化，所以直接继承一个 <code>GenericServlet</code> 就可以。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="实现这个servlet的功能"><a href="#实现这个servlet的功能" class="headerlink" title="实现这个servlet的功能"></a>实现这个 servlet 的功能</h1><p><code>service()</code> 方法定义了这个 servlet 的具体实现，这里先让它返回一个 HTML。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    res.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    res.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java 8 新特性 - try with resources</span></span><br><span class="line">    <span class="comment">// 该特性优点在于，try代码块执行完毕后，会自动close相关资源</span></span><br><span class="line">    <span class="comment">// 要求资源所属的类必须实现了 AutoCloseable 或 Closeable 接口</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> res.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="注册到容器"><a href="#注册到容器" class="headerlink" title="注册到容器"></a>注册到容器</h1><p>光有 servlet 还不够，下面还需要让容器知道有这个 servlet，以及知道要把哪些请求发往这个 servlet。这里可以通过修改 <code>web.xml</code> 的方式，也可以通过注解的方式完成注册。</p>
<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><code>web.xml</code></h2><p><code>web.xml</code> 位于 <code>src/main/webapp/WEB_INF/web.xml</code>。</p>
<p>向其中添加如下内容：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet属性定义了一个servlet的名字和对应的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.boris.tomcatlistener.servlet.DemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- servlet-mapping属性定义了匹配某个URL的请求应该发往哪个servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 目标servlet的servlet-name --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 匹配的URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demoServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>WebServlet(String value)</code> 注解表明了这个类是一个 servlet，其中 <code>value</code> 的值等同于 <code>web.xml</code> 中 <code>url-patterm</code> 参数。</p>
<p>在项目部署时，容器会处理 <code>WebServlet</code> 注解，并将这个 servlet 与指定的 URL pattern 绑定。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = "/demoServlet")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">        res.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">        res.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 8 新特性 - try with resources</span></span><br><span class="line">        <span class="comment">// 该特性优点在于，try代码块执行完毕后，会自动close相关资源</span></span><br><span class="line">        <span class="comment">// 要求资源所属的类必须实现了 AutoCloseable 或 Closeable 接口</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> res.getWriter()) {</span><br><span class="line">            <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">            writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="运行起来吧，servlet哟！"><a href="#运行起来吧，servlet哟！" class="headerlink" title="运行起来吧，servlet哟！"></a>运行起来吧，servlet 哟！</h1><p>在上面步骤中，创建一个 servlet 的所有步骤就完成了，尽管这个 servlet 的功能及其有限，它甚至不能区分发来的 HTTP 请求。</p>
<p>那么，就将这个 servlet 部署到容器中，让它开始工作吧。启动成功后，使用浏览器，或者 HTTP 请求构造工具，向 <code>http://localhost:8080/servletdemo/DemoServlet</code>（假设 Tomcat 在监听 8080 端口）发一条请求。</p>
<p>如果一切正常的话，就可以看到服务器返回了上面 <code>service()</code> 方法中指定的内容。</p>
<h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul>
<li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个 Servlet (1) - 介绍相关的接口和类</a></li>
<li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个 Servlet (2) - 第一个 servlet</a></li>
<li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个 Servlet (3) - 分别处理 GET 和 POST</a></li>
<li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个 Servlet (4) - 会话追踪</a></li>
<li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个 Servlet (5) - Filter</a></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>循序渐进写一个 Servlet (3) - 分别处理 GET 和 POST</title>
    <url>/java-servlet-3-handle-get-and-post.html</url>
    <content><![CDATA[<p>Servlet（Server Applet），全称 Java Servlet，是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。本系列将一步步地写出一个 Servlet 程序。</p>
<p>这篇博文将演示如何分别处理 <code>GET</code> 和 <code>POST</code> 请求，以及处理请求中的参数。</p>
<span id="more"></span>

<h1 id="编写doGet-和doPost-方法"><a href="#编写doGet-和doPost-方法" class="headerlink" title="编写doGet()和doPost()方法"></a>编写 <code>doGet()</code> 和 <code>doPost()</code> 方法</h1><p>首先把要实现的功能写好，后面才好调用不是。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="区分HTTP方法"><a href="#区分HTTP方法" class="headerlink" title="区分HTTP方法"></a>区分 HTTP 方法</h1><p>因为 servlet 是调用 <code>service()</code> 方法来处理请求的，所以对请求做区分也需要在 <code>service()</code> 方法中进行。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"GET"</span>.equalsIgnoreCase(httpServletRequest.getMethod())) {</span><br><span class="line">        doGet(httpServletRequest, httpServletResponse);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"POST"</span>.equalsIgnoreCase(httpServletRequest.getMethod())) {</span><br><span class="line">        doPost(httpServletRequest, httpServletResponse);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 如果请求既不是GET也不是POST</span></span><br><span class="line">        <span class="comment">// 那么就返回HTTP 501 NOT IMPLEMENTED状态码</span></span><br><span class="line">        <span class="comment">// 毕竟不能把请求直接扔了，总是要有个返回的</span></span><br><span class="line">        httpServletResponse.sendError(<span class="number">501</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="运行起来看看效果"><a href="#运行起来看看效果" class="headerlink" title="运行起来看看效果"></a>运行起来看看效果</h1><p>首先发个 <code>GET</code> 请求</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-3-handle-get-and-post/handling-get-request.png" alt="Handling GET request"></p>
<p>再发个 <code>POST</code> 请求</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-3-handle-get-and-post/handling-post-request.png" alt="Handling POST request"></p>
<h1 id="为什么不用HttpServlet类呢"><a href="#为什么不用HttpServlet类呢" class="headerlink" title="为什么不用HttpServlet类呢"></a>为什么不用 <code>HttpServlet</code> 类呢</h1><p>没错，上面做的，就是自己实现了一个简陋的 <code>HttpServlet</code> 类，因为是循序渐进嘛，没头没脑的直接砸上来一个，算什么循序渐进。</p>
<p>那么现在就让 <code>DemoServlet</code> 继承 <code>HttpServlet</code>。同时，因为 <code>HttpServlet</code> 已经在 <code>service()</code> 方法中实现了判断请求类型，所以 <code>DemoServlet</code> 中不要覆盖 <code>service()</code> 方法，只覆盖 <code>doGet()</code> 和 <code>doPost()</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">            <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">            writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">            <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">            writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">            writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="处理请求中的参数"><a href="#处理请求中的参数" class="headerlink" title="处理请求中的参数"></a>处理请求中的参数</h1><p>HTTP 请求是可以带参数的，有了参数，那就得处理。</p>
<h2 id="处理GET请求的参数"><a href="#处理GET请求的参数" class="headerlink" title="处理GET请求的参数"></a>处理 <code>GET</code> 请求的参数</h2><p><code>GET</code> 请求里带的参数，名字叫<code>查询字符串(query string)</code>，是一组或多组 <code>key=value</code> 格式的键值对。</p>
<p>Query string 写在 URL 后面，以一个问号起头，用 <code>&amp;</code> 分隔各个键值对，即类似 <code>http://localhost:8080/appname/servlet?arg1=value1&amp;arg2=value2&amp;...&amp;argN=valueN</code>。</p>
<p>在代码里使用 <code>HttpServletRequest#getQueryString()</code> 方法，就可以获取到问号后面的 query string，分别用 <code>&amp;</code> 和 <code>=</code> 分割字符串，就可以取到每个参数的 key 和 value。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    String queryString = request.getQueryString();</span></span><br><span class="line"><span class="comment">    String[] queryStrings;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (queryString != null) {</span></span><br><span class="line"><span class="comment">        queryStrings = queryString.split("&amp;");</span></span><br><span class="line"><span class="comment">    } else {</span></span><br><span class="line"><span class="comment">        queryStrings = new String[]{};</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类简化null判断</span></span><br><span class="line">    Optional&lt;String&gt; optionalQueryString = Optional.ofNullable(request.getQueryString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有query string则取出每个参数</span></span><br><span class="line">    <span class="comment">// 如果没有则返回一个空的String数组</span></span><br><span class="line">    String[] queryStrings = optionalQueryString.isPresent() ? optionalQueryString.get().split(<span class="string">"&amp;"</span>) : <span class="keyword">new</span> <span class="title class_">String</span>[]{};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (String query : queryStrings) {</span><br><span class="line">            <span class="comment">// 取出参数的key和value</span></span><br><span class="line">            String[] q = query.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            writer.print(q[<span class="number">0</span>] + <span class="string">" = "</span> + q[<span class="number">1</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行一下，结果是这样子的：</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-3-handle-get-and-post/handling-query-string.png" alt="Handling query string"></p>
<h2 id="处理POST请求的参数"><a href="#处理POST请求的参数" class="headerlink" title="处理POST请求的参数"></a>处理 <code>POST</code> 请求的参数</h2><p><code>POST</code> 请求的参数就叫参数 (parameter)，位于请求体 (body) 里，格式由 <code>Content-Type</code> 请求头决定。详细介绍可以参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9NZXRob2RzL1BPU1Q=">这篇 MDN 文档<i class="fa fa-external-link-alt"></i></span>。</p>
<p><code>HttpServletRequest#getParameterMap()</code> 方法可以取出请求中的所有参数，并放到一个 Map 中。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有参数，得到一个Map</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">parameterMap</span> <span class="operator">=</span> request.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历parameterMap</span></span><br><span class="line">        parameterMap.forEach((k, v) -&gt; writer.print(k + <span class="string">" = "</span> + ((String[]) v)[<span class="number">0</span>] + <span class="string">"&lt;br&gt;"</span>));</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>本文中将使用 <code>application/x-www-form-urlencoded</code> 格式做示例。</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-3-handle-get-and-post/handling-parameter.png" alt="Handling parameter"></p>
<h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul>
<li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个 Servlet (1) - 介绍相关的接口和类</a></li>
<li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个 Servlet (2) - 第一个 servlet</a></li>
<li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个 Servlet (3) - 分别处理 GET 和 POST</a></li>
<li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个 Servlet (4) - 会话追踪</a></li>
<li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个 Servlet (5) - Filter</a></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>循序渐进写一个 Servlet (4) - 会话追踪</title>
    <url>/java-servlet-4-session-tracking.html</url>
    <content><![CDATA[<p>Servlet（Server Applet），全称 Java Servlet，是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。本系列将一步步地写出一个 Servlet 程序。</p>
<p>这篇博文将演示如何使用 <code>cookie</code> 和 <code>session</code> 进行会话追踪。</p>
<span id="more"></span>

<p>HTTP 协议是一个无状态的协议，也就是说，在服务器眼中，每一个 HTTP 请求都是一个全新的请求，每个请求之间没有关联。所以我们需要一个可以管理请求中携带的用户信息的方法。而会话追踪就是一个可以管理用户信息的方法。</p>
<p>会话追踪可以通过下列几个方式实现：</p>
<ol>
<li>Cookie</li>
<li> 表单隐藏域</li>
<li> URL 改写</li>
<li> HttpSession</li>
</ol>
<p>本文将主要演示 <code>Cookie</code> 和 <code>HttpSession</code> 的用法。</p>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h1><h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是 cookie</h2><p><code>Cookie</code> 是一串可以持久化于各个请求之间的信息片段。每个 cookie 都有一个名字，并有一个值，同时可以包含备注、路径、域名、过期时间、版本等附加信息。</p>
<p>Cookie 有两种：</p>
<ol>
<li>非持久 cookie，这种 cookie 只在会话中存留，并且不具有过期时间属性，一旦用户关闭浏览器 (或者标签页)，也就是使这个会话失效，这个 cookie 就会丢失。</li>
<li>持久化 cookie，这种 cookie 可以被用于多个会话中，而且只会在到达过期时间，或者用户主动使该 cookie 失效后，才会被删除。</li>
</ol>
<p>可以使用 <code>HttpServletResponse#addCookie(Cookie)</code> 方法在 HTTP 响应中携带 cookie。</p>
<h2 id="保存cookie"><a href="#保存cookie" class="headerlink" title="保存cookie"></a>保存 cookie</h2><p>首先修改前文中的 <code>doPost()</code> 方法，将请求中的参数取出来，并存入 cookie。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有参数，得到一个Map</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">parameterMap</span> <span class="operator">=</span> request.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历parameterMap</span></span><br><span class="line">        parameterMap.forEach((k, v) -&gt; {</span><br><span class="line">            <span class="comment">// 将参数以 key = value 形式输出</span></span><br><span class="line">            writer.print(k + <span class="string">" = "</span> + ((String[]) v)[<span class="number">0</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数的key作为cookie的name，参数的value作为cookie的value</span></span><br><span class="line">            response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]));</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后发送一个 <code>POST</code> 请求，在返回中可以看到请求中的参数已经被放到 cookie 中，并返回到了客户端。</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-4-session-tracking/post-request-with-cookie.png" alt="POST request with cookie"></p>
<h2 id="使用cookie"><a href="#使用cookie" class="headerlink" title="使用cookie"></a>使用 cookie</h2><p>一旦 cookie 被保存到了客户端，那么在下次访问这个 cookie 所对应的地址时，客户端就会自动将相关的 cookie 带入请求一并发送到服务端。所以客户端不需要对 cookie 主动做任何操作。</p>
<p>修改前文中的 <code>doGet()</code> 方法，使其可以取出 cookie 的值，并输出到页面上。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类简化null判断</span></span><br><span class="line">    Optional&lt;String&gt; optionalQueryString = Optional.ofNullable(request.getQueryString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出每个参数</span></span><br><span class="line">    String[] queryStrings = optionalQueryString.isPresent() ? optionalQueryString.get().split(<span class="string">"&amp;"</span>) : <span class="keyword">new</span> <span class="title class_">String</span>[]{};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Parameters: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (String query : queryStrings) {</span><br><span class="line">            <span class="comment">// 取出参数的key和value</span></span><br><span class="line">            String[] q = query.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            writer.print(q[<span class="number">0</span>] + <span class="string">" = "</span> + q[<span class="number">1</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Cookies:&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从request中取出cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历各个cookie</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) {</span><br><span class="line">            <span class="comment">// 输出其name和value</span></span><br><span class="line">            writer.print(cookie.getName() + <span class="string">" = "</span> + cookie.getValue());</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后发送一个 <code>GET</code> 请求，在返回中可以看到 cookie 中的内容已经被输出到页面上。</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-4-session-tracking/get-request-with-cookie.png" alt="GET request with cookie"></p>
<h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除 cookie</h2><p>将 cookie 的存活时间设为 0，并返回到客户端，即可从客户端中删除这个 cookie。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDelete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line">    Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) {</span><br><span class="line">        <span class="comment">// JSESSIONID存放的是当前session的ID</span></span><br><span class="line">        <span class="comment">// 如果删掉这个cookie，那么当前的session也会被丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"JSESSIONID"</span>.equalsIgnoreCase(cookie.getName())) {</span><br><span class="line">            <span class="comment">// 设定存活时间为0秒</span></span><br><span class="line">            cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将修改过的cookie放入响应中返回到客户端</span></span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter()) {</span><br><span class="line">        <span class="comment">// 因为response需要输出到客户端，才可以使新的cookie被送到客户端</span></span><br><span class="line">        <span class="comment">// 但是又懒得输出那么多东西了</span></span><br><span class="line">        <span class="comment">// 所以就输出了一个空字符串</span></span><br><span class="line">        <span class="comment">// 实际上输出内容不影响对cookie的操作</span></span><br><span class="line">        writer.print(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a><code>HttpSession</code></h1><h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是 session</h2><p>Session 记录着一次会话相关的信息。</p>
<p>当一个请求到达服务器后，服务器会检查请求中是否包含 session ID 信息，比如在 Tomcat 中就是检查有无 <code>JSESSIONID</code> 这个 cookie，或者 URL 中有无 <code>JSESSIONID</code> 这个查询字符串。如果找到了对应的 session，则服务器会将这个 session 检索出来使用；请求中没有包含 session ID，或者对应的 session 已经被销毁，则服务器会创建一个新的 session 并返回其 ID。</p>
<p>Session ID 通常以 cookie 的形式返回到客户端，如果客户端禁用了 cookie，那么服务端则会使用 URL 重写技术将 session ID 写到 URL 中。</p>
<p>Session 中可以键值对的形式保存附加数据，称为 attributes。</p>
<p>与 cookie 不同，session 保存于服务器端，而且它能保存的数据也不仅限于字符串。</p>
<h2 id="保存attribute"><a href="#保存attribute" class="headerlink" title="保存attribute"></a>保存 attribute</h2><p>修改 <code>doPost()</code> 方法，编写修改 session 的代码。修改完成后发送一个带有参数的 <code>POST</code> 请求，以向 session 中写入一些数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有参数，得到一个Map</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">parameterMap</span> <span class="operator">=</span> request.getParameterMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    <span class="comment">// 如果没有，则会新建一个session并返回其ID</span></span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doPost()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历parameterMap</span></span><br><span class="line">        parameterMap.forEach((k, v) -&gt; {</span><br><span class="line">            <span class="comment">// 将参数以 key = value 形式输出</span></span><br><span class="line">            writer.print(k + <span class="string">" = "</span> + ((String[]) v)[<span class="number">0</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数的key作为cookie的name，参数的value作为cookie的value</span></span><br><span class="line">            <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]);</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将各个参数放到session的attributes中</span></span><br><span class="line">            session.setAttribute(String.valueOf(k), ((String[]) v)[<span class="number">0</span>]);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="取出attribute"><a href="#取出attribute" class="headerlink" title="取出attribute"></a>取出 attribute</h2><p>修改 <code>doGet()</code> 方法，使其可以从 session 中取出 attributes 并显示在页面上。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 设定返回内容的MIME类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定内容以UTF-8编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Optional类简化null判断</span></span><br><span class="line">    Optional&lt;String&gt; optionalQueryString = Optional.ofNullable(request.getQueryString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出所有attribute的name</span></span><br><span class="line">    Enumeration&lt;String&gt; attributeNames = session.getAttributeNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出每个参数</span></span><br><span class="line">    String[] queryStrings = optionalQueryString.isPresent() ? optionalQueryString.get().split(<span class="string">"&amp;"</span>) : <span class="keyword">new</span> <span class="title class_">String</span>[]{};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) {</span><br><span class="line">        <span class="comment">// 开始输出HTML文本</span></span><br><span class="line">        writer.print(<span class="string">"&lt;html lang=\"en\"&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Response from DemoServlet&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Handled by &lt;code&gt;doGet()&lt;/code&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出当前session的ID</span></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Session ID: "</span> + request.getSession().getId() + <span class="string">"&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Parameters: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (String query : queryStrings) {</span><br><span class="line">            <span class="comment">// 取出参数的key和value</span></span><br><span class="line">            String[] q = query.split(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            writer.print(q[<span class="number">0</span>] + <span class="string">" = "</span> + q[<span class="number">1</span>] + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Cookies:&lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从request中取出cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历各个cookie</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) {</span><br><span class="line">            <span class="comment">// 输出其name和value</span></span><br><span class="line">            writer.print(cookie.getName() + <span class="string">" = "</span> + cookie.getValue());</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;b&gt;Attributes: &lt;/b&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历attribute的各个name</span></span><br><span class="line">        <span class="keyword">while</span>(attributeNames.hasMoreElements()) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> attributeNames.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出attribute的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> String.valueOf(session.getAttribute(key));</span><br><span class="line"></span><br><span class="line">            writer.print(key + <span class="string">" = "</span> + value);</span><br><span class="line">            writer.print(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.print(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后发送一个 <code>GET</code> 请求，在返回中就可以看到刚才保存在 session 中的数据：</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-4-session-tracking/get-request-with-session-attribute.png" alt="GET request with session attribute"></p>
<h2 id="删除attribute"><a href="#删除attribute" class="headerlink" title="删除attribute"></a>删除 attribute</h2><p>此外 <code>HttpSession</code> 类提供了 <code>removeAttribute()</code> 方法用于删除一个 attribute。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDelete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line">    Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前会话的session</span></span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line"></span><br><span class="line">    Enumeration&lt;String&gt; attributeNames = session.getAttributeNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) {</span><br><span class="line">        <span class="comment">// JSESSIONID存放的是当前session的ID</span></span><br><span class="line">        <span class="comment">// 如果删掉这个cookie，那么当前的session也会被丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"JSESSIONID"</span>.equalsIgnoreCase(cookie.getName())) {</span><br><span class="line">            <span class="comment">// 设定存活时间为0秒</span></span><br><span class="line">            cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将修改过的cookie放入响应中返回到客户端</span></span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历attribute names</span></span><br><span class="line">        <span class="keyword">while</span>(attributeNames.hasMoreElements()) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> attributeNames.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将其从session中移除</span></span><br><span class="line">            session.removeAttribute(key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter()) {</span><br><span class="line">        <span class="comment">// 因为response需要输出到客户端，才可以使新的cookie被送到客户端</span></span><br><span class="line">        <span class="comment">// 但是又懒得输出那么多东西了</span></span><br><span class="line">        <span class="comment">// 所以就输出了一个空字符串</span></span><br><span class="line">        <span class="comment">// 实际上输出内容不影响对cookie的操作</span></span><br><span class="line">        writer.print(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul>
<li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个 Servlet (1) - 介绍相关的接口和类</a></li>
<li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个 Servlet (2) - 第一个 servlet</a></li>
<li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个 Servlet (3) - 分别处理 GET 和 POST</a></li>
<li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个 Servlet (4) - 会话追踪</a></li>
<li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个 Servlet (5) - Filter</a></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>循序渐进写一个 Servlet (5) - Filter</title>
    <url>/java-servlet-5-filter.html</url>
    <content><![CDATA[<p>Servlet（Server Applet），全称 Java Servlet，是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。本系列将一步步地写出一个 Servlet 程序。</p>
<p>这篇博文将演示如何创建和使用 filter。</p>
<span id="more"></span>

<h1 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是 <code>Filter</code></h1><p>当客户端向 servlet 容器发送请求时，请求通常会直接发送到 servlet 进行处理，就像下图这样：</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-5-filter/request-flow-without-filter.png" alt="Request flow without Filter"></p>
<p>但是，如果希望在请求被 servlet 处理之前和之后，再进行一些附加的处理，就可以使用 <code>Filter</code> 完成。</p>
<p><img data-src="https://blog-static.boris1993.com/java-servlet-5-filter/request-flow-with-filter.png" alt="Request flow with Filter"></p>
<p>一个常见的使用场景是，在 filter 中定义如何检查请求是否合法，比如请求头中是否携带了有效的认证和鉴权信息；或者可以在 filter 中针对请求和响应记录日志。</p>
<h1 id="怎么使用Filter"><a href="#怎么使用Filter" class="headerlink" title="怎么使用Filter"></a>怎么使用 <code>Filter</code></h1><p><code>javax.servlet.Filter</code> 接口定义了一个 filter 的生命周期，要创建一个 filter，就要实现 <code>Filter</code> 接口。</p>
<p><code>Filter</code> 接口包含下列方法声明：</p>
<ol>
<li><code>init()</code>，用于定义在初始化这个 filter 时要执行的操作，该方法在 filter 的生命周期内只会执行一次；</li>
<li><code>doFilter()</code>，用于定义这个 filter 要进行的操作，每当有请求被发送到与该 filter 绑定的资源时，该方法都会被执行一次；</li>
<li><code>destroy()</code>，用于定义在停止这个 filter 时要执行的操作，只会在一个 filter 被销毁时执行。</li>
</ol>
<h2 id="创建一个实现Filter接口的类"><a href="#创建一个实现Filter接口的类" class="headerlink" title="创建一个实现Filter接口的类"></a>创建一个实现 <code>Filter</code> 接口的类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="定义这个filter的行为"><a href="#定义这个filter的行为" class="headerlink" title="定义这个filter的行为"></a>定义这个 filter 的行为</h2><p>在 <code>doFilter()</code> 方法内定义这个 filter 的行为。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在处理请求前打印信息</span></span><br><span class="line">    System.out.println(<span class="string">"Request passing through Filter 1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交由FilterChain将请求交给下一个filter或交给servlet处理</span></span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// servlet发送响应后打印信息</span></span><br><span class="line">    System.out.println(<span class="string">"Response passing througe Filter 1"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="在容器中注册filter"><a href="#在容器中注册filter" class="headerlink" title="在容器中注册filter"></a>在容器中注册 filter</h2><p>与 servlet 一样，filter 也需要在容器中注册之后才能发挥作用。注册 filter 也有两种方式：通过 <code>web.xml</code>，或者通过 <code>@WebFilter</code> 注解。</p>
<p>这里有一点需要注意，虽然 filter 之间没有依赖关系，但是如果要保证 filter 的执行顺序，那么必须使用 <code>web.xml</code> 来注册。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5vcmFjbGUuY29tL290bmRvY3MvamNwL3NlcnZsZXQtMy4wLWZyLWV2YWwtb3RoLUpTcGVjLw==">Servlet 3.0 规范<i class="fa fa-external-link-alt"></i></span>的 <code>8.2.3</code> 节中有如下说明：</p>
<blockquote>
<p>If the order in which the listeners, servlets, filters are invoked is important to an application then a deployment descriptor must be used.</p>
</blockquote>
<p>因为使用注解注册的 filter，其调用顺序没有在规范中指定。</p>
<blockquote>
<p>As described above, when using annotations to define the listeners, servlets and filters, the order in which they are invoked is unspecified.</p>
</blockquote>
<p>如果一定要使用注解并保证 filter 的执行顺序，那么可以参考<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY1NjE4MTYvMzgzMzg1OA=="> Stack Overflow 中这篇回答<i class="fa fa-external-link-alt"></i></span>。</p>
<p>为了演示 filter 的执行顺序，这里再增加一个名为 <code>Filter2</code> 的 filter，内容与 <code>Filter1</code> 类似。</p>
<h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><code>web.xml</code></h3><p>在 <code>web.xml</code> 中增加如下配置：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.boris.tomcatlistener.filter.Filter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demoServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.boris.tomcatlistener.filter.Filter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demoServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>filter</code> 标签描述了一个 filter 的基本信息，其中 filter 名称 (<code>filter-name</code>) 和 filter 所在类 (<code>filter-class</code>) 为必填项。</p>
<p><code>filter-mapping</code> 标签描述了一个 filter 将与哪个 URL 或者与哪个 servlet 绑定，<code>filter-name</code> 指定使用哪个 filter 处理请求，<code>url-pattern</code> 指定发往哪个 URL 的请求会触发这个 filter，<code>servlet-name</code> 指定发往哪个 servlet 的请求会触发这个 filter。<code>url-pattern</code> 和 <code>servlet-name</code> 可以同时存在，也可以同时存在多个。</p>
<p><code>filter-mapping</code> 标签的先后顺序，将决定 filter 链中各个 filter 被调用的先后顺序。如上文中先配置了 <code>filter1</code> 后配置了 <code>filter2</code>，那么在请求到达时，会先执行 <code>filter1</code> 然后再执行 <code>filter2</code>。</p>
<p>配置完毕后部署并运行该项目，向 <code>http://localhost:8080/servletdemo/DemoServlet</code> 发送一个请求，在控制台可以看到如下输出：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Request passing through Filter 1</span><br><span class="line">Request passing through Filter 2</span><br><span class="line">Response passing througe Filter 2</span><br><span class="line">Response passing througe Filter 1</span><br></pre></td></tr></tbody></table></figure>

<h3 id="WebFilter注解"><a href="#WebFilter注解" class="headerlink" title="@WebFilter注解"></a><code>@WebFilter</code> 注解</h3><p><code>@WebFilter</code> 是 <code>Servlet 3.0</code> 中新增的特性，在 <code>Tomcat 7</code> 及以前版本中将无法工作。</p>
<p>以 <code>Filter1</code> 为例，为其添加如下注解：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(</span></span><br><span class="line"><span class="meta">    filterName = "filter1",</span></span><br><span class="line"><span class="meta">    urlPatterns = "/demoServlet"</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>filter-name</code> 属性指定了这个 filter 的名称。</p>
<p>有三个属性可以指定 filter 的触发条件：</p>
<ol>
<li><code>value</code></li>
<li><code>urlPatterns</code></li>
<li><code>servletNames</code></li>
</ol>
<p>以上三个属性都可以接受一个字符串，或者用大括号包括起来的多个字符串。</p>
<p>在注解只有一个参数，并且该参数是指定要匹配的 URL 时，建议使用 <code>value</code> 属性，比如这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// value为默认的属性</span></span><br><span class="line"><span class="meta">@WebFilter("/demoServlet")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式指定value属性</span></span><br><span class="line"><span class="meta">@WebFilter(value = "/demoServlet")</span></span><br></pre></td></tr></tbody></table></figure>

<p>否则，建议使用 <code>urlPatterns</code> 属性和 <code>servletNames</code> 属性。不允许 <code>value</code> 和 <code>urlPatterns</code> 同时出现。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5vcmFjbGUuY29tL290bmRvY3MvamNwL3NlcnZsZXQtMy4wLWZyLWV2YWwtb3RoLUpTcGVjLw==">Servlet 3.0 规范<i class="fa fa-external-link-alt"></i></span>的 <code>8.1.2 @WebFilter</code> 节中说明原文如下：</p>
<blockquote>
<p>It is recommended to use value when the only attribute on the annotation is the url pattern and to use the urlPatterns attribute when the other attributes are also used. It is illegal to have both value and urlPatterns attribute used together on the same annotation.</p>
</blockquote>
<p>配置完毕后部署并运行该项目，向 <code>http://localhost:8080/servletdemo/DemoServlet</code> 发送一个请求，在控制台可以看到如下输出：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Request passing through Filter 1</span><br><span class="line">Response passing througe Filter 1</span><br></pre></td></tr></tbody></table></figure>

<h1 id="系列博文"><a href="#系列博文" class="headerlink" title="系列博文"></a>系列博文</h1><ul>
<li><a href="/projects/java/Servlet/java-servlet-1-introducing-classes-and-interfaces.html">循序渐进写一个 Servlet (1) - 介绍相关的接口和类</a></li>
<li><a href="/projects/java/Servlet/java-servlet-2-first-servlet.html">循序渐进写一个 Servlet (2) - 第一个 servlet</a></li>
<li><a href="/projects/java/Servlet/java-servlet-3-handle-get-and-post.html">循序渐进写一个 Servlet (3) - 分别处理 GET 和 POST</a></li>
<li><a href="/projects/java/Servlet/java-servlet-4-session-tracking.html">循序渐进写一个 Servlet (4) - 会话追踪</a></li>
<li><a href="/projects/java/Servlet/java-servlet-5-filter.html">循序渐进写一个 Servlet (5) - Filter</a></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 自动配置的原理</title>
    <url>/java-spring-autoconfiguration.html</url>
    <content><![CDATA[<p>在使用 Spring Boot 时，最使我们收益的一个功能就是它的自动配置。但是，用了这么久的自动配置功能，有没有想过它是怎么实现的？本文将从源码入手，一步一步搞明白 Spring Boot 自动配置的原理。</p>
<span id="more"></span>

<p>我这里就用一个简单的 Eureka server 的项目来举例。实际上只要是个 Spring Boot 项目就可以，我只是懒得再创建一个新的项目了。</p>
<p>它的启动代码我们都很熟悉，是这样子的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SpringApplication.run(EurekaServer.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>东西很简单，一共就这么几行。我们看看 <code>@SpringBootApplication</code> 里面有什么？</p>
<h2 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication 注解</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {</span><br><span class="line">    <span class="comment">// 因为里面的属性与本文关系不大，所以就略掉了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里我们可以看到一个 <code>@EnableAutoConfiguration</code> 注解，顾名思义，这个注解是用来开启自动配置的。我们继续深入进去看看。</p>
<h2 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="@EnableAutoConfiguration注解"></a>@EnableAutoConfiguration 注解</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration {</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">     * applied.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> {};</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个注解上面还有一大段的 JavaDoc，因为篇幅太长，就不把全文放上来了。翻译过来的大意是这样的：</p>
<blockquote>
<p>这个注解可以启用 Spring 应用上下文的自动配置。开启这个配置后，Spring 将会尝试猜测你需要的类，并进行配置。Spring 通常会根据 ClassPath 和用户定义的 bean 来完成自动配置的操作。<br>举例来说，如果在你的 ClassPath 中出现了 tomcat-embedded.jar，那么你很可能会需要 TomcatServletWebServerFactory 这个类，除非你自己定义了 ServletWebServerFactory。</p>
</blockquote>
<p>看完 JavaDoc，我们大概知道了 Spring 是怎么判断哪些类需要自动配置。那么我们继续深入源码。</p>
<p>这里有两个注解比较重要：<code>@Import(AutoConfigurationImportSelector.class)</code> 和 <code>@AutoConfigurationPackage</code>。</p>
<h2 id="AutoConfigurationImportSelector类"><a href="#AutoConfigurationImportSelector类" class="headerlink" title="AutoConfigurationImportSelector类"></a>AutoConfigurationImportSelector 类</h2><p>Spring Boot 应用启动过程中使用 <code>ConfigurationClassParser</code> 分析配置类时，如果发现注解中存在 <code>@Import(ImportSelector)</code> 的情况，就会创建一个相应的 <code>ImportSelector</code> 对象， 并调用其方法 <code>public String[] selectImports(AnnotationMetadata annotationMetadata)</code>。所以我们就从 <code>selectImports</code> 方法开始看起。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从META-INF/spring-autoconfigure-metadata.properties中加载AutoConfigurationMetaData</span></span><br><span class="line">    <span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取自动配置项</span></span><br><span class="line">    <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面方法通过 <code>getAutoConfigurationEntry</code> 获取到了需要自动配置的项，那么它是怎么知道哪些东西需要自动配置的呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the {<span class="doctag">@link</span> AutoConfigurationEntry} based on the {<span class="doctag">@link</span> AnnotationMetadata}</span></span><br><span class="line"><span class="comment"> * of the importing {<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>} class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoConfigurationMetadata the auto-configuration metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到注解里面的属性</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到需要自动配置的类，并去重</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得要排除在自动配置之外的类的列表，并将其排除</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用过滤器AutoConfigurationImportFilter</span></span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播自动配置事件</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面我们看到，Spring Boot 通过 <code>getCandidateConfigurations</code> 方法找到了需要自动配置的类，那么它又是怎么工作的呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the auto-configuration class names that should be considered. By default</span></span><br><span class="line"><span class="comment"> * this method will load candidates using {<span class="doctag">@link</span> SpringFactoriesLoader} with</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> #getSpringFactoriesLoaderFactoryClass()}.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the source metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes the {<span class="doctag">@link</span> #getAttributes(AnnotationMetadata) annotation</span></span><br><span class="line"><span class="comment"> * attributes}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list of candidate configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> {</span><br><span class="line">    <span class="comment">// 扫描ClassPath中所有的META-INF/spring.factories，并从中获取所有自动配置的类名</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">            + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the class used by {<span class="doctag">@link</span> SpringFactoriesLoader} to load configuration</span></span><br><span class="line"><span class="comment"> * candidates.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the factory class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() {</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> ClassLoader <span class="title function_">getBeanClassLoader</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.beanClassLoader;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面 <code>getCandidateConfigurations</code> 方法又调用了 <code>loadFactoryNames</code> 方法来获取 <code>EnableAutoConfiguration</code> 注解相关的工厂类。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The location to look for factories.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from {<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION}, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@code</span> null} to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> factoryClass.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上文我们知道，factoryClass传入的是EnableAutoConfiguration.class</span></span><br><span class="line">    <span class="comment">// 所以这里就是从spring.factories中寻找org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的自动配置类</span></span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从ClassPath中寻找所有spring.factories文件，并将其包装成一个Properties对象</span></span><br><span class="line"><span class="comment"> * 然后把Properties对象里面的各个条目包装到一个Map&lt;String, List&lt;String&gt;&gt;对象中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> {</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) {</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">            <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {</span><br><span class="line">                <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>这里我们用 <code>RedisAutoConfiguration</code> 类来说明一个具体的自动配置类是如何工作的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> EnableAutoConfiguration Auto-configuration} for Spring Data's Redis support.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andy Wilkinson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christian Dupuis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christoph Strobl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eddú Meléndez</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stephane Nicoll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Marco Aust</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Paluch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 说明这是一个配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span> <span class="comment">// 当RedisOperations类存在时这个配置类才会生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span> <span class="comment">// 将配置文件的字段与RedisProperties类绑定</span></span><br><span class="line"><span class="meta">@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })</span> <span class="comment">// 导入两个Redis连接池的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> {</span><br><span class="line">    <span class="comment">// 这里是初始化redisTemplate和stringRedisTemplate的代码，因为与本文无关，所以略掉了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>根据上文我们了解到的内容，我们可以推测出它是这样子被初始化的：</p>
<ul>
<li>首先 Spring 在 <code>spring.factories</code> 中，根据 <code>EnableAutoConfiguration</code> 发现了 <code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code></li>
<li>然后 Spring 会检查 <code>RedisOperations</code> 类是否存在于 ClassPath 中</li>
<li>如果存在，则会从配置文件的 <code>spring.redis</code> 字段中取值，并初始化 <code>RedisProperties</code></li>
<li>然后根据 <code>LettuceConnectionConfiguration</code> 和 <code>JedisConnectionConfiguration</code> 中的条件，选择使用哪个连接池，并将其初始化</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上文的分析，我们知道了 Spring 在启动时，会加载一系列的配置类，并会根据配置类中指定的条件，来决定是否对其实施自动配置。</p>
<p><code>xxAutoConfigurartion</code> 这样的类是自动配置类，用于向容器中添加组件。</p>
<p><code>xxProperties</code> 这样的类是属性类，用于封装配置文件中的属性，并规定了 Spring 应该从配置文件的哪个字段取值用于初始化。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring bean 的作用域</title>
    <url>/java-spring-bean-scopes.html</url>
    <content><![CDATA[<p>在 Spring 中，那些由 IoC 容器所管理的对象被称之为 bean。而一个 bean 的定义，其实只是一个 “蓝图”，指导着 Spring 如何去创建这样一个 bean。而在这个蓝图中，有一个属性叫做 “作用域”，它规定了这个 bean 的可见范围。这里我们看一下 Spring 的 bean 都有哪些作用域。</p>
<span id="more"></span>

<h2 id="支持的作用域"><a href="#支持的作用域" class="headerlink" title="支持的作用域"></a>支持的作用域</h2><p>我们先来看一下 Spring 支持哪些作用域。</p>
<table>
<thead>
<tr>
<th align="right">作用域</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="right"> singleton</td>
<td> 在 Spring 容器中仅存在一个 bean 的实例，bean 以单例形式存在。这是默认的作用域</td>
</tr>
<tr>
<td align="right"> prototype</td>
<td> 每次从容器中获取 bean 时，都将生成一个新的实例，即相当于每次都执行 <code>new xxxBean()</code></td>
</tr>
<tr>
<td align="right">request</td>
<td> 在 HTTP 请求 (request) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicatonContext</code> 环境</td>
</tr>
<tr>
<td align="right"> session</td>
<td> 在 HTTP 会话 (session) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td>
</tr>
<tr>
<td align="right"> globalSession</td>
<td> 在全局的 HTTP 会话 (session) 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境，且通常只能用在 <code>Portlet</code> 环境中。</td>
</tr>
<tr>
<td align="right">application</td>
<td> 在 <code>ServletContext</code> 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td>
</tr>
<tr>
<td align="right"> websocket</td>
<td> 在 <code>WebSocket</code> 的完整生命周期中，将创建并使用单个实例。该作用域仅适用于 <code>WebApplicationContext</code> 环境</td>
</tr>
</tbody></table>
<h2 id="指定bean的作用域"><a href="#指定bean的作用域" class="headerlink" title="指定bean的作用域"></a>指定 bean 的作用域</h2><p>要指定一个 bean 的作用域，我们可以通过 XML 的方式或注解的方式来设定。</p>
<p>使用 XML 指定配置 bean 时，可以通过 <code>scope</code> 属性来指定作用域：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"someBean"</span> <span class="attr">class</span>=<span class="string">"com.demo.SomeClass"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用注解方式配置 bean 时，可以通过 <code>@Scope</code> 注解来指定作用域：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeClass</span> {</span><br><span class="line">    <span class="comment">// Class definitions goes here</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此外，如果使用注解方式配置作用域，Spring 也提供了一系列常量值来方便我们配置：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在ConfigurableBeanFactory类中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> <span class="string">"singleton"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> <span class="string">"prototype"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在WebApplicationContext类中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SCOPE_REQUEST</span> <span class="operator">=</span> <span class="string">"request"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">SCOPE_SESSION</span> <span class="operator">=</span> <span class="string">"session"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">SCOPE_APPLICATION</span> <span class="operator">=</span> <span class="string">"application"</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="singleton作用域"><a href="#singleton作用域" class="headerlink" title="singleton作用域"></a>singleton 作用域</h2><p><code>singleton</code> 是 Spring 容器中的默认作用域。这个作用域下，容器中只创建各管理一个 bean 实例，实例存在于缓存中，并在后续对该 bean 的请求中都返回这个实例。</p>
<h2 id="prototype作用域"><a href="#prototype作用域" class="headerlink" title="prototype作用域"></a>prototype 作用域</h2><p>与 <code>singleton</code> 正相反，每次对 <code>prototype</code> 作用域的 bean 的请求，Spring 都会生成一个新的实例，即类似我们手动使用 <code>new XxxBean()</code> 方式创建实例。</p>
<p>需要注意的是，Spring 不会完整的管理一个 <code>prototype</code> 的 bean 的生命周期。容器在初始化、配置，并将 bean 交由请求方 (client) 之后，就撒手不管了。也就是说，在销毁一个 <code>prototype</code> 的 bean 时，销毁 bean 的回调方法是不会被调用的，所以在销毁一个 <code>prototype</code> 的 bean 时，开发者必须手动释放它所使用的资源，或者可以尝试使用一个自定义的 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension-bpp"><code>bean post-processor</code></a>来让 Spring 做这些事。</p>
<p>对于有状态的 bean，应当使用 <code>prototype</code> 作用域；对于无状态的 bean，则应当使用 <code>singleton</code> 作用域。</p>
<h2 id="向singleton-bean注入prototype-bean"><a href="#向singleton-bean注入prototype-bean" class="headerlink" title="向singleton bean注入prototype bean"></a>向 singleton bean 注入 prototype bean</h2><p>因为 bean 的依赖关系在实例化 bean 时才会被解析，所以通常来说，我们不可以将一个 prototype bean 注入到一个 singleton bean 中。</p>
<p>如果我们向一个 singleton bean 中注入一个 prototype bean，因为这个 singleton bean 只会被实例化一次，使得它的依赖也只会被注入一次，最终导致它依赖的那个 singleton bean 也只存在一个实例。</p>
<h2 id="request、session、global-session、application和websocket作用域"><a href="#request、session、global-session、application和websocket作用域" class="headerlink" title="request、session、global session、application和websocket作用域"></a>request、session、global session、application 和 websocket 作用域</h2><p>这几种作用域只能用在 <code>web-aware</code> 的 Spring 上下文中，比如 <code>XmlWebApplicationContext</code>。如果用在一般的 IoC 容器中，比如 <code>ClassPathXmlApplicationContext</code> 中，那么容器会抛出一个 <code>IllegalStateException</code>。</p>
<p>要使用这几个作用域，你可能需要对你的应用进行一些配置。因为这些内容与本文无关，所以在这里就不详细说明了。感兴趣的话可以看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy9jdXJyZW50L3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL2NvcmUuaHRtbCNiZWFucy1mYWN0b3J5LXNjb3Blcy1vdGhlci13ZWItY29uZmlndXJhdGlvbg=="> Spring 参考手册中的内容<i class="fa fa-external-link-alt"></i></span>。</p>
<p>注：<code>web-aware</code> 这个词，我也不知道怎么翻译才合适。查阅了一些资料之后，感觉一个 <code>web-aware</code> 的 Spring 应用就是一个运行在 web 容器 (比如 Tomcat) 中的应用，因为上面提到的这些作用域也是与 web 应用相关的。如果有好的理解，请一定在留言区写下来让在下知道。</p>
<h3 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request 作用域</h3><p><code>request</code> 作用域下的 bean，在每次 HTTP 请求中，都会创建一个新的实例。当请求完成时，对应的 bean 就会被销毁。对一个实例的任何更改，对其他的所有实例来说都是不可见的。</p>
<h3 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session 作用域</h3><p><code>session</code> 作用域下的 bean，在每个活动的 HTTP 会话中，都有一个独自的实例，而当会话结束后，对应的 bean 就会被销毁。对一个实例的任何更改，对其他所有的实例来说都是不可见的。</p>
<h3 id="globalSession作用域"><a href="#globalSession作用域" class="headerlink" title="globalSession作用域"></a>globalSession 作用域</h3><p>这个作用域只能用在 <code>portlet</code> 应用中。一个 <code>portlet</code> 站点中可能有多个 <code>portlet</code> 应用，而它们相关的 session 中都会共享同一个 <code>globalSession</code> 作用域的 bean。</p>
<p>注：其实我也不知道 <code>portlet</code> 到底是个啥，就算看过维基百科的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmF2YV9Qb3J0bGV0X1NwZWNpZmljYXRpb24="> Portlet 条目<i class="fa fa-external-link-alt"></i></span>也没看明白。</p>
<h3 id="application作用域"><a href="#application作用域" class="headerlink" title="application作用域"></a>application 作用域</h3><p>在整个应用范围内，容器为每个 web 应用程序运行时创建一个实例。这个作用域与 <code>singleton</code> 很类似，但是还是有两个不同点：</p>
<ul>
<li>在不同 <code>ServletContext</code> 中有不同的 bean 单例对象；singleton 作用域的 bean 是每个 <code>ApplicationContext</code> 的单例对象。而一个应用可能有多个 <code>ApplicationContext</code></li>
<li>bean 作为 <code>ServletContext</code> 属性可见</li>
</ul>
<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy9jdXJyZW50L3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL2NvcmUuaHRtbCNiZWFucy1mYWN0b3J5LXNjb3Blcw==">Bean Scopes - The IoC container<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGFkMTQ1NWYyNjVkYTViNjAwNmZhNmE=">Spring 系列四：Bean Scopes 作用域<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljYXJ1c193YW5nL2FydGljbGUvZGV0YWlscy81MTU4Njc3Ng==">Spring 学习（十五）Spring Bean 的 5 种作用域介绍<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的线程安全，以及死锁</title>
    <url>/java-thread-security-deadlock.html</url>
    <content><![CDATA[<p>刚才面试的时候被问到了关于线程安全和死锁的问题，有点露怯，故赶紧查漏补缺，记录于此。</p>
<span id="more"></span>

<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote>
<p>线程安全是程序设计中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的公用变量，使程序功能正确完成。</p>
</blockquote>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><ul>
<li>乐观锁：认为在使用数据时，不会有别的线程修改数据，所以不会加锁，只在更新时判断之前有没有被别的线程更新了数据。比如在数据库中设置一个 <code>version</code> 字段，在更新前先查询该字段的值，然后在写入时比较数据库中的值是否与之前查询到的值相同。</li>
<li>悲观锁：认为自己在使用数据的时候，一定有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被线程修改。</li>
</ul>
<h2 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h2><ul>
<li><code>syncronized</code> 关键字，举例：<code>ConcurrentHashMap</code>。是悲观锁。<ul>
<li>锁升级机制：<blockquote>
<p>它是指在锁对象的对象头里面有一个 <code>threadid</code> 字段，在第一次访问的时候 <code>threadid</code> 为空，JVM 让其持有偏向锁，并将 <code>threadid</code> 设置为其线程 ID，再次进入的时候会先判断 <code>threadid</code> 是否与其线程 ID 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 <code>synchronized</code> 锁的升级。</p>
</blockquote>
<ul>
<li>偏向锁（无锁）：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后（线程的 id 会记录在对象的 <code>Mark Word</code> 中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</li>
<li>轻量级锁（CAS）：就是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；轻量级锁的意图是在没有多线程竞争的情况下，通过 CAS 操作尝试将 <code>Mark Word</code> 更新为指向 <code>LockRecord</code> 的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。</li>
<li>重量级锁：虚拟机使用 CAS 操作尝试将 <code>MarkWord</code> 更新为指向 <code>LockRecord</code> 的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查 <code>MarkWord</code> 是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁。</li>
</ul>
</li>
</ul>
</li>
<li><code>Lock</code> 接口的实现类，常用 <code>ReentrantLock</code>。是悲观锁。<code>lock()</code> 加锁，<code>unlock()</code> 解锁，不解锁会造成死锁。<ul>
<li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<code>synchronized</code> 中的锁是非公平的，<code>ReentrantLock</code> 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li>
<li>锁绑定多个条件：一个 <code>ReentrantLock</code> 对象可以同时绑定多个 <code>Condition</code> 对象，而在 <code>synchronized</code> 中，锁对象的 <code>wait()</code> 和 <code>notify()</code> 或 <code>notifyAll()</code> 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 <code>ReentrantLock</code> 则无须这样做，只需要多次调用 <code>newCondition()</code> 方法即可。</li>
</ul>
</li>
<li><code>ThreadLocal</code>。当多个线程操作同一个变量且互不干扰的场景下，可以使用 <code>ThreadLocal</code> 来解决。它会在每个线程中对该变量创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。<ul>
<li><code>ThreadLocal</code> 线程容器保存变量时，底层其实是通过 <code>ThreadLocalMap</code> 来实现的。它是以当前 <code>ThreadLocal</code> 变量为 key，要存的变量为 value。获取的时候就是以当前 <code>ThreadLocal</code> 变量去找到对应的 key，然后获取到对应的值。</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p>两个或两个以上的线程持有不同系统资源的锁，线程彼此都等待获取对方的锁来完成自己的任务，但是没有让出自己持有的锁，线程就会无休止等待下去。线程竞争的资源可以是：锁、网络连接、通知事件，磁盘、带宽，以及一切可以被称作 “资源” 的东西。</p>
</blockquote>
<h2 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h2><p>可以使用 <code>jstack</code> 检查死锁。</p>
<p>命令：<code>jstack $(jps -l | grep 'DeadLockExample' | cut -f1 -d ' ')</code>。</p>
<p>示例输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"Thread-1":</span><br><span class="line">    at DeadLockExample$2.run(DeadLockExample.java:58)</span><br><span class="line">    - waiting to lock &lt;0x000000076ab660a0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076ab660b0&gt; (a java.lang.Object)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"Thread-0":</span><br><span class="line">    at DeadLockExample$1.run(DeadLockExample.java:28)</span><br><span class="line">    - waiting to lock &lt;0x000000076ab660b0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076ab660a0&gt; (a java.lang.Object)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ul>
<li>以确定的顺序获锁</li>
<li>超时放弃</li>
<li>死锁检测</li>
<li>尽量降低锁的使用粒度</li>
<li>尽量使用同步代码块，而不是同步方法</li>
<li>避免嵌套锁</li>
<li>专锁专用</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAzODMyMDY3MA==">4 种解决线程安全问题的方式<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aWhlbmdjYXQuZ2l0aHViLmlvLzIwMTkvMDgvMDkvamF2YS10dXRvcmlhbC1mb3ItbGFuZ3VhZ2UtYWRhdmFuY2VkLWRlYWRsb2NrLWV4YW1wbGUtYW5kLXNvbHV0aW9uLw==">Java 高级教程系列 - 死锁示例及解决<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjI5NjY5L2FydGljbGUvZGV0YWlscy8xMDg1NTIzMzE=">Java 多线程开发中避免死锁的八种方法<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>线程安全</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>看懂 ParallelGC 的日志</title>
    <url>/java-understand-parallel-gc-logs.html</url>
    <content><![CDATA[<p>在排查垃圾回收相关的问题时，一个必不可少的技能就是要能看懂 Java 的垃圾回收日志。本文将介绍打印 GC 日志相关的 JVM 参数，以及使用不同参数时 JVM 将会打印出的日志内容。</p>
<span id="more"></span>

<h2 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK 版本</h2><figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">openjdk version "1.8.0_232"</span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_232-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.232-b09, mixed mode)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>在演示过程中，我们将通过在死循环中构造大对象的方式来触发垃圾回收</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        String[] strings;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            strings = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1024</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同时，为了让垃圾回收更早的开始，我们还需要指定一个较小的堆内存，比如我选择只分配 10MB 的空间。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">-Xmx10m</span><br><span class="line">-Xms10m</span><br></pre></td></tr></tbody></table></figure>

<h2 id="GC日志相关的JVM参数"><a href="#GC日志相关的JVM参数" class="headerlink" title="GC日志相关的JVM参数"></a>GC 日志相关的 JVM 参数</h2><p>与 GC 日志相关的 JVM 参数有如下 8 个：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td> -XX:+PrintGC</td>
<td> 输出简要 GC 日志</td>
</tr>
<tr>
<td> -verbose:gc</td>
<td> 等同于 -XX:+PrintGC</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td> 输出详细 GC 日志</td>
</tr>
<tr>
<td> -Xloggc:gc.log</td>
<td> 输出 GC 日志到文件 gc.log</td>
</tr>
<tr>
<td>-XX:+PrintGCTimeStamps</td>
<td> 输出 GC 的时间戳（以 JVM 启动到当期的总时长的时间戳形式）</td>
</tr>
<tr>
<td>-XX:+PrintGCDateStamps</td>
<td> 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td> 在进行 GC 的前后打印出堆的信息</td>
</tr>
<tr>
<td> -XX:+PrintReferenceGC</td>
<td> 打印年轻代各个引用的数量以及时长</td>
</tr>
</tbody></table>
<h3 id="XX-PrintGC与-verbose-gc"><a href="#XX-PrintGC与-verbose-gc" class="headerlink" title="-XX:+PrintGC与-verbose:gc"></a><code>-XX:+PrintGC</code> 与 <code>-verbose:gc</code></h3><p>虽然上面说这两个参数是等价的，但是，<code>-verbose:gc</code> 是一个标准的参数，而 <code>-XX:+PrintGC</code> 则在 JDK 9 之后被标为废弃的 (deprecated)，所以建议使用 <code>-verbose:gc</code> 代替 <code>-XX:+PrintGC</code>。</p>
<h2 id="打开-verbose-gc"><a href="#打开-verbose-gc" class="headerlink" title="打开-verbose:gc"></a>打开 <code>-verbose:gc</code></h2><p>使用这个参数将会打开简略的 GC 日志。打开这个参数并运行程序，很快就可以看到这样的 GC 日志：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  2520K-&gt;472K(9728K), 0.0005722 secs]</span><br></pre></td></tr></tbody></table></figure>

<p>我们将上面的日志拆分开来：</p>
<ul>
<li><code>GC</code> 代表这次垃圾回收的类型。<code>GC</code> 代表发生了 <code>Minor GC</code>，<code>Full GC</code> 代表发生了 <code>Full GC</code></li>
<li><code>Allocation Failure</code> 简述了发生 GC 的原因。在这个例子中，是因为在年轻代中没有合适的空间导致新的对象分配失败，从而发生 GC</li>
<li><code>2520K-&gt;472K</code> 说明了年轻代的占用量变化。在这个例子中，年轻代的使用量从 2520KB 减少到了 472KB</li>
<li><code>9728K</code> 表示整个堆的大小</li>
<li><code>0.0005722 secs</code> 表示了本次 GC 消耗的时间</li>
</ul>
<h2 id="打开-XX-PrintGCDetails"><a href="#打开-XX-PrintGCDetails" class="headerlink" title="打开-XX:+PrintGCDetails"></a>打开 <code>-XX:+PrintGCDetails</code></h2><p>使用这个参数后，将会打印详细的 GC 日志，它打印的内容包含了 <code>-verbose:gc</code> 参数打印的内容。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 2500K-&gt;452K(9728K), 0.0003785 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure>

<p>这个参数打印的日志与上一个参数打印的日志有一部分重合，这里我们关注新增的内容：</p>
<ul>
<li><code>[PSYoungGen: 2048K-&gt;0K(2560K)]</code> 表明了使用的垃圾回收器、年轻代的占用量变化，和年轻代的大小</li>
<li><code>2500K-&gt;452K(9728K)</code> 表明了整个堆的占用量变化，和整个堆的大小</li>
<li><code>[Times: user=0.00 sys=0.00, real=0.00 secs]</code> 表示本次 GC 消耗的时间<ul>
<li><code>user</code> 代表垃圾回收器消耗的 CPU 时间</li>
<li><code>sys</code> 代表系统调用或等待系统事件消耗的时间</li>
<li><code>real</code> 代表应用实际停止的时间，近似于 <code>(user + sys) / 垃圾回收器使用的线程数</code></li>
</ul>
</li>
</ul>
<h2 id="打开-XX-PrintGCTimeStamps"><a href="#打开-XX-PrintGCTimeStamps" class="headerlink" title="打开-XX:+PrintGCTimeStamps"></a>打开 <code>-XX:+PrintGCTimeStamps</code></h2><p>这个参数不影响日志的详细程度，在打开之后，日志中会出现从 JVM 启动到出现日志时的毫秒数，比如下面例子的 <code>1.523</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.523: [GC (Allocation Failure) [PSYoungGen: 2141K-&gt;96K(2560K)] 4805K-&gt;2776K(9728K), 0.0004359 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="打开-XX-PrintGCDateStamps"><a href="#打开-XX-PrintGCDateStamps" class="headerlink" title="打开-XX:+PrintGCDateStamps"></a>打开 <code>-XX:+PrintGCDateStamps</code></h2><p>这个参数也不影响日志的详细程度，在打开之后，日志头部会加上打印日志的时间和时区，比如下面例子的 <code>2020-02-06T10:13:08.634-0800</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2020-02-06T10:13:08.634-0800: 1.122: [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 3328K-&gt;1280K(9728K), 0.0004243 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="打开-XX-PrintHeapAtGC"><a href="#打开-XX-PrintHeapAtGC" class="headerlink" title="打开-XX:+PrintHeapAtGC"></a>打开 <code>-XX:+PrintHeapAtGC</code></h2><p>使用这个参数后，在打印 GC 日志时，会同时打印出堆在 GC 前后的信息，即根据不同的内存区域，分别显示在垃圾回收前后的空间使用情况。同时，日志中还以 <code>[bottom,top,end)</code> 的格式展现出了各个内存区域的地址，其中 <code>bottom</code> 为这个区域的起始位置，<code>top</code> 为这个区域当前的顶部位置，<code>end</code> 为这个区域可使用的地址上限 [^1]。</p>
<p>此外，日志中关于 <code>Metaspace</code> 相关的信息可以参考注脚 4 [^4] 指向的那篇回答。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{Heap before GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 2560K, used 2047K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 99% used [0x00000007bfd00000,0x00000007bfeffe78,0x00000007bff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 0K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf600000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 3045K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 320K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">2020-02-06T10:21:05.317-0800: 0.219: [GC (Allocation Failure) [PSYoungGen: 2047K-&gt;496K(2560K)] 2047K-&gt;512K(9728K), 0.0019061 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span><br><span class="line">Heap after GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 2560K, used 496K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 2048K, 0% used [0x00000007bfd00000,0x00000007bfd00000,0x00000007bff00000)</span><br><span class="line">  from space 512K, 96% used [0x00000007bff00000,0x00000007bff7c010,0x00000007bff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span><br><span class="line"> ParOldGen       total 7168K, used 16K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000007bf600000,0x00000007bf604000,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 3045K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 320K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="打开-XX-PrintReferenceGC"><a href="#打开-XX-PrintReferenceGC" class="headerlink" title="打开-XX:+PrintReferenceGC"></a>打开 <code>-XX:+PrintReferenceGC</code></h2><p>打开这个参数后，就可以看到各种引用的数量，以及对其垃圾回收所消耗的时长。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [SoftReference, 0 refs, 0.0000125 secs][WeakReference, 0 refs, 0.0000054 secs][FinalReference, 0 refs, 0.0000045 secs][PhantomReference, 0 refs, 0 refs, 0.0000222 secs][JNI Weak Reference, 0.0000037 secs][PSYoungGen: 2112K-&gt;64K(2560K)] 3488K-&gt;1456K(9728K), 0.0005389 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></tbody></table></figure>

<p>[^1]: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjgzNDQ0NTEvbWVhbmluZy1vZi1oZWFwLW1lbW9yeS1hZGRyZXNzZXMtaW4tZ2MtbG9ncy11c2luZy14eHByaW50aGVhcGF0Z2M=">Meaning of heap memory addresses in GC logs using -XX:+PrintHeapAtGC?<i class="fa fa-external-link-alt"></i></span><br>[^2]: <span class="exturl" data-url="aHR0cHM6Ly9wbHVtYnIuaW8vaGFuZGJvb2svZ2FyYmFnZS1jb2xsZWN0aW9uLWFsZ29yaXRobXMtaW1wbGVtZW50YXRpb25zL3BhcmFsbGVsLWdj">Parallel GC - Plumber<i class="fa fa-external-link-alt"></i></span><br>[^3]: <span class="exturl" data-url="aHR0cHM6Ly9wbHVtYnIuaW8vaGFuZGJvb2svZ2FyYmFnZS1jb2xsZWN0aW9uLWFsZ29yaXRobXMtaW1wbGVtZW50YXRpb25zL3BhcmFsbGVsLWdjL3BhcmFsbGVsLWZ1bGwtZ2M=">Parallel Full GC - Plumber<i class="fa fa-external-link-alt"></i></span><br>[^4]: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDA4OTE0MzMvdW5kZXJzdGFuZGluZy1tZXRhc3BhY2UtbGluZS1pbi1qdm0taGVhcC1wcmludG91dA==">Understanding metaspace line in JVM heap printout<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile 修饰符在双检锁单例模式中的作用</title>
    <url>/java-volatile-in-double-checked-singleton.html</url>
    <content><![CDATA[<p>在实现一个双检锁单例的时候，IDEA 提示我要给 <code>INSTANCE</code> 实例加上 <code>volatile</code> 修饰符。当时并不明白为啥，所以选择相信 IDE。但是还是那句话，不能知其然不知其所以然啊，自己写的代码，不能自己心里没底不是。于是乎我一顿网上冲浪，终于整明白了为啥双检单例必须要用 <code>volatile</code> 修饰符。</p>
<span id="more"></span>

<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>这个单例类没什么好说的，就是一个平平无奇的双检锁单例实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) {</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// Do something here</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而 IDEA 在外层的 <code>if</code> 上标了一个警告，并且建议我给 <code>INSTANCE</code> 变量加上 <code>volatile</code> 修饰符。</p>
<p><img data-src="https://blog-static.boris1993.com/java-volatile-in-double-checked-singleton/suggestion-in-idea.png"></p>
<h2 id="如果不加volatile会有什么问题"><a href="#如果不加volatile会有什么问题" class="headerlink" title="如果不加volatile会有什么问题"></a>如果不加 <code>volatile</code> 会有什么问题</h2><p>上面的代码，乍一看非常严谨，在发现 <code>INSTANCE</code> 是 <code>null</code> 的时候，就对其加锁并再检查一次，还是 <code>null</code> 的话就为它创建一个新的实例，最后返回它。但是看了一些文章之后发现，在多线程场景下，有可能出现虽然成功获取到 <code>INSTANCE</code>，但在调用其中的方法时仍然抛出空指针异常的诡异情况。</p>
<p>比如有这样一个场景，<code>Thread 1</code> 和 <code>Thread 2</code> 同时请求了 <code>Singleton#getInstance()</code> 方法，<code>Thread 1</code> 执行到了第 8 行，开始实例化这个对象；而 <code>Thread 2</code> 执行到了第 5 行，开始检查 <code>INSTANCE</code> 是否为 <code>null</code>。这个时候，有一定几率，虽然 <code>Thread 2</code> 检查到 <code>INSTANCE</code> 并不是 <code>null</code>，但是调用 <code>Singleton#doSomething()</code> 方法的时候却会抛出空指针异常。</p>
<p><img data-src="https://blog-static.boris1993.com/java-volatile-in-double-checked-singleton/instance-accessed-by-multi-threads.png"></p>
<p>造成这个问题的原因就是 Java 的指令重排。</p>
<p>在搞清楚 <code>Thread 2</code> 看到 <code>INSTANCE</code> 虽然不是 <code>null</code>，却在方法调用的时候会抛空指针异常的原因之前，先要搞清楚实例化对象的时候，JVM 到底干了什么。</p>
<p>JVM 实例化一个对象的过程，大致可以分为这几步：</p>
<ol>
<li>JVM 为这个对象分配一片内存</li>
<li>在这片内存上初始化这个对象</li>
<li>将这片内存的地址赋值给 <code>INSTANCE</code> 变量</li>
</ol>
<p>因为把内存地址赋值给 <code>INSTANCE</code> 是最后一步，所以 <code>Thread 1</code> 在这一步执行之前，<code>Thread 2</code> 对 <code>INSTANCE == null</code> 的判断一定为 <code>true</code>，进而因为拿不到 <code>Singleton</code> 类的锁而被阻塞，直到 <code>Thread 1</code> 完成对 <code>INSTANCE</code> 变量的实例化。</p>
<p>但是，上面这三步它不是个原子操作，并且 JVM 可能会进行重排序，也就是说上面这三步可能被重排成</p>
<ol>
<li>JVM 为这个对象分配一片内存</li>
<li>将这片内存的地址赋值给 <code>INSTANCE</code> 变量</li>
<li>在这片内存上初始化这个对象</li>
</ol>
<p>你看，这问题就来了，如果在 <code>Thread 1</code> 做完第二步但没做第三步的时候，<code>Thread 2</code> 开始检查 <code>INSTANCE</code> 是不是 <code>null</code> 就会得到 <code>false</code>，然后就走到 <code>return</code>，得到一个不完整的 <code>INSTANCE</code> 对象。这时候，虽然 <code>INSTANCE</code> 不是 <code>null</code>，但同时它也没有完成初始化，所以 <code>Thread 2</code> 在调用 <code>Singleton#doSomething()</code> 方法的时候，就会抛出空指针异常。</p>
<p>这个问题的解决方案就是 <code>volatile</code> 修饰符，因为它可以禁止指令重排，所以在给 <code>INSTANCE</code> 加上 <code>volatile</code> 之后，JVM 就会老老实实的先初始化好这个对象，再为 <code>INSTANCE</code> 赋值，这样多线程场景下每个线程得到的 <code>INSTANCE</code> 实例都会是一个初始化好了的 <code>Singleton</code> 对象。</p>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>volatile</tag>
        <tag>singleton</tag>
        <tag>单例模式</tag>
        <tag>双检锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC 的事务和隔离级别</title>
    <url>/jdbc-transaction-and-isolation-level.html</url>
    <content><![CDATA[<p>这里简单写一下我对 <code>JDBC</code> 的事务和隔离级别的理解。</p>
<span id="more"></span>

<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>数据库事务是 DBMS 执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。<br>一个事务一定是具有<code>原子性(atomic)</code>、<code>一致性(consistency)</code>、<code>隔离性(isolation)</code>、<code>持久性(durability)</code>，即 <code>ACID</code>。<br>一个事务会包含一个或多个<code>数据操作语句(data-manipulation statements)</code> 和查询语句。<br>通常来说，事务会依照如下的流程执行：</p>
<ol>
<li><p>开始一个事务</p>
</li>
<li><p>执行一系列操作或查询语句</p>
</li>
<li><p>如果没有发生错误，则提交这个事务，并将其结束</p>
</li>
<li><p>如果发生了错误，则回滚这个事务，并将其结束。</p>
</li>
</ol>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ul>
<li>Atomic</li>
</ul>
<p>原子性，即一个事务内的所有操作都被作为一个整体看待，要么全部成功，要么全部失败</p>
<ul>
<li>Consistency</li>
</ul>
<p>一致性，即事务中有操作失败时，这个事务所更改的数据都必须回滚至操作前的状态。</p>
<ul>
<li>Isolation</li>
</ul>
<p>隔离性，即事务所查看到的数据，要么是一个事务提交前的状态，要么是一个事务提交后的状态，而不可能是事务在执行中的状态。</p>
<ul>
<li>Durability</li>
</ul>
<p>持久性，即事务对系统的影响是永久的。</p>
<h2 id="读现象"><a href="#读现象" class="headerlink" title="读现象"></a>读现象</h2><ul>
<li>脏读</li>
</ul>
<p>当一个事务允许读取另一个事务修改但尚未提交的数据时，就有可能发生脏读。</p>
<ul>
<li>不可重复读</li>
</ul>
<p>在一次事务中，对一行数据的两次读取获得了不同的结果。<br>该现象发生于在执行 <code>SELECT</code> 时没有获得读锁，或者在读取完毕后立刻释放了读锁。</p>
<ul>
<li>幻读</li>
</ul>
<p>在事务执行过程中，两个完全一样的查询得到了不同的结果集，即是幻读。它是不可重复读的一个特殊场景。<br>当事务 1 在执行两次 <code>SELECT ... WHERE</code> 操作中间，事务 2 在这个表中生成了一行新数据，而这条新数据正好满足事务 1 的 <code>WHERE</code> 条件，导致事务 1 的两次查询得到了不同的结果集。</p>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><h2 id="NONE"><a href="#NONE" class="headerlink" title="NONE"></a><code>NONE</code></h2><p><code>NONE</code> 是一个特殊的级别，代表 <code>JDBC</code> 驱动不支持事务。</p>
<h2 id="未提交读-READ-UNCOMMITED"><a href="#未提交读-READ-UNCOMMITED" class="headerlink" title="未提交读(READ UNCOMMITED)"></a>未提交读 (<code>READ UNCOMMITED</code>)</h2><p>这个是最低的隔离级别。<br>这个隔离级别允许事务读取到其他事务尚未提交 (commit) 的数据，即允许脏读。</p>
<h2 id="提交读-READ-COMMITED"><a href="#提交读-READ-COMMITED" class="headerlink" title="提交读(READ COMMITED)"></a>提交读 (<code>READ COMMITED</code>)</h2><p>这个隔离级别中，DBMS 需要选定对象的写锁一直保持到事务结束，但是读锁会在 <code>SELECT</code> 操作完成后马上释放，所以有可能会发生 “不可重复读”。</p>
<h2 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读(REPEATABLE READ)"></a>可重复读 (<code>REPEATABLE READ</code>)</h2><p>在这个隔离级别下，DBMS 需要对选定对象的读锁和写锁一直保持到事务结束，但是不要求范围锁，所以有可能发生幻读。</p>
<h2 id="可串行化-SERIALIZABLE"><a href="#可串行化-SERIALIZABLE" class="headerlink" title="可串行化(SERIALIZABLE)"></a>可串行化 (<code>SERIALIZABLE</code>)</h2><p>这是最高的隔离级别。<br>在这个隔离级别下，要求 DBMS 在选定对象上的读锁和写锁一直保持到事务结束，如果使用了 <code>WHERE</code> 来描述范围时，则应当获取一个范围锁。这个隔离级别可以防止幻读。</p>
<h1 id="隔离级别与读现象"><a href="#隔离级别与读现象" class="headerlink" title="隔离级别与读现象"></a>隔离级别与读现象</h1><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未提交读</td>
<td align="left">可能发生</td>
<td align="left">可能发生</td>
<td align="left">可能发生</td>
</tr>
<tr>
<td align="left">提交读</td>
<td align="left">不会发生</td>
<td align="left">可能发生</td>
<td align="left">可能发生</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">不会发生</td>
<td align="left">不会发生</td>
<td align="left">可能发生</td>
</tr>
<tr>
<td align="left">可串行化</td>
<td align="left">不会发生</td>
<td align="left">不会发生</td>
<td align="left">不会发生</td>
</tr>
</tbody></table>
<h1 id="隔离级别与锁持续时间"><a href="#隔离级别与锁持续时间" class="headerlink" title="隔离级别与锁持续时间"></a>隔离级别与锁持续时间</h1><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">写操作</th>
<th align="left">读操作</th>
<th align="left">范围操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未提交读</td>
<td align="left">当前语句执行完毕</td>
<td align="left">当前语句执行完毕</td>
<td align="left">当前语句执行完毕</td>
</tr>
<tr>
<td align="left">提交读</td>
<td align="left">当前事务提交</td>
<td align="left">当前语句执行完毕</td>
<td align="left">当前语句执行完毕</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">当前事务提交</td>
<td align="left">当前事务提交</td>
<td align="left">当前语句执行完毕</td>
</tr>
<tr>
<td align="left">可串行化</td>
<td align="left">当前事务提交</td>
<td align="left">当前事务提交</td>
<td align="left">当前事务提交</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDBC</tag>
        <tag>Transaction</tag>
        <tag>Isolation level</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 刷题笔记</title>
    <url>/leetcode-notes.html</url>
    <content><![CDATA[<p>迫于找工作，不得不一边鄙视自己的智商，一边硬着头皮刷 LeetCode。既然开始刷题，那顺便做个笔记，以便日后温习。</p>
<p>因为顺序是乱的，所以请善用 <code>CTRL-F</code>。</p>
<span id="more"></span>

<h2 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbnMtZHVwbGljYXRlLw==">217. Contains Duplicate<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">            <span class="comment">// 看见一个数字就去hashSet里面查，</span></span><br><span class="line">            <span class="comment">// 查到就说明重复过了</span></span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(i)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            hashSet.add(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS8=">242. Valid Anagram<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: s = "anagram", t = "nagaram"</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: s = "rat", t = "car"</span><br><span class="line">Output: false</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串s中各个字符出现的次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; countS = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串t中各个字符出现的次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; countT = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            countS.put(</span><br><span class="line">                s.charAt(i), </span><br><span class="line">                countS.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) {</span><br><span class="line">            countT.put(</span><br><span class="line">                t.charAt(i), </span><br><span class="line">                countT.getOrDefault(t.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map#equals比较的是两个map中的键值对</span></span><br><span class="line">        <span class="comment">// 键值对相同，说明两串字符都用了相同的字母，每个字母出现的次数也一样</span></span><br><span class="line">        <span class="comment">// 即同字母异序词</span></span><br><span class="line">        <span class="keyword">return</span> countS.equals(countT);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1299-Replace-Elements-with-Greatest-Element-on-Right-Side"><a href="#1299-Replace-Elements-with-Greatest-Element-on-Right-Side" class="headerlink" title="1299. Replace Elements with Greatest Element on Right Side"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmVwbGFjZS1lbGVtZW50cy13aXRoLWdyZWF0ZXN0LWVsZW1lbnQtb24tcmlnaHQtc2lkZS8=">1299. Replace Elements with Greatest Element on Right Side<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: arr = [17,18,5,4,6,1]</span><br><span class="line">Output: [18,6,6,6,1,-1]</span><br><span class="line">Explanation: </span><br><span class="line">- index 0 --&gt; the greatest element to the right of index 0 is index 1 (18).</span><br><span class="line">- index 1 --&gt; the greatest element to the right of index 1 is index 4 (6).</span><br><span class="line">- index 2 --&gt; the greatest element to the right of index 2 is index 4 (6).</span><br><span class="line">- index 3 --&gt; the greatest element to the right of index 3 is index 4 (6).</span><br><span class="line">- index 4 --&gt; the greatest element to the right of index 4 is index 5 (1).</span><br><span class="line">- index 5 --&gt; there are no elements to the right of index 5, so we put -1.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] replaceElements(<span class="type">int</span>[] arr) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = max;</span><br><span class="line">            max = Math.max(max, a);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解题思路就是把 explanation 反过来看，既然要找元素右边最大的数，那么就从最右开始，这样找到的最大的数必定适用于 <code>arr[i] ~ arr[length - 1]</code> 这个范围。</p>
<h2 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392. Is Subsequence"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaXMtc3Vic2VxdWVuY2Uv">392. Is Subsequence<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: s = "abc", t = "ahbgdc"</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: s = "axc", t = "ahbgdc"</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Input: s = "acb", t = "ahbgdc"</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Input: s = "aaaaaa", t = "bbaaaa"</span><br><span class="line">Output: false</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.equals(t) || s.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (t.charAt(i) == s.charAt(sIndex)) {</span><br><span class="line">                sIndex++;</span><br><span class="line">                <span class="keyword">if</span> (sIndex &gt;= s.length()) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解题思路就是整两个指针，<code>sIndex</code> 指向 <code>s</code> 的各个字符，在循环里面逐个取 <code>t</code> 的字符跟 <code>s[sIndex]</code> 对比，匹配到的话 <code>sIndex</code> 就往下走一步，如果 <code>sIndex</code> 能走到头，就说明 <code>s</code> 是 <code>t</code> 的子序列。</p>
<h2 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGVuZ3RoLW9mLWxhc3Qtd29yZC8=">58. Length of Last Word<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: s = "Hello World"</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The last word is "World" with length 5.</span><br><span class="line"></span><br><span class="line">Input: s = "   fly me   to   the moon  "</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The last word is "moon" with length 4.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> {</span><br><span class="line">        String[] strs = s.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">return</span> strs[strs.length - <span class="number">1</span>].length();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我的评价是，这道题不应该出现在 LeetCode，应该出现在大学 Java 课程的作业里。</p>
<h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tcHJlZml4Lw==">14. Longest Common Prefix<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: strs = ["flower","flow","flight"]</span><br><span class="line">Output: "fl"</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> {</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿第一个字符串当模版，匹配剩下几个字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">commonPrefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) {</span><br><span class="line">            <span class="comment">// 如果commonPrefix在strs[i]的下标不是0</span></span><br><span class="line">            <span class="comment">// 那么就去掉commonPrefix的最后一个字母，直到下标为0</span></span><br><span class="line">            <span class="comment">// 如果没有common prefix，那么commonPrefix会被砍成空字符串</span></span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(commonPrefix) != <span class="number">0</span>) {</span><br><span class="line">                commonPrefix = commonPrefix.substring(<span class="number">0</span>, commonPrefix.length() - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> commonPrefix;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>计算过程：（语言描述太费劲，直接拿 Replit 放示意图算了）</p>
<p><img data-src="https://blog-static.boris1993.com/leetcode-notes/longest-common-prefix.png"></p>
<h2 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZ3JvdXAtYW5hZ3JhbXMv">49. Group Anagrams<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: strs = ["eat","tea","tan","ate","nat","bat"]</span><br><span class="line">Output: [["bat"],["nat","tan"],["ate","eat","tea"]]</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> {</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str: strs) {</span><br><span class="line">            <span class="comment">// 取一个字符串，打散成字符数组，把字符数组排序后得到一个新字符串</span></span><br><span class="line">            <span class="comment">// 比如eat-&gt; aet，tea-&gt;aet</span></span><br><span class="line">            <span class="comment">// 这个作为map的key</span></span><br><span class="line">            <span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">            Arrays.sort(charArray);</span><br><span class="line">            <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(newStr)) {</span><br><span class="line">                map.put(newStr, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 把重排序后结果相同的字符串放在同一个key下面的List里面</span></span><br><span class="line">            map.get(newStr).add(str);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(map.values());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>计算过程语言不好描述…… 但是代码挺易懂的吧，实在看不明白的话自己 debug 一下就清楚了。</p>
<h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGFzY2Fscy10cmlhbmdsZS8=">118. Pascal’s Triangle<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: numRows = 5</span><br><span class="line">Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br><span class="line"></span><br><span class="line">Input: numRows = 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif"></p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> {</span><br><span class="line">        <span class="comment">// 需要单独处理只有一行的情况</span></span><br><span class="line">        <span class="comment">// 否则会因为下面预设前两行数据的代码而返回错误的数据</span></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> List.of(List.of(<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(numRows);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前两行的内容是固定的</span></span><br><span class="line">        result.add(List.of(<span class="number">1</span>));</span><br><span class="line">        result.add(List.of(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">2</span>; row &lt; numRows; row++) {</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(row + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这一行最左边肯定是1</span></span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两个两个取上一行的各个数，两两相加，得到当前格子的数字</span></span><br><span class="line">            <span class="comment">// 因为要取上一行的第i和第i+1个元素，所以循环结束条件得是上一行的个数减一</span></span><br><span class="line">            <span class="comment">// 否则就下标越界了</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">previousRow</span> <span class="operator">=</span> row - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.get(previousRow).size() - <span class="number">1</span>; i++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> result.get(previousRow).get(i) + result.get(previousRow).get(i + <span class="number">1</span>);</span><br><span class="line">                list.add(sum);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最右边也肯定是1</span></span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            result.add(list);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmVtb3ZlLWVsZW1lbnQv">27. Remove Element<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: nums = [3,2,2,3], val = 3</span><br><span class="line">Output: 2, nums = [2,2,_,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 2.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="comment">// 不等于val的数字的个数，同时当作nums的一个指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) {</span><br><span class="line">                nums[count] = nums[i];</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="929-Unique-Email-Addresses"><a href="#929-Unique-Email-Addresses" class="headerlink" title="929. Unique Email Addresses"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdW5pcXVlLWVtYWlsLWFkZHJlc3Nlcw==">929. Unique Email Addresses<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numUniqueEmails</span><span class="params">(String[] emails)</span> {</span><br><span class="line">        HashSet&lt;String&gt; uniqueEmails = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String email : emails) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">sanitizedEmail</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">indexOfPlusSign</span> <span class="operator">=</span> email.indexOf(<span class="string">"+"</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">indexOfAtSign</span> <span class="operator">=</span> email.indexOf(<span class="string">"@"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (indexOfPlusSign &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 按题目要求，第一个加号及其以后的用户名部分都会被忽略</span></span><br><span class="line">                sanitizedEmail += email.substring(<span class="number">0</span>, indexOfPlusSign);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sanitizedEmail += email.substring(<span class="number">0</span>, indexOfAtSign);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按题目要求，用户名部分的点都会被忽略</span></span><br><span class="line">            sanitizedEmail = sanitizedEmail.replace(<span class="string">"."</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理完了用户名部分，把域名部分拼上去</span></span><br><span class="line">            sanitizedEmail += email.substring(indexOfAtSign);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 全处理完之后，扔进HashSet里面，顺便去重</span></span><br><span class="line">            uniqueEmails.add(sanitizedEmail);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uniqueEmails.size();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205. Isomorphic Strings"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaXNvbW9ycGhpYy1zdHJpbmdz">205. Isomorphic Strings<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: s = "paper", t = "title"</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: s = "foo", t = "bar"</span><br><span class="line">Output: false</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> {</span><br><span class="line">        <span class="comment">// 俩字符串长度都不一样，那必然不同形</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立s中每个字符与t中同位置字符的映射关系</span></span><br><span class="line">        <span class="comment">// 如 egg -&gt; add</span></span><br><span class="line">        <span class="comment">// e -&gt; a, g -&gt; d</span></span><br><span class="line">        HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(s.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (map.containsValue(t.charAt(i))) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            map.put(s.charAt(i), t.charAt(i));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后从map里面，按照s的每个字母，取出映射过的字符</span></span><br><span class="line">        <span class="comment">// 拼在StringBuilder里面</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            <span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> map.get(s.charAt(i));</span><br><span class="line">            sb.append(ch);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查用映射拼出来的字符串与t是否相同</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString().equals(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdG9wLWstZnJlcXVlbnQtZWxlbWVudHMv">347. Top K Frequent Elements<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span> (nums.length == k) {</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays</span><br><span class="line">            .stream(nums)</span><br><span class="line">            <span class="comment">// int -&gt; Integer</span></span><br><span class="line">            .boxed()</span><br><span class="line">            <span class="comment">// 收集到一个map中，key是数字，value是出现的次数</span></span><br><span class="line">            .collect(Collectors.groupingBy(num -&gt; num, Collectors.summingInt(num -&gt; <span class="number">1</span>)))</span><br><span class="line">            .entrySet()</span><br><span class="line">            .stream()</span><br><span class="line">            <span class="comment">// 把entry set按照value降序排列</span></span><br><span class="line">            .sorted(Map.Entry.comparingByValue((a, b) -&gt; Integer.compare(b, a)))</span><br><span class="line">            <span class="comment">// 取前k个</span></span><br><span class="line">            .limit(k)</span><br><span class="line">            <span class="comment">// 把key取出来，unbox成int</span></span><br><span class="line">            .mapToInt(e -&gt; e.getKey())</span><br><span class="line">            <span class="comment">// 最后造个数组出来返回掉</span></span><br><span class="line">            .toArray();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还写 (chao) 了一个不用 <code>stream</code>，纯手工拿 entry set 做比较的解法，因过于丑陋，就不贴在这了，<code>submission</code> 在<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdG9wLWstZnJlcXVlbnQtZWxlbWVudHMvc3VibWlzc2lvbnMvODg2MTUyMzUzLw==">这里<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb25zZWN1dGl2ZS1zZXF1ZW5jZS9kZXNjcmlwdGlvbi8=">128. Longest Consecutive Sequence<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: nums = [100,4,200,1,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br><span class="line"></span><br><span class="line">Input: nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: The longest consecutive elements sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8]. Therefore its length is 9.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">longestStreak</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentStreak</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="comment">// 因为当前数字已经记入了一个“连击”</span></span><br><span class="line">            <span class="comment">// 所以当这个数字跟上一个数字重复的时候，直接跳到下一个数字</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>]) {</span><br><span class="line">                <span class="comment">// 既然连续，那么当前数字跟上一个数字肯定差1</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) {</span><br><span class="line">                    currentStreak++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 如果不连续了，记下来最大的连击数，当前连击数重置</span></span><br><span class="line">                    longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">                    currentStreak = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后取最大的连击数，这个不用多说吧</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(longestStreak, currentStreak);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFsaW5kcm9tZS8=">125. Valid Palindrome<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: s = "A man, a plan, a canal: Panama"</span><br><span class="line">Output: true</span><br><span class="line">Explanation: "amanaplanacanalpanama" is a palindrome.</span><br><span class="line"></span><br><span class="line">Input: s = " "</span><br><span class="line">Output: true</span><br><span class="line">Explanation: s is an empty string "" after removing non-alphanumeric characters.</span><br><span class="line">Since an empty string reads the same forward and backward, it is a palindrome.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="comment">// 把不是字母和数字的字符剔出去，然后转小写，方便比较</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.replaceAll(<span class="string">"[\\W]|_"</span>, <span class="string">""</span>);</span><br><span class="line">        str = str.toLowerCase();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str).reverse().toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.equals(reversed);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是很显然，这个偷鸡解法并不是 <code>two pointers</code> 这个分类想要的，所以另一个解法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="comment">// 把不是字母和数字的字符剔出去，然后转小写，方便比较</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.replaceAll(<span class="string">"[\\W]|_"</span>, <span class="string">""</span>);</span><br><span class="line">        str = str.toLowerCase();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> chars.length / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> chars.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// head和tail两个指针逐步向middle逼近</span></span><br><span class="line">        <span class="comment">// 一边走，一边比较两个指针指向的字母是不是一样</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt; middle) {</span><br><span class="line">            <span class="keyword">if</span> (chars[head] != chars[tail]) {</span><br><span class="line">                <span class="comment">// 不一样的话，那自然就不是回文字符串了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            head++;</span><br><span class="line">            tail--;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">1. Two Sum<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: nums = [2,7,11,15], target = 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">        <span class="comment">// key是数字本身，value是数字所在下标</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="comment">// 算一下target与当前下标的差</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] { map.get(complement), i };</span><br><span class="line">            }</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"No solution found"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>计算过程：</p>
<ul>
<li><code>i = 0</code>，<code>nums[i] = 2</code>，<code>complement = 9 - 2 = 7</code>，map 的 key 里面找不到 7，所以 <code>map.put(2, 0)</code></li>
<li><code>i = 1</code>，<code>nums[i] = 7</code>，<code>complement = 9 - 7 = 2</code>，map 的 key 里面有 2，即 <code>nums[i] + nums[map.get(2)] = 9</code>，返回 <code>[map.get(2), nums[i]]</code> 即 <code>[0, 1]</code></li>
</ul>
<h2 id="167-Two-Sum-II-Input-Array-Is-Sorted"><a href="#167-Two-Sum-II-Input-Array-Is-Sorted" class="headerlink" title="167. Two Sum II - Input Array Is Sorted"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS1paS1pbnB1dC1hcnJheS1pcy1zb3J0ZWQ=">167. Two Sum II - Input Array Is Sorted<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) {</span><br><span class="line">        <span class="comment">// 两个指针</span></span><br><span class="line">        <span class="comment">// 一个从头往尾走，一个从尾往头走</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) {</span><br><span class="line">            <span class="comment">// 要求是计算两个数字之和是否等于target</span></span><br><span class="line">            <span class="comment">// 同时因为数组已经按升序排列</span></span><br><span class="line">            <span class="comment">// 那么如果加的结果大于target，就让尾指针往前，取更小的数</span></span><br><span class="line">            <span class="comment">// 如果结果小于target，就让头指针往后，取更大的数</span></span><br><span class="line">            <span class="comment">// 结果要么找到合适的两个数，要么两个指针相遇，即没有合适的数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {low + <span class="number">1</span>, high + <span class="number">1</span>};</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                ++low;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                --high;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {-<span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvM3N1bQ==">15. 3Sum<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: nums = [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.</span><br><span class="line">The distinct triplets are [-1,0,1] and [-1,-1,2].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>一种解法是，类似 <code>Two Sum II</code>，取一个基准数，然后用 <code>Two Sum II</code> 的方法找基准数右边符合要求的两个数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// 先把nums排序，让这个数组符合Two Sum II的要求</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从头到尾遍历nums，取一个数字作为基准</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length &amp;&amp; nums[i] &lt;= <span class="number">0</span>; ++i) {</span><br><span class="line">            <span class="comment">// 这里的条件是为了不重复计算相同的数字，</span></span><br><span class="line">            <span class="comment">// 即只在当前数字不跟上一个数字重复的时候才计算</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i - <span class="number">1</span>] != nums[i]) {</span><br><span class="line">                twoSumII(nums, i, result);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">twoSumII</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="comment">// 取nums[i]右边的数组作为子数组</span></span><br><span class="line">        <span class="comment">// 左指针指向子数组第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右指针指向最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) {</span><br><span class="line">            <span class="comment">// 基准数 + 左指针 + 右指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[low] + nums[high];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 结果小于零，那么左指针往右走，取更大的一个数</span></span><br><span class="line">                ++low;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 结果大于零，那么右指针往左走，取更小的一个数</span></span><br><span class="line">                --high;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 等于零，那么这三个数就是我们想要的</span></span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[low], nums[high]));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 继续缩小范围</span></span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 并且当low指向相同数字时，继续向右走</span></span><br><span class="line">                <span class="comment">// 然后重新在上一层循环里面继续找符合要求的数字</span></span><br><span class="line">                <span class="comment">// 毕竟区间内可能有多组符合条件的数字</span></span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == nums[low - <span class="number">1</span>]) {</span><br><span class="line">                    ++low;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是，如果题目不允许改变 <code>nums</code> 数组呢？那么可以这样解，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; duplicates = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!duplicates.add(nums[i])) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> -(nums[i] + nums[j]);</span><br><span class="line">                <span class="comment">// 如果在seen这个map里面找到了曾经计算过的complement</span></span><br><span class="line">                <span class="comment">// 那么说明complement存在于nums数组中</span></span><br><span class="line">                <span class="comment">// 即找到了三个和为零的数字，nums[i]，nums[j]，complement</span></span><br><span class="line">                <span class="keyword">if</span> (seen.containsKey(complement) &amp;&amp; seen.get(complement) == i) {</span><br><span class="line">                    List&lt;Integer&gt; triplet = Arrays.asList(nums[i], nums[j], complement);</span><br><span class="line">                    <span class="comment">// 排序之后再放进set，避免插入内容相同位置不同的结果</span></span><br><span class="line">                    Collections.sort(triplet);</span><br><span class="line">                    result.add(triplet);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录nums[j]可以作为nums[i]的补充（complement）</span></span><br><span class="line">                seen.put(nums[j], i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlcg==">11. Container With Most Water<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"></p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="comment">// 取容器最短的那个板子，木桶原理嘛</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ht</span> <span class="operator">=</span> Math.min(height[left], height[right]);</span><br><span class="line">            <span class="comment">// 板子左右有几格水</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">water</span> <span class="operator">=</span> right - left;</span><br><span class="line">            <span class="comment">// 水的体积，也就是蓝色正方形的面积，底*高</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">volume</span> <span class="operator">=</span> ht * water;</span><br><span class="line">            <span class="comment">// 记录最大的体积</span></span><br><span class="line">            max = Math.max(max, volume);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 既然要找最大的体积，当然哪个板子短就换哪个</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) {</span><br><span class="line">                left++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay8=">121. Best Time to Buy and Sell Stock<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">buyPrice</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">overallProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profitIfSoldToday</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) {</span><br><span class="line">            <span class="comment">// 让buyPrice保存最小的价格</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; buyPrice) {</span><br><span class="line">                buyPrice = prices[i];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算今日价格与买入价的差</span></span><br><span class="line">            profitIfSoldToday = prices[i] - buyPrice;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// overallProfit记录最大的总利润</span></span><br><span class="line">            <span class="keyword">if</span> (overallProfit &lt; profitIfSoldToday) {</span><br><span class="line">                overallProfit = profitIfSoldToday;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> overallProfit;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udmVydC1zb3J0ZWQtYXJyYXktdG8tYmluYXJ5LXNlYXJjaC10cmVlLw==">108. Convert Sorted Array to Binary Search Tree<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg"></p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">return</span> builder(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">builder</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从中间将nums二分</span></span><br><span class="line">        <span class="comment">// 比如在第一层递归中，</span></span><br><span class="line">        <span class="comment">// [-10,-3,0,5,9] -&gt; [-10,-3,0] [5,9]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中间的数字作为二叉搜索树的根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rootNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[middle]);</span><br><span class="line">        <span class="comment">// 第一层递归中[-10, -3]拿去构造左边的子节点</span></span><br><span class="line">        rootNode.left = builder(nums, left, middle - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 第一层递归中[5,9]拿去构造右边的子节点</span></span><br><span class="line">        rootNode.right = builder(nums, middle + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>思路就是递归 + 二分，或许还有些分治思想？先找见根节点，然后把数组左右分成两半，在递归里面再重复这样的操作，直到只有一个根节点，也就是最下面的叶子节点。最后往上组装。<br>数据怎么跑的 debug 一下看看吧，用语言描述肯定要乱死。</p>
<h2 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbHJ1LWNhY2hlL2Rlc2NyaXB0aW9uLw==">146. LRU Cache<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // cache is {1=1}</span><br><span class="line">lRUCache.put(2, 2); // cache is {1=1, 2=2}</span><br><span class="line">lRUCache.get(1);    // return 1</span><br><span class="line">lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}</span><br><span class="line">lRUCache.get(2);    // returns -1 (not found)</span><br><span class="line">lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}</span><br><span class="line">lRUCache.get(1);    // return -1 (not found)</span><br><span class="line">lRUCache.get(3);    // return 3</span><br><span class="line">lRUCache.get(4);    // return 4</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>解题思路：</p>
<p>LRU Cache，即 <code>Least Recently Used Cache</code>，其运作机理是，如果在 cache 已满的时候添加新的记录，那么要先删掉其中最不常用的记录，然后添加新的记录。</p>
<p>我们可以用双向链表来实现这个效果，越靠近链表头，就代表这个元素越常被用到；反之越靠近链表尾，这个元素就越不常用，链表尾的前一个元素也将是在 cache 满了之后被删掉的那个元素。</p>
<p>那么首先需要创建一个类 <code>Node</code>，代表双向链表中的节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    Node next;</span><br><span class="line">    Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时候就可以初始化 <code>LRUCache</code> 这个类的结构了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line">    <span class="comment">// 链表头节点，永远不动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 链表尾节点，永远不动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 存储key与Node的映射，get的时候实际上是从这取值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// cache容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 双向链表头尾相连</span></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来先实现 <code>get</code> 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 当一个节点被get</span></span><br><span class="line"><span class="comment">// 那么就把它提到双向链表的头部位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="comment">// 根据题目要求，key不存在就返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (!map.containsKey(key)) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">nodeNext</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">nodePrev</span> <span class="operator">=</span> node.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先把这个node从当前位置抹去</span></span><br><span class="line">    nodePrev.next = nodeNext;</span><br><span class="line">    nodeNext.prev = nodePrev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后插入到头部</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">headNext</span> <span class="operator">=</span> head.next;</span><br><span class="line">    node.next = headNext;</span><br><span class="line">    node.prev = head;</span><br><span class="line">    headNext.prev = node;</span><br><span class="line">    head.next = node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来实现 <code>put</code> 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">    <span class="comment">// 如果key已经存在</span></span><br><span class="line">    <span class="comment">// 那么put相当于更新value，同时刷新在LRU Cache中的位置</span></span><br><span class="line">    <span class="comment">// 所以先把已有的这个node删掉</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.remove(key);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeNext</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodePrev</span> <span class="operator">=</span> node.prev;</span><br><span class="line">        nodePrev.next = nodeNext;</span><br><span class="line">        nodeNext.prev = nodePrev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果cache满了，就要先删掉末尾的节点（末位淘汰制？</span></span><br><span class="line">    <span class="keyword">if</span> (map.size() == capacity) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">leastRecentUsedNode</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        map.remove(leastRecentUsedNode.key);</span><br><span class="line"></span><br><span class="line">        leastRecentUsedNode.prev = tail;</span><br><span class="line">        tail.prev = leastRecentUsedNode.prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">    map.put(key, newNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把这个新建的node塞到head和headNext之间</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">headNext</span> <span class="operator">=</span> head.next;</span><br><span class="line">    newNode.prev = head;</span><br><span class="line">    newNode.next = headNext;</span><br><span class="line">    headNext.prev = newNode;</span><br><span class="line">    head.next = newNode;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可见新增节点和删除节点操作的代码是经常重复的，所以抽成两个单独的方法。最后完整的解题代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        remove(node);</span><br><span class="line">        insert(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">            remove(map.get(key));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity) {</span><br><span class="line">            remove(tail.prev);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        insert(<span class="keyword">new</span> <span class="title class_">Node</span>(key, value));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> {</span><br><span class="line">        map.remove(node.key);</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Node node)</span> {</span><br><span class="line">        map.put(node.key, node);</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">headNext</span> <span class="operator">=</span> head.next;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = headNext;</span><br><span class="line">        headNext.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node next;</span><br><span class="line">        Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="9-Palindrome-number"><a href="#9-Palindrome-number" class="headerlink" title="9. Palindrome number"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1udW1iZXIv">9. Palindrome number<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: x = 121</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 121 reads as 121 from left to right and from right to left.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">input</span> <span class="operator">=</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">reversedNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// x从低位往高位取数字，然后从高位到低位填给reversedNum</span></span><br><span class="line">        <span class="comment">// 即把x反转</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// reversedNum乘10，加上x除以10的余数，即当前x的末位数</span></span><br><span class="line">            reversedNum = reversedNum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// x除以10，抛掉当前的末位数</span></span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (reversedNum &gt; Integer.MAX_VALUE || reversedNum &lt; Integer.MIN_VALUE) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> input == reversedNum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>计算过程：</p>
<ul>
<li><code>x = 121</code>，<code>reversedNum = 0</code>；<code>reversedNum = reversedNum * 10 + x % 10 = 0 + 1 = 1</code>；<code>x = x / 10 = 121 / 10 = 12</code></li>
<li><code>x = 12</code>，<code>reversedNum = 1</code>；<code>reversedNum = reversedNum * 10 + x % 10 = 10 + 2 = 12</code>；<code>x = x / 10 = 12 / 10 = 1</code></li>
<li><code>x = 1</code>，<code>reversedNum = 12</code>；<code>reversedNum = reversedNum * 10 + x % 10 = 120 + 1 = 121</code>；<code>x = x / 10 = 1 / 10 = 0</code></li>
<li><code>input == reversedNum =&gt; 121 == 121 =&gt; true</code></li>
</ul>
<p>写到这想到还有个粗暴解法，把数字当成字符串，翻转一下然后比较两个字符串是不是一样不就行了，做什么数学题？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputString</span> <span class="operator">=</span> Integer.toString(x);</span><br><span class="line">        <span class="type">String</span> <span class="variable">reversedString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(inputString).reverse().toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputString.equals(reversedString);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>多清爽，三行完事还不烧脑子。</p>
<h2 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcm9tYW4tdG8taW50ZWdlci8=">13. Roman to Integer<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: s = "MCMXCIV"</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="comment">// 基本罗马数字</span></span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">7</span>);</span><br><span class="line">        map.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IV这种左减格式的数字收拾起来太麻烦，</span></span><br><span class="line">        <span class="comment">// 直接转成连续的基本数字</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sanitized</span> <span class="operator">=</span> s</span><br><span class="line">                .replace(<span class="string">"IV"</span>, <span class="string">"IIII"</span>)</span><br><span class="line">                .replace(<span class="string">"IX"</span>, <span class="string">"VIIII"</span>)</span><br><span class="line">                .replace(<span class="string">"XL"</span>, <span class="string">"XXXX"</span>)</span><br><span class="line">                .replace(<span class="string">"XC"</span>, <span class="string">"LXXXX"</span>)</span><br><span class="line">                .replace(<span class="string">"CD"</span>, <span class="string">"CCCC"</span>)</span><br><span class="line">                .replace(<span class="string">"CM"</span>, <span class="string">"DCCCC"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] chars = sanitized.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) {</span><br><span class="line">            result += map.get(aChar);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>计算过程：</p>
<ul>
<li><code>MCMXCIV</code>(1994) =&gt; <code>M CM XC IV</code>(1000 900 90 4) =&gt; <code>M DCCC LXXXX IIII</code></li>
<li>从头到尾遍历 <code>MDCCCLXXXXIIII</code> 中每个字符，去 map 里面找对应的阿拉伯数字，加起来就完事了</li>
</ul>
<p>一开始做的时候愁死我了，没有左减格式的数字没啥难度，想破脑袋也没想到怎么处理左减，抄答案发现还能这么玩，属实打开思路了。</p>
<h2 id="252-Meeting-Rooms"><a href="#252-Meeting-Rooms" class="headerlink" title="252. Meeting Rooms"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVldGluZy1yb29tcy8=">252. Meeting Rooms<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Given an array of meeting time <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, determine if a person could attend all meetings.</p>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: intervals = [[0,30],[5,10],[15,20]]</span><br><span class="line">Output: false</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>Easy 级别的题，思路很简单，先把会议安排按照开始时间升序排列，然后比较下一场会议的开始时间是否小于上一场会议的结束时间，是的话就说明这个人无法参加全部会议。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canAttendMeetings</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">        <span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort with the meeting start time</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastEndTime</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentBeginTime</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentBeginTime &lt; lastEndTime) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            lastEndTime = intervals[i][<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253. Meeting Rooms II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVldGluZy1yb29tcy1paS8=">253. Meeting Rooms II<i class="fa fa-external-link-alt"></i></span></h2><blockquote>
<p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, return the minimum number of conference rooms required.</p>
<p>Example:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Input: intervals = [[0,30],[5,10],[15,20]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>这道题要用到优先队列，具体算法见注释。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">        <span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> intervals.length;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个优先队列，存储会议的结束时间，按升序排列</span></span><br><span class="line">        <span class="comment">// 因为会议结束，下一场会议才能占用这个会议室</span></span><br><span class="line">        <span class="comment">// 所以只需要比较当前会议的开始时间与上一场会议的结束时间</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; allocator = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            intervals.length,</span><br><span class="line">            (a, b) -&gt; a - b</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新排序intervals，按照会议的开始时间升序排列</span></span><br><span class="line">        Arrays.sort(</span><br><span class="line">            intervals, </span><br><span class="line">            (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一场会议占用一个会议室</span></span><br><span class="line">        allocator.add(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) {</span><br><span class="line">            <span class="comment">// 从第二场会议开始检查</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= allocator.peek()) {</span><br><span class="line">                <span class="comment">// 如果第二场会议在开始的时候，上一场会议已经结束</span></span><br><span class="line">                <span class="comment">// 那么释放掉上一场会议的会议室</span></span><br><span class="line">                <span class="comment">// 也就是删除掉优先队列的第一个元素</span></span><br><span class="line">                allocator.poll();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前会议肯定要占一个会议室</span></span><br><span class="line">            allocator.add(intervals[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> allocator.size();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="655-Print-Binary-Tree"><a href="#655-Print-Binary-Tree" class="headerlink" title="655. Print Binary Tree"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcHJpbnQtYmluYXJ5LXRyZWUv">655. Print Binary Tree<i class="fa fa-external-link-alt"></i></span></h2><p>抄答案<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcHJpbnQtYmluYXJ5LXRyZWUvc29sdXRpb25zLzIyMjI3NTgvamF2YS1lYXN5LXNvbHV0aW9uLw=="> Java Easy Solution - shawonnirob16<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">printTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> getHeight(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> height + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, height + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先全部填充空字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; row; k++) {</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; column; i++) {</span><br><span class="line">                list.add(<span class="string">""</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            result.add(list);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> column - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        fill(result, left, right, level, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归整个树，每层高度加一，计算树的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(</span></span><br><span class="line"><span class="params">        List&lt;List&lt;String&gt;&gt; result,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> left,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> right,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">        TreeNode root</span></span><br><span class="line"><span class="params">    )</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算list的中间位置的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在中间位置填入当前节点的值</span></span><br><span class="line">        result.get(level).set(middle, String.valueOf(root.val));</span><br><span class="line"></span><br><span class="line">        fill(result, left, middle - <span class="number">1</span>, level + <span class="number">1</span>, root.left);</span><br><span class="line">        fill(result, middle + <span class="number">1</span>, right, level + <span class="number">1</span>, root.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>学知识</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>乐扣</tag>
      </tags>
  </entry>
  <entry>
    <title>购买新的 Linux 服务器后需要做的安全措施</title>
    <url>/linux-server-security-measures.html</url>
    <content><![CDATA[<p>在购买了一台安装 Linux 系统的 VPS 之后，首先要做好一定的安全防护措施，来尽可能地保证你的 VPS 不会沦为某些人的肉鸡。</p>
<span id="more"></span>

<h1 id="修改SSH默认端口"><a href="#修改SSH默认端口" class="headerlink" title="修改SSH默认端口"></a>修改 SSH 默认端口</h1><p>这个世界上，总有不少无聊的人做着 SSH 弱口令扫描这种事情，相信我，你的 IP 一定是在被扫描的 IP 段里的，所以，更换掉 SSH 的默认端口会是个好主意。</p>
<p>用你喜欢的文本编辑器，编辑 <code>/etc/ssh/sshd_config</code> ，修改如下内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># SSH默认端口号为22</span><br><span class="line"># 将其修改为一个自定义的端口号，比如15</span><br><span class="line">Port 15</span><br></pre></td></tr></tbody></table></figure>

<p>保存配置文件，并重启 SSH 服务端进程，使新的配置生效。<strong>注意此时不要退出现在的 SSH 会话，因为一旦出现问题，我们还可以使用这个会话来修复，否则就只能通过虚拟控制台来登陆了</strong></p>
<p>接下来新开一个 SSH 会话，记得通过新指定的端口号来连接，以检查配置是否正确无误。没问题之后，就可以关掉其中一个 SSH 会话了，毕竟还是不要浪费资源，注意环保不是。</p>
<h1 id="启用防火墙"><a href="#启用防火墙" class="headerlink" title="启用防火墙"></a>启用防火墙</h1><p>一台放在公网上的，没有防火墙的服务器，那就是一台公交车。那么怎么变成私家车呢？废话，开防火墙啊！</p>
<p>目前已经有一些 iptables 的前端工具，来简化防火墙的配置了，所以不建议直接操作 iptables。当然如果您有信心，那就当我没说。</p>
<p>不同发行版所使用的 iptables 前端可能是不一样的，比如 CentOS 使用的是 <code>firewalld</code> ，而 Ubuntu 使用的是 <code>ufw</code> 。由于我使用的是 Ubuntu，所以下面就以 <code>ufw</code> 来举例了，使用 <code>firewalld</code> 的同学，可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhwcm9iZS5jb20vY2VudG9zLWZpcmV3YWxsZC5odG1s">这篇文章<i class="fa fa-external-link-alt"></i></span>来学习。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 首先检查防火墙是否在运行</span></span><br><span class="line">$ sudo ufw status</span><br><span class="line">Status: inactive <span class="comment"># 说明目前ufw并没有启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动ufw</span></span><br><span class="line">$ sudo ufw <span class="built_in">enable</span></span><br><span class="line"><span class="comment"># 防火墙已激活，并会跟随系统自动启动</span></span><br><span class="line">Firewall is active and enabled on system startup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把SSH的端口加入到开放的列表中</span></span><br><span class="line"><span class="comment"># 否则这个会话断掉之后，你就再也别想用SSH登陆了</span></span><br><span class="line">$ ufw allow 15</span><br><span class="line">Rule added</span><br><span class="line">Rule added (v6)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看一下是不是成功加进去了</span></span><br><span class="line">$ sudo ufw status</span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">15                         ALLOW       Anywhere</span><br><span class="line">15 (v6)                    ALLOW       Anywhere (v6)</span><br></pre></td></tr></tbody></table></figure>

<p>这样防火墙就启动了，并且仅接受来自 15 端口的入站请求。</p>
<p>在配置放行列表的时候，注意仅添加必要的端口。乱开一气，或者直接允许所有端口，那就跟没有防火墙一样了。</p>
<h1 id="禁止root用户通过SSH登陆"><a href="#禁止root用户通过SSH登陆" class="headerlink" title="禁止root用户通过SSH登陆"></a>禁止 root 用户通过 SSH 登陆</h1><p>地球人都知道，root 是 Linux 系统中权限最高的用户，同时也是最危险的用户。所以当然不能开放 root 远程登录的权限。</p>
<p>在此之前，你需要先创建一个自己的用户，并且设置好密码，保证可以正常登陆到系统中。至于创建用户的方法我这里就不赘述了。</p>
<p>有了自己的用户之后，编辑 <code>/etc/ssh/sshd_config</code> ，修改如下内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 允许使用root用户登陆</span><br><span class="line">PermitRootLogin no</span><br></pre></td></tr></tbody></table></figure>

<p>保存并重启 SSH 服务，就可以阻止 root 用户通过 SSH 登陆了。</p>
<h1 id="使用RSA密钥对登陆SSH"><a href="#使用RSA密钥对登陆SSH" class="headerlink" title="使用RSA密钥对登陆SSH"></a>使用 RSA 密钥对登陆 SSH</h1><p>在防止被破解的角度上，光是换端口和开防火墙，是远远不够的。还记得上文提到的 SSH 弱口令扫描吗？相信我，你绞尽脑汁想出来的密码，还真不一定打得过字典，而 VPS 提供商给你的默认密码，你确定你能记得住？但是 RSA 密钥对不仅能抵抗字典攻击，还不需要你记忆什么登陆信息，何乐而不为？</p>
<h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><h3 id="Windows下生成密钥对"><a href="#Windows下生成密钥对" class="headerlink" title="Windows下生成密钥对"></a>Windows 下生成密钥对</h3><p>如果你用的是 Windows，那么可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmN5eXNlbGYubmFtZS8yMDE3LzEwL3NzaC1rZXktYXV0aC8=">这篇文章<i class="fa fa-external-link-alt"></i></span>来生成你的密钥对，并将其上传至服务器。</p>
<h3 id="Linux下生成密钥对"><a href="#Linux下生成密钥对" class="headerlink" title="Linux下生成密钥对"></a>Linux 下生成密钥对</h3><p>如果你用的是 Linux，那么可以使用 <code>ssh-keygen</code> 命令生成密钥对。</p>
<p>首先在本地电脑上生成密钥对</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh-keygen -b 2048</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/boris/.ssh/id_rsa): 密钥文件的位置，回车使用默认值</span><br><span class="line">Enter passphrase (empty for no passphrase): 密钥的密码，留空表示没有密码</span><br><span class="line">Enter same passphrase again: 确认密码</span><br><span class="line">Your identification has been saved in /Users/boris/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /Users/boris/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:K23EGsTSYVod8LbR/6MRHm3XHJbAlTxCbewMUXmfaOo boris@Boris-MacBook-Pro.local</span><br><span class="line">The key's randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|      =o..  o+Boo|</span><br><span class="line">|     * o..   +.Oo|</span><br><span class="line">|    o + + .   B+=|</span><br><span class="line">|     o o o . +.=+|</span><br><span class="line">|      . S   * o +|</span><br><span class="line">|       = . o = . |</span><br><span class="line">|  .   o + . o o  |</span><br><span class="line">|       o   E o . |</span><br><span class="line">|   +        .    |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></tbody></table></figure>

<p>生成好了之后，就可以使用 <code>ssh-copy-id</code> 来传输公钥到远程服务器了：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa &lt;USERNAME&gt;@&lt;HOST&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>然后就可以使用密钥登陆来测试了，方法很简单，只需要为 <code>ssh</code> 命令添加 <code>-i</code> 参数并指定私钥文件即可，如果私钥文件名为 <code>id_rsa</code> 的话， <code>-i</code> 参数也可以省略了。</p>
<p>如果觉得使用密钥登陆的命令过长，那么可以参考我的另一篇博客<a href="/tools/ssh/ssh-config-file.html">使用 SSH config 简化 SSH 连接</a>来简化 SSH 客户端的操作。</p>
<h2 id="配置SSH仅接受密钥登陆"><a href="#配置SSH仅接受密钥登陆" class="headerlink" title="配置SSH仅接受密钥登陆"></a>配置 SSH 仅接受密钥登陆</h2><p>在服务器上编辑 <code>/etc/ssh/sshd_config</code> 修改如下内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 启用公钥认证</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"># 禁用密码认证</span><br><span class="line">PasswordAuthentication no</span><br><span class="line"># 不允许空密码登陆</span><br><span class="line">PermitEmptyPasswords no</span><br></pre></td></tr></tbody></table></figure>

<p>保存文件并重启 SSH 服务，然后服务器就只会接受通过密钥认证的登陆请求了，在密钥错误或者未提供密钥的时候，服务器会直接拒绝请求。</p>
<p>做完以上几步之后，通常的端口扫描和弱口令攻击基本上就免疫了，但是安全没有终点，在日常维护中还是需要时常检查鉴权日志和防火墙日志，以保证系统仍处于安全的状态下。在配置其他应用的时候，也要考虑到应用的安全相关的配置。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在 macOS 中通过 SSH 进行 X11 转发</title>
    <url>/macos-install-x11-client.html</url>
    <content><![CDATA[<p>本文记录如何在 macOS 中安装 X11 客户端，并通过 SSH 进行 X11 转发。</p>
<span id="more"></span>

<h1 id="安装X11客户端"><a href="#安装X11客户端" class="headerlink" title="安装X11客户端"></a>安装 X11 客户端</h1><p>在 macOS 中，可以使用 <code>XQuartz</code> 作为 X11 客户端。可以到<span class="exturl" data-url="aHR0cHM6Ly93d3cueHF1YXJ0ei5vcmcvcmVsZWFzZXMv"> XQuartz Releases<i class="fa fa-external-link-alt"></i></span>下载安装包手动安装，也可使用 <code>Homebrew</code> 安装。</p>
<p>使用 <code>Homebrew</code> 安装 <code>XQuartz</code> 的命令如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ brew cask install xquartz</span><br></pre></td></tr></tbody></table></figure>

<p>注意安装期间需要提供管理员密码以完成安装。安装完成之后需要完全退出并重启终端模拟器。</p>
<h1 id="检查远程服务器配置"><a href="#检查远程服务器配置" class="headerlink" title="检查远程服务器配置"></a>检查远程服务器配置</h1><p>编辑 <code>/etc/ssh/sshd_config</code>，设定如下条目：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">X11Forwarding yes</span><br><span class="line">X11DisplayOffset 10</span><br></pre></td></tr></tbody></table></figure>

<p>然后重启 <code>sshd</code> 使配置生效：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></tbody></table></figure>

<h1 id="转发远程X11程序"><a href="#转发远程X11程序" class="headerlink" title="转发远程X11程序"></a>转发远程 X11 程序</h1><p>使用 <code>ssh -X</code> 连接到远程服务器，执行任意 X11 程序，然后程序的窗口就会在本机显示。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>XQuartz</tag>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Maven 配置阿里云镜像和代理服务器</title>
    <url>/maven-configure-mirrors.html</url>
    <content><![CDATA[<p>Maven 中央仓库在国内的速度简直是感人，好在阿里云提供了 Maven 中央仓库的镜像，配置方法在此记录备用。</p>
<span id="more"></span>

<p>打开 Maven 的用户配置文件 (默认位置在 <code>~/.m2/settings.xml</code>)，在 <code>mirrrors</code> 段加入如下内容：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 镜像ID，自行定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该镜像对应的仓库名，central即中央仓库 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 个人建议不要将其设为星号 [注] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 镜像名，自行定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 镜像的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>[注]</strong> 有些教程在 <code>mirrorOf</code> 字段中填写的是星号，但根据<span class="exturl" data-url="aHR0cHM6Ly9tYXZlbi5hcGFjaGUub3JnL2d1aWRlcy9taW5pL2d1aWRlLW1pcnJvci1zZXR0aW5ncy5odG1s"> Using Mirrors for Repositories<i class="fa fa-external-link-alt"></i></span>中 <code>Using A Single Repository</code> 一段的解释，这将会强制使用该镜像处理所有的仓库请求，而阿里云镜像并不能达到这样的效果，所以个人建议仅使用该镜像代理中央仓库的请求。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
</search>
